#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: ReadyOrNot

#include "Basic.hpp"

#include "ObjectPooler_classes.hpp"
#include "UMG_classes.hpp"
#include "ReadyOrNot_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "EnhancedInput_structs.hpp"
#include "EnhancedInput_classes.hpp"
#include "SlateCore_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "CommonUI_classes.hpp"
#include "DynamicCoverSystem_structs.hpp"
#include "DynamicCoverSystem_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "LevelSequence_classes.hpp"
#include "DeveloperSettings_classes.hpp"
#include "Slate_structs.hpp"
#include "AIModule_structs.hpp"
#include "AIModule_classes.hpp"
#include "FMODStudio_structs.hpp"
#include "FMODStudio_classes.hpp"
#include "CommonInput_structs.hpp"
#include "CommonInput_classes.hpp"
#include "InputCore_structs.hpp"
#include "InputRemapping_structs.hpp"
#include "PhysicsCore_structs.hpp"
#include "PhysicsCore_classes.hpp"
#include "ModularGameplay_classes.hpp"
#include "OnlineSubsystemUtils_structs.hpp"
#include "AdvancedSessions_structs.hpp"
#include "AdvancedSessions_classes.hpp"
#include "Gauntlet_classes.hpp"
#include "NavigationSystem_classes.hpp"


namespace SDK
{

// Class ReadyOrNot.AchievementSubsystem
// 0x0188 (0x01B8 - 0x0030)
class UAchievementSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EAchievementStats, struct FUniversalStat> AchievementStats;                                 // 0x0038(0x0050)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_88[0x10];                                      // 0x0088(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class ABaseItem*>                        UsedItemsInCurrentMission;                         // 0x0098(0x0050)(UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E8[0x50];                                      // 0x00E8(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class ULocalAchievements*                     LocalAchievements;                                 // 0x0138(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_140[0x78];                                     // 0x0140(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static TArray<EAchievement> GetAllAchievements();

	void BeginMission();
	void C2Detonated(class UObject* WorldContextObject, class AReadyOrNotCharacter* Breacher, class AActor* Target);
	void CharacterKilled(class UObject* WorldContextObject, class AReadyOrNotCharacter* KilledCharacter, class AReadyOrNotCharacter* KilledBy, bool bWasActiveBeforeDeath);
	void DrankBeverage(const class FString& Beverage);
	void EndMission(class UObject* WorldContextObject);
	bool HasOnlyUsedItems(const TArray<EItemCategory>& Categories);
	void HelicopterCameraUpdate(class UObject* WorldContextObject, class UTrackingCameraComponent* CameraComponent, float DeltaTime);
	void IndicateUserAchievementProgress(EAchievement Achievement, int32 Progress, int32 MaxProgress);
	void QueryAchievementsAndStatsFailure(int32 SteamErrorOutput);
	void QueryAchievementsAndStatsSuccess(int32 SteamErrorOutput);
	void StoreStatsAndAchievementsFailure(int32 SteamErrorOutput);
	void StoreStatsAndAchievementsSuccess(int32 SteamErrorOutput);
	void UsedItem(class ABaseItem* Item);
	void UserAchievementProgressFailure(int32 SteamErrorOutput);
	void UserAchievementProgressSuccess(int32 SteamErrorOutput);

	TArray<struct FAchievementStatus> GetAchievementStatuses() const;
	class ULocalAchievements* GetLocalAchievements() const;
	TArray<EAchievement> GetLockedAchievements() const;
	TArray<EAchievement> GetUnlockedAchievements() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AchievementSubsystem">();
	}
	static class UAchievementSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAchievementSubsystem>();
	}
};
static_assert(alignof(UAchievementSubsystem) == 0x000008, "Wrong alignment on UAchievementSubsystem");
static_assert(sizeof(UAchievementSubsystem) == 0x0001B8, "Wrong size on UAchievementSubsystem");
static_assert(offsetof(UAchievementSubsystem, AchievementStats) == 0x000038, "Member 'UAchievementSubsystem::AchievementStats' has a wrong offset!");
static_assert(offsetof(UAchievementSubsystem, UsedItemsInCurrentMission) == 0x000098, "Member 'UAchievementSubsystem::UsedItemsInCurrentMission' has a wrong offset!");
static_assert(offsetof(UAchievementSubsystem, LocalAchievements) == 0x000138, "Member 'UAchievementSubsystem::LocalAchievements' has a wrong offset!");

// Class ReadyOrNot.CustomizationSocket
// 0x0078 (0x00A0 - 0x0028)
class UCustomizationSocket final : public UObject
{
public:
	TSoftClassPtr<class UClass>                   ActorClass;                                        // 0x0028(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachSocket;                                      // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RelativeLocation;                                  // 0x0058(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RelativeRotation;                                  // 0x0070(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RelativeScale;                                     // 0x0088(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationSocket">();
	}
	static class UCustomizationSocket* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomizationSocket>();
	}
};
static_assert(alignof(UCustomizationSocket) == 0x000008, "Wrong alignment on UCustomizationSocket");
static_assert(sizeof(UCustomizationSocket) == 0x0000A0, "Wrong size on UCustomizationSocket");
static_assert(offsetof(UCustomizationSocket, ActorClass) == 0x000028, "Member 'UCustomizationSocket::ActorClass' has a wrong offset!");
static_assert(offsetof(UCustomizationSocket, AttachSocket) == 0x000050, "Member 'UCustomizationSocket::AttachSocket' has a wrong offset!");
static_assert(offsetof(UCustomizationSocket, RelativeLocation) == 0x000058, "Member 'UCustomizationSocket::RelativeLocation' has a wrong offset!");
static_assert(offsetof(UCustomizationSocket, RelativeRotation) == 0x000070, "Member 'UCustomizationSocket::RelativeRotation' has a wrong offset!");
static_assert(offsetof(UCustomizationSocket, RelativeScale) == 0x000088, "Member 'UCustomizationSocket::RelativeScale' has a wrong offset!");

// Class ReadyOrNot.WallHoleTraversal
// 0x0268 (0x0500 - 0x0298)
class AWallHoleTraversal final : public AActor
{
public:
	class USceneComponent*                        SceneComponent;                                    // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bEnabled : 1;                                      // 0x02A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2A1[0x7];                                      // 0x02A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Name_0;                                            // 0x02A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class AStaticMeshActor>> IgnoredMeshActors;                                // 0x02B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         CooldownAfterUse;                                  // 0x02C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NavLinkProxyDistance;                              // 0x02CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             EntryTriggerBoxTransform;                          // 0x02D0(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EntryTriggerBoxExtent;                             // 0x0330(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_348[0x8];                                      // 0x0348(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ExitTriggerBoxTransform;                           // 0x0350(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ExitTriggerBoxExtent;                              // 0x03B0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           EntryAnim;                                         // 0x03C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           LoopAnim;                                          // 0x03D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ExitAnim;                                          // 0x03D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AAIController*                          OccupiedByController;                              // 0x03E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ANavLinkProxy*                          NavLinkProxy;                                      // 0x03E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class AController*, float>               CooldownMap;                                       // 0x03F0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_440[0xC0];                                     // 0x0440(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddCooldownFor(class AController* InController, float InCooldownTime);
	void TestForMeshes();

	bool IsCooldownActiveFor(const class AController* InController) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WallHoleTraversal">();
	}
	static class AWallHoleTraversal* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWallHoleTraversal>();
	}
};
static_assert(alignof(AWallHoleTraversal) == 0x000010, "Wrong alignment on AWallHoleTraversal");
static_assert(sizeof(AWallHoleTraversal) == 0x000500, "Wrong size on AWallHoleTraversal");
static_assert(offsetof(AWallHoleTraversal, SceneComponent) == 0x000298, "Member 'AWallHoleTraversal::SceneComponent' has a wrong offset!");
static_assert(offsetof(AWallHoleTraversal, Name_0) == 0x0002A8, "Member 'AWallHoleTraversal::Name_0' has a wrong offset!");
static_assert(offsetof(AWallHoleTraversal, IgnoredMeshActors) == 0x0002B8, "Member 'AWallHoleTraversal::IgnoredMeshActors' has a wrong offset!");
static_assert(offsetof(AWallHoleTraversal, CooldownAfterUse) == 0x0002C8, "Member 'AWallHoleTraversal::CooldownAfterUse' has a wrong offset!");
static_assert(offsetof(AWallHoleTraversal, NavLinkProxyDistance) == 0x0002CC, "Member 'AWallHoleTraversal::NavLinkProxyDistance' has a wrong offset!");
static_assert(offsetof(AWallHoleTraversal, EntryTriggerBoxTransform) == 0x0002D0, "Member 'AWallHoleTraversal::EntryTriggerBoxTransform' has a wrong offset!");
static_assert(offsetof(AWallHoleTraversal, EntryTriggerBoxExtent) == 0x000330, "Member 'AWallHoleTraversal::EntryTriggerBoxExtent' has a wrong offset!");
static_assert(offsetof(AWallHoleTraversal, ExitTriggerBoxTransform) == 0x000350, "Member 'AWallHoleTraversal::ExitTriggerBoxTransform' has a wrong offset!");
static_assert(offsetof(AWallHoleTraversal, ExitTriggerBoxExtent) == 0x0003B0, "Member 'AWallHoleTraversal::ExitTriggerBoxExtent' has a wrong offset!");
static_assert(offsetof(AWallHoleTraversal, EntryAnim) == 0x0003C8, "Member 'AWallHoleTraversal::EntryAnim' has a wrong offset!");
static_assert(offsetof(AWallHoleTraversal, LoopAnim) == 0x0003D0, "Member 'AWallHoleTraversal::LoopAnim' has a wrong offset!");
static_assert(offsetof(AWallHoleTraversal, ExitAnim) == 0x0003D8, "Member 'AWallHoleTraversal::ExitAnim' has a wrong offset!");
static_assert(offsetof(AWallHoleTraversal, OccupiedByController) == 0x0003E0, "Member 'AWallHoleTraversal::OccupiedByController' has a wrong offset!");
static_assert(offsetof(AWallHoleTraversal, NavLinkProxy) == 0x0003E8, "Member 'AWallHoleTraversal::NavLinkProxy' has a wrong offset!");
static_assert(offsetof(AWallHoleTraversal, CooldownMap) == 0x0003F0, "Member 'AWallHoleTraversal::CooldownMap' has a wrong offset!");

// Class ReadyOrNot.AnimNotify_SpawnWeapon
// 0x0020 (0x0058 - 0x0038)
class UAnimNotify_SpawnWeapon final : public UAnimNotify
{
public:
	TArray<TSubclassOf<class ABaseWeapon>>        PotentialWeapons;                                  // 0x0038(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	EItemCategory                                 ItemCategory;                                      // 0x0048(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 WeaponClass;                                       // 0x0050(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_SpawnWeapon">();
	}
	static class UAnimNotify_SpawnWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_SpawnWeapon>();
	}
};
static_assert(alignof(UAnimNotify_SpawnWeapon) == 0x000008, "Wrong alignment on UAnimNotify_SpawnWeapon");
static_assert(sizeof(UAnimNotify_SpawnWeapon) == 0x000058, "Wrong size on UAnimNotify_SpawnWeapon");
static_assert(offsetof(UAnimNotify_SpawnWeapon, PotentialWeapons) == 0x000038, "Member 'UAnimNotify_SpawnWeapon::PotentialWeapons' has a wrong offset!");
static_assert(offsetof(UAnimNotify_SpawnWeapon, ItemCategory) == 0x000048, "Member 'UAnimNotify_SpawnWeapon::ItemCategory' has a wrong offset!");
static_assert(offsetof(UAnimNotify_SpawnWeapon, WeaponClass) == 0x000050, "Member 'UAnimNotify_SpawnWeapon::WeaponClass' has a wrong offset!");

// Class ReadyOrNot.BaseActivity
// 0x01C8 (0x01F0 - 0x0028)
class UBaseActivity : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class UBaseActivity* Activity, class ACyberneticController* Controller)> OnStartActivity; // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UBaseActivity* Activity, class ACyberneticController* Controller, float DeltaTime)> OnPerformActivity; // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UBaseActivity* Activity, class ACyberneticController* Controller)> OnFinishActivity; // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UBaseActivity* Activity, class ACyberneticController* Controller)> OnFinishActivity_NoOwner; // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_70[0x18];                                      // 0x0070(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ActivityName;                                      // 0x0088(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         MaxActivityTime;                                   // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActivityStartDelay;                                // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bNoResetDataOnFinish : 1;                          // 0x00A8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MoveAcceptanceRadius;                              // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OverrideMoveAcceptanceRadius;                      // 0x00B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GlobalCooldown;                                    // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bGlobalCooldownRandomRange : 1;                    // 0x00C4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_C5[0x3];                                       // 0x00C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              GlobalCooldownRange;                               // 0x00C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIsProgressActivity : 1;                           // 0x00D8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFinishActivityWhenOverriden : 1;                  // 0x00D8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAbortMoveWhenActivityFinished : 1;                // 0x00D8(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAbortMoveWhenActivityOverriden : 1;               // 0x00D8(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAbortActivityIfCannotReachLocation : 1;           // 0x00D8(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAbortActivityIfProjectedLocationFailed : 1;       // 0x00D8(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAbortIfTrackingEnemy : 1;                         // 0x00D8(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPauseIfTrackingEnemy : 1;                         // 0x00D8(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPauseIfRecentlyInCombat : 1;                      // 0x00D9(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_DA[0x2];                                       // 0x00DA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RecentCombatTimeThreshold;                         // 0x00DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bAllowWhileArrested : 1;                           // 0x00E0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bNoMoveActivity : 1;                               // 0x00E0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsSquadsRoleActivity : 1;                         // 0x00E0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bResetStateMachineWhenActivityResumed : 1;         // 0x00E0(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowPartialMove : 1;                             // 0x00E0(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowRePathOnInvalidation : 1;                    // 0x00E0(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAbortIfNotMovingForAWhile : 1;                    // 0x00E0(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAlwaysRequestMove : 1;                            // 0x00E0(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAbortIfSurrendered : 1;                           // 0x00E1(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_E2[0x1E];                                      // 0x00E2(0x001E)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ElapsedActivityTime;                               // 0x0100(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeNotMoving;                                     // 0x0104(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                Location;                                          // 0x0108(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   ProgressState;                                     // 0x0120(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	float                                         TimeSinceLastAsyncMove;                            // 0x0138(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13C[0x4];                                      // 0x013C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LastRequestedLocation;                             // 0x0140(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_158[0x5C];                                     // 0x0158(0x005C)(Fixing Size After Last Property [ Dumper-7 ])
	EActivityStatus                               ActivityStatus;                                    // 0x01B4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B5[0x5];                                      // 0x01B5(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         BitPad_1BA_0 : 1;                                  // 0x01BA(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bSearchingPath : 1;                                // 0x01BA(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bLastRequestedLocationWaitingForRepath : 1;        // 0x01BA(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1BB[0x15];                                     // 0x01BB(0x0015)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LastPathLength;                                    // 0x01D0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D4[0x4];                                      // 0x01D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ACyberneticController*                  OwningController;                                  // 0x01D8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACyberneticCharacter*                   OwningCharacter;                                   // 0x01E0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UActivityFiniteStateMachine*            ActivityStateMachine;                              // 0x01E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void EquipItem(EItemCategory InItemCategory);
	void EquipItemOfClass(TSubclassOf<class ABaseItem> InItemClass);
	void EquipSpecificItem(class ABaseItem* Item);
	void EquipWeapon();
	void FinishedActivity_Blueprint(bool bSuccess);
	void OnIncapacitated(class AReadyOrNotCharacter* IncapacitatedCharacter, class AReadyOrNotCharacter* InstigatorCharacter);
	void OnKilled(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter);
	bool OverrideFocalPoint_Blueprint(struct FVector* FocalPoint);
	void PerformActivity_Blueprint(float DeltaTime);
	void ResetData();
	void SetLocation(const struct FVector& NewLocation, bool bRequestMove, const struct FVector& CustomExtent);
	void StartActivity_Blueprint(class AAIController* Owner);

	bool CanBePushed() const;
	bool CanOverrideActivity() const;
	int32 GetActiveStateID() const;
	class FString GetActiveStateName() const;
	float GetActiveStateUptime() const;
	EActivityStatus GetActivityStatus() const;
	class ACyberneticCharacter* GetCharacter() const;
	struct FVector GetLocation() const;
	class FName GetMoveStyleOverride() const;
	class ACyberneticController* GetOwningController() const;
	class FText GetProgressState() const;
	bool HasReachedLocation(float Tolerance) const;
	bool HasReachedLocation_Custom(const struct FVector& CustomLocation, float Tolerance) const;
	bool HasStartedActivity() const;
	bool IsActivityComplete() const;
	bool IsActivityInitialized() const;
	bool IsActivityPaused() const;
	bool IsNoMoveActivity() const;
	bool IsProgressActivity() const;
	bool IsSquadsRoleActivity() const;
	bool ShouldForceNoStrafe() const;
	bool ShouldForceStrafe() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseActivity">();
	}
	static class UBaseActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseActivity>();
	}
};
static_assert(alignof(UBaseActivity) == 0x000008, "Wrong alignment on UBaseActivity");
static_assert(sizeof(UBaseActivity) == 0x0001F0, "Wrong size on UBaseActivity");
static_assert(offsetof(UBaseActivity, OnStartActivity) == 0x000030, "Member 'UBaseActivity::OnStartActivity' has a wrong offset!");
static_assert(offsetof(UBaseActivity, OnPerformActivity) == 0x000040, "Member 'UBaseActivity::OnPerformActivity' has a wrong offset!");
static_assert(offsetof(UBaseActivity, OnFinishActivity) == 0x000050, "Member 'UBaseActivity::OnFinishActivity' has a wrong offset!");
static_assert(offsetof(UBaseActivity, OnFinishActivity_NoOwner) == 0x000060, "Member 'UBaseActivity::OnFinishActivity_NoOwner' has a wrong offset!");
static_assert(offsetof(UBaseActivity, ActivityName) == 0x000088, "Member 'UBaseActivity::ActivityName' has a wrong offset!");
static_assert(offsetof(UBaseActivity, MaxActivityTime) == 0x0000A0, "Member 'UBaseActivity::MaxActivityTime' has a wrong offset!");
static_assert(offsetof(UBaseActivity, ActivityStartDelay) == 0x0000A4, "Member 'UBaseActivity::ActivityStartDelay' has a wrong offset!");
static_assert(offsetof(UBaseActivity, MoveAcceptanceRadius) == 0x0000B0, "Member 'UBaseActivity::MoveAcceptanceRadius' has a wrong offset!");
static_assert(offsetof(UBaseActivity, OverrideMoveAcceptanceRadius) == 0x0000B8, "Member 'UBaseActivity::OverrideMoveAcceptanceRadius' has a wrong offset!");
static_assert(offsetof(UBaseActivity, GlobalCooldown) == 0x0000C0, "Member 'UBaseActivity::GlobalCooldown' has a wrong offset!");
static_assert(offsetof(UBaseActivity, GlobalCooldownRange) == 0x0000C8, "Member 'UBaseActivity::GlobalCooldownRange' has a wrong offset!");
static_assert(offsetof(UBaseActivity, RecentCombatTimeThreshold) == 0x0000DC, "Member 'UBaseActivity::RecentCombatTimeThreshold' has a wrong offset!");
static_assert(offsetof(UBaseActivity, ElapsedActivityTime) == 0x000100, "Member 'UBaseActivity::ElapsedActivityTime' has a wrong offset!");
static_assert(offsetof(UBaseActivity, TimeNotMoving) == 0x000104, "Member 'UBaseActivity::TimeNotMoving' has a wrong offset!");
static_assert(offsetof(UBaseActivity, Location) == 0x000108, "Member 'UBaseActivity::Location' has a wrong offset!");
static_assert(offsetof(UBaseActivity, ProgressState) == 0x000120, "Member 'UBaseActivity::ProgressState' has a wrong offset!");
static_assert(offsetof(UBaseActivity, TimeSinceLastAsyncMove) == 0x000138, "Member 'UBaseActivity::TimeSinceLastAsyncMove' has a wrong offset!");
static_assert(offsetof(UBaseActivity, LastRequestedLocation) == 0x000140, "Member 'UBaseActivity::LastRequestedLocation' has a wrong offset!");
static_assert(offsetof(UBaseActivity, ActivityStatus) == 0x0001B4, "Member 'UBaseActivity::ActivityStatus' has a wrong offset!");
static_assert(offsetof(UBaseActivity, LastPathLength) == 0x0001D0, "Member 'UBaseActivity::LastPathLength' has a wrong offset!");
static_assert(offsetof(UBaseActivity, OwningController) == 0x0001D8, "Member 'UBaseActivity::OwningController' has a wrong offset!");
static_assert(offsetof(UBaseActivity, OwningCharacter) == 0x0001E0, "Member 'UBaseActivity::OwningCharacter' has a wrong offset!");
static_assert(offsetof(UBaseActivity, ActivityStateMachine) == 0x0001E8, "Member 'UBaseActivity::ActivityStateMachine' has a wrong offset!");

// Class ReadyOrNot.BaseCombatMoveActivity
// 0x0040 (0x0230 - 0x01F0)
class UBaseCombatMoveActivity : public UBaseActivity
{
public:
	class UBaseCombatActivity*                    OwningCombatActivity;                              // 0x01F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FailureCount;                                      // 0x01F8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastSuccessTime;                                   // 0x01FC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastFailTime;                                      // 0x0200(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_204[0x4];                                      // 0x0204(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBaseActivity*                          InterruptActivity;                                 // 0x0208(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_210[0x18];                                     // 0x0210(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bRequireMagazineWeapon;                            // 0x0228(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_229[0x7];                                      // 0x0229(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FinishCombatMove(bool bSuccess);
	void GenerateNavigablePoints(const struct FVector& GenAroundLoc, const struct FNavGenerationParameters& NavGenerationParameters, TArray<struct FVector>* OutLocations);
	void RequestCombatMove_Blueprint(float DeltaTime);

	class UBaseActivity* GetInterruptActivity() const;
	bool HasAnyOtherCombatMoveGotLocation(const struct FVector& TestLocation, float Tolerance) const;
	bool HasLOSToEnemy() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseCombatMoveActivity">();
	}
	static class UBaseCombatMoveActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseCombatMoveActivity>();
	}
};
static_assert(alignof(UBaseCombatMoveActivity) == 0x000008, "Wrong alignment on UBaseCombatMoveActivity");
static_assert(sizeof(UBaseCombatMoveActivity) == 0x000230, "Wrong size on UBaseCombatMoveActivity");
static_assert(offsetof(UBaseCombatMoveActivity, OwningCombatActivity) == 0x0001F0, "Member 'UBaseCombatMoveActivity::OwningCombatActivity' has a wrong offset!");
static_assert(offsetof(UBaseCombatMoveActivity, FailureCount) == 0x0001F8, "Member 'UBaseCombatMoveActivity::FailureCount' has a wrong offset!");
static_assert(offsetof(UBaseCombatMoveActivity, LastSuccessTime) == 0x0001FC, "Member 'UBaseCombatMoveActivity::LastSuccessTime' has a wrong offset!");
static_assert(offsetof(UBaseCombatMoveActivity, LastFailTime) == 0x000200, "Member 'UBaseCombatMoveActivity::LastFailTime' has a wrong offset!");
static_assert(offsetof(UBaseCombatMoveActivity, InterruptActivity) == 0x000208, "Member 'UBaseCombatMoveActivity::InterruptActivity' has a wrong offset!");
static_assert(offsetof(UBaseCombatMoveActivity, bRequireMagazineWeapon) == 0x000228, "Member 'UBaseCombatMoveActivity::bRequireMagazineWeapon' has a wrong offset!");

// Class ReadyOrNot.SoftCoverCombatMove
// 0x0008 (0x0238 - 0x0230)
class USoftCoverCombatMove final : public UBaseCombatMoveActivity
{
public:
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoftCoverCombatMove">();
	}
	static class USoftCoverCombatMove* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoftCoverCombatMove>();
	}
};
static_assert(alignof(USoftCoverCombatMove) == 0x000008, "Wrong alignment on USoftCoverCombatMove");
static_assert(sizeof(USoftCoverCombatMove) == 0x000238, "Wrong size on USoftCoverCombatMove");

// Class ReadyOrNot.AchievementStatics
// 0x0000 (0x0028 - 0x0028)
class UAchievementStatics final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AchievementStatics">();
	}
	static class UAchievementStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAchievementStatics>();
	}
};
static_assert(alignof(UAchievementStatics) == 0x000008, "Wrong alignment on UAchievementStatics");
static_assert(sizeof(UAchievementStatics) == 0x000028, "Wrong size on UAchievementStatics");

// Class ReadyOrNot.Watch
// 0x0030 (0x02C8 - 0x0298)
class AWatch final : public AActor
{
public:
	class UStaticMeshComponent*                   WatchMesh;                                         // 0x0298(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   HourHandMesh;                                      // 0x02A0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   MinuteHandMesh;                                    // 0x02A8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   SecondHandMesh;                                    // 0x02B0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   DateMesh;                                          // 0x02B8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C0[0x8];                                      // 0x02C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Watch">();
	}
	static class AWatch* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWatch>();
	}
};
static_assert(alignof(AWatch) == 0x000008, "Wrong alignment on AWatch");
static_assert(sizeof(AWatch) == 0x0002C8, "Wrong size on AWatch");
static_assert(offsetof(AWatch, WatchMesh) == 0x000298, "Member 'AWatch::WatchMesh' has a wrong offset!");
static_assert(offsetof(AWatch, HourHandMesh) == 0x0002A0, "Member 'AWatch::HourHandMesh' has a wrong offset!");
static_assert(offsetof(AWatch, MinuteHandMesh) == 0x0002A8, "Member 'AWatch::MinuteHandMesh' has a wrong offset!");
static_assert(offsetof(AWatch, SecondHandMesh) == 0x0002B0, "Member 'AWatch::SecondHandMesh' has a wrong offset!");
static_assert(offsetof(AWatch, DateMesh) == 0x0002B8, "Member 'AWatch::DateMesh' has a wrong offset!");

// Class ReadyOrNot.COOPScorePopUp
// 0x0008 (0x02C8 - 0x02C0)
class UCOOPScorePopUp : public UUserWidget
{
public:
	class UFMODEvent*                             Reward;                                            // 0x02C0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void PlayRewardSound();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"COOPScorePopUp">();
	}
	static class UCOOPScorePopUp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCOOPScorePopUp>();
	}
};
static_assert(alignof(UCOOPScorePopUp) == 0x000008, "Wrong alignment on UCOOPScorePopUp");
static_assert(sizeof(UCOOPScorePopUp) == 0x0002C8, "Wrong size on UCOOPScorePopUp");
static_assert(offsetof(UCOOPScorePopUp, Reward) == 0x0002C0, "Member 'UCOOPScorePopUp::Reward' has a wrong offset!");

// Class ReadyOrNot.LocalAchievements
// 0x0070 (0x0098 - 0x0028)
class ULocalAchievements final : public USaveGame
{
public:
	TArray<EAchievement>                          Achievements;                                      // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TMap<EAchievementStats, struct FUniversalStat> Stats;                                            // 0x0038(0x0050)(NativeAccessSpecifierPrivate)
	TArray<class FName>                           UnlockedTraits;                                    // 0x0088(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocalAchievements">();
	}
	static class ULocalAchievements* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULocalAchievements>();
	}
};
static_assert(alignof(ULocalAchievements) == 0x000008, "Wrong alignment on ULocalAchievements");
static_assert(sizeof(ULocalAchievements) == 0x000098, "Wrong size on ULocalAchievements");
static_assert(offsetof(ULocalAchievements, Achievements) == 0x000028, "Member 'ULocalAchievements::Achievements' has a wrong offset!");
static_assert(offsetof(ULocalAchievements, Stats) == 0x000038, "Member 'ULocalAchievements::Stats' has a wrong offset!");
static_assert(offsetof(ULocalAchievements, UnlockedTraits) == 0x000088, "Member 'ULocalAchievements::UnlockedTraits' has a wrong offset!");

// Class ReadyOrNot.ShotDetectionVolume
// 0x0008 (0x02A0 - 0x0298)
class AShotDetectionVolume final : public AActor
{
public:
	class UBoxComponent*                          Bounds;                                            // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnShotFired(class ABaseWeapon* FiringWeapon, class APlayerCharacter* FiringPlayer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShotDetectionVolume">();
	}
	static class AShotDetectionVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShotDetectionVolume>();
	}
};
static_assert(alignof(AShotDetectionVolume) == 0x000008, "Wrong alignment on AShotDetectionVolume");
static_assert(sizeof(AShotDetectionVolume) == 0x0002A0, "Wrong size on AShotDetectionVolume");
static_assert(offsetof(AShotDetectionVolume, Bounds) == 0x000298, "Member 'AShotDetectionVolume::Bounds' has a wrong offset!");

// Class ReadyOrNot.ActivatableBaseWidget
// 0x0028 (0x0438 - 0x0410)
class UActivatableBaseWidget : public UCommonActivatableWidget
{
public:
	struct FVector2D                              MouseAxisDeltaThreshold;                           // 0x0410(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              GamepadAxisDeltaThreshold;                         // 0x0420(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AReadyOrNotGameState*                   RONGS;                                             // 0x0430(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	struct FVector2D GetCenterScreenPosition();
	void HideWidget();
	bool IsBlockingAnimationPlaying();
	bool IsGamepadAxisBeyondThreshold(const struct FVector2D& InGamepadAxis);
	bool IsMouseAxisBeyondThreshold(const struct FVector2D& InMouseDelta);
	void PauseWidgetAnimation_Internal(class UWidgetAnimation* InWidgetAnimation);
	void PlaySoundEffect(class UFMODEvent* SoundEffectToPlay);
	void PlayWidgetAnimation_Internal(class UWidgetAnimation* InWidgetAnimation, bool bRestartIfAlreadyPlaying);
	void ShowWidget(bool bNotHitTestable);
	void StopWidgetAnimation_Internal(class UWidgetAnimation* InWidgetAnimation);
	void ToggleWidgetVisibility(bool bNotHitTestable);
	bool UpdateDebugInfo();

	struct FVector2D GetMouseDelta() const;
	struct FVector2D GetMousePosition() const;
	bool HasMouseMoved() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivatableBaseWidget">();
	}
	static class UActivatableBaseWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivatableBaseWidget>();
	}
};
static_assert(alignof(UActivatableBaseWidget) == 0x000008, "Wrong alignment on UActivatableBaseWidget");
static_assert(sizeof(UActivatableBaseWidget) == 0x000438, "Wrong size on UActivatableBaseWidget");
static_assert(offsetof(UActivatableBaseWidget, MouseAxisDeltaThreshold) == 0x000410, "Member 'UActivatableBaseWidget::MouseAxisDeltaThreshold' has a wrong offset!");
static_assert(offsetof(UActivatableBaseWidget, GamepadAxisDeltaThreshold) == 0x000420, "Member 'UActivatableBaseWidget::GamepadAxisDeltaThreshold' has a wrong offset!");
static_assert(offsetof(UActivatableBaseWidget, RONGS) == 0x000430, "Member 'UActivatableBaseWidget::RONGS' has a wrong offset!");

// Class ReadyOrNot.RadialTrackingTarget
// 0x0008 (0x02A0 - 0x0298)
class ARadialTrackingTarget final : public AActor
{
public:
	float                                         WaitDuration;                                      // 0x0298(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29C[0x4];                                      // 0x029C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RadialTrackingTarget">();
	}
	static class ARadialTrackingTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARadialTrackingTarget>();
	}
};
static_assert(alignof(ARadialTrackingTarget) == 0x000008, "Wrong alignment on ARadialTrackingTarget");
static_assert(sizeof(ARadialTrackingTarget) == 0x0002A0, "Wrong size on ARadialTrackingTarget");
static_assert(offsetof(ARadialTrackingTarget, WaitDuration) == 0x000298, "Member 'ARadialTrackingTarget::WaitDuration' has a wrong offset!");

// Class ReadyOrNot.ActivityData
// 0x0100 (0x0130 - 0x0030)
class UActivityData final : public UDataAsset
{
public:
	EActivity                                     Activity;                                          // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSwatCommandData                       SwatCommandData;                                   // 0x0038(0x0038)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FTutorialWidgetData                    WidgetData;                                        // 0x0070(0x0078)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          ForceEnableAllSwatCommands;                        // 0x00E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E9[0x3];                                       // 0x00E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ActionsRequired;                                   // 0x00EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeRequired;                                      // 0x00F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F4[0x4];                                       // 0x00F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class UActivityData* ActivityData)> OnComplete;                    // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class APlayerCharacter*                       PlayerCharacter;                                   // 0x0108(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_110[0x10];                                     // 0x0110(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AReadyOrNotCharacter*>           CharactersKilled;                                  // 0x0120(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	void CompleteActivity();
	void OnAttachmentLightToggled();
	void OnCantedSightToggled(bool bUsingCantedSight);
	void OnCharacterArrested(class AReadyOrNotCharacter* Character, class AReadyOrNotCharacter* ArrestedBy);
	void OnCharacterKilled(class AReadyOrNotCharacter* Character, class AReadyOrNotCharacter* KilledBy);
	void OnCharacterMovementUpdated(float DeltaSeconds, const struct FVector& OldLocation, const struct FVector& OldVelocity);
	void OnChemlightThrown(class APlayerCharacter* DelegatePlayerCharacter);
	void OnDoorKicked(class ADoor* Door, class AReadyOrNotCharacter* InstigatorCharacter, bool bSuccess);
	void OnEvidenceCollected(class AActor* Evidence);
	void OnExfiltrateMission();
	void OnInteract(class UInteractableComponent* InteractableComponent);
	void OnItemEquipped(class ABaseItem* Item);
	void OnItemUseCompleted(class ABaseItem* Item);
	void OnItemUseStart(class ABaseItem* Item);
	void OnNightVisionGogglesToggled(class AReadyOrNotCharacter* Character, bool bOn);
	void OnSwatCommandIssued(const ESwatCommand SwatCommand, const ETeamType TeamType, class AActor* ContextActor);
	void OnSwatCommandIssuedGamepad(const ESwatCommand SwatCommand, const ETeamType TeamType, class AActor* ContextActor);
	void OnSwatCommandQueued(const struct FQueuedSwatCommand& QueuedSwatCommand, const ETeamType TeamType);
	void OnSwatCommandQueuedGamepad(const struct FQueuedSwatCommand& QueuedSwatCommand, const ETeamType TeamType);
	void OnSwatElementChanged(ETeamType TeamType);
	void OnSwatElementChangedGamepad(ETeamType TeamType);
	void OnTargetHit(class ATrainingTarget* Target);
	void OnTeamViewSet(class AReadyOrNotCharacter* NewViewCharacter);
	void OnWeaponFire(class AReadyOrNotCharacter* Character, class ABaseMagazineWeapon* Weapon, const struct FVector& fireDirection);
	void OnWeaponFireModeChanged(class APlayerCharacter* DelegatePlayerCharacter, EFireMode newFireMode, EFireMode LastFireMode);
	void OnWeaponReload(class APlayerCharacter* DelegatePlayerCharacter);
	void OnWeaponSwitchAmmoType(class APlayerCharacter* DelegatePlayerCharacter);
	void OnWeaponTacticalReload(class APlayerCharacter* DelegatePlayerCharacter);

	bool IsComplete() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivityData">();
	}
	static class UActivityData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivityData>();
	}
};
static_assert(alignof(UActivityData) == 0x000008, "Wrong alignment on UActivityData");
static_assert(sizeof(UActivityData) == 0x000130, "Wrong size on UActivityData");
static_assert(offsetof(UActivityData, Activity) == 0x000030, "Member 'UActivityData::Activity' has a wrong offset!");
static_assert(offsetof(UActivityData, SwatCommandData) == 0x000038, "Member 'UActivityData::SwatCommandData' has a wrong offset!");
static_assert(offsetof(UActivityData, WidgetData) == 0x000070, "Member 'UActivityData::WidgetData' has a wrong offset!");
static_assert(offsetof(UActivityData, ForceEnableAllSwatCommands) == 0x0000E8, "Member 'UActivityData::ForceEnableAllSwatCommands' has a wrong offset!");
static_assert(offsetof(UActivityData, ActionsRequired) == 0x0000EC, "Member 'UActivityData::ActionsRequired' has a wrong offset!");
static_assert(offsetof(UActivityData, TimeRequired) == 0x0000F0, "Member 'UActivityData::TimeRequired' has a wrong offset!");
static_assert(offsetof(UActivityData, OnComplete) == 0x0000F8, "Member 'UActivityData::OnComplete' has a wrong offset!");
static_assert(offsetof(UActivityData, PlayerCharacter) == 0x000108, "Member 'UActivityData::PlayerCharacter' has a wrong offset!");
static_assert(offsetof(UActivityData, CharactersKilled) == 0x000120, "Member 'UActivityData::CharactersKilled' has a wrong offset!");

// Class ReadyOrNot.AnimNotify_SetCoverIdlePose
// 0x0008 (0x0040 - 0x0038)
class UAnimNotify_SetCoverIdlePose final : public UAnimNotify
{
public:
	class UAnimSequence*                          Pose;                                              // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_SetCoverIdlePose">();
	}
	static class UAnimNotify_SetCoverIdlePose* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_SetCoverIdlePose>();
	}
};
static_assert(alignof(UAnimNotify_SetCoverIdlePose) == 0x000008, "Wrong alignment on UAnimNotify_SetCoverIdlePose");
static_assert(sizeof(UAnimNotify_SetCoverIdlePose) == 0x000040, "Wrong size on UAnimNotify_SetCoverIdlePose");
static_assert(offsetof(UAnimNotify_SetCoverIdlePose, Pose) == 0x000038, "Member 'UAnimNotify_SetCoverIdlePose::Pose' has a wrong offset!");

// Class ReadyOrNot.ActivityState
// 0x0070 (0x0098 - 0x0028)
class UActivityState final : public UObject
{
public:
	uint8                                         Pad_28[0x30];                                      // 0x0028(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Name_0;                                            // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ID;                                                // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Uptime;                                            // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UActivityFiniteStateMachine*            StateMachineOwner;                                 // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FActivityStateTransition>       StateTransitions;                                  // 0x0078(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)
	uint8                                         Pad_88[0x10];                                      // 0x0088(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UActivityState* CreateTransition(const struct FActivityStateTransition& InStateTransition);
	class UActivityState* RemoveTransitionByID(const int32 InID);
	class UActivityState* RemoveTransitionByName(const class FString& InName);

	TArray<struct FActivityStateTransition> GetTransitions() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivityState">();
	}
	static class UActivityState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivityState>();
	}
};
static_assert(alignof(UActivityState) == 0x000008, "Wrong alignment on UActivityState");
static_assert(sizeof(UActivityState) == 0x000098, "Wrong size on UActivityState");
static_assert(offsetof(UActivityState, Name_0) == 0x000058, "Member 'UActivityState::Name_0' has a wrong offset!");
static_assert(offsetof(UActivityState, ID) == 0x000068, "Member 'UActivityState::ID' has a wrong offset!");
static_assert(offsetof(UActivityState, Uptime) == 0x00006C, "Member 'UActivityState::Uptime' has a wrong offset!");
static_assert(offsetof(UActivityState, StateMachineOwner) == 0x000070, "Member 'UActivityState::StateMachineOwner' has a wrong offset!");
static_assert(offsetof(UActivityState, StateTransitions) == 0x000078, "Member 'UActivityState::StateTransitions' has a wrong offset!");

// Class ReadyOrNot.BaseItem
// 0x0918 (0x0BB0 - 0x0298)
class ABaseItem : public AActor
{
public:
	uint8                                         Pad_298[0x40];                                     // 0x0298(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ItemName;                                          // 0x02D8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              ItemIcon;                                          // 0x02F0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ItemDescription;                                   // 0x0318(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EItemClass                                    ItemClass;                                         // 0x0330(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemType                                     ItemType;                                          // 0x0331(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_332[0x2];                                      // 0x0332(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        CategoryFlags;                                     // 0x0334(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LoadoutPriority;                                   // 0x0338(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowInLoadout;                                    // 0x033C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEmptyItem;                                      // 0x033D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33E[0x2];                                      // 0x033E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CustomizationTag;                                  // 0x0340(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemsPerSlot;                                      // 0x0348(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LookupTableIdx;                                    // 0x034C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ItemWeight;                                        // 0x0354(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementSpeedMultiplier;                           // 0x0358(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HolsterPlayRate;                                   // 0x035C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DrawPlayRate;                                      // 0x0360(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeanOffset;                                        // 0x0364(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisallowKicking;                                  // 0x0368(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFreelookEnabled;                                  // 0x0369(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseLowReady;                                      // 0x036A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36B[0x1];                                      // 0x036B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PushbackRange;                                     // 0x036C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LowReadyRange;                                     // 0x0370(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LowReadyRangeSightsModifier;                       // 0x0374(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableTickWhenNotEquipped;                       // 0x0378(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_379[0x7];                                      // 0x0379(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EGameVersionRestriction>               LockedToDLC;                                       // 0x0380(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FItemVisualData                        Visuals;                                           // 0x0390(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UTexture2D*                             HudOutline;                                        // 0x03C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraBobScaleH;                                   // 0x03C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraBobScaleV;                                   // 0x03CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraBobSpeedScaleH;                              // 0x03D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraBobSpeedScaleV;                              // 0x03D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraBobAmplitudeBaseSpeed;                       // 0x03D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraBobIntensitySprintScale;                     // 0x03DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraBobAmplitudeWalkScale;                       // 0x03E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraBobAmplitudeSprintScale;                     // 0x03E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponBobScaleH;                                   // 0x03E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponBobScaleV;                                   // 0x03EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponBobScaleInjured;                             // 0x03F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponBobSpeedScaleH;                              // 0x03F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponBobSpeedScaleV;                              // 0x03F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponBobSpeedScaleInjured;                        // 0x03FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponBobCrouchModifier;                           // 0x0400(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponBobADSModifier;                              // 0x0404(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponBobRotPitchScale;                            // 0x0408(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponBobRotRollScale;                             // 0x040C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponBobRotPitchSpeed;                            // 0x0410(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponBobRotRollSpeed;                             // 0x0414(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponBobRotCrouchModifier;                        // 0x0418(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponBobRotADSModifier;                           // 0x041C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        SceneComp;                                         // 0x0420(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 ItemMesh;                                          // 0x0428(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          InteractionBox;                                    // 0x0430(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODAudioComponent*                    FMODAudioComp;                                     // 0x0438(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractableComponent*                 InteractableComponent;                             // 0x0440(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UScoringComponent*                      ScoringComponent;                                  // 0x0448(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEvidenceComponent*                     EvidenceComponent;                                 // 0x0450(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_458[0x18];                                     // 0x0458(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             PhysicsImpact;                                     // 0x0470(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_478[0x10];                                     // 0x0478(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AThrownItem>                ThrownItemClass;                                   // 0x0488(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_490[0x74];                                     // 0x0490(0x0074)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAttachOnDrawComplete;                             // 0x0504(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_505[0x3];                                      // 0x0505(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMesh*                          Rep_CustomItemMeshFromAttachment;                  // 0x0508(0x0008)(Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCustomizationSkin>      DefaultSkin;                                       // 0x0510(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCustomizationSkin*                     Skin;                                              // 0x0538(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         SkinActors;                                        // 0x0540(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_550[0x1];                                      // 0x0550(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bInInventory;                                      // 0x0551(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldTickAnimBPWhenNotEquipped;                  // 0x0552(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_553[0x5];                                      // 0x0553(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Server_ReplicatedPhysicsLocation;                  // 0x0558(0x0018)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetWorldScale;                                  // 0x0570(0x0018)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetWorldScaleInterpSpeed;                       // 0x0588(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58C[0x1];                                      // 0x058C(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsClearable;                                      // 0x058D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasBeenCleared;                                   // 0x058E(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58F[0x9];                                      // 0x058F(0x0009)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UDamageType>>        BlockAnyDamageFrom;                                // 0x0598(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UDamageType>>        BlockDirectHitsFrom;                               // 0x05A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bTaserDamageBlocked;                               // 0x05B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5B9[0x7];                                      // 0x05B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<TSubclassOf<class UDamageType>, float>   MultiplyStunDamageFrom;                            // 0x05C0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<TSubclassOf<class UDamageType>, struct FWeightStunMultiplier> MultiplyStunDamageByWeight;   // 0x0610(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<class UMaterialInstanceDynamic*>       Dynamic1PMaterialInstances;                        // 0x0660(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_670[0x8];                                      // 0x0670(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMaterialInstanceDynamic*>       DynamicWeaponFovMats;                              // 0x0678(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<class USkinnedAsset*, struct FMeshFOVMaterials> SkeletalMeshToFOVMats;                      // 0x0688(0x0050)(NativeAccessSpecifierPublic)
	TMap<class UStaticMesh*, struct FMeshFOVMaterials> StaticMeshToFOVMats;                          // 0x06D8(0x0050)(NativeAccessSpecifierPublic)
	uint8                                         Pad_728[0x8];                                      // 0x0728(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMaterialInstanceDynamic*>       FP_SkinMaterials;                                  // 0x0730(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UMaterialInstanceDynamic*>       TP_SkinMaterials;                                  // 0x0740(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 MasterPoseRep;                                     // 0x0750(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowStaticMeshOnBody;                             // 0x0758(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_759[0x3];                                      // 0x0759(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   WeaponWheelCategoryName;                           // 0x075C(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_764[0x4];                                      // 0x0764(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class ABaseItem* Item)> OnItemUseCompleted;                        // 0x0768(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_778[0x18];                                     // 0x0778(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bCanReloadSameMagazine;                            // 0x0790(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_791[0x7];                                      // 0x0791(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           LastReloadAnim_3P;                                 // 0x0798(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         QuickLeanMultiplier;                               // 0x07A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FreeLeanMultiplier;                                // 0x07A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeaponType                                   WeaponType;                                        // 0x07A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableMeshspaceMovement;                         // 0x07A9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7AA[0x6];                                      // 0x07AA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             MeshspaceTransform_Default;                        // 0x07B0(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             MeshspaceTransform_Aiming;                         // 0x0810(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             MeshspaceTransform_Back;                           // 0x0870(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InertiaDragAimRotation;                            // 0x08D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InertiaDragAimLocation;                            // 0x08D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InertiaDragStrafeRotation;                         // 0x08D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InertiaDragStrafeLocation;                         // 0x08DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MovementSpeedScale;                                // 0x08E0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               MovementSpeedRotationScalePitchYawRoll;            // 0x08F8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MeshSpaceAimInterp;                                // 0x0910(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_914[0xC];                                      // 0x0914(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             MeshspaceTransform_OnDraw;                         // 0x0920(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OnDrawMeshspaceInterp;                             // 0x0980(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_984[0xC];                                      // 0x0984(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             MeshspaceTransform_OnHolster;                      // 0x0990(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OnHolsterMeshspaceInterp;                          // 0x09F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BodySocket;                                        // 0x09F4(0x0008)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HandsSocket;                                       // 0x09FC(0x0008)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AnimationIndex1P;                                  // 0x0A04(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A08[0x4];                                      // 0x0A08(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AnimationIndex3P;                                  // 0x0A0C(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A10[0x4];                                      // 0x0A10(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDeployable;                                       // 0x0A14(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldEquipToHands;                               // 0x0A15(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A16[0x2];                                      // 0x0A16(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EItemCategory>                         ItemCategories;                                    // 0x0A18(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_A28[0x10];                                     // 0x0A28(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class ABaseItem* Item)> OnItemDrawComplete;                        // 0x0A38(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_A48[0x8];                                      // 0x0A48(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ULegacyCameraShake>         Reload_CameraShake;                                // 0x0A50(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ULegacyCameraShake>         ReloadEmpty_CameraShake;                           // 0x0A58(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ULegacyCameraShake>         DrawCameraShake;                                   // 0x0A60(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ULegacyCameraShake>         HolsterCameraShake;                                // 0x0A68(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AReadyOrNotCharacter*                   PreviousOwner;                                     // 0x0A70(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A78[0x38];                                     // 0x0A78(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UObject>                    LastFPAnimInstanceClass;                           // 0x0AB0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AB8[0x38];                                     // 0x0AB8(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UObject>                    LastTPAnimInstanceClass;                           // 0x0AF0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDropping;                                         // 0x0AF8(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AF9[0xF];                                      // 0x0AF9(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDisableAnimInstanceWhenNotEquipped;               // 0x0B08(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B09[0xF];                                      // 0x0B09(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	class UReadyOrNotWeaponAnimData*              AnimationData;                                     // 0x0B18(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReadyOrNotWeaponAnimData*              DefaultAnimationData;                              // 0x0B20(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReadyOrNotWeaponAnimData*              GripAnimationData;                                 // 0x0B28(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReadyOrNotWeaponAnimData*              ShieldRaisedAnimationData;                         // 0x0B30(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReadyOrNotWeaponAnimData*              ShieldLoweredAnimationData;                        // 0x0B38(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FreeAimLimit;                                      // 0x0B40(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FreeAimLimitADS;                                   // 0x0B44(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LazySpringStrength;                                // 0x0B48(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LazySpringStrengthADS;                             // 0x0B4C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FreeAimInterpSpeed;                                // 0x0B50(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FreeAimInterpADSModifier;                          // 0x0B54(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FreeAimInterpHipModifier;                          // 0x0B58(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FreeAimSlowMoveModifier;                           // 0x0B5C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FreeAimSlowMoveTolerance;                          // 0x0B60(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B64[0x4];                                      // 0x0B64(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ULegacyCameraShake>         MeleeUserCameraShake;                              // 0x0B68(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bADSCountsAsAbuse;                                 // 0x0B70(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B71[0x3];                                      // 0x0B71(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HesitationBoostMultiplier;                         // 0x0B74(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAimingDownSights;                               // 0x0B78(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B79[0x3];                                      // 0x0B79(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LowReadyPitchThreshold;                            // 0x0B7C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWeaponSound*                           SoundData;                                         // 0x0B80(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideBreathingEvent;                           // 0x0B88(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B89[0x7];                                      // 0x0B89(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             BreathingAudioOverride;                            // 0x0B90(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEasyPickup;                                       // 0x0B98(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNoPickup;                                         // 0x0B99(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bScriptedFPHidden;                                 // 0x0B9A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMotionBlockType                              ActiveMotionBlock;                                 // 0x0B9B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsOneHandedItem;                                  // 0x0B9C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9D[0x3];                                      // 0x0B9D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FP_ADS_Motion_Weight;                              // 0x0BA0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BA4[0xC];                                      // 0x0BA4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AttachStatic();
	void BP_AttachmentRep();
	void CancelCurrentReloadAction(bool bCancel);
	bool CanShowActionSlot1(class AReadyOrNotCharacter* PC);
	void Client_OnItemPickedUp(class AActor* NewOwner, bool bEquipped);
	void Client_PlayFPMontage(class UAnimMontage* NewMontage, float PlayRate);
	void Client_PlayItemAnimation(const struct FWeaponAnim& InWeaponAnim, bool bRestartIfAlreadyPlaying, bool bOnlyLocal, bool bOnlyTP);
	void Client_SetFPModelVisibility(bool bVisibility);
	void Client_StopItemAnimation(const struct FWeaponAnim& InWeaponAnim, bool bOnlyTP);
	void ClientPlayDraw(bool bDrawFirst);
	void DetachStatic();
	void DisableOrEnableAnimation();
	void DisableOutline();
	void DrawOutline();
	void EndStunWhileEquipped();
	class UAnimMontage* GetCurrentFPMontage();
	class UAnimMontage* GetCurrentTPMontage();
	class FName GetEquipSocket();
	float GetLowReadyRange();
	float GetWeight();
	void InterpToTargetScale(const struct FVector& NewScale, float InterpSpeed);
	bool IsLocallyControlled();
	bool IsMontagePlaying(class UAnimMontage* Montage, bool bIncludeFP, bool bIncludeTP);
	bool IsPlayingStunnedAnimation();
	bool IsPlayingStunnedEndAnimation();
	void LastStunTick(EStunType StunType);
	void MarkAsEvidence(bool bMarkAsEvidence);
	void Multicast_PlayTPMontage(class UAnimMontage* NewMontage, float PlayRate);
	void NextFireMode();
	void OnAddedToInventory(class AReadyOrNotCharacter* NewOwner);
	void OnEvidenceStateChanged(EEvidenceActorState NewState);
	void OnItemEndUse();
	void OnItemPrimaryUse();
	void OnItemPrimaryUseEnd();
	void OnItemUseComplete();
	void OnItemUsed();
	void OnMeshComponentHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void OnOwnerPossessed();
	void OnPhysicsImpact(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void OnRep_AttachmentRep();
	void OnRep_IsDropping();
	void OnRep_MasterPoseComponent();
	void OnRep_Skin();
	void OnThrownFromInventory(class AReadyOrNotCharacter* Thrower, bool bMarkAsEvidence);
	void PlayButtonPushAnimation();
	void PlayDoorPushAnimation();
	bool PlayDraw(bool bDrawFirst);
	void PlayFMODAudio(class UFMODEvent* Event);
	void PlayFPMontage(class UAnimMontage* NewMontage, float PlayRate);
	void PlayTPMontage(class UAnimMontage* NewMontage, float PlayRate);
	void PlayWeaponCleaning();
	void Server_ApplyPointDamage(class AActor* DamagedActor, float BaseDamage, const struct FVector& HitFromDirection, const struct FHitResult& HitInfo, class AController* EventInstigator, class AActor* DamageCauser, TSubclassOf<class UDamageType> DamageTypeClass);
	void Server_PlayTPMontage(class UAnimMontage* NewMontage, float PlayRate);
	void Server_SetMasterPoseComponent(class USkeletalMeshComponent* Mesh);
	void SetupBaseEvents();
	bool ShouldHideInPictureInPictureScopes();
	void SpawnThrownItemAtTransform(const struct FTransform& Transform, const struct FVector& ThrowDirection, const struct FVector& ThrowLocation);
	void StopFPMontage(class UAnimMontage* AnimMontage);
	void StopTPMontage(class UAnimMontage* AnimMontage);
	void StunnedWhileEquipped();
	void StunTick(EStunType StunType);

	bool CanEquip(class AReadyOrNotCharacter* ToCharacter) const;
	bool ContainsItemCategory(EItemCategory TestCategory) const;
	class USkeletalMeshComponent* GetItemMesh() const;
	bool HasButtonPushAnimation() const;
	bool HasDoorPushAnimation() const;
	bool IsBlockingAnimationPlaying(const TArray<EBlockingAnimationExclusion>& Exclusions) const;
	bool IsButtonPushAnimationPlaying() const;
	bool IsCollidesWhileNotEquipped() const;
	bool IsCurrentlyReloading() const;
	bool IsDepleted() const;
	bool IsDoorPushAnimationPlaying() const;
	bool IsEquipped() const;
	bool IsPlayingDraw() const;
	bool IsPlayingHolster() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseItem">();
	}
	static class ABaseItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseItem>();
	}
};
static_assert(alignof(ABaseItem) == 0x000010, "Wrong alignment on ABaseItem");
static_assert(sizeof(ABaseItem) == 0x000BB0, "Wrong size on ABaseItem");
static_assert(offsetof(ABaseItem, ItemName) == 0x0002D8, "Member 'ABaseItem::ItemName' has a wrong offset!");
static_assert(offsetof(ABaseItem, ItemIcon) == 0x0002F0, "Member 'ABaseItem::ItemIcon' has a wrong offset!");
static_assert(offsetof(ABaseItem, ItemDescription) == 0x000318, "Member 'ABaseItem::ItemDescription' has a wrong offset!");
static_assert(offsetof(ABaseItem, ItemClass) == 0x000330, "Member 'ABaseItem::ItemClass' has a wrong offset!");
static_assert(offsetof(ABaseItem, ItemType) == 0x000331, "Member 'ABaseItem::ItemType' has a wrong offset!");
static_assert(offsetof(ABaseItem, CategoryFlags) == 0x000334, "Member 'ABaseItem::CategoryFlags' has a wrong offset!");
static_assert(offsetof(ABaseItem, LoadoutPriority) == 0x000338, "Member 'ABaseItem::LoadoutPriority' has a wrong offset!");
static_assert(offsetof(ABaseItem, bShowInLoadout) == 0x00033C, "Member 'ABaseItem::bShowInLoadout' has a wrong offset!");
static_assert(offsetof(ABaseItem, bIsEmptyItem) == 0x00033D, "Member 'ABaseItem::bIsEmptyItem' has a wrong offset!");
static_assert(offsetof(ABaseItem, CustomizationTag) == 0x000340, "Member 'ABaseItem::CustomizationTag' has a wrong offset!");
static_assert(offsetof(ABaseItem, ItemsPerSlot) == 0x000348, "Member 'ABaseItem::ItemsPerSlot' has a wrong offset!");
static_assert(offsetof(ABaseItem, LookupTableIdx) == 0x00034C, "Member 'ABaseItem::LookupTableIdx' has a wrong offset!");
static_assert(offsetof(ABaseItem, ItemWeight) == 0x000354, "Member 'ABaseItem::ItemWeight' has a wrong offset!");
static_assert(offsetof(ABaseItem, MovementSpeedMultiplier) == 0x000358, "Member 'ABaseItem::MovementSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(ABaseItem, HolsterPlayRate) == 0x00035C, "Member 'ABaseItem::HolsterPlayRate' has a wrong offset!");
static_assert(offsetof(ABaseItem, DrawPlayRate) == 0x000360, "Member 'ABaseItem::DrawPlayRate' has a wrong offset!");
static_assert(offsetof(ABaseItem, LeanOffset) == 0x000364, "Member 'ABaseItem::LeanOffset' has a wrong offset!");
static_assert(offsetof(ABaseItem, bDisallowKicking) == 0x000368, "Member 'ABaseItem::bDisallowKicking' has a wrong offset!");
static_assert(offsetof(ABaseItem, bFreelookEnabled) == 0x000369, "Member 'ABaseItem::bFreelookEnabled' has a wrong offset!");
static_assert(offsetof(ABaseItem, bUseLowReady) == 0x00036A, "Member 'ABaseItem::bUseLowReady' has a wrong offset!");
static_assert(offsetof(ABaseItem, PushbackRange) == 0x00036C, "Member 'ABaseItem::PushbackRange' has a wrong offset!");
static_assert(offsetof(ABaseItem, LowReadyRange) == 0x000370, "Member 'ABaseItem::LowReadyRange' has a wrong offset!");
static_assert(offsetof(ABaseItem, LowReadyRangeSightsModifier) == 0x000374, "Member 'ABaseItem::LowReadyRangeSightsModifier' has a wrong offset!");
static_assert(offsetof(ABaseItem, bDisableTickWhenNotEquipped) == 0x000378, "Member 'ABaseItem::bDisableTickWhenNotEquipped' has a wrong offset!");
static_assert(offsetof(ABaseItem, LockedToDLC) == 0x000380, "Member 'ABaseItem::LockedToDLC' has a wrong offset!");
static_assert(offsetof(ABaseItem, Visuals) == 0x000390, "Member 'ABaseItem::Visuals' has a wrong offset!");
static_assert(offsetof(ABaseItem, HudOutline) == 0x0003C0, "Member 'ABaseItem::HudOutline' has a wrong offset!");
static_assert(offsetof(ABaseItem, CameraBobScaleH) == 0x0003C8, "Member 'ABaseItem::CameraBobScaleH' has a wrong offset!");
static_assert(offsetof(ABaseItem, CameraBobScaleV) == 0x0003CC, "Member 'ABaseItem::CameraBobScaleV' has a wrong offset!");
static_assert(offsetof(ABaseItem, CameraBobSpeedScaleH) == 0x0003D0, "Member 'ABaseItem::CameraBobSpeedScaleH' has a wrong offset!");
static_assert(offsetof(ABaseItem, CameraBobSpeedScaleV) == 0x0003D4, "Member 'ABaseItem::CameraBobSpeedScaleV' has a wrong offset!");
static_assert(offsetof(ABaseItem, CameraBobAmplitudeBaseSpeed) == 0x0003D8, "Member 'ABaseItem::CameraBobAmplitudeBaseSpeed' has a wrong offset!");
static_assert(offsetof(ABaseItem, CameraBobIntensitySprintScale) == 0x0003DC, "Member 'ABaseItem::CameraBobIntensitySprintScale' has a wrong offset!");
static_assert(offsetof(ABaseItem, CameraBobAmplitudeWalkScale) == 0x0003E0, "Member 'ABaseItem::CameraBobAmplitudeWalkScale' has a wrong offset!");
static_assert(offsetof(ABaseItem, CameraBobAmplitudeSprintScale) == 0x0003E4, "Member 'ABaseItem::CameraBobAmplitudeSprintScale' has a wrong offset!");
static_assert(offsetof(ABaseItem, WeaponBobScaleH) == 0x0003E8, "Member 'ABaseItem::WeaponBobScaleH' has a wrong offset!");
static_assert(offsetof(ABaseItem, WeaponBobScaleV) == 0x0003EC, "Member 'ABaseItem::WeaponBobScaleV' has a wrong offset!");
static_assert(offsetof(ABaseItem, WeaponBobScaleInjured) == 0x0003F0, "Member 'ABaseItem::WeaponBobScaleInjured' has a wrong offset!");
static_assert(offsetof(ABaseItem, WeaponBobSpeedScaleH) == 0x0003F4, "Member 'ABaseItem::WeaponBobSpeedScaleH' has a wrong offset!");
static_assert(offsetof(ABaseItem, WeaponBobSpeedScaleV) == 0x0003F8, "Member 'ABaseItem::WeaponBobSpeedScaleV' has a wrong offset!");
static_assert(offsetof(ABaseItem, WeaponBobSpeedScaleInjured) == 0x0003FC, "Member 'ABaseItem::WeaponBobSpeedScaleInjured' has a wrong offset!");
static_assert(offsetof(ABaseItem, WeaponBobCrouchModifier) == 0x000400, "Member 'ABaseItem::WeaponBobCrouchModifier' has a wrong offset!");
static_assert(offsetof(ABaseItem, WeaponBobADSModifier) == 0x000404, "Member 'ABaseItem::WeaponBobADSModifier' has a wrong offset!");
static_assert(offsetof(ABaseItem, WeaponBobRotPitchScale) == 0x000408, "Member 'ABaseItem::WeaponBobRotPitchScale' has a wrong offset!");
static_assert(offsetof(ABaseItem, WeaponBobRotRollScale) == 0x00040C, "Member 'ABaseItem::WeaponBobRotRollScale' has a wrong offset!");
static_assert(offsetof(ABaseItem, WeaponBobRotPitchSpeed) == 0x000410, "Member 'ABaseItem::WeaponBobRotPitchSpeed' has a wrong offset!");
static_assert(offsetof(ABaseItem, WeaponBobRotRollSpeed) == 0x000414, "Member 'ABaseItem::WeaponBobRotRollSpeed' has a wrong offset!");
static_assert(offsetof(ABaseItem, WeaponBobRotCrouchModifier) == 0x000418, "Member 'ABaseItem::WeaponBobRotCrouchModifier' has a wrong offset!");
static_assert(offsetof(ABaseItem, WeaponBobRotADSModifier) == 0x00041C, "Member 'ABaseItem::WeaponBobRotADSModifier' has a wrong offset!");
static_assert(offsetof(ABaseItem, SceneComp) == 0x000420, "Member 'ABaseItem::SceneComp' has a wrong offset!");
static_assert(offsetof(ABaseItem, ItemMesh) == 0x000428, "Member 'ABaseItem::ItemMesh' has a wrong offset!");
static_assert(offsetof(ABaseItem, InteractionBox) == 0x000430, "Member 'ABaseItem::InteractionBox' has a wrong offset!");
static_assert(offsetof(ABaseItem, FMODAudioComp) == 0x000438, "Member 'ABaseItem::FMODAudioComp' has a wrong offset!");
static_assert(offsetof(ABaseItem, InteractableComponent) == 0x000440, "Member 'ABaseItem::InteractableComponent' has a wrong offset!");
static_assert(offsetof(ABaseItem, ScoringComponent) == 0x000448, "Member 'ABaseItem::ScoringComponent' has a wrong offset!");
static_assert(offsetof(ABaseItem, EvidenceComponent) == 0x000450, "Member 'ABaseItem::EvidenceComponent' has a wrong offset!");
static_assert(offsetof(ABaseItem, PhysicsImpact) == 0x000470, "Member 'ABaseItem::PhysicsImpact' has a wrong offset!");
static_assert(offsetof(ABaseItem, ThrownItemClass) == 0x000488, "Member 'ABaseItem::ThrownItemClass' has a wrong offset!");
static_assert(offsetof(ABaseItem, bAttachOnDrawComplete) == 0x000504, "Member 'ABaseItem::bAttachOnDrawComplete' has a wrong offset!");
static_assert(offsetof(ABaseItem, Rep_CustomItemMeshFromAttachment) == 0x000508, "Member 'ABaseItem::Rep_CustomItemMeshFromAttachment' has a wrong offset!");
static_assert(offsetof(ABaseItem, DefaultSkin) == 0x000510, "Member 'ABaseItem::DefaultSkin' has a wrong offset!");
static_assert(offsetof(ABaseItem, Skin) == 0x000538, "Member 'ABaseItem::Skin' has a wrong offset!");
static_assert(offsetof(ABaseItem, SkinActors) == 0x000540, "Member 'ABaseItem::SkinActors' has a wrong offset!");
static_assert(offsetof(ABaseItem, bInInventory) == 0x000551, "Member 'ABaseItem::bInInventory' has a wrong offset!");
static_assert(offsetof(ABaseItem, bShouldTickAnimBPWhenNotEquipped) == 0x000552, "Member 'ABaseItem::bShouldTickAnimBPWhenNotEquipped' has a wrong offset!");
static_assert(offsetof(ABaseItem, Server_ReplicatedPhysicsLocation) == 0x000558, "Member 'ABaseItem::Server_ReplicatedPhysicsLocation' has a wrong offset!");
static_assert(offsetof(ABaseItem, TargetWorldScale) == 0x000570, "Member 'ABaseItem::TargetWorldScale' has a wrong offset!");
static_assert(offsetof(ABaseItem, TargetWorldScaleInterpSpeed) == 0x000588, "Member 'ABaseItem::TargetWorldScaleInterpSpeed' has a wrong offset!");
static_assert(offsetof(ABaseItem, bIsClearable) == 0x00058D, "Member 'ABaseItem::bIsClearable' has a wrong offset!");
static_assert(offsetof(ABaseItem, bHasBeenCleared) == 0x00058E, "Member 'ABaseItem::bHasBeenCleared' has a wrong offset!");
static_assert(offsetof(ABaseItem, BlockAnyDamageFrom) == 0x000598, "Member 'ABaseItem::BlockAnyDamageFrom' has a wrong offset!");
static_assert(offsetof(ABaseItem, BlockDirectHitsFrom) == 0x0005A8, "Member 'ABaseItem::BlockDirectHitsFrom' has a wrong offset!");
static_assert(offsetof(ABaseItem, bTaserDamageBlocked) == 0x0005B8, "Member 'ABaseItem::bTaserDamageBlocked' has a wrong offset!");
static_assert(offsetof(ABaseItem, MultiplyStunDamageFrom) == 0x0005C0, "Member 'ABaseItem::MultiplyStunDamageFrom' has a wrong offset!");
static_assert(offsetof(ABaseItem, MultiplyStunDamageByWeight) == 0x000610, "Member 'ABaseItem::MultiplyStunDamageByWeight' has a wrong offset!");
static_assert(offsetof(ABaseItem, Dynamic1PMaterialInstances) == 0x000660, "Member 'ABaseItem::Dynamic1PMaterialInstances' has a wrong offset!");
static_assert(offsetof(ABaseItem, DynamicWeaponFovMats) == 0x000678, "Member 'ABaseItem::DynamicWeaponFovMats' has a wrong offset!");
static_assert(offsetof(ABaseItem, SkeletalMeshToFOVMats) == 0x000688, "Member 'ABaseItem::SkeletalMeshToFOVMats' has a wrong offset!");
static_assert(offsetof(ABaseItem, StaticMeshToFOVMats) == 0x0006D8, "Member 'ABaseItem::StaticMeshToFOVMats' has a wrong offset!");
static_assert(offsetof(ABaseItem, FP_SkinMaterials) == 0x000730, "Member 'ABaseItem::FP_SkinMaterials' has a wrong offset!");
static_assert(offsetof(ABaseItem, TP_SkinMaterials) == 0x000740, "Member 'ABaseItem::TP_SkinMaterials' has a wrong offset!");
static_assert(offsetof(ABaseItem, MasterPoseRep) == 0x000750, "Member 'ABaseItem::MasterPoseRep' has a wrong offset!");
static_assert(offsetof(ABaseItem, bShowStaticMeshOnBody) == 0x000758, "Member 'ABaseItem::bShowStaticMeshOnBody' has a wrong offset!");
static_assert(offsetof(ABaseItem, WeaponWheelCategoryName) == 0x00075C, "Member 'ABaseItem::WeaponWheelCategoryName' has a wrong offset!");
static_assert(offsetof(ABaseItem, OnItemUseCompleted) == 0x000768, "Member 'ABaseItem::OnItemUseCompleted' has a wrong offset!");
static_assert(offsetof(ABaseItem, bCanReloadSameMagazine) == 0x000790, "Member 'ABaseItem::bCanReloadSameMagazine' has a wrong offset!");
static_assert(offsetof(ABaseItem, LastReloadAnim_3P) == 0x000798, "Member 'ABaseItem::LastReloadAnim_3P' has a wrong offset!");
static_assert(offsetof(ABaseItem, QuickLeanMultiplier) == 0x0007A0, "Member 'ABaseItem::QuickLeanMultiplier' has a wrong offset!");
static_assert(offsetof(ABaseItem, FreeLeanMultiplier) == 0x0007A4, "Member 'ABaseItem::FreeLeanMultiplier' has a wrong offset!");
static_assert(offsetof(ABaseItem, WeaponType) == 0x0007A8, "Member 'ABaseItem::WeaponType' has a wrong offset!");
static_assert(offsetof(ABaseItem, bDisableMeshspaceMovement) == 0x0007A9, "Member 'ABaseItem::bDisableMeshspaceMovement' has a wrong offset!");
static_assert(offsetof(ABaseItem, MeshspaceTransform_Default) == 0x0007B0, "Member 'ABaseItem::MeshspaceTransform_Default' has a wrong offset!");
static_assert(offsetof(ABaseItem, MeshspaceTransform_Aiming) == 0x000810, "Member 'ABaseItem::MeshspaceTransform_Aiming' has a wrong offset!");
static_assert(offsetof(ABaseItem, MeshspaceTransform_Back) == 0x000870, "Member 'ABaseItem::MeshspaceTransform_Back' has a wrong offset!");
static_assert(offsetof(ABaseItem, InertiaDragAimRotation) == 0x0008D0, "Member 'ABaseItem::InertiaDragAimRotation' has a wrong offset!");
static_assert(offsetof(ABaseItem, InertiaDragAimLocation) == 0x0008D4, "Member 'ABaseItem::InertiaDragAimLocation' has a wrong offset!");
static_assert(offsetof(ABaseItem, InertiaDragStrafeRotation) == 0x0008D8, "Member 'ABaseItem::InertiaDragStrafeRotation' has a wrong offset!");
static_assert(offsetof(ABaseItem, InertiaDragStrafeLocation) == 0x0008DC, "Member 'ABaseItem::InertiaDragStrafeLocation' has a wrong offset!");
static_assert(offsetof(ABaseItem, MovementSpeedScale) == 0x0008E0, "Member 'ABaseItem::MovementSpeedScale' has a wrong offset!");
static_assert(offsetof(ABaseItem, MovementSpeedRotationScalePitchYawRoll) == 0x0008F8, "Member 'ABaseItem::MovementSpeedRotationScalePitchYawRoll' has a wrong offset!");
static_assert(offsetof(ABaseItem, MeshSpaceAimInterp) == 0x000910, "Member 'ABaseItem::MeshSpaceAimInterp' has a wrong offset!");
static_assert(offsetof(ABaseItem, MeshspaceTransform_OnDraw) == 0x000920, "Member 'ABaseItem::MeshspaceTransform_OnDraw' has a wrong offset!");
static_assert(offsetof(ABaseItem, OnDrawMeshspaceInterp) == 0x000980, "Member 'ABaseItem::OnDrawMeshspaceInterp' has a wrong offset!");
static_assert(offsetof(ABaseItem, MeshspaceTransform_OnHolster) == 0x000990, "Member 'ABaseItem::MeshspaceTransform_OnHolster' has a wrong offset!");
static_assert(offsetof(ABaseItem, OnHolsterMeshspaceInterp) == 0x0009F0, "Member 'ABaseItem::OnHolsterMeshspaceInterp' has a wrong offset!");
static_assert(offsetof(ABaseItem, BodySocket) == 0x0009F4, "Member 'ABaseItem::BodySocket' has a wrong offset!");
static_assert(offsetof(ABaseItem, HandsSocket) == 0x0009FC, "Member 'ABaseItem::HandsSocket' has a wrong offset!");
static_assert(offsetof(ABaseItem, AnimationIndex1P) == 0x000A04, "Member 'ABaseItem::AnimationIndex1P' has a wrong offset!");
static_assert(offsetof(ABaseItem, AnimationIndex3P) == 0x000A0C, "Member 'ABaseItem::AnimationIndex3P' has a wrong offset!");
static_assert(offsetof(ABaseItem, bDeployable) == 0x000A14, "Member 'ABaseItem::bDeployable' has a wrong offset!");
static_assert(offsetof(ABaseItem, bShouldEquipToHands) == 0x000A15, "Member 'ABaseItem::bShouldEquipToHands' has a wrong offset!");
static_assert(offsetof(ABaseItem, ItemCategories) == 0x000A18, "Member 'ABaseItem::ItemCategories' has a wrong offset!");
static_assert(offsetof(ABaseItem, OnItemDrawComplete) == 0x000A38, "Member 'ABaseItem::OnItemDrawComplete' has a wrong offset!");
static_assert(offsetof(ABaseItem, Reload_CameraShake) == 0x000A50, "Member 'ABaseItem::Reload_CameraShake' has a wrong offset!");
static_assert(offsetof(ABaseItem, ReloadEmpty_CameraShake) == 0x000A58, "Member 'ABaseItem::ReloadEmpty_CameraShake' has a wrong offset!");
static_assert(offsetof(ABaseItem, DrawCameraShake) == 0x000A60, "Member 'ABaseItem::DrawCameraShake' has a wrong offset!");
static_assert(offsetof(ABaseItem, HolsterCameraShake) == 0x000A68, "Member 'ABaseItem::HolsterCameraShake' has a wrong offset!");
static_assert(offsetof(ABaseItem, PreviousOwner) == 0x000A70, "Member 'ABaseItem::PreviousOwner' has a wrong offset!");
static_assert(offsetof(ABaseItem, LastFPAnimInstanceClass) == 0x000AB0, "Member 'ABaseItem::LastFPAnimInstanceClass' has a wrong offset!");
static_assert(offsetof(ABaseItem, LastTPAnimInstanceClass) == 0x000AF0, "Member 'ABaseItem::LastTPAnimInstanceClass' has a wrong offset!");
static_assert(offsetof(ABaseItem, bDropping) == 0x000AF8, "Member 'ABaseItem::bDropping' has a wrong offset!");
static_assert(offsetof(ABaseItem, bDisableAnimInstanceWhenNotEquipped) == 0x000B08, "Member 'ABaseItem::bDisableAnimInstanceWhenNotEquipped' has a wrong offset!");
static_assert(offsetof(ABaseItem, AnimationData) == 0x000B18, "Member 'ABaseItem::AnimationData' has a wrong offset!");
static_assert(offsetof(ABaseItem, DefaultAnimationData) == 0x000B20, "Member 'ABaseItem::DefaultAnimationData' has a wrong offset!");
static_assert(offsetof(ABaseItem, GripAnimationData) == 0x000B28, "Member 'ABaseItem::GripAnimationData' has a wrong offset!");
static_assert(offsetof(ABaseItem, ShieldRaisedAnimationData) == 0x000B30, "Member 'ABaseItem::ShieldRaisedAnimationData' has a wrong offset!");
static_assert(offsetof(ABaseItem, ShieldLoweredAnimationData) == 0x000B38, "Member 'ABaseItem::ShieldLoweredAnimationData' has a wrong offset!");
static_assert(offsetof(ABaseItem, FreeAimLimit) == 0x000B40, "Member 'ABaseItem::FreeAimLimit' has a wrong offset!");
static_assert(offsetof(ABaseItem, FreeAimLimitADS) == 0x000B44, "Member 'ABaseItem::FreeAimLimitADS' has a wrong offset!");
static_assert(offsetof(ABaseItem, LazySpringStrength) == 0x000B48, "Member 'ABaseItem::LazySpringStrength' has a wrong offset!");
static_assert(offsetof(ABaseItem, LazySpringStrengthADS) == 0x000B4C, "Member 'ABaseItem::LazySpringStrengthADS' has a wrong offset!");
static_assert(offsetof(ABaseItem, FreeAimInterpSpeed) == 0x000B50, "Member 'ABaseItem::FreeAimInterpSpeed' has a wrong offset!");
static_assert(offsetof(ABaseItem, FreeAimInterpADSModifier) == 0x000B54, "Member 'ABaseItem::FreeAimInterpADSModifier' has a wrong offset!");
static_assert(offsetof(ABaseItem, FreeAimInterpHipModifier) == 0x000B58, "Member 'ABaseItem::FreeAimInterpHipModifier' has a wrong offset!");
static_assert(offsetof(ABaseItem, FreeAimSlowMoveModifier) == 0x000B5C, "Member 'ABaseItem::FreeAimSlowMoveModifier' has a wrong offset!");
static_assert(offsetof(ABaseItem, FreeAimSlowMoveTolerance) == 0x000B60, "Member 'ABaseItem::FreeAimSlowMoveTolerance' has a wrong offset!");
static_assert(offsetof(ABaseItem, MeleeUserCameraShake) == 0x000B68, "Member 'ABaseItem::MeleeUserCameraShake' has a wrong offset!");
static_assert(offsetof(ABaseItem, bADSCountsAsAbuse) == 0x000B70, "Member 'ABaseItem::bADSCountsAsAbuse' has a wrong offset!");
static_assert(offsetof(ABaseItem, HesitationBoostMultiplier) == 0x000B74, "Member 'ABaseItem::HesitationBoostMultiplier' has a wrong offset!");
static_assert(offsetof(ABaseItem, bIsAimingDownSights) == 0x000B78, "Member 'ABaseItem::bIsAimingDownSights' has a wrong offset!");
static_assert(offsetof(ABaseItem, LowReadyPitchThreshold) == 0x000B7C, "Member 'ABaseItem::LowReadyPitchThreshold' has a wrong offset!");
static_assert(offsetof(ABaseItem, SoundData) == 0x000B80, "Member 'ABaseItem::SoundData' has a wrong offset!");
static_assert(offsetof(ABaseItem, bOverrideBreathingEvent) == 0x000B88, "Member 'ABaseItem::bOverrideBreathingEvent' has a wrong offset!");
static_assert(offsetof(ABaseItem, BreathingAudioOverride) == 0x000B90, "Member 'ABaseItem::BreathingAudioOverride' has a wrong offset!");
static_assert(offsetof(ABaseItem, bEasyPickup) == 0x000B98, "Member 'ABaseItem::bEasyPickup' has a wrong offset!");
static_assert(offsetof(ABaseItem, bNoPickup) == 0x000B99, "Member 'ABaseItem::bNoPickup' has a wrong offset!");
static_assert(offsetof(ABaseItem, bScriptedFPHidden) == 0x000B9A, "Member 'ABaseItem::bScriptedFPHidden' has a wrong offset!");
static_assert(offsetof(ABaseItem, ActiveMotionBlock) == 0x000B9B, "Member 'ABaseItem::ActiveMotionBlock' has a wrong offset!");
static_assert(offsetof(ABaseItem, bIsOneHandedItem) == 0x000B9C, "Member 'ABaseItem::bIsOneHandedItem' has a wrong offset!");
static_assert(offsetof(ABaseItem, FP_ADS_Motion_Weight) == 0x000BA0, "Member 'ABaseItem::FP_ADS_Motion_Weight' has a wrong offset!");

// Class ReadyOrNot.Pepperspray
// 0x0090 (0x0C40 - 0x0BB0)
class APepperspray : public ABaseItem
{
public:
	TSubclassOf<class UDamageType>                DamageType;                                        // 0x0BB0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BB8[0x8];                                      // 0x0BB8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystemComponent*               SprayParticleComponent;                            // 0x0BC0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAmmoComponent*                         AmmoComponent;                                     // 0x0BC8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        ParticleStart;                                     // 0x0BD0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        ParticleEnd;                                       // 0x0BD8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        ParticleImpact;                                    // 0x0BE0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        ParticleRunningOut;                                // 0x0BE8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        ParticleSprayLoop;                                 // 0x0BF0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               ParticleSprayLoopComponent;                        // 0x0BF8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODEvent*                             FMODSprayEvent;                                    // 0x0C00(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODEvent*                             FMODSprayEmptyEvent;                               // 0x0C08(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODEvent*                             FMODImpactEvent;                                   // 0x0C10(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODEvent*                             FMODSprayLowAmmoEvent;                             // 0x0C18(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SprayDistance;                                     // 0x0C20(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bSpraying : 1;                                     // 0x0C24(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_C25[0x3];                                      // 0x0C25(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DurationFrontTorso;                                // 0x0C28(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DurationBackFace;                                  // 0x0C2C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DurationFrontFace;                                 // 0x0C30(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PepperSprayAbuseDebounce;                          // 0x0C34(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C38[0x8];                                      // 0x0C38(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDepletedPeppersprayAmmo();
	void OnLowPeppersprayAmmo(float CurrentResource);
	void OnRep_Spraying();
	void PlaySprayParticleEffect(bool bRunningOutEffect);
	void PlaySpraySoundEffect(bool bRunningOutEffect);
	void Server_StartSpraying();
	void Server_StopSpraying();
	void StartSpraying();
	void StopSpraying();
	void StopSprayParticleEffect();
	void StopSpraySoundEffect();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Pepperspray">();
	}
	static class APepperspray* GetDefaultObj()
	{
		return GetDefaultObjImpl<APepperspray>();
	}
};
static_assert(alignof(APepperspray) == 0x000010, "Wrong alignment on APepperspray");
static_assert(sizeof(APepperspray) == 0x000C40, "Wrong size on APepperspray");
static_assert(offsetof(APepperspray, DamageType) == 0x000BB0, "Member 'APepperspray::DamageType' has a wrong offset!");
static_assert(offsetof(APepperspray, SprayParticleComponent) == 0x000BC0, "Member 'APepperspray::SprayParticleComponent' has a wrong offset!");
static_assert(offsetof(APepperspray, AmmoComponent) == 0x000BC8, "Member 'APepperspray::AmmoComponent' has a wrong offset!");
static_assert(offsetof(APepperspray, ParticleStart) == 0x000BD0, "Member 'APepperspray::ParticleStart' has a wrong offset!");
static_assert(offsetof(APepperspray, ParticleEnd) == 0x000BD8, "Member 'APepperspray::ParticleEnd' has a wrong offset!");
static_assert(offsetof(APepperspray, ParticleImpact) == 0x000BE0, "Member 'APepperspray::ParticleImpact' has a wrong offset!");
static_assert(offsetof(APepperspray, ParticleRunningOut) == 0x000BE8, "Member 'APepperspray::ParticleRunningOut' has a wrong offset!");
static_assert(offsetof(APepperspray, ParticleSprayLoop) == 0x000BF0, "Member 'APepperspray::ParticleSprayLoop' has a wrong offset!");
static_assert(offsetof(APepperspray, ParticleSprayLoopComponent) == 0x000BF8, "Member 'APepperspray::ParticleSprayLoopComponent' has a wrong offset!");
static_assert(offsetof(APepperspray, FMODSprayEvent) == 0x000C00, "Member 'APepperspray::FMODSprayEvent' has a wrong offset!");
static_assert(offsetof(APepperspray, FMODSprayEmptyEvent) == 0x000C08, "Member 'APepperspray::FMODSprayEmptyEvent' has a wrong offset!");
static_assert(offsetof(APepperspray, FMODImpactEvent) == 0x000C10, "Member 'APepperspray::FMODImpactEvent' has a wrong offset!");
static_assert(offsetof(APepperspray, FMODSprayLowAmmoEvent) == 0x000C18, "Member 'APepperspray::FMODSprayLowAmmoEvent' has a wrong offset!");
static_assert(offsetof(APepperspray, SprayDistance) == 0x000C20, "Member 'APepperspray::SprayDistance' has a wrong offset!");
static_assert(offsetof(APepperspray, DurationFrontTorso) == 0x000C28, "Member 'APepperspray::DurationFrontTorso' has a wrong offset!");
static_assert(offsetof(APepperspray, DurationBackFace) == 0x000C2C, "Member 'APepperspray::DurationBackFace' has a wrong offset!");
static_assert(offsetof(APepperspray, DurationFrontFace) == 0x000C30, "Member 'APepperspray::DurationFrontFace' has a wrong offset!");
static_assert(offsetof(APepperspray, PepperSprayAbuseDebounce) == 0x000C34, "Member 'APepperspray::PepperSprayAbuseDebounce' has a wrong offset!");

// Class ReadyOrNot.ActivityFiniteStateMachine
// 0x0020 (0x0048 - 0x0028)
class UActivityFiniteStateMachine final : public UObject
{
public:
	TArray<class UActivityState*>                 States;                                            // 0x0028(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, UObjectWrapper, NativeAccessSpecifierPrivate)
	class UActivityState*                         ActiveState;                                       // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bMachineInitialized : 1;                           // 0x0040(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnTemplate, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UActivityState* AddState(const class FString& NewStateName, const TArray<struct FActivityStateTransition>& Transitions);
	class UActivityState* GetActiveState();

	class UActivityState* GetStateByID(int32 InStateID) const;
	class UActivityState* GetStateByName(const class FString& InStateName) const;
	bool IsMachineInitialized() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivityFiniteStateMachine">();
	}
	static class UActivityFiniteStateMachine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivityFiniteStateMachine>();
	}
};
static_assert(alignof(UActivityFiniteStateMachine) == 0x000008, "Wrong alignment on UActivityFiniteStateMachine");
static_assert(sizeof(UActivityFiniteStateMachine) == 0x000048, "Wrong size on UActivityFiniteStateMachine");
static_assert(offsetof(UActivityFiniteStateMachine, States) == 0x000028, "Member 'UActivityFiniteStateMachine::States' has a wrong offset!");
static_assert(offsetof(UActivityFiniteStateMachine, ActiveState) == 0x000038, "Member 'UActivityFiniteStateMachine::ActiveState' has a wrong offset!");

// Class ReadyOrNot.ActivityManager
// 0x0070 (0x00B0 - 0x0040)
class UActivityManager final : public UTickableWorldSubsystem
{
public:
	TMulticastInlineDelegate<void(class UBaseActivity* Activity, class ACyberneticController* Controller)> OnStartActivity; // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class UBaseActivity*>                  AllActivities;                                     // 0x0050(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<TSubclassOf<class UBaseActivity>, float> ActivityClassGlobalCooldownMap;                    // 0x0060(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UBaseActivity* CreateActivity(class UObject* ContextObject, TSubclassOf<class UBaseActivity> InActivityClass, const class FText& InActivityName, float InActivityStartDelay);
	static bool GiveActivityTo(class UBaseActivity* InActivity, class ACyberneticCharacter* InCharacter, bool bOverrideCurrentActivity, bool bClearActivityList);

	bool IsActivityClassOnCooldown(TSubclassOf<class UBaseActivity> Class_0) const;
	bool IsActivityClassOnCooldown_WithTimeRemaining(TSubclassOf<class UBaseActivity> Class_0, float* TimeRemaining) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivityManager">();
	}
	static class UActivityManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivityManager>();
	}
};
static_assert(alignof(UActivityManager) == 0x000008, "Wrong alignment on UActivityManager");
static_assert(sizeof(UActivityManager) == 0x0000B0, "Wrong size on UActivityManager");
static_assert(offsetof(UActivityManager, OnStartActivity) == 0x000040, "Member 'UActivityManager::OnStartActivity' has a wrong offset!");
static_assert(offsetof(UActivityManager, AllActivities) == 0x000050, "Member 'UActivityManager::AllActivities' has a wrong offset!");
static_assert(offsetof(UActivityManager, ActivityClassGlobalCooldownMap) == 0x000060, "Member 'UActivityManager::ActivityClassGlobalCooldownMap' has a wrong offset!");

// Class ReadyOrNot.AnimNotify_DisarmExplosiveVest
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_DisarmExplosiveVest final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_DisarmExplosiveVest">();
	}
	static class UAnimNotify_DisarmExplosiveVest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_DisarmExplosiveVest>();
	}
};
static_assert(alignof(UAnimNotify_DisarmExplosiveVest) == 0x000008, "Wrong alignment on UAnimNotify_DisarmExplosiveVest");
static_assert(sizeof(UAnimNotify_DisarmExplosiveVest) == 0x000038, "Wrong size on UAnimNotify_DisarmExplosiveVest");

// Class ReadyOrNot.ActivityTriggerVolume
// 0x00B0 (0x0350 - 0x02A0)
class AActivityTriggerVolume : public ATriggerBox
{
public:
	TArray<struct FActivityEvent>                 ActivationEvents;                                  // 0x02A0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FActivityEvent>                 OnEnterEvents;                                     // 0x02B0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UActivityData*>                  Activities;                                        // 0x02C0(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<struct FActivityEvent>                 OnLeaveEvents;                                     // 0x02D0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FActivityEvent>                 CompletionEvents;                                  // 0x02E0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class AActivityTriggerVolume>  NextTransitionVolume;                              // 0x02F0(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TransitionDelay;                                   // 0x0318(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bStartActive;                                      // 0x031C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31D[0x3];                                      // 0x031D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ActivityDelay;                                     // 0x0320(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bTriggerEventsWhileInactive;                       // 0x0324(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDrawDebug;                                        // 0x0325(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_326[0x2];                                      // 0x0326(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerCharacter*                       PlayerCharacter;                                   // 0x0328(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           ActivateDelayTimerHandle;                          // 0x0330(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_338[0x8];                                      // 0x0338(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AActivityTriggerVolume* TriggerVolume)> OnAllActivitiesComplete; // 0x0340(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void Activate();
	void Deactivate();
	void OnActivityComplete(class UActivityData* Activity);
	void OnPlayerBeginOverlap(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnPlayerEndOverlap(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnSpawnedAiKilled(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter);
	void Reactivate(float ReactivateDelay);
	void ResetAllProgress();

	bool AllActivitiesComplete() const;
	TArray<class UActivityData*> GetActivities() const;
	bool IsActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivityTriggerVolume">();
	}
	static class AActivityTriggerVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AActivityTriggerVolume>();
	}
};
static_assert(alignof(AActivityTriggerVolume) == 0x000008, "Wrong alignment on AActivityTriggerVolume");
static_assert(sizeof(AActivityTriggerVolume) == 0x000350, "Wrong size on AActivityTriggerVolume");
static_assert(offsetof(AActivityTriggerVolume, ActivationEvents) == 0x0002A0, "Member 'AActivityTriggerVolume::ActivationEvents' has a wrong offset!");
static_assert(offsetof(AActivityTriggerVolume, OnEnterEvents) == 0x0002B0, "Member 'AActivityTriggerVolume::OnEnterEvents' has a wrong offset!");
static_assert(offsetof(AActivityTriggerVolume, Activities) == 0x0002C0, "Member 'AActivityTriggerVolume::Activities' has a wrong offset!");
static_assert(offsetof(AActivityTriggerVolume, OnLeaveEvents) == 0x0002D0, "Member 'AActivityTriggerVolume::OnLeaveEvents' has a wrong offset!");
static_assert(offsetof(AActivityTriggerVolume, CompletionEvents) == 0x0002E0, "Member 'AActivityTriggerVolume::CompletionEvents' has a wrong offset!");
static_assert(offsetof(AActivityTriggerVolume, NextTransitionVolume) == 0x0002F0, "Member 'AActivityTriggerVolume::NextTransitionVolume' has a wrong offset!");
static_assert(offsetof(AActivityTriggerVolume, TransitionDelay) == 0x000318, "Member 'AActivityTriggerVolume::TransitionDelay' has a wrong offset!");
static_assert(offsetof(AActivityTriggerVolume, bStartActive) == 0x00031C, "Member 'AActivityTriggerVolume::bStartActive' has a wrong offset!");
static_assert(offsetof(AActivityTriggerVolume, ActivityDelay) == 0x000320, "Member 'AActivityTriggerVolume::ActivityDelay' has a wrong offset!");
static_assert(offsetof(AActivityTriggerVolume, bTriggerEventsWhileInactive) == 0x000324, "Member 'AActivityTriggerVolume::bTriggerEventsWhileInactive' has a wrong offset!");
static_assert(offsetof(AActivityTriggerVolume, bDrawDebug) == 0x000325, "Member 'AActivityTriggerVolume::bDrawDebug' has a wrong offset!");
static_assert(offsetof(AActivityTriggerVolume, PlayerCharacter) == 0x000328, "Member 'AActivityTriggerVolume::PlayerCharacter' has a wrong offset!");
static_assert(offsetof(AActivityTriggerVolume, ActivateDelayTimerHandle) == 0x000330, "Member 'AActivityTriggerVolume::ActivateDelayTimerHandle' has a wrong offset!");
static_assert(offsetof(AActivityTriggerVolume, OnAllActivitiesComplete) == 0x000340, "Member 'AActivityTriggerVolume::OnAllActivitiesComplete' has a wrong offset!");

// Class ReadyOrNot.BaseWidget
// 0x0028 (0x02E8 - 0x02C0)
class UBaseWidget : public UUserWidget
{
public:
	struct FVector2D                              MouseAxisDeltaThreshold;                           // 0x02C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              GamepadAxisDeltaThreshold;                         // 0x02D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AReadyOrNotGameState*                   RONGS;                                             // 0x02E0(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	struct FVector2D GetCenterScreenPosition();
	void HideWidget();
	bool IsBlockingAnimationPlaying();
	bool IsGamepadAxisBeyondThreshold(const struct FVector2D& InGamepadAxis);
	bool IsMouseAxisBeyondThreshold(const struct FVector2D& InMouseDelta);
	void PauseWidgetAnimation_Internal(class UWidgetAnimation* InWidgetAnimation);
	void PlaySoundEffect(class UFMODEvent* SoundEffectToPlay);
	void PlayWidgetAnimation_Internal(class UWidgetAnimation* InWidgetAnimation, bool bRestartIfAlreadyPlaying);
	void ShowWidget(bool bNotHitTestable);
	void StopWidgetAnimation_Internal(class UWidgetAnimation* InWidgetAnimation);
	void ToggleWidgetVisibility(bool bNotHitTestable);
	bool UpdateDebugInfo();

	struct FVector2D GetMouseDelta() const;
	struct FVector2D GetMousePosition() const;
	bool HasMouseMoved() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseWidget">();
	}
	static class UBaseWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseWidget>();
	}
};
static_assert(alignof(UBaseWidget) == 0x000008, "Wrong alignment on UBaseWidget");
static_assert(sizeof(UBaseWidget) == 0x0002E8, "Wrong size on UBaseWidget");
static_assert(offsetof(UBaseWidget, MouseAxisDeltaThreshold) == 0x0002C0, "Member 'UBaseWidget::MouseAxisDeltaThreshold' has a wrong offset!");
static_assert(offsetof(UBaseWidget, GamepadAxisDeltaThreshold) == 0x0002D0, "Member 'UBaseWidget::GamepadAxisDeltaThreshold' has a wrong offset!");
static_assert(offsetof(UBaseWidget, RONGS) == 0x0002E0, "Member 'UBaseWidget::RONGS' has a wrong offset!");

// Class ReadyOrNot.ObjectiveWidget
// 0x0010 (0x02F8 - 0x02E8)
class UObjectiveWidget final : public UBaseWidget
{
public:
	class UWidgetComponent*                       OwningComponent;                                   // 0x02E8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETeamType                                     ObjectiveTeam;                                     // 0x02F0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F1[0x7];                                      // 0x02F1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetObjectiveText(const class FText& NewText);
	void SetObjectiveType(EPlayerObjectiveMarkerType NewType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectiveWidget">();
	}
	static class UObjectiveWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectiveWidget>();
	}
};
static_assert(alignof(UObjectiveWidget) == 0x000008, "Wrong alignment on UObjectiveWidget");
static_assert(sizeof(UObjectiveWidget) == 0x0002F8, "Wrong size on UObjectiveWidget");
static_assert(offsetof(UObjectiveWidget, OwningComponent) == 0x0002E8, "Member 'UObjectiveWidget::OwningComponent' has a wrong offset!");
static_assert(offsetof(UObjectiveWidget, ObjectiveTeam) == 0x0002F0, "Member 'UObjectiveWidget::ObjectiveTeam' has a wrong offset!");

// Class ReadyOrNot.ReadyOrNotGameMode
// 0x0638 (0x0970 - 0x0338)
class alignas(0x10) AReadyOrNotGameMode : public AGameModeBase
{
public:
	uint8                                         Pad_338[0x58];                                     // 0x0338(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataTableRowHandle                    GameModeSettings;                                  // 0x0390(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A0[0x4];                                      // 0x03A0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeSinceGameStart;                                // 0x03A4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A8[0x58];                                     // 0x03A8(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class AReadyOrNotCharacter*, int32>      AbuseCountMap;                                     // 0x0400(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bIsCampaignTransitioning;                          // 0x0450(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_451[0x7];                                      // 0x0451(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           Reinforcement_Handle;                              // 0x0458(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRunWarmup;                                        // 0x0460(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bArrestSpectator;                                  // 0x0461(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowLoadouts;                                    // 0x0462(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_463[0x1];                                      // 0x0463(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxPlayersAllowed;                                 // 0x0464(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayersJoining;                                    // 0x0468(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnabledForPlay;                                   // 0x046C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_46D[0x3];                                      // 0x046D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 urlShortName;                                      // 0x0470(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Password;                                          // 0x0480(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     PlayerStartClass;                                  // 0x0490(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ASpectatePawn>              DeadSpectatorClass;                                // 0x0498(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LobbyStartTag;                                     // 0x04A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RedCustomizationStartTag;                          // 0x04A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BlueCustomizationStartTag;                         // 0x04B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SWATBlueStartTag;                                  // 0x04B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SWATRedStartTag;                                   // 0x04C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SuspectStartTag;                                   // 0x04C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpectateKillerOnDeath;                            // 0x04D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInitialPlayerRespawn;                             // 0x04D1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bDrawPlayerCameraSphere : 1;                       // 0x04D2(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_4D3[0x5];                                      // 0x04D3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnMatchStarted;                                    // 0x04D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	ERespawnMode                                  RespawnMode;                                       // 0x04E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E9[0x1];                                      // 0x04E9(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bTimelimitUsedInMode;                              // 0x04EA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMatchState                                   CurrentMatchState;                                 // 0x04EB(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4EC[0x4];                                      // 0x04EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(EMatchState NewMatchState)> OnMatchStateChanged;                   // 0x04F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_500[0x8];                                      // 0x0500(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSavedLoadout                          DefaultLoadoutIfNothingLoaded;                     // 0x0508(0x02E8)(Edit, NativeAccessSpecifierPublic)
	uint8                                         Pad_7F0[0x8];                                      // 0x07F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ModeName;                                          // 0x07F8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   ModeDescription;                                   // 0x0810(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bCanRespawn;                                       // 0x0828(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_829[0x3];                                      // 0x0829(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinimumPlayersToStart;                             // 0x082C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinimumPlayersForTimer;                            // 0x0830(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_834[0x4];                                      // 0x0834(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   BlueCharacterClass;                                // 0x0838(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   RedCharacterClass;                                 // 0x0860(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_888[0x68];                                     // 0x0888(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class APlayerController*>              DeadPlayers;                                       // 0x08F0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class APlayerController*>              RespawnableDeadPlayers;                            // 0x0900(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class FString                                 PlayerSpawnTag;                                    // 0x0910(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class APawn* Pawn, class APlayerController* Controller)> OnPlayerRespawned; // 0x0920(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSubclassOf<class UUserWidget>                CharacterHUD;                                      // 0x0930(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ASpectatorPawn>             NormalSpectatorPawn;                               // 0x0938(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMissionPlanManager*                    MissionPlanManager;                                // 0x0940(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMissionExfiltrated;                               // 0x0948(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsExfilEnabled;                                   // 0x0949(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94A[0x26];                                     // 0x094A(0x0026)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void AddAbuse(class AReadyOrNotCharacter* Abuser, class ACyberneticCharacter* Abused);

	bool AreAllPlayersDead();
	void CheckToAnnounceTeamkill(class ACharacter* InstigatorCharacter, class ACharacter* KilledCharacter);
	bool DoesLevelRequireGeneration();
	void ExfiltrateMission(const TArray<class ASWATCharacter*>& ExfilCharacters);
	bool GetIsExfilEnabled();
	EMatchState GetMatchState();
	class AReadyOrNotGameSession* GetReadyOrNotGameSession();
	class AReadyOrNotGameState* GetReadyOrNotGameState();
	class AActor* GetThisPlayersStartPointByTag(class APlayerController* Player, const class FString& IncomingName);
	bool IsTeamDead(ETeamType Team, bool bIncludeArrestedAsDead);
	bool KickPlayer(class APlayerController* KickedPlayer, const class FText& KickReason);
	void NextGame();
	void OnBanStatusChecked(const class FString& SteamId, bool bIsBanned, const class FString& BanReason, bool bIsMySteamId);
	void OnOutOfBoundsTimeLimitEnded();
	void PlayerArrested(class AReadyOrNotCharacter* ArrestedCharacter, class AReadyOrNotCharacter* InstigatorCharacter);
	void PlayerDowned(class AReadyOrNotCharacter* DownedCharacter, class AReadyOrNotCharacter* InstigatorCharacter);
	void PlayerFreed(class ACharacter* Freed, class ACharacter* Freer);
	void PlayerKilled(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter);
	void PlayerTakenDamage(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* DamagedCharacter, class AActor* DamageCauser, float Damage, float HealthRemaining);
	void ProcessServerTravel(const class FString& URL, bool bAbsolute);
	void RefreshSession();
	bool RemoveDeadPlayer(class APlayerController* InPlayerController);
	bool RemoveDeadPlayerAt(int32 Index_0);
	void RespawnAllPlayers();
	void RespawnAllPlayersOnTeam(ETeamType Team);
	void RespawnDeadPlayers();
	void RespawnDeadPlayersOnTeam(ETeamType Team);
	void RespawnPlayer(class APlayerController* Player, bool bForceSpectator);
	void RestartGame();
	void SetExfilEnabled(bool bEnabled);
	void SetMatchState(EMatchState NewMatchState);
	void SetPassword(const class FString& newPassword);
	bool ShouldCountDownTimelimitNow();
	class APlayerCharacter* SpawnPlayerCharacter(class APlayerController* Controller, TSubclassOf<class APlayerCharacter> Class_0, const struct FTransform& SpawnTransform);
	class ASpectatorPawn* SpawnSpectator(class AReadyOrNotPlayerController* Controller, bool bDeadSpectator, const struct FTransform& SpawnTransform);
	void StartMatch();
	void SwapPlayerTeams();

	TArray<class APlayerCharacter*> GetAllPlayerCharactersInWorld() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotGameMode">();
	}
	static class AReadyOrNotGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AReadyOrNotGameMode>();
	}
};
static_assert(alignof(AReadyOrNotGameMode) == 0x000010, "Wrong alignment on AReadyOrNotGameMode");
static_assert(sizeof(AReadyOrNotGameMode) == 0x000970, "Wrong size on AReadyOrNotGameMode");
static_assert(offsetof(AReadyOrNotGameMode, GameModeSettings) == 0x000390, "Member 'AReadyOrNotGameMode::GameModeSettings' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, TimeSinceGameStart) == 0x0003A4, "Member 'AReadyOrNotGameMode::TimeSinceGameStart' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, AbuseCountMap) == 0x000400, "Member 'AReadyOrNotGameMode::AbuseCountMap' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, bIsCampaignTransitioning) == 0x000450, "Member 'AReadyOrNotGameMode::bIsCampaignTransitioning' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, Reinforcement_Handle) == 0x000458, "Member 'AReadyOrNotGameMode::Reinforcement_Handle' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, bRunWarmup) == 0x000460, "Member 'AReadyOrNotGameMode::bRunWarmup' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, bArrestSpectator) == 0x000461, "Member 'AReadyOrNotGameMode::bArrestSpectator' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, bAllowLoadouts) == 0x000462, "Member 'AReadyOrNotGameMode::bAllowLoadouts' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, MaxPlayersAllowed) == 0x000464, "Member 'AReadyOrNotGameMode::MaxPlayersAllowed' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, PlayersJoining) == 0x000468, "Member 'AReadyOrNotGameMode::PlayersJoining' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, bEnabledForPlay) == 0x00046C, "Member 'AReadyOrNotGameMode::bEnabledForPlay' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, urlShortName) == 0x000470, "Member 'AReadyOrNotGameMode::urlShortName' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, Password) == 0x000480, "Member 'AReadyOrNotGameMode::Password' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, PlayerStartClass) == 0x000490, "Member 'AReadyOrNotGameMode::PlayerStartClass' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, DeadSpectatorClass) == 0x000498, "Member 'AReadyOrNotGameMode::DeadSpectatorClass' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, LobbyStartTag) == 0x0004A0, "Member 'AReadyOrNotGameMode::LobbyStartTag' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, RedCustomizationStartTag) == 0x0004A8, "Member 'AReadyOrNotGameMode::RedCustomizationStartTag' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, BlueCustomizationStartTag) == 0x0004B0, "Member 'AReadyOrNotGameMode::BlueCustomizationStartTag' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, SWATBlueStartTag) == 0x0004B8, "Member 'AReadyOrNotGameMode::SWATBlueStartTag' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, SWATRedStartTag) == 0x0004C0, "Member 'AReadyOrNotGameMode::SWATRedStartTag' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, SuspectStartTag) == 0x0004C8, "Member 'AReadyOrNotGameMode::SuspectStartTag' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, bSpectateKillerOnDeath) == 0x0004D0, "Member 'AReadyOrNotGameMode::bSpectateKillerOnDeath' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, bInitialPlayerRespawn) == 0x0004D1, "Member 'AReadyOrNotGameMode::bInitialPlayerRespawn' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, OnMatchStarted) == 0x0004D8, "Member 'AReadyOrNotGameMode::OnMatchStarted' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, RespawnMode) == 0x0004E8, "Member 'AReadyOrNotGameMode::RespawnMode' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, bTimelimitUsedInMode) == 0x0004EA, "Member 'AReadyOrNotGameMode::bTimelimitUsedInMode' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, CurrentMatchState) == 0x0004EB, "Member 'AReadyOrNotGameMode::CurrentMatchState' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, OnMatchStateChanged) == 0x0004F0, "Member 'AReadyOrNotGameMode::OnMatchStateChanged' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, DefaultLoadoutIfNothingLoaded) == 0x000508, "Member 'AReadyOrNotGameMode::DefaultLoadoutIfNothingLoaded' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, ModeName) == 0x0007F8, "Member 'AReadyOrNotGameMode::ModeName' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, ModeDescription) == 0x000810, "Member 'AReadyOrNotGameMode::ModeDescription' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, bCanRespawn) == 0x000828, "Member 'AReadyOrNotGameMode::bCanRespawn' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, MinimumPlayersToStart) == 0x00082C, "Member 'AReadyOrNotGameMode::MinimumPlayersToStart' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, MinimumPlayersForTimer) == 0x000830, "Member 'AReadyOrNotGameMode::MinimumPlayersForTimer' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, BlueCharacterClass) == 0x000838, "Member 'AReadyOrNotGameMode::BlueCharacterClass' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, RedCharacterClass) == 0x000860, "Member 'AReadyOrNotGameMode::RedCharacterClass' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, DeadPlayers) == 0x0008F0, "Member 'AReadyOrNotGameMode::DeadPlayers' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, RespawnableDeadPlayers) == 0x000900, "Member 'AReadyOrNotGameMode::RespawnableDeadPlayers' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, PlayerSpawnTag) == 0x000910, "Member 'AReadyOrNotGameMode::PlayerSpawnTag' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, OnPlayerRespawned) == 0x000920, "Member 'AReadyOrNotGameMode::OnPlayerRespawned' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, CharacterHUD) == 0x000930, "Member 'AReadyOrNotGameMode::CharacterHUD' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, NormalSpectatorPawn) == 0x000938, "Member 'AReadyOrNotGameMode::NormalSpectatorPawn' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, MissionPlanManager) == 0x000940, "Member 'AReadyOrNotGameMode::MissionPlanManager' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, bMissionExfiltrated) == 0x000948, "Member 'AReadyOrNotGameMode::bMissionExfiltrated' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode, bIsExfilEnabled) == 0x000949, "Member 'AReadyOrNotGameMode::bIsExfilEnabled' has a wrong offset!");

// Class ReadyOrNot.ReadyOrNotGameMode_PVP
// 0x0060 (0x09D0 - 0x0970)
class AReadyOrNotGameMode_PVP : public AReadyOrNotGameMode
{
public:
	TMulticastInlineDelegate<void()>              OnMatchStart;                                      // 0x0970(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(ETeamType WinningTeam)> OnRoundWon;                                // 0x0980(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnRoundStart;                                      // 0x0990(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnRoundEnd;                                        // 0x09A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         RoundEndResetDelay;                                // 0x09B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MatchEndResetDelay;                                // 0x09B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class URoundEndWidget_PVP>        RoundEndWidgetClass;                               // 0x09B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bIncrementedRoundCounterThisRound : 1;             // 0x09C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_9C1[0xF];                                      // 0x09C1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AnyDeathsOnWinningTeam();
	void CheckRoundEnd(float DeltaSeconds);
	void MatchEnd();
	void Multicast_SetWinningTeam(ETeamType WinningTeam);
	void NextRound();
	void OnRoundEnded();
	void OnRoundStarted();
	void RoundEnd();
	void RoundWon(const TArray<class AReadyOrNotPlayerState*>& WinningPlayers);
	void RoundWonTeam(ETeamType WinningTeam);
	void TimelimitReached();
	void TimeLimitVictoryConditions();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotGameMode_PVP">();
	}
	static class AReadyOrNotGameMode_PVP* GetDefaultObj()
	{
		return GetDefaultObjImpl<AReadyOrNotGameMode_PVP>();
	}
};
static_assert(alignof(AReadyOrNotGameMode_PVP) == 0x000010, "Wrong alignment on AReadyOrNotGameMode_PVP");
static_assert(sizeof(AReadyOrNotGameMode_PVP) == 0x0009D0, "Wrong size on AReadyOrNotGameMode_PVP");
static_assert(offsetof(AReadyOrNotGameMode_PVP, OnMatchStart) == 0x000970, "Member 'AReadyOrNotGameMode_PVP::OnMatchStart' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode_PVP, OnRoundWon) == 0x000980, "Member 'AReadyOrNotGameMode_PVP::OnRoundWon' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode_PVP, OnRoundStart) == 0x000990, "Member 'AReadyOrNotGameMode_PVP::OnRoundStart' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode_PVP, OnRoundEnd) == 0x0009A0, "Member 'AReadyOrNotGameMode_PVP::OnRoundEnd' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode_PVP, RoundEndResetDelay) == 0x0009B0, "Member 'AReadyOrNotGameMode_PVP::RoundEndResetDelay' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode_PVP, MatchEndResetDelay) == 0x0009B4, "Member 'AReadyOrNotGameMode_PVP::MatchEndResetDelay' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameMode_PVP, RoundEndWidgetClass) == 0x0009B8, "Member 'AReadyOrNotGameMode_PVP::RoundEndWidgetClass' has a wrong offset!");

// Class ReadyOrNot.ArrestAndRescueGM
// 0x0040 (0x0A10 - 0x09D0)
class AArrestAndRescueGM final : public AReadyOrNotGameMode_PVP
{
public:
	bool                                          bSuddenDeath;                                      // 0x09D0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9D1[0x7];                                      // 0x09D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class APlayerCharacter*>               ArrestedBlueCharacters;                            // 0x09D8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class APlayerCharacter*>               ArrestedRedCharacters;                             // 0x09E8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class UFMODEvent*                             VIPArrestedSound;                                  // 0x09F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             VIPKilledSound;                                    // 0x0A00(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A08[0x8];                                      // 0x0A08(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArrestAndRescueGM">();
	}
	static class AArrestAndRescueGM* GetDefaultObj()
	{
		return GetDefaultObjImpl<AArrestAndRescueGM>();
	}
};
static_assert(alignof(AArrestAndRescueGM) == 0x000010, "Wrong alignment on AArrestAndRescueGM");
static_assert(sizeof(AArrestAndRescueGM) == 0x000A10, "Wrong size on AArrestAndRescueGM");
static_assert(offsetof(AArrestAndRescueGM, bSuddenDeath) == 0x0009D0, "Member 'AArrestAndRescueGM::bSuddenDeath' has a wrong offset!");
static_assert(offsetof(AArrestAndRescueGM, ArrestedBlueCharacters) == 0x0009D8, "Member 'AArrestAndRescueGM::ArrestedBlueCharacters' has a wrong offset!");
static_assert(offsetof(AArrestAndRescueGM, ArrestedRedCharacters) == 0x0009E8, "Member 'AArrestAndRescueGM::ArrestedRedCharacters' has a wrong offset!");
static_assert(offsetof(AArrestAndRescueGM, VIPArrestedSound) == 0x0009F8, "Member 'AArrestAndRescueGM::VIPArrestedSound' has a wrong offset!");
static_assert(offsetof(AArrestAndRescueGM, VIPKilledSound) == 0x000A00, "Member 'AArrestAndRescueGM::VIPKilledSound' has a wrong offset!");

// Class ReadyOrNot.ActorSpawnPoint
// 0x0018 (0x02B0 - 0x0298)
class AActorSpawnPoint : public AActor
{
public:
	class USceneComponent*                        SceneComponent;                                    // 0x0298(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBillboardComponent*                    BillboardComponent;                                // 0x02A0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bHasVisited : 1;                                   // 0x02A8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2A9[0x7];                                      // 0x02A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorSpawnPoint">();
	}
	static class AActorSpawnPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AActorSpawnPoint>();
	}
};
static_assert(alignof(AActorSpawnPoint) == 0x000008, "Wrong alignment on AActorSpawnPoint");
static_assert(sizeof(AActorSpawnPoint) == 0x0002B0, "Wrong size on AActorSpawnPoint");
static_assert(offsetof(AActorSpawnPoint, SceneComponent) == 0x000298, "Member 'AActorSpawnPoint::SceneComponent' has a wrong offset!");
static_assert(offsetof(AActorSpawnPoint, BillboardComponent) == 0x0002A0, "Member 'AActorSpawnPoint::BillboardComponent' has a wrong offset!");

// Class ReadyOrNot.WidgetsData
// 0x0218 (0x0248 - 0x0030)
class UWidgetsData final : public UDataAsset
{
public:
	TSubclassOf<class UUserWidget>                MagCheckUI;                                        // 0x0030(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   FireModeUI;                                        // 0x0038(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   StartupMenu;                                       // 0x0060(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   AuthenticationMenu;                                // 0x0088(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   MainMenu;                                          // 0x00B0(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   OptionsMenu;                                       // 0x00D8(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   CustomizationMenu;                                 // 0x0100(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   ChatBox;                                           // 0x0128(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftClassPtr<class UClass>>           Overlays;                                          // 0x0150(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   Scoreboard;                                        // 0x0160(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UUserWidget>                LoadingScreen;                                     // 0x0188(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   MessageDisplayBoxClass;                            // 0x0190(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   Leaderboards;                                      // 0x01B8(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   CrosshairOverlay;                                  // 0x01E0(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USoundBase*>                     UISoundClasses;                                    // 0x0208(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   EscapeMenu;                                        // 0x0218(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWeaponWheelWidget>         WeaponWheelWidget;                                 // 0x0240(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetsData">();
	}
	static class UWidgetsData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetsData>();
	}
};
static_assert(alignof(UWidgetsData) == 0x000008, "Wrong alignment on UWidgetsData");
static_assert(sizeof(UWidgetsData) == 0x000248, "Wrong size on UWidgetsData");
static_assert(offsetof(UWidgetsData, MagCheckUI) == 0x000030, "Member 'UWidgetsData::MagCheckUI' has a wrong offset!");
static_assert(offsetof(UWidgetsData, FireModeUI) == 0x000038, "Member 'UWidgetsData::FireModeUI' has a wrong offset!");
static_assert(offsetof(UWidgetsData, StartupMenu) == 0x000060, "Member 'UWidgetsData::StartupMenu' has a wrong offset!");
static_assert(offsetof(UWidgetsData, AuthenticationMenu) == 0x000088, "Member 'UWidgetsData::AuthenticationMenu' has a wrong offset!");
static_assert(offsetof(UWidgetsData, MainMenu) == 0x0000B0, "Member 'UWidgetsData::MainMenu' has a wrong offset!");
static_assert(offsetof(UWidgetsData, OptionsMenu) == 0x0000D8, "Member 'UWidgetsData::OptionsMenu' has a wrong offset!");
static_assert(offsetof(UWidgetsData, CustomizationMenu) == 0x000100, "Member 'UWidgetsData::CustomizationMenu' has a wrong offset!");
static_assert(offsetof(UWidgetsData, ChatBox) == 0x000128, "Member 'UWidgetsData::ChatBox' has a wrong offset!");
static_assert(offsetof(UWidgetsData, Overlays) == 0x000150, "Member 'UWidgetsData::Overlays' has a wrong offset!");
static_assert(offsetof(UWidgetsData, Scoreboard) == 0x000160, "Member 'UWidgetsData::Scoreboard' has a wrong offset!");
static_assert(offsetof(UWidgetsData, LoadingScreen) == 0x000188, "Member 'UWidgetsData::LoadingScreen' has a wrong offset!");
static_assert(offsetof(UWidgetsData, MessageDisplayBoxClass) == 0x000190, "Member 'UWidgetsData::MessageDisplayBoxClass' has a wrong offset!");
static_assert(offsetof(UWidgetsData, Leaderboards) == 0x0001B8, "Member 'UWidgetsData::Leaderboards' has a wrong offset!");
static_assert(offsetof(UWidgetsData, CrosshairOverlay) == 0x0001E0, "Member 'UWidgetsData::CrosshairOverlay' has a wrong offset!");
static_assert(offsetof(UWidgetsData, UISoundClasses) == 0x000208, "Member 'UWidgetsData::UISoundClasses' has a wrong offset!");
static_assert(offsetof(UWidgetsData, EscapeMenu) == 0x000218, "Member 'UWidgetsData::EscapeMenu' has a wrong offset!");
static_assert(offsetof(UWidgetsData, WeaponWheelWidget) == 0x000240, "Member 'UWidgetsData::WeaponWheelWidget' has a wrong offset!");

// Class ReadyOrNot.ReadyOrNotCSGasSettings
// 0x0028 (0x0060 - 0x0038)
class UReadyOrNotCSGasSettings final : public UDeveloperSettings
{
public:
	TSoftObjectPtr<class UCSGasData>              GasDataAsset;                                      // 0x0038(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotCSGasSettings">();
	}
	static class UReadyOrNotCSGasSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotCSGasSettings>();
	}
};
static_assert(alignof(UReadyOrNotCSGasSettings) == 0x000008, "Wrong alignment on UReadyOrNotCSGasSettings");
static_assert(sizeof(UReadyOrNotCSGasSettings) == 0x000060, "Wrong size on UReadyOrNotCSGasSettings");
static_assert(offsetof(UReadyOrNotCSGasSettings, GasDataAsset) == 0x000038, "Member 'UReadyOrNotCSGasSettings::GasDataAsset' has a wrong offset!");

// Class ReadyOrNot.AdminGameControls
// 0x0000 (0x02C0 - 0x02C0)
class UAdminGameControls : public UUserWidget
{
public:
	void GetKickablePlayers(TArray<class APlayerState*>* KickablePlayers);
	bool IsAdmin();
	void KickPlayer(class APlayerState* KickingPlayerState, const class FText& Reason);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AdminGameControls">();
	}
	static class UAdminGameControls* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAdminGameControls>();
	}
};
static_assert(alignof(UAdminGameControls) == 0x000008, "Wrong alignment on UAdminGameControls");
static_assert(sizeof(UAdminGameControls) == 0x0002C0, "Wrong size on UAdminGameControls");

// Class ReadyOrNot.AIAction
// 0x0030 (0x0058 - 0x0028)
class UAIAction : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           Tags;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class ACyberneticController*                  OwningController;                                  // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_48[0x4];                                       // 0x0048(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LastMoveRequestPathID;                             // 0x004C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         LastMoveRequestMoveID;                             // 0x0050(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAbortActionOnPathingError;                        // 0x0054(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AbortAction();
	void BeginAction_Blueprint();
	void EndAction_Blueprint();
	void InitAction_Blueprint(class ACyberneticController* Controller);
	void OnCreate_Blueprint(class ACyberneticController* Controller);
	void OnFailedToConsider_Blueprint();
	void OnMoveComplete(class AAIController* Controller, int32 RequestID);
	void OnMoveComplete_Blueprint(class AAIController* Controller, int32 RequestID);
	void OnPathFound(int32 PathId, ERonNavigationQueryResult Result);
	void OnPathFound_Blueprint(int32 PathId, ERonNavigationQueryResult Result);
	void OnSucceededToConsider_Blueprint();
	void OnTakenDamage_Blueprint(float Damage, class AReadyOrNotCharacter* Instigator);
	void RequestMove(const struct FVector& Location, float AcceptanceRadius);
	bool ShouldForcePerformAction();
	void Tick_Blueprint(float DeltaTime);

	class FString GatherDebugInfo() const;
	struct FAIActionData GetActionData() const;
	int32 GetActionRunCount() const;
	class ACyberneticCharacter* GetCharacter() const;
	class FName GetMoveStyleOverride() const;
	bool HasTag(const class FName Tag) const;
	bool ShouldPerformAction() const;
	bool WantsAbort() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAction">();
	}
	static class UAIAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAction>();
	}
};
static_assert(alignof(UAIAction) == 0x000008, "Wrong alignment on UAIAction");
static_assert(sizeof(UAIAction) == 0x000058, "Wrong size on UAIAction");
static_assert(offsetof(UAIAction, Tags) == 0x000030, "Member 'UAIAction::Tags' has a wrong offset!");
static_assert(offsetof(UAIAction, OwningController) == 0x000040, "Member 'UAIAction::OwningController' has a wrong offset!");
static_assert(offsetof(UAIAction, LastMoveRequestPathID) == 0x00004C, "Member 'UAIAction::LastMoveRequestPathID' has a wrong offset!");
static_assert(offsetof(UAIAction, LastMoveRequestMoveID) == 0x000050, "Member 'UAIAction::LastMoveRequestMoveID' has a wrong offset!");
static_assert(offsetof(UAIAction, bAbortActionOnPathingError) == 0x000054, "Member 'UAIAction::bAbortActionOnPathingError' has a wrong offset!");

// Class ReadyOrNot.PepperGasCloud
// 0x0020 (0x02B8 - 0x0298)
class APepperGasCloud : public AActor
{
public:
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystemComponent*               GasParticleSystem;                                 // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GasRadius;                                         // 0x02A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Lifetime;                                          // 0x02AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxGasPoints;                                      // 0x02B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B4[0x4];                                      // 0x02B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PepperGasCloud">();
	}
	static class APepperGasCloud* GetDefaultObj()
	{
		return GetDefaultObjImpl<APepperGasCloud>();
	}
};
static_assert(alignof(APepperGasCloud) == 0x000008, "Wrong alignment on APepperGasCloud");
static_assert(sizeof(APepperGasCloud) == 0x0002B8, "Wrong size on APepperGasCloud");
static_assert(offsetof(APepperGasCloud, GasParticleSystem) == 0x0002A0, "Member 'APepperGasCloud::GasParticleSystem' has a wrong offset!");
static_assert(offsetof(APepperGasCloud, GasRadius) == 0x0002A8, "Member 'APepperGasCloud::GasRadius' has a wrong offset!");
static_assert(offsetof(APepperGasCloud, Lifetime) == 0x0002AC, "Member 'APepperGasCloud::Lifetime' has a wrong offset!");
static_assert(offsetof(APepperGasCloud, MaxGasPoints) == 0x0002B0, "Member 'APepperGasCloud::MaxGasPoints' has a wrong offset!");

// Class ReadyOrNot.AIActionConsideration
// 0x00B0 (0x00D8 - 0x0028)
class UAIActionConsideration : public UObject
{
public:
	uint8                                         bManualCurveEdit : 1;                              // 0x0028(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCustomCurveFunction : 1;                          // 0x0028(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	EEasingFunc                                   CurveType;                                         // 0x0029(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bInverseX : 1;                                     // 0x002A(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bInverseY : 1;                                     // 0x002A(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bClamp : 1;                                        // 0x002A(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_2B[0x5];                                       // 0x002B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     Curve;                                             // 0x0030(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	uint8                                         bCustomRange : 1;                                  // 0x00B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_B9[0x3];                                       // 0x00B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinRange;                                          // 0x00BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxRange;                                          // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OffsetX;                                           // 0x00C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OffsetY;                                           // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Exponent;                                          // 0x00CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SubStep;                                           // 0x00D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERichCurveInterpMode                          InterpMode;                                        // 0x00D4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERichCurveTangentMode                         TangentMode;                                       // 0x00D5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D6[0x2];                                       // 0x00D6(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float CalculateCurve(float X) const;
	float EvaluateResponseCurve(float Score_0) const;
	float Score(const struct FAIActionDecisionContext& Context, bool* bSuccess) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIActionConsideration">();
	}
	static class UAIActionConsideration* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIActionConsideration>();
	}
};
static_assert(alignof(UAIActionConsideration) == 0x000008, "Wrong alignment on UAIActionConsideration");
static_assert(sizeof(UAIActionConsideration) == 0x0000D8, "Wrong size on UAIActionConsideration");
static_assert(offsetof(UAIActionConsideration, CurveType) == 0x000029, "Member 'UAIActionConsideration::CurveType' has a wrong offset!");
static_assert(offsetof(UAIActionConsideration, Curve) == 0x000030, "Member 'UAIActionConsideration::Curve' has a wrong offset!");
static_assert(offsetof(UAIActionConsideration, MinRange) == 0x0000BC, "Member 'UAIActionConsideration::MinRange' has a wrong offset!");
static_assert(offsetof(UAIActionConsideration, MaxRange) == 0x0000C0, "Member 'UAIActionConsideration::MaxRange' has a wrong offset!");
static_assert(offsetof(UAIActionConsideration, OffsetX) == 0x0000C4, "Member 'UAIActionConsideration::OffsetX' has a wrong offset!");
static_assert(offsetof(UAIActionConsideration, OffsetY) == 0x0000C8, "Member 'UAIActionConsideration::OffsetY' has a wrong offset!");
static_assert(offsetof(UAIActionConsideration, Exponent) == 0x0000CC, "Member 'UAIActionConsideration::Exponent' has a wrong offset!");
static_assert(offsetof(UAIActionConsideration, SubStep) == 0x0000D0, "Member 'UAIActionConsideration::SubStep' has a wrong offset!");
static_assert(offsetof(UAIActionConsideration, InterpMode) == 0x0000D4, "Member 'UAIActionConsideration::InterpMode' has a wrong offset!");
static_assert(offsetof(UAIActionConsideration, TangentMode) == 0x0000D5, "Member 'UAIActionConsideration::TangentMode' has a wrong offset!");

// Class ReadyOrNot.Objective
// 0x0088 (0x0320 - 0x0298)
class AObjective : public AInfo
{
public:
	class UScoringComponent*                      ScoringComponent;                                  // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AObjective* Objective)> OnObjectiveUpdated;                  // 0x02A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UFMODEvent*                             ObjectiveCompleteAudio;                            // 0x02B0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             ObjectiveFailedAudio;                              // 0x02B8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ObjectiveName;                                     // 0x02C0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   ObjectiveDescription;                              // 0x02D8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	ECOOPMode                                     LockedToMode;                                      // 0x02F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFailureEndsMission;                               // 0x02F1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHiddenObjective;                                  // 0x02F2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowCompletionWhileHidden;                       // 0x02F3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHiddenObjectiveUnlockMethod                  UnlockMethod;                                      // 0x02F4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F5[0x3];                                      // 0x02F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AReportableActor>           UnlockingReportableClass;                          // 0x02F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AObjective>                 UnlockingObjectiveClass;                           // 0x0300(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AReportableActor*                       UnlockingReportable;                               // 0x0308(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AObjective*                             UnlockingObjective;                                // 0x0310(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EObjectiveStatus                              ObjectiveStatus;                                   // 0x0318(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_319[0x7];                                      // 0x0319(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void CompleteObjectivesOfClass(const class UObject* WorldContextObject, TSubclassOf<class AObjective> ObjectiveClass);
	static void FailObjectivesOfClass(const class UObject* WorldContextObject, TSubclassOf<class AObjective> ObjectiveClass);
	static TArray<class AObjective*> GetObjectivesOfClass(const class UObject* WorldContextObject, TSubclassOf<class AObjective> ObjectiveClass);

	class FText GetFormattedDescription();
	class FText GetFormattedName();
	void Multicast_UnlockObjective();
	void ObjectiveCompleted();
	void ObjectiveFailed();
	void OnObjectiveCompleted();
	void OnObjectiveCreated();
	void OnObjectiveFailed();
	void OnRep_ObjectiveStatus();
	void OnUnlockingObjectiveUpdated(class AObjective* Objective);
	void OnUnlockingReportableReported(class AReportableActor* ReportableActor, class AReadyOrNotCharacter* Reporter);
	void TickObjective_BP();

	EObjectiveStatus GetObjectiveStatus() const;
	bool IsObjectiveCompleted() const;
	bool IsObjectiveFailed() const;
	bool IsObjectiveInProgress() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Objective">();
	}
	static class AObjective* GetDefaultObj()
	{
		return GetDefaultObjImpl<AObjective>();
	}
};
static_assert(alignof(AObjective) == 0x000008, "Wrong alignment on AObjective");
static_assert(sizeof(AObjective) == 0x000320, "Wrong size on AObjective");
static_assert(offsetof(AObjective, ScoringComponent) == 0x000298, "Member 'AObjective::ScoringComponent' has a wrong offset!");
static_assert(offsetof(AObjective, OnObjectiveUpdated) == 0x0002A0, "Member 'AObjective::OnObjectiveUpdated' has a wrong offset!");
static_assert(offsetof(AObjective, ObjectiveCompleteAudio) == 0x0002B0, "Member 'AObjective::ObjectiveCompleteAudio' has a wrong offset!");
static_assert(offsetof(AObjective, ObjectiveFailedAudio) == 0x0002B8, "Member 'AObjective::ObjectiveFailedAudio' has a wrong offset!");
static_assert(offsetof(AObjective, ObjectiveName) == 0x0002C0, "Member 'AObjective::ObjectiveName' has a wrong offset!");
static_assert(offsetof(AObjective, ObjectiveDescription) == 0x0002D8, "Member 'AObjective::ObjectiveDescription' has a wrong offset!");
static_assert(offsetof(AObjective, LockedToMode) == 0x0002F0, "Member 'AObjective::LockedToMode' has a wrong offset!");
static_assert(offsetof(AObjective, bFailureEndsMission) == 0x0002F1, "Member 'AObjective::bFailureEndsMission' has a wrong offset!");
static_assert(offsetof(AObjective, bHiddenObjective) == 0x0002F2, "Member 'AObjective::bHiddenObjective' has a wrong offset!");
static_assert(offsetof(AObjective, bAllowCompletionWhileHidden) == 0x0002F3, "Member 'AObjective::bAllowCompletionWhileHidden' has a wrong offset!");
static_assert(offsetof(AObjective, UnlockMethod) == 0x0002F4, "Member 'AObjective::UnlockMethod' has a wrong offset!");
static_assert(offsetof(AObjective, UnlockingReportableClass) == 0x0002F8, "Member 'AObjective::UnlockingReportableClass' has a wrong offset!");
static_assert(offsetof(AObjective, UnlockingObjectiveClass) == 0x000300, "Member 'AObjective::UnlockingObjectiveClass' has a wrong offset!");
static_assert(offsetof(AObjective, UnlockingReportable) == 0x000308, "Member 'AObjective::UnlockingReportable' has a wrong offset!");
static_assert(offsetof(AObjective, UnlockingObjective) == 0x000310, "Member 'AObjective::UnlockingObjective' has a wrong offset!");
static_assert(offsetof(AObjective, ObjectiveStatus) == 0x000318, "Member 'AObjective::ObjectiveStatus' has a wrong offset!");

// Class ReadyOrNot.BringOrderToChaos
// 0x0000 (0x0320 - 0x0320)
class ABringOrderToChaos final : public AObjective
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BringOrderToChaos">();
	}
	static class ABringOrderToChaos* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABringOrderToChaos>();
	}
};
static_assert(alignof(ABringOrderToChaos) == 0x000008, "Wrong alignment on ABringOrderToChaos");
static_assert(sizeof(ABringOrderToChaos) == 0x000320, "Wrong size on ABringOrderToChaos");

// Class ReadyOrNot.ACNumberOfNearbyAI
// 0x0010 (0x00E8 - 0x00D8)
class UACNumberOfNearbyAI : public UAIActionConsideration
{
public:
	ETeamType                                     TeamType;                                          // 0x00D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D9[0x3];                                       // 0x00D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SearchRange;                                       // 0x00DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMustBeVisible;                                    // 0x00E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMustBeActive;                                     // 0x00E1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E2[0x6];                                       // 0x00E2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ACNumberOfNearbyAI">();
	}
	static class UACNumberOfNearbyAI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UACNumberOfNearbyAI>();
	}
};
static_assert(alignof(UACNumberOfNearbyAI) == 0x000008, "Wrong alignment on UACNumberOfNearbyAI");
static_assert(sizeof(UACNumberOfNearbyAI) == 0x0000E8, "Wrong size on UACNumberOfNearbyAI");
static_assert(offsetof(UACNumberOfNearbyAI, TeamType) == 0x0000D8, "Member 'UACNumberOfNearbyAI::TeamType' has a wrong offset!");
static_assert(offsetof(UACNumberOfNearbyAI, SearchRange) == 0x0000DC, "Member 'UACNumberOfNearbyAI::SearchRange' has a wrong offset!");
static_assert(offsetof(UACNumberOfNearbyAI, bMustBeVisible) == 0x0000E0, "Member 'UACNumberOfNearbyAI::bMustBeVisible' has a wrong offset!");
static_assert(offsetof(UACNumberOfNearbyAI, bMustBeActive) == 0x0000E1, "Member 'UACNumberOfNearbyAI::bMustBeActive' has a wrong offset!");

// Class ReadyOrNot.PingActor
// 0x0108 (0x03A0 - 0x0298)
class APingActor final : public AActor
{
public:
	class AActor*                                 PingedActor;                                       // 0x0298(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateBrush                            IconBrush;                                         // 0x02A0(0x00D0)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	class FText                                   PingText;                                          // 0x0370(0x0018)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	class UObjectiveMarkerComponent*              ObjectiveMarkerComponent;                          // 0x0388(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMapActorComponent*                     MapActorComponent;                                 // 0x0390(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_398[0x8];                                      // 0x0398(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_SetIconBrush();
	void OnRep_SetPingText();
	void Setup(class AActor* InActor);

	void HideObjectiveMarker() const;
	void ShowObjectiveMarker() const;
	void ToggleObjectiveMarkerVisibility() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PingActor">();
	}
	static class APingActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<APingActor>();
	}
};
static_assert(alignof(APingActor) == 0x000010, "Wrong alignment on APingActor");
static_assert(sizeof(APingActor) == 0x0003A0, "Wrong size on APingActor");
static_assert(offsetof(APingActor, PingedActor) == 0x000298, "Member 'APingActor::PingedActor' has a wrong offset!");
static_assert(offsetof(APingActor, IconBrush) == 0x0002A0, "Member 'APingActor::IconBrush' has a wrong offset!");
static_assert(offsetof(APingActor, PingText) == 0x000370, "Member 'APingActor::PingText' has a wrong offset!");
static_assert(offsetof(APingActor, ObjectiveMarkerComponent) == 0x000388, "Member 'APingActor::ObjectiveMarkerComponent' has a wrong offset!");
static_assert(offsetof(APingActor, MapActorComponent) == 0x000390, "Member 'APingActor::MapActorComponent' has a wrong offset!");

// Class ReadyOrNot.AC_Health
// 0x0000 (0x00D8 - 0x00D8)
class UAC_Health : public UAIActionConsideration
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AC_Health">();
	}
	static class UAC_Health* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAC_Health>();
	}
};
static_assert(alignof(UAC_Health) == 0x000008, "Wrong alignment on UAC_Health");
static_assert(sizeof(UAC_Health) == 0x0000D8, "Wrong size on UAC_Health");

// Class ReadyOrNot.AC_TargetHealth
// 0x0000 (0x00D8 - 0x00D8)
class UAC_TargetHealth : public UAIActionConsideration
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AC_TargetHealth">();
	}
	static class UAC_TargetHealth* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAC_TargetHealth>();
	}
};
static_assert(alignof(UAC_TargetHealth) == 0x000008, "Wrong alignment on UAC_TargetHealth");
static_assert(sizeof(UAC_TargetHealth) == 0x0000D8, "Wrong size on UAC_TargetHealth");

// Class ReadyOrNot.AnimNotify_GetupComplete
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_GetupComplete final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_GetupComplete">();
	}
	static class UAnimNotify_GetupComplete* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_GetupComplete>();
	}
};
static_assert(alignof(UAnimNotify_GetupComplete) == 0x000008, "Wrong alignment on UAnimNotify_GetupComplete");
static_assert(sizeof(UAnimNotify_GetupComplete) == 0x000038, "Wrong size on UAnimNotify_GetupComplete");

// Class ReadyOrNot.PlayerSpeedIndicator_V2
// 0x0078 (0x0360 - 0x02E8)
class UPlayerSpeedIndicator_V2 final : public UBaseWidget
{
public:
	class USizeBox*                               Twenty_Box;                                        // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Twenty_Image;                                      // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USizeBox*                               Fourty_Box;                                        // 0x02F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Fourty_Image;                                      // 0x0300(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USizeBox*                               Sixty_Box;                                         // 0x0308(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Sixty_Image;                                       // 0x0310(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USizeBox*                               Eighty_Box;                                        // 0x0318(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Eighty_Image;                                      // 0x0320(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USizeBox*                               OneHundred_Box;                                    // 0x0328(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 OneHundred_Image;                                  // 0x0330(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             SpeedPercentage_Text;                              // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APlayerCharacter*                       PlayerCharacter;                                   // 0x0340(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BaselineOpacity;                                   // 0x0348(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FadeSpeed;                                         // 0x034C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LastSetRunSpeedPercent;                            // 0x0350(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinRunSpeedPercent;                                // 0x0354(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxRunSpeedPercent;                                // 0x0358(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NormalizedRunSpeedPercent;                         // 0x035C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerSpeedIndicator_V2">();
	}
	static class UPlayerSpeedIndicator_V2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerSpeedIndicator_V2>();
	}
};
static_assert(alignof(UPlayerSpeedIndicator_V2) == 0x000008, "Wrong alignment on UPlayerSpeedIndicator_V2");
static_assert(sizeof(UPlayerSpeedIndicator_V2) == 0x000360, "Wrong size on UPlayerSpeedIndicator_V2");
static_assert(offsetof(UPlayerSpeedIndicator_V2, Twenty_Box) == 0x0002E8, "Member 'UPlayerSpeedIndicator_V2::Twenty_Box' has a wrong offset!");
static_assert(offsetof(UPlayerSpeedIndicator_V2, Twenty_Image) == 0x0002F0, "Member 'UPlayerSpeedIndicator_V2::Twenty_Image' has a wrong offset!");
static_assert(offsetof(UPlayerSpeedIndicator_V2, Fourty_Box) == 0x0002F8, "Member 'UPlayerSpeedIndicator_V2::Fourty_Box' has a wrong offset!");
static_assert(offsetof(UPlayerSpeedIndicator_V2, Fourty_Image) == 0x000300, "Member 'UPlayerSpeedIndicator_V2::Fourty_Image' has a wrong offset!");
static_assert(offsetof(UPlayerSpeedIndicator_V2, Sixty_Box) == 0x000308, "Member 'UPlayerSpeedIndicator_V2::Sixty_Box' has a wrong offset!");
static_assert(offsetof(UPlayerSpeedIndicator_V2, Sixty_Image) == 0x000310, "Member 'UPlayerSpeedIndicator_V2::Sixty_Image' has a wrong offset!");
static_assert(offsetof(UPlayerSpeedIndicator_V2, Eighty_Box) == 0x000318, "Member 'UPlayerSpeedIndicator_V2::Eighty_Box' has a wrong offset!");
static_assert(offsetof(UPlayerSpeedIndicator_V2, Eighty_Image) == 0x000320, "Member 'UPlayerSpeedIndicator_V2::Eighty_Image' has a wrong offset!");
static_assert(offsetof(UPlayerSpeedIndicator_V2, OneHundred_Box) == 0x000328, "Member 'UPlayerSpeedIndicator_V2::OneHundred_Box' has a wrong offset!");
static_assert(offsetof(UPlayerSpeedIndicator_V2, OneHundred_Image) == 0x000330, "Member 'UPlayerSpeedIndicator_V2::OneHundred_Image' has a wrong offset!");
static_assert(offsetof(UPlayerSpeedIndicator_V2, SpeedPercentage_Text) == 0x000338, "Member 'UPlayerSpeedIndicator_V2::SpeedPercentage_Text' has a wrong offset!");
static_assert(offsetof(UPlayerSpeedIndicator_V2, PlayerCharacter) == 0x000340, "Member 'UPlayerSpeedIndicator_V2::PlayerCharacter' has a wrong offset!");
static_assert(offsetof(UPlayerSpeedIndicator_V2, BaselineOpacity) == 0x000348, "Member 'UPlayerSpeedIndicator_V2::BaselineOpacity' has a wrong offset!");
static_assert(offsetof(UPlayerSpeedIndicator_V2, FadeSpeed) == 0x00034C, "Member 'UPlayerSpeedIndicator_V2::FadeSpeed' has a wrong offset!");
static_assert(offsetof(UPlayerSpeedIndicator_V2, LastSetRunSpeedPercent) == 0x000350, "Member 'UPlayerSpeedIndicator_V2::LastSetRunSpeedPercent' has a wrong offset!");
static_assert(offsetof(UPlayerSpeedIndicator_V2, MinRunSpeedPercent) == 0x000354, "Member 'UPlayerSpeedIndicator_V2::MinRunSpeedPercent' has a wrong offset!");
static_assert(offsetof(UPlayerSpeedIndicator_V2, MaxRunSpeedPercent) == 0x000358, "Member 'UPlayerSpeedIndicator_V2::MaxRunSpeedPercent' has a wrong offset!");
static_assert(offsetof(UPlayerSpeedIndicator_V2, NormalizedRunSpeedPercent) == 0x00035C, "Member 'UPlayerSpeedIndicator_V2::NormalizedRunSpeedPercent' has a wrong offset!");

// Class ReadyOrNot.AC_IncapacitationHealth
// 0x0000 (0x00D8 - 0x00D8)
class UAC_IncapacitationHealth : public UAIActionConsideration
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AC_IncapacitationHealth">();
	}
	static class UAC_IncapacitationHealth* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAC_IncapacitationHealth>();
	}
};
static_assert(alignof(UAC_IncapacitationHealth) == 0x000008, "Wrong alignment on UAC_IncapacitationHealth");
static_assert(sizeof(UAC_IncapacitationHealth) == 0x0000D8, "Wrong size on UAC_IncapacitationHealth");

// Class ReadyOrNot.ASequenceInteraction
// 0x0030 (0x0368 - 0x0338)
class AASequenceInteraction final : public ALevelSequenceActor
{
public:
	uint8                                         Pad_338[0x10];                                     // 0x0338(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAutoActivateInRange;                              // 0x0348(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_349[0x7];                                      // 0x0349(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ReferencedCharacterViewTarget;                     // 0x0350(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          RadiusComp;                                        // 0x0358(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerCharacter*                       LastPlayedSequencerCharacter;                      // 0x0360(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnBoxEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnBoxOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnSequencerFinished();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ASequenceInteraction">();
	}
	static class AASequenceInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<AASequenceInteraction>();
	}
};
static_assert(alignof(AASequenceInteraction) == 0x000008, "Wrong alignment on AASequenceInteraction");
static_assert(sizeof(AASequenceInteraction) == 0x000368, "Wrong size on AASequenceInteraction");
static_assert(offsetof(AASequenceInteraction, bAutoActivateInRange) == 0x000348, "Member 'AASequenceInteraction::bAutoActivateInRange' has a wrong offset!");
static_assert(offsetof(AASequenceInteraction, ReferencedCharacterViewTarget) == 0x000350, "Member 'AASequenceInteraction::ReferencedCharacterViewTarget' has a wrong offset!");
static_assert(offsetof(AASequenceInteraction, RadiusComp) == 0x000358, "Member 'AASequenceInteraction::RadiusComp' has a wrong offset!");
static_assert(offsetof(AASequenceInteraction, LastPlayedSequencerCharacter) == 0x000360, "Member 'AASequenceInteraction::LastPlayedSequencerCharacter' has a wrong offset!");

// Class ReadyOrNot.AC_Ammo
// 0x0000 (0x00D8 - 0x00D8)
class UAC_Ammo : public UAIActionConsideration
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AC_Ammo">();
	}
	static class UAC_Ammo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAC_Ammo>();
	}
};
static_assert(alignof(UAC_Ammo) == 0x000008, "Wrong alignment on UAC_Ammo");
static_assert(sizeof(UAC_Ammo) == 0x0000D8, "Wrong size on UAC_Ammo");

// Class ReadyOrNot.CustomizationDataBase
// 0x0150 (0x0180 - 0x0030)
class UCustomizationDataBase : public UPrimaryDataAsset
{
public:
	ECustomizationType                            Type;                                              // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCustomizationDataBase*                 Parent;                                            // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Name_0;                                            // 0x0040(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Variant;                                           // 0x0058(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0070(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Icon;                                              // 0x0088(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterialInterface>      VariantIcon;                                       // 0x00B0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DisplayPriority;                                   // 0x00D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           RequiredTags;                                      // 0x00E0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FText                                   RequirementsText;                                  // 0x00F0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSet<ECustomizationType>                      TypesToHide;                                       // 0x0108(0x0050)(Edit, NativeAccessSpecifierPublic)
	bool                                          bShowInLoadout;                                    // 0x0158(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_159[0x7];                                      // 0x0159(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EGameVersionRestriction>               LockedToDLC;                                       // 0x0160(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UCustomizationSocket*>           Extras;                                            // 0x0170(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationDataBase">();
	}
	static class UCustomizationDataBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomizationDataBase>();
	}
};
static_assert(alignof(UCustomizationDataBase) == 0x000008, "Wrong alignment on UCustomizationDataBase");
static_assert(sizeof(UCustomizationDataBase) == 0x000180, "Wrong size on UCustomizationDataBase");
static_assert(offsetof(UCustomizationDataBase, Type) == 0x000030, "Member 'UCustomizationDataBase::Type' has a wrong offset!");
static_assert(offsetof(UCustomizationDataBase, Parent) == 0x000038, "Member 'UCustomizationDataBase::Parent' has a wrong offset!");
static_assert(offsetof(UCustomizationDataBase, Name_0) == 0x000040, "Member 'UCustomizationDataBase::Name_0' has a wrong offset!");
static_assert(offsetof(UCustomizationDataBase, Variant) == 0x000058, "Member 'UCustomizationDataBase::Variant' has a wrong offset!");
static_assert(offsetof(UCustomizationDataBase, Description) == 0x000070, "Member 'UCustomizationDataBase::Description' has a wrong offset!");
static_assert(offsetof(UCustomizationDataBase, Icon) == 0x000088, "Member 'UCustomizationDataBase::Icon' has a wrong offset!");
static_assert(offsetof(UCustomizationDataBase, VariantIcon) == 0x0000B0, "Member 'UCustomizationDataBase::VariantIcon' has a wrong offset!");
static_assert(offsetof(UCustomizationDataBase, DisplayPriority) == 0x0000D8, "Member 'UCustomizationDataBase::DisplayPriority' has a wrong offset!");
static_assert(offsetof(UCustomizationDataBase, RequiredTags) == 0x0000E0, "Member 'UCustomizationDataBase::RequiredTags' has a wrong offset!");
static_assert(offsetof(UCustomizationDataBase, RequirementsText) == 0x0000F0, "Member 'UCustomizationDataBase::RequirementsText' has a wrong offset!");
static_assert(offsetof(UCustomizationDataBase, TypesToHide) == 0x000108, "Member 'UCustomizationDataBase::TypesToHide' has a wrong offset!");
static_assert(offsetof(UCustomizationDataBase, bShowInLoadout) == 0x000158, "Member 'UCustomizationDataBase::bShowInLoadout' has a wrong offset!");
static_assert(offsetof(UCustomizationDataBase, LockedToDLC) == 0x000160, "Member 'UCustomizationDataBase::LockedToDLC' has a wrong offset!");
static_assert(offsetof(UCustomizationDataBase, Extras) == 0x000170, "Member 'UCustomizationDataBase::Extras' has a wrong offset!");

// Class ReadyOrNot.CustomizationEmpty
// 0x0000 (0x0180 - 0x0180)
class UCustomizationEmpty final : public UCustomizationDataBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationEmpty">();
	}
	static class UCustomizationEmpty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomizationEmpty>();
	}
};
static_assert(alignof(UCustomizationEmpty) == 0x000008, "Wrong alignment on UCustomizationEmpty");
static_assert(sizeof(UCustomizationEmpty) == 0x000180, "Wrong size on UCustomizationEmpty");

// Class ReadyOrNot.AC_Armor
// 0x0000 (0x00D8 - 0x00D8)
class UAC_Armor final : public UAIActionConsideration
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AC_Armor">();
	}
	static class UAC_Armor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAC_Armor>();
	}
};
static_assert(alignof(UAC_Armor) == 0x000008, "Wrong alignment on UAC_Armor");
static_assert(sizeof(UAC_Armor) == 0x0000D8, "Wrong size on UAC_Armor");

// Class ReadyOrNot.AC_Morale
// 0x0000 (0x00D8 - 0x00D8)
class UAC_Morale : public UAIActionConsideration
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AC_Morale">();
	}
	static class UAC_Morale* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAC_Morale>();
	}
};
static_assert(alignof(UAC_Morale) == 0x000008, "Wrong alignment on UAC_Morale");
static_assert(sizeof(UAC_Morale) == 0x0000D8, "Wrong size on UAC_Morale");

// Class ReadyOrNot.PickupActor
// 0x0068 (0x0300 - 0x0298)
class APickupActor : public AActor
{
public:
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AActor* PickedActor)> OnActorPickedUp;                       // 0x02A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnActorPickedUp_NoParam;                           // 0x02B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AActor* DroppedActor)> OnActorDropped;                       // 0x02C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FName                                   PickupName;                                        // 0x02D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 SkeletalMesh;                                      // 0x02D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   StaticMesh;                                        // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UObjectiveMarkerComponent*              ObjectiveMarkerComponent;                          // 0x02E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractableComponent*                 InteractableComponent;                             // 0x02F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 PickupInstigator;                                  // 0x02F8(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ActorDropped(class AActor* InDroppedInstigator);
	void ActorPickedUp(class AActor* InPickupInstigator);
	bool CanPickUpNow(class APlayerCharacter* PickerUpper);
	void HideObjectiveMarker();
	void ShowObjectiveMarker();
	void ToggleObjectiveMarker();

	class AActor* GetPickupInstigator() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PickupActor">();
	}
	static class APickupActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<APickupActor>();
	}
};
static_assert(alignof(APickupActor) == 0x000008, "Wrong alignment on APickupActor");
static_assert(sizeof(APickupActor) == 0x000300, "Wrong size on APickupActor");
static_assert(offsetof(APickupActor, OnActorPickedUp) == 0x0002A0, "Member 'APickupActor::OnActorPickedUp' has a wrong offset!");
static_assert(offsetof(APickupActor, OnActorPickedUp_NoParam) == 0x0002B0, "Member 'APickupActor::OnActorPickedUp_NoParam' has a wrong offset!");
static_assert(offsetof(APickupActor, OnActorDropped) == 0x0002C0, "Member 'APickupActor::OnActorDropped' has a wrong offset!");
static_assert(offsetof(APickupActor, PickupName) == 0x0002D0, "Member 'APickupActor::PickupName' has a wrong offset!");
static_assert(offsetof(APickupActor, SkeletalMesh) == 0x0002D8, "Member 'APickupActor::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(APickupActor, StaticMesh) == 0x0002E0, "Member 'APickupActor::StaticMesh' has a wrong offset!");
static_assert(offsetof(APickupActor, ObjectiveMarkerComponent) == 0x0002E8, "Member 'APickupActor::ObjectiveMarkerComponent' has a wrong offset!");
static_assert(offsetof(APickupActor, InteractableComponent) == 0x0002F0, "Member 'APickupActor::InteractableComponent' has a wrong offset!");
static_assert(offsetof(APickupActor, PickupInstigator) == 0x0002F8, "Member 'APickupActor::PickupInstigator' has a wrong offset!");

// Class ReadyOrNot.PickupMagazineActor
// 0x0028 (0x0328 - 0x0300)
class APickupMagazineActor final : public APickupActor
{
public:
	class FName                                   MagazineLabel;                                     // 0x0300(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimumHitThreshold;                               // 0x0308(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30C[0x4];                                      // 0x030C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             DroppedMagazineHitEvent;                           // 0x0310(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMagazine                              MagazineData;                                      // 0x0318(0x0004)(Net, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31C[0x4];                                      // 0x031C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ABaseMagazineWeapon*                    CameFromWeapon;                                    // 0x0320(0x0008)(Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class ABaseMagazineWeapon* GetValidWeaponForPickerUpper(class APlayerCharacter* PlayerCharacter);
	void Multicast_SetWeapon(class ABaseMagazineWeapon* Weapon);
	void OnComponentHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void Server_Pickup(class AActor* InPickupInstigator);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PickupMagazineActor">();
	}
	static class APickupMagazineActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<APickupMagazineActor>();
	}
};
static_assert(alignof(APickupMagazineActor) == 0x000008, "Wrong alignment on APickupMagazineActor");
static_assert(sizeof(APickupMagazineActor) == 0x000328, "Wrong size on APickupMagazineActor");
static_assert(offsetof(APickupMagazineActor, MagazineLabel) == 0x000300, "Member 'APickupMagazineActor::MagazineLabel' has a wrong offset!");
static_assert(offsetof(APickupMagazineActor, MinimumHitThreshold) == 0x000308, "Member 'APickupMagazineActor::MinimumHitThreshold' has a wrong offset!");
static_assert(offsetof(APickupMagazineActor, DroppedMagazineHitEvent) == 0x000310, "Member 'APickupMagazineActor::DroppedMagazineHitEvent' has a wrong offset!");
static_assert(offsetof(APickupMagazineActor, MagazineData) == 0x000318, "Member 'APickupMagazineActor::MagazineData' has a wrong offset!");
static_assert(offsetof(APickupMagazineActor, CameFromWeapon) == 0x000320, "Member 'APickupMagazineActor::CameFromWeapon' has a wrong offset!");

// Class ReadyOrNot.AC_Stress
// 0x0000 (0x00D8 - 0x00D8)
class UAC_Stress : public UAIActionConsideration
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AC_Stress">();
	}
	static class UAC_Stress* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAC_Stress>();
	}
};
static_assert(alignof(UAC_Stress) == 0x000008, "Wrong alignment on UAC_Stress");
static_assert(sizeof(UAC_Stress) == 0x0000D8, "Wrong size on UAC_Stress");

// Class ReadyOrNot.AC_SquadMembersAlive
// 0x0008 (0x00E0 - 0x00D8)
class UAC_SquadMembersAlive final : public UAIActionConsideration
{
public:
	bool                                          bOnlyActive;                                       // 0x00D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AC_SquadMembersAlive">();
	}
	static class UAC_SquadMembersAlive* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAC_SquadMembersAlive>();
	}
};
static_assert(alignof(UAC_SquadMembersAlive) == 0x000008, "Wrong alignment on UAC_SquadMembersAlive");
static_assert(sizeof(UAC_SquadMembersAlive) == 0x0000E0, "Wrong size on UAC_SquadMembersAlive");
static_assert(offsetof(UAC_SquadMembersAlive, bOnlyActive) == 0x0000D8, "Member 'UAC_SquadMembersAlive::bOnlyActive' has a wrong offset!");

// Class ReadyOrNot.ExperienceSettings
// 0x0010 (0x0048 - 0x0038)
class UExperienceSettings final : public UDeveloperSettings
{
public:
	struct FPrimaryAssetId                        DefaultExperience;                                 // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExperienceSettings">();
	}
	static class UExperienceSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExperienceSettings>();
	}
};
static_assert(alignof(UExperienceSettings) == 0x000008, "Wrong alignment on UExperienceSettings");
static_assert(sizeof(UExperienceSettings) == 0x000048, "Wrong size on UExperienceSettings");
static_assert(offsetof(UExperienceSettings, DefaultExperience) == 0x000038, "Member 'UExperienceSettings::DefaultExperience' has a wrong offset!");

// Class ReadyOrNot.CommonTabListWidgetImplementation
// 0x0008 (0x0470 - 0x0468)
class UCommonTabListWidgetImplementation : public UCommonTabListWidgetBase
{
public:
	uint8                                         Pad_468[0x8];                                      // 0x0468(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommonTabListWidgetImplementation">();
	}
	static class UCommonTabListWidgetImplementation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommonTabListWidgetImplementation>();
	}
};
static_assert(alignof(UCommonTabListWidgetImplementation) == 0x000008, "Wrong alignment on UCommonTabListWidgetImplementation");
static_assert(sizeof(UCommonTabListWidgetImplementation) == 0x000470, "Wrong size on UCommonTabListWidgetImplementation");

// Class ReadyOrNot.ReadyOrNotGameInstance
// 0x0DE0 (0x1020 - 0x0240)
class UReadyOrNotGameInstance : public UAdvancedFriendsGameInstance
{
public:
	uint8                                         Pad_240[0x8];                                      // 0x0240(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LobbyLevel;                                        // 0x0248(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TrainingLevel;                                     // 0x0258(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ULoadoutManager>            LoadoutManagerClass;                               // 0x0268(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_270[0x8];                                      // 0x0270(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UReadyOrNotBackend*                     ReadyOrNotBackend;                                 // 0x0278(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULoadoutManager*                        LoadoutManager;                                    // 0x0280(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UModioManager*                          ModioManager;                                      // 0x0288(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReadyOrNotAIConfig*                    AIConfig;                                          // 0x0290(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_298[0x40];                                     // 0x0298(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialParameterCollection*           GlobalMaterialParameterCollection;                 // 0x02D8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialParameterCollection*           WeaponFOVMaterialCollection;                       // 0x02E0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialParameterCollection*           ScalabilityMaterialParameterCollection;            // 0x02E8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F0[0x8];                                      // 0x02F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UMetaGameProfile*                       MetaGameProfile;                                   // 0x02F8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESessionType                                  SessionType;                                       // 0x0300(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_301[0x7];                                      // 0x0301(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftClassPtr<class UClass>>           LazyLoadedClasses;                                 // 0x0308(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UObject>>         LazyLoadedObjects;                                 // 0x0318(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_328[0x8];                                      // 0x0328(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UUserWidget>                SpawnWidgetOnLevelLoad;                            // 0x0330(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_338[0x8];                                      // 0x0338(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, bool>                             OwnedDLCMap;                                       // 0x0340(0x0050)(NativeAccessSpecifierPublic)
	TArray<class AActor*>                         DecalMeshActors;                                   // 0x0390(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A0[0x280];                                    // 0x03A0(0x0280)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         PreviouslyJoinedGames;                             // 0x0620(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         DedicatedServerGamesPlayedWithoutReturningToLobby; // 0x0630(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DedicatedServerMapIdx;                             // 0x0634(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_638[0x68];                                     // 0x0638(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const class FString& ConnectionAddress)> OnConnectSteamServerByIP; // 0x06A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_6B0[0x50];                                     // 0x06B0(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bHostedGame;                                       // 0x0700(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_701[0x3];                                      // 0x0701(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Saved_RoundTimerGameStart;                         // 0x0704(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Saved_RoundTimerBetweenMaps;                       // 0x0708(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Saved_ReinforcementTimer;                          // 0x070C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Saved_Timelimit;                                   // 0x0710(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Saved_RoundsPerMap;                                // 0x0714(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Saved_Scorelimit;                                  // 0x0718(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Saved_AiEnabled;                                   // 0x071C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSinglePlayerMode;                               // 0x071D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71E[0x2];                                      // 0x071E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         ActivePauseConditions;                             // 0x0720(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class UHostMigrationManager*                  HostMigrationManager;                              // 0x0730(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 NextLevel;                                         // 0x0738(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MainMenuDisplayMessage;                            // 0x0748(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_758[0x8];                                      // 0x0758(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLevelDataLookupTable                  ModdedMapLookUpData;                               // 0x0760(0x0818)(Edit, NativeAccessSpecifierPublic)
	uint8                                         Pad_F78[0x60];                                     // 0x0F78(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UModLevelData*>                  ModdedLevelDataAssets;                             // 0x0FD8(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class FString>                         BuiltMapList;                                      // 0x0FE8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bShowingFPS;                                       // 0x0FF8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FF9[0x1];                                      // 0x0FF9(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsRecordingReplay;                                // 0x0FFA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPlayingReplay;                                  // 0x0FFB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         bReplayBeginTime;                                  // 0x0FFC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReplayNumPlayers;                                  // 0x1000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1004[0x4];                                     // 0x1004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserWidget*                            ReplayLoadingScreen;                               // 0x1008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FReplayEvent>                   ReplayEvents;                                      // 0x1010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static bool IsGameModded();

	void AddPauseGameCondition(const class FString& PauseCondition);
	void AddReplayEvent(EReplayEventType EventType, const struct FVector& Location, float Timestamp, const class FString& AdditionalInformation);
	void ApplyDecalSettings();
	void BuildMapList();
	void CommanderCompleteMission(const class FString& Mission);
	void CommanderDeleteProfile(int32 Slot);
	void CommanderGenerateProfile(int32 Slot);
	void ConnectSteamServer(const class FString& serverConnect);
	void CreateReplayLoadingScreen();
	void DeleteReplay(const class FString& ReplayName);
	TMap<class FString, struct FReplayData> FindReplays();
	void GenerateURLMap();
	TArray<class AReadyOrNotGameMode*> GetAllGameModes();
	TArray<class AReadyOrNotGameState*> GetAllGameStates();
	ELastMenuStateBeforeJoin GetAndClearLastJoinState();
	class FString GetAndClearMainMenuDisplayMessage();
	bool GetAvailableAudioDevices(TArray<class FString>* OutAudioDevices);
	bool GetBanned();
	class FString GetBestGuessMapName(const class FString& MapName);
	TArray<class FString> GetBuiltMapList();
	TArray<class FString> GetBuiltModdedMapList();
	class FString GetDiscordOneTimeUseCode();
	class FString GetFriendlyGamemodeName(const class FString& UnfriendlyName);
	uint32 GetLocalNetworkVersion();
	bool GetMutedState(const class FString& UniqueNetId);
	TArray<struct FReplayEvent> GetReplayEvents();
	class FString GetSessionTicket();
	void Gratr();
	bool IsHostMigrationInProgress(class FString* MigratedHostToName);
	bool IsNetworkCompatible(const uint32 LocalNetworkVersion, const uint32 RemoteNetworkVersion);
	bool IsPublicMissionInProgress();
	bool IsReplaySystemEnabled();
	bool IsSinglePlayer();
	void OnConnectSteamServer(const class FString& URL);
	bool OnWindowCloseRequested();
	void OpenReplayFolder();
	void PlayReplayFromBP(const class FString& ReplayName);
	void RemovePauseGameCondition(const class FString& PauseCondition);
	void RemoveReplayLoadingScreen();
	void RenameReplay(const class FString& ReplayName, const class FString& NewFriendlyReplayName);
	void RetryLogin();
	bool SetInputAudioDevice(const class FString& DeviceName, bool bShouldSave);
	void SetLastJoinState(ELastMenuStateBeforeJoin LastJoiNState);
	void StartRecordingReplay();
	void StopRecordingReplay(bool bSave);
	void StopRecordingReplayFromBP();

	uint8 GetBackendState() const;
	bool IsLoggedIntoBackend() const;
	bool IsSafeMode() const;
	bool SupportsDisablingMods() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotGameInstance">();
	}
	static class UReadyOrNotGameInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotGameInstance>();
	}
};
static_assert(alignof(UReadyOrNotGameInstance) == 0x000008, "Wrong alignment on UReadyOrNotGameInstance");
static_assert(sizeof(UReadyOrNotGameInstance) == 0x001020, "Wrong size on UReadyOrNotGameInstance");
static_assert(offsetof(UReadyOrNotGameInstance, LobbyLevel) == 0x000248, "Member 'UReadyOrNotGameInstance::LobbyLevel' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, TrainingLevel) == 0x000258, "Member 'UReadyOrNotGameInstance::TrainingLevel' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, LoadoutManagerClass) == 0x000268, "Member 'UReadyOrNotGameInstance::LoadoutManagerClass' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, ReadyOrNotBackend) == 0x000278, "Member 'UReadyOrNotGameInstance::ReadyOrNotBackend' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, LoadoutManager) == 0x000280, "Member 'UReadyOrNotGameInstance::LoadoutManager' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, ModioManager) == 0x000288, "Member 'UReadyOrNotGameInstance::ModioManager' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, AIConfig) == 0x000290, "Member 'UReadyOrNotGameInstance::AIConfig' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, GlobalMaterialParameterCollection) == 0x0002D8, "Member 'UReadyOrNotGameInstance::GlobalMaterialParameterCollection' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, WeaponFOVMaterialCollection) == 0x0002E0, "Member 'UReadyOrNotGameInstance::WeaponFOVMaterialCollection' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, ScalabilityMaterialParameterCollection) == 0x0002E8, "Member 'UReadyOrNotGameInstance::ScalabilityMaterialParameterCollection' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, MetaGameProfile) == 0x0002F8, "Member 'UReadyOrNotGameInstance::MetaGameProfile' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, SessionType) == 0x000300, "Member 'UReadyOrNotGameInstance::SessionType' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, LazyLoadedClasses) == 0x000308, "Member 'UReadyOrNotGameInstance::LazyLoadedClasses' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, LazyLoadedObjects) == 0x000318, "Member 'UReadyOrNotGameInstance::LazyLoadedObjects' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, SpawnWidgetOnLevelLoad) == 0x000330, "Member 'UReadyOrNotGameInstance::SpawnWidgetOnLevelLoad' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, OwnedDLCMap) == 0x000340, "Member 'UReadyOrNotGameInstance::OwnedDLCMap' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, DecalMeshActors) == 0x000390, "Member 'UReadyOrNotGameInstance::DecalMeshActors' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, PreviouslyJoinedGames) == 0x000620, "Member 'UReadyOrNotGameInstance::PreviouslyJoinedGames' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, DedicatedServerGamesPlayedWithoutReturningToLobby) == 0x000630, "Member 'UReadyOrNotGameInstance::DedicatedServerGamesPlayedWithoutReturningToLobby' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, DedicatedServerMapIdx) == 0x000634, "Member 'UReadyOrNotGameInstance::DedicatedServerMapIdx' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, OnConnectSteamServerByIP) == 0x0006A0, "Member 'UReadyOrNotGameInstance::OnConnectSteamServerByIP' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, bHostedGame) == 0x000700, "Member 'UReadyOrNotGameInstance::bHostedGame' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, Saved_RoundTimerGameStart) == 0x000704, "Member 'UReadyOrNotGameInstance::Saved_RoundTimerGameStart' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, Saved_RoundTimerBetweenMaps) == 0x000708, "Member 'UReadyOrNotGameInstance::Saved_RoundTimerBetweenMaps' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, Saved_ReinforcementTimer) == 0x00070C, "Member 'UReadyOrNotGameInstance::Saved_ReinforcementTimer' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, Saved_Timelimit) == 0x000710, "Member 'UReadyOrNotGameInstance::Saved_Timelimit' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, Saved_RoundsPerMap) == 0x000714, "Member 'UReadyOrNotGameInstance::Saved_RoundsPerMap' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, Saved_Scorelimit) == 0x000718, "Member 'UReadyOrNotGameInstance::Saved_Scorelimit' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, Saved_AiEnabled) == 0x00071C, "Member 'UReadyOrNotGameInstance::Saved_AiEnabled' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, bIsSinglePlayerMode) == 0x00071D, "Member 'UReadyOrNotGameInstance::bIsSinglePlayerMode' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, ActivePauseConditions) == 0x000720, "Member 'UReadyOrNotGameInstance::ActivePauseConditions' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, HostMigrationManager) == 0x000730, "Member 'UReadyOrNotGameInstance::HostMigrationManager' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, NextLevel) == 0x000738, "Member 'UReadyOrNotGameInstance::NextLevel' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, MainMenuDisplayMessage) == 0x000748, "Member 'UReadyOrNotGameInstance::MainMenuDisplayMessage' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, ModdedMapLookUpData) == 0x000760, "Member 'UReadyOrNotGameInstance::ModdedMapLookUpData' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, ModdedLevelDataAssets) == 0x000FD8, "Member 'UReadyOrNotGameInstance::ModdedLevelDataAssets' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, BuiltMapList) == 0x000FE8, "Member 'UReadyOrNotGameInstance::BuiltMapList' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, bShowingFPS) == 0x000FF8, "Member 'UReadyOrNotGameInstance::bShowingFPS' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, bIsRecordingReplay) == 0x000FFA, "Member 'UReadyOrNotGameInstance::bIsRecordingReplay' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, bIsPlayingReplay) == 0x000FFB, "Member 'UReadyOrNotGameInstance::bIsPlayingReplay' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, bReplayBeginTime) == 0x000FFC, "Member 'UReadyOrNotGameInstance::bReplayBeginTime' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, ReplayNumPlayers) == 0x001000, "Member 'UReadyOrNotGameInstance::ReplayNumPlayers' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, ReplayLoadingScreen) == 0x001008, "Member 'UReadyOrNotGameInstance::ReplayLoadingScreen' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameInstance, ReplayEvents) == 0x001010, "Member 'UReadyOrNotGameInstance::ReplayEvents' has a wrong offset!");

// Class ReadyOrNot.AC_SquadMembersKilled
// 0x0008 (0x00E0 - 0x00D8)
class UAC_SquadMembersKilled final : public UAIActionConsideration
{
public:
	bool                                          bIncludeIncapacitated;                             // 0x00D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AC_SquadMembersKilled">();
	}
	static class UAC_SquadMembersKilled* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAC_SquadMembersKilled>();
	}
};
static_assert(alignof(UAC_SquadMembersKilled) == 0x000008, "Wrong alignment on UAC_SquadMembersKilled");
static_assert(sizeof(UAC_SquadMembersKilled) == 0x0000E0, "Wrong size on UAC_SquadMembersKilled");
static_assert(offsetof(UAC_SquadMembersKilled, bIncludeIncapacitated) == 0x0000D8, "Member 'UAC_SquadMembersKilled::bIncludeIncapacitated' has a wrong offset!");

// Class ReadyOrNot.AC_SquadMembersArrested
// 0x0000 (0x00D8 - 0x00D8)
class UAC_SquadMembersArrested final : public UAIActionConsideration
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AC_SquadMembersArrested">();
	}
	static class UAC_SquadMembersArrested* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAC_SquadMembersArrested>();
	}
};
static_assert(alignof(UAC_SquadMembersArrested) == 0x000008, "Wrong alignment on UAC_SquadMembersArrested");
static_assert(sizeof(UAC_SquadMembersArrested) == 0x0000D8, "Wrong size on UAC_SquadMembersArrested");

// Class ReadyOrNot.BlendRagdollAnimNotifyState
// 0x0040 (0x0070 - 0x0030)
class UBlendRagdollAnimNotifyState final : public UAnimNotifyState
{
public:
	float                                         TotalBlendDuration;                                // 0x0030(0x0004)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentBlendAmount;                                // 0x0034(0x0004)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PelvisWakeUpTime;                                  // 0x0038(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x1];                                       // 0x003C(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bUsePhysicalAnimComp;                              // 0x003D(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E[0x2];                                       // 0x003E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPhysicalAnimationData                 PhysicalAnimData;                                  // 0x0040(0x0024)(Edit, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0xC];                                       // 0x0064(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlendRagdollAnimNotifyState">();
	}
	static class UBlendRagdollAnimNotifyState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlendRagdollAnimNotifyState>();
	}
};
static_assert(alignof(UBlendRagdollAnimNotifyState) == 0x000008, "Wrong alignment on UBlendRagdollAnimNotifyState");
static_assert(sizeof(UBlendRagdollAnimNotifyState) == 0x000070, "Wrong size on UBlendRagdollAnimNotifyState");
static_assert(offsetof(UBlendRagdollAnimNotifyState, TotalBlendDuration) == 0x000030, "Member 'UBlendRagdollAnimNotifyState::TotalBlendDuration' has a wrong offset!");
static_assert(offsetof(UBlendRagdollAnimNotifyState, CurrentBlendAmount) == 0x000034, "Member 'UBlendRagdollAnimNotifyState::CurrentBlendAmount' has a wrong offset!");
static_assert(offsetof(UBlendRagdollAnimNotifyState, PelvisWakeUpTime) == 0x000038, "Member 'UBlendRagdollAnimNotifyState::PelvisWakeUpTime' has a wrong offset!");
static_assert(offsetof(UBlendRagdollAnimNotifyState, bUsePhysicalAnimComp) == 0x00003D, "Member 'UBlendRagdollAnimNotifyState::bUsePhysicalAnimComp' has a wrong offset!");
static_assert(offsetof(UBlendRagdollAnimNotifyState, PhysicalAnimData) == 0x000040, "Member 'UBlendRagdollAnimNotifyState::PhysicalAnimData' has a wrong offset!");

// Class ReadyOrNot.NavArea_ClosedDoor
// 0x0000 (0x0048 - 0x0048)
class UNavArea_ClosedDoor final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_ClosedDoor">();
	}
	static class UNavArea_ClosedDoor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_ClosedDoor>();
	}
};
static_assert(alignof(UNavArea_ClosedDoor) == 0x000008, "Wrong alignment on UNavArea_ClosedDoor");
static_assert(sizeof(UNavArea_ClosedDoor) == 0x000048, "Wrong size on UNavArea_ClosedDoor");

// Class ReadyOrNot.AC_SquadMembersWithTarget
// 0x0018 (0x00F0 - 0x00D8)
class UAC_SquadMembersWithTarget final : public UAIActionConsideration
{
public:
	TArray<ETargetType>                           TargetTypes;                                       // 0x00D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, ExposeOnSpawn, NativeAccessSpecifierProtected)
	bool                                          bAllowLastTrackedTarget;                           // 0x00E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E9[0x7];                                       // 0x00E9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AC_SquadMembersWithTarget">();
	}
	static class UAC_SquadMembersWithTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAC_SquadMembersWithTarget>();
	}
};
static_assert(alignof(UAC_SquadMembersWithTarget) == 0x000008, "Wrong alignment on UAC_SquadMembersWithTarget");
static_assert(sizeof(UAC_SquadMembersWithTarget) == 0x0000F0, "Wrong size on UAC_SquadMembersWithTarget");
static_assert(offsetof(UAC_SquadMembersWithTarget, TargetTypes) == 0x0000D8, "Member 'UAC_SquadMembersWithTarget::TargetTypes' has a wrong offset!");
static_assert(offsetof(UAC_SquadMembersWithTarget, bAllowLastTrackedTarget) == 0x0000E8, "Member 'UAC_SquadMembersWithTarget::bAllowLastTrackedTarget' has a wrong offset!");

// Class ReadyOrNot.Challenge
// 0x0048 (0x0070 - 0x0028)
class UChallenge : public UObject
{
public:
	class FText                                   ChallengeName;                                     // 0x0028(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   ChallengeDescription;                              // 0x0040(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FName                                   ChallengeProgressName;                             // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ChallengeProgressCurrent;                          // 0x0060(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ChallengeProgressMax;                              // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHiddenChallenge;                                  // 0x0068(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChallengeComplete;                                // 0x0069(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLevelSpecificChallenge;                           // 0x006A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6B[0x5];                                       // 0x006B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DecrementChallengeProgress(int32 DecrementBy);
	void IncrementChallengeProgress(int32 IncrementBy);
	void OnChallengeAchieved();
	void OnChallengeInit(class AReadyOrNotGameState* gs);
	void ResetChallengeProgress();
	void UpdateFromProfile(class UReadyOrNotProfile* Profile);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Challenge">();
	}
	static class UChallenge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChallenge>();
	}
};
static_assert(alignof(UChallenge) == 0x000008, "Wrong alignment on UChallenge");
static_assert(sizeof(UChallenge) == 0x000070, "Wrong size on UChallenge");
static_assert(offsetof(UChallenge, ChallengeName) == 0x000028, "Member 'UChallenge::ChallengeName' has a wrong offset!");
static_assert(offsetof(UChallenge, ChallengeDescription) == 0x000040, "Member 'UChallenge::ChallengeDescription' has a wrong offset!");
static_assert(offsetof(UChallenge, ChallengeProgressName) == 0x000058, "Member 'UChallenge::ChallengeProgressName' has a wrong offset!");
static_assert(offsetof(UChallenge, ChallengeProgressCurrent) == 0x000060, "Member 'UChallenge::ChallengeProgressCurrent' has a wrong offset!");
static_assert(offsetof(UChallenge, ChallengeProgressMax) == 0x000064, "Member 'UChallenge::ChallengeProgressMax' has a wrong offset!");
static_assert(offsetof(UChallenge, bHiddenChallenge) == 0x000068, "Member 'UChallenge::bHiddenChallenge' has a wrong offset!");
static_assert(offsetof(UChallenge, bChallengeComplete) == 0x000069, "Member 'UChallenge::bChallengeComplete' has a wrong offset!");
static_assert(offsetof(UChallenge, bLevelSpecificChallenge) == 0x00006A, "Member 'UChallenge::bLevelSpecificChallenge' has a wrong offset!");

// Class ReadyOrNot.AC_SquadMemberThreat
// 0x0000 (0x00D8 - 0x00D8)
class UAC_SquadMemberThreat final : public UAIActionConsideration
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AC_SquadMemberThreat">();
	}
	static class UAC_SquadMemberThreat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAC_SquadMemberThreat>();
	}
};
static_assert(alignof(UAC_SquadMemberThreat) == 0x000008, "Wrong alignment on UAC_SquadMemberThreat");
static_assert(sizeof(UAC_SquadMemberThreat) == 0x0000D8, "Wrong size on UAC_SquadMemberThreat");

// Class ReadyOrNot.ReadyOrNotMathLibrary
// 0x0000 (0x0028 - 0x0028)
class UReadyOrNotMathLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FVector CalculateLocationOnSphere(const struct FVector& Origin, float Radius, float Angle, float Phi);
	static struct FVector2D CalculatePositionOnCircle(const struct FVector2D& Origin, float Radius, float Angle);
	static struct FVector2D CalculatePositionOnEllipse(const struct FVector2D& Origin, float RadiusX, float RadiusY, float Angle);
	static struct FVector GenerateRandomLocationOnSphere(const struct FVector& Origin, float Radius);
	static float GetLastKeyTime_FloatCurve(const struct FRuntimeFloatCurve& InCurve);
	static float KeepAngleAbove0(float Angle);
	static float KeepAngleBelow360(float Angle);
	static float WrapAngleIfOutOfBounds(float Angle, float MinBounds, float MaxBounds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotMathLibrary">();
	}
	static class UReadyOrNotMathLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotMathLibrary>();
	}
};
static_assert(alignof(UReadyOrNotMathLibrary) == 0x000008, "Wrong alignment on UReadyOrNotMathLibrary");
static_assert(sizeof(UReadyOrNotMathLibrary) == 0x000028, "Wrong size on UReadyOrNotMathLibrary");

// Class ReadyOrNot.AC_RecentlyStunned
// 0x0008 (0x00E0 - 0x00D8)
class UAC_RecentlyStunned final : public UAIActionConsideration
{
public:
	EStunType                                     StunType;                                          // 0x00D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AC_RecentlyStunned">();
	}
	static class UAC_RecentlyStunned* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAC_RecentlyStunned>();
	}
};
static_assert(alignof(UAC_RecentlyStunned) == 0x000008, "Wrong alignment on UAC_RecentlyStunned");
static_assert(sizeof(UAC_RecentlyStunned) == 0x0000E0, "Wrong size on UAC_RecentlyStunned");
static_assert(offsetof(UAC_RecentlyStunned, StunType) == 0x0000D8, "Member 'UAC_RecentlyStunned::StunType' has a wrong offset!");

// Class ReadyOrNot.AIActionGate
// 0x0000 (0x0028 - 0x0028)
class UAIActionGate : public UObject
{
public:
	bool CanOpen(const struct FAIActionDecisionContext& Context) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIActionGate">();
	}
	static class UAIActionGate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIActionGate>();
	}
};
static_assert(alignof(UAIActionGate) == 0x000008, "Wrong alignment on UAIActionGate");
static_assert(sizeof(UAIActionGate) == 0x000028, "Wrong size on UAIActionGate");

// Class ReadyOrNot.CampaignSettings
// 0x0010 (0x0048 - 0x0038)
class UCampaignSettings final : public UDeveloperSettings
{
public:
	TArray<TSoftObjectPtr<class UCampaignData>>   Campaigns;                                         // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CampaignSettings">();
	}
	static class UCampaignSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCampaignSettings>();
	}
};
static_assert(alignof(UCampaignSettings) == 0x000008, "Wrong alignment on UCampaignSettings");
static_assert(sizeof(UCampaignSettings) == 0x000048, "Wrong size on UCampaignSettings");
static_assert(offsetof(UCampaignSettings, Campaigns) == 0x000038, "Member 'UCampaignSettings::Campaigns' has a wrong offset!");

// Class ReadyOrNot.ReadyOrNotFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UReadyOrNotFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool AllFalse(TArray<bool>& BoolArray);
	static bool AllTrue(TArray<bool>& BoolArray);
	static bool AnyFalse(TArray<bool>& BoolArray);
	static bool AnyTrue(TArray<bool>& BoolArray);
	static bool AreAllPlayersDead(class UObject* WorldContextObject);
	static class FString BadAIActionConfigDir();
	static struct FVector2D CalculateOffscreenPositionFromWorldLocation_Ellipse(class UObject* WorldContext, const struct FVector& WorldLocation, float ViewportOffset, bool* bIsOffscreen, float* Angle, float* ForwardDotProduct, float* RightDotProduct);
	static struct FVector2D CalculateOffscreenPositionFromWorldLocation_Square(class UObject* WorldContext, const struct FVector& WorldLocation, float ViewportOffset, bool* bIsOffscreen, float* Angle, float* ForwardDotProduct, float* RightDotProduct);
	static struct FKey ConvertIntToFKey(int32 Integer);
	static struct FSlateBrush ConvertKeyToIcon(const struct FKey& InKey);
	static class FString ConvertUnrealKeyNameToRonKeyName(const struct FKey& InKey);
	static struct FRonKey ConvertUnrealKeyToRonKey(const struct FKey& InKey);
	static void CopySupporterStringToClipboard(const class UObject* WorldContextObject);
	static class FString DevMenuSettingsConfigDir();
	static bool DoesWidgetOverlap(class UObject* WorldContext, class UWidget* ParentWidget, class UWidget* WidgetA, class UWidget* WidgetB);
	static class FString DoorBreachTypeToVoiceline(const EDoorBreachType DoorBreachType);
	static class FString DoorBreachTypeToVoiceline_Negative(const EDoorBreachType DoorBreachType);
	static class FString DoorCheckResultToVoiceline(const EDoorCheckResult DoorBreachType);
	static class AActor* FindClosestActorFromLocation_Blueprint(const struct FVector& InTestLocation, const TArray<class AActor*>& InActors);
	static bool FindConfigKeyFromINIFile(const class FString& ConfigFilePath, const class FString& Section, const class FString& Key);
	static float FindNearestFloor_BP(class AActor* InActor, const TArray<class AActor*>& InActorsToIgnore, const TArray<class UPrimitiveComponent*>& InComponentsToIgnore);
	static class FText FormatPlayerActionText(const struct FKey& InKey, const EInputEvent& InInputEvent, const class FText& InActionText, const class FString& InColorLabel);
	static bool FulfillsAllPostProcessRequirements(class UObject* Context, class APlayerCharacter* OwningCharacter, class AActor* DamageCauser, const TArray<TSubclassOf<class UPostProcessRequirement>>& InRequirementClasses, const bool bForceSuccess);
	static TArray<class UFMODEvent*> GetAll2DFMODAudioEvents();
	static TArray<class UAudioComponent*> GetAllAudioComponents();
	static TArray<class UFMODBus*> GetAllFMODBusObjects();
	static TArray<class ABaseItem*> GetAllItemsInMemory();
	static TArray<class FString> GetAllSectionNamesFromINIFile(const class FString& ConfigFilePath);
	static TArray<class USoundBase*> GetAllSoundsInWorld();
	static class UAnimMontage* GetAnimationFromTable(const class FString& AnimationName, bool bIsCrouching);
	static float GetAspectRatio();
	static bool GetBoolFromINIFile(const class FString& ConfigFilePath, const class FString& Section, const class FString& Key);
	static ERONBuildConfiguration GetBuildConfiguration();
	static class UObject* GetClassDefaultObject(class UClass* Class_0);
	static class UClass* GetClassFromObject(class UObject* Object);
	static ECOOPMode GetCOOPMode();
	static class FString GetCurrentLevelNameForLookupTable(class UObject* Context);
	static float GetFloatFromINIFile(const class FString& ConfigFilePath, const class FString& Section, const class FString& Key);
	static float GetFMODBusVolume(class UFMODBus* Bus);
	static struct FSlateBrush GetIconFromInputKeyName(const class FName& RonKeyName);
	static int32 GetIntegerFromINIFile(const class FString& ConfigFilePath, const class FString& Section, const class FString& Key);
	static float GetInterfaceFovOffset(float InFov);
	static struct FKey GetKeyFromInputActionName(const class FName& ActionName, bool bOnlyGamepadKey, int32 Index_0);
	static struct FKey GetKeyFromInputAxisName(const class FName& AxisName, bool bUsingGamepad, int32 Index_0);
	static struct FVector2D GetPixelPositionOfWidget(class UObject* WorldContext, class UWidget* InParentWidget, class UWidget* InWidget, const struct FVector2D& InCoordinates);
	static struct FVector2D GetPixelPositionOfWidgetCenter(class UObject* WorldContext, class UWidget* InParentWidget, class UWidget* InWidget);
	static class APlayerCharacter* GetPlayerCharacterMutableDefaultObject(class UClass* Class_0);
	static class UHumanCharacterHUD_V2* GetPlayerHUD(class UObject* WorldContext);
	static class UReadyOrNotGameUserSettings* GetReadyOrNotGameUserSettings();
	static class AReadyOrNotLevelScript* GetReadyOrNotLevelScript(class UObject* Context);
	static struct FRoom GetRoomDataForLocation(const struct FVector& Location);
	static struct FRoom GetRoomDataFromName(class FName Name_0);
	static class FString GetServerNameFromCurrentSession();
	static TArray<class FString> GetSingleLineArrayFromINIFile(const class FString& ConfigFilePath, const class FString& Section, const class FString& Key);
	static TArray<class FString> GetStringArrayFromINIFile(const class FString& ConfigFilePath, const class FString& Section, const class FString& Key);
	static class FString GetStringFromINIFile(const class FString& ConfigFilePath, const class FString& Section, const class FString& Key);
	static bool GetUseGearListInsteadOfRadial();
	static struct FVector2D GetVector2DFromINIFile(const class FString& ConfigFilePath, const class FString& Section, const class FString& Key);
	static struct FVector GetVectorFromINIFile(const class FString& ConfigFilePath, const class FString& Section, const class FString& Key);
	static struct FVector2D GetViewportPositionOfWidget(class UObject* WorldContext, class UWidget* InParentWidget, class UWidget* InWidget, const struct FVector2D& InCoordinates);
	static struct FVector2D GetViewportPositionOfWidgetCenter(class UObject* WorldContext, class UWidget* InParentWidget, class UWidget* InWidget);
	static float GetWeaponFOVOffset();
	static struct FVector2D GetWidgetSize_Absolute(class UWidget* InWidget);
	static struct FVector2D GetWidgetSize_Local(class UWidget* InWidget);
	static bool IsActorInsideSplineEnclosure(class ASplineTrigger* InSplineTrigger, class AActor* InActor);
	static bool IsActorOutsideSplineEnclosure(class ASplineTrigger* InSplineTrigger, class AActor* InActor);
	static bool IsAprilFools();
	static bool IsBuildPirated();
	static bool IsDLSSEnabled();
	static bool IsFMODBusMuted(class UFMODBus* Bus);
	static bool IsFMODBusPaused(class UFMODBus* Bus);
	static bool IsFSREnabled();
	static bool IsHalloween();
	static bool IsInDefusalWarmup();
	static bool IsInLobby();
	static bool IsItemEquipped(class AReadyOrNotCharacter* PlayerCharacter, EItemCategory ItemCategory);
	static bool IsItemInInventory(class AReadyOrNotCharacter* PlayerCharacter, EItemCategory ItemCategory);
	static bool IsTableMontagePlaying(class APlayerCharacter* PlayerCharacter, const class FString& AnimationName, bool bIsCrouching);
	static bool IsUsingGamepad(class AReadyOrNotPlayerController* InController);
	static bool LoadStringArrayFromFile(TArray<class FString>* StringArray, int32* ArraySize, const class FString& FullFilePath, bool ExcludeEmptyLines);
	static void MuteFMOD(bool bMuted);
	static void PauseFMOD(bool bPaused);
	static void PlayRandomFMODEvent_2D(class UObject* WorldContextObject, TArray<class UFMODEvent*>& FMODEvents);
	static void PlayRandomFMODEventAtLocation(class UObject* WorldContextObject, const struct FVector& Location, TArray<class UFMODEvent*>& FMODEvents);
	static bool ProcessPostProcessEffect(class UObject* Context, struct FPostProcessSettings* PostProcessSettings, struct FPostProcessEffect* InPostProcessEffect, float DeltaTime);
	static void RegisterTick(class AActor* Actor);
	static void RemoveAllNullElements_BP(const TArray<TSubclassOf<class UClass>>& Array);
	static bool RemoveBadAIActionReport(class ABadAIAction* InBadAIActionActor, bool bReportToLog, bool bDrawDebugString);
	static void RemoveFromParentAndClear(TArray<class UWidget*>& InWidgets);
	static bool ReportBadAIAction(class ABadAIAction* InBadAIActionActor, const class FText& InSummary, const class FText& InDescription, bool bReportToLog, bool bDrawDebugString);
	static void RestartGame(const class UObject* WorldContextObject);
	static void ServerTravel(const class FString& URL);
	static void SetDecalSize(class UDecalComponent* InDecalComponent, const struct FVector& DecalSize);
	static void SetFMODVolume(float Volume);
	static void SetPlanarReflectionScreenPercentage(class UPlanarReflectionComponent* InPlanarReflectionComponent, float NewScreenPercentage);
	static void SetSafeZonePadding(class USafeZoneSlot* SafeZoneSlot, const struct FMargin& Padding);
	static void SetupPostProcessEffect(class UObject* Context, struct FPostProcessEffect* InPostProcessEffect);
	static class FString SimulateAnimatedText(class FString& FinalString, int32& Iterator, TArray<class FString>& Chars, float& ElapsedTime, float& CurrentDelay, float DelayBetweenLetters, float DelayBetweenWords, float DeltaTime, bool* bCompleted);
	static void StartPostProcessEffect(class UObject* Context, struct FPostProcessSettings* PostProcessSettings, struct FPostProcessEffect* InPostProcessEffect, class AActor* DamageCauser);
	static void StartPostProcessEffect_Specific(class UObject* Context, struct FPostProcessSettings* PostProcessSettings, struct FPostProcessEffectPlayer* InPostProcessEffectPlayer, class AActor* DamageCauser);
	static void StopPostProcessEffect(struct FPostProcessSettings* PostProcessSettings, struct FPostProcessEffect* InPostProcessEffect);
	static EEasingFunc StringToEasingFunc(const class FString& InEasingFunc);
	static int32 StringToIntegerSum(const class FString& String);
	static class FText SwatCommandToText(ESwatCommand SwatCommand);
	static class FString TimeSecondsToHHMMSS(float InSeconds);
	static void UnregisterTick(class AActor* Actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotFunctionLibrary">();
	}
	static class UReadyOrNotFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotFunctionLibrary>();
	}
};
static_assert(alignof(UReadyOrNotFunctionLibrary) == 0x000008, "Wrong alignment on UReadyOrNotFunctionLibrary");
static_assert(sizeof(UReadyOrNotFunctionLibrary) == 0x000028, "Wrong size on UReadyOrNotFunctionLibrary");

// Class ReadyOrNot.AGValidTarget
// 0x0008 (0x0030 - 0x0028)
class UAGValidTarget : public UAIActionGate
{
public:
	bool                                          bAllowFriendly;                                    // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowEnemy;                                       // 0x0029(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowNeutral;                                     // 0x002A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowLastTrackedTarget;                           // 0x002B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGValidTarget">();
	}
	static class UAGValidTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGValidTarget>();
	}
};
static_assert(alignof(UAGValidTarget) == 0x000008, "Wrong alignment on UAGValidTarget");
static_assert(sizeof(UAGValidTarget) == 0x000030, "Wrong size on UAGValidTarget");
static_assert(offsetof(UAGValidTarget, bAllowFriendly) == 0x000028, "Member 'UAGValidTarget::bAllowFriendly' has a wrong offset!");
static_assert(offsetof(UAGValidTarget, bAllowEnemy) == 0x000029, "Member 'UAGValidTarget::bAllowEnemy' has a wrong offset!");
static_assert(offsetof(UAGValidTarget, bAllowNeutral) == 0x00002A, "Member 'UAGValidTarget::bAllowNeutral' has a wrong offset!");
static_assert(offsetof(UAGValidTarget, bAllowLastTrackedTarget) == 0x00002B, "Member 'UAGValidTarget::bAllowLastTrackedTarget' has a wrong offset!");

// Class ReadyOrNot.ExperienceDefinition
// 0x0030 (0x0060 - 0x0030)
class UExperienceDefinition final : public UPrimaryDataAsset
{
public:
	TArray<class FString>                         GameFeaturesToEnable;                              // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UGameFeatureAction*>             Actions;                                           // 0x0040(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UExperienceActionSet*>           ActionSets;                                        // 0x0050(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExperienceDefinition">();
	}
	static class UExperienceDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExperienceDefinition>();
	}
};
static_assert(alignof(UExperienceDefinition) == 0x000008, "Wrong alignment on UExperienceDefinition");
static_assert(sizeof(UExperienceDefinition) == 0x000060, "Wrong size on UExperienceDefinition");
static_assert(offsetof(UExperienceDefinition, GameFeaturesToEnable) == 0x000030, "Member 'UExperienceDefinition::GameFeaturesToEnable' has a wrong offset!");
static_assert(offsetof(UExperienceDefinition, Actions) == 0x000040, "Member 'UExperienceDefinition::Actions' has a wrong offset!");
static_assert(offsetof(UExperienceDefinition, ActionSets) == 0x000050, "Member 'UExperienceDefinition::ActionSets' has a wrong offset!");

// Class ReadyOrNot.AGAnyNearbyAI
// 0x0010 (0x0038 - 0x0028)
class UAGAnyNearbyAI final : public UAIActionGate
{
public:
	ETeamType                                     TeamType;                                          // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SearchRange;                                       // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMustBeVisible;                                    // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGAnyNearbyAI">();
	}
	static class UAGAnyNearbyAI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGAnyNearbyAI>();
	}
};
static_assert(alignof(UAGAnyNearbyAI) == 0x000008, "Wrong alignment on UAGAnyNearbyAI");
static_assert(sizeof(UAGAnyNearbyAI) == 0x000038, "Wrong size on UAGAnyNearbyAI");
static_assert(offsetof(UAGAnyNearbyAI, TeamType) == 0x000028, "Member 'UAGAnyNearbyAI::TeamType' has a wrong offset!");
static_assert(offsetof(UAGAnyNearbyAI, SearchRange) == 0x00002C, "Member 'UAGAnyNearbyAI::SearchRange' has a wrong offset!");
static_assert(offsetof(UAGAnyNearbyAI, bMustBeVisible) == 0x000030, "Member 'UAGAnyNearbyAI::bMustBeVisible' has a wrong offset!");

// Class ReadyOrNot.FireOnDroppedAnimNotify
// 0x0008 (0x0040 - 0x0038)
class UFireOnDroppedAnimNotify final : public UAnimNotify
{
public:
	float                                         ChanceToFire;                                      // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FireOnDroppedAnimNotify">();
	}
	static class UFireOnDroppedAnimNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFireOnDroppedAnimNotify>();
	}
};
static_assert(alignof(UFireOnDroppedAnimNotify) == 0x000008, "Wrong alignment on UFireOnDroppedAnimNotify");
static_assert(sizeof(UFireOnDroppedAnimNotify) == 0x000040, "Wrong size on UFireOnDroppedAnimNotify");
static_assert(offsetof(UFireOnDroppedAnimNotify, ChanceToFire) == 0x000038, "Member 'UFireOnDroppedAnimNotify::ChanceToFire' has a wrong offset!");

// Class ReadyOrNot.ConsoleHotkeys
// 0x1740 (0x1A00 - 0x02C0)
class UConsoleHotkeys : public UUserWidget
{
public:
	class UHorizontalBox*                         DpadNavigation;                                    // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 UpIcon;                                            // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 RightIcon;                                         // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 DownIcon;                                          // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         DownIconCounter;                                   // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 LeftIcon;                                          // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UConsoleHotkey*                         HotkeyItemWheel;                                   // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCommonVisibilitySwitcher*              IconSwitcher;                                      // 0x02F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSlateBrush                            NVGOnIcon;                                         // 0x0300(0x00D0)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            NVGOffIcon;                                        // 0x03D0(0x00D0)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            CycleCantedSightIcon;                              // 0x04A0(0x00D0)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            CycleSecondarySightIcon;                           // 0x0570(0x00D0)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            CycleNeutralSightIcon;                             // 0x0640(0x00D0)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            ToggleNeutralSightIcon;                            // 0x0710(0x00D0)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            ToggleCantedSightIcon;                             // 0x07E0(0x00D0)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            FireModeSafeIcon;                                  // 0x08B0(0x00D0)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            FireModeSingleIcon;                                // 0x0980(0x00D0)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            FireModeBurstIcon;                                 // 0x0A50(0x00D0)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            FireModeFullAutoIcon;                              // 0x0B20(0x00D0)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            TeamViewIcon;                                      // 0x0BF0(0x00D0)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            LaserIconOn;                                       // 0x0CC0(0x00D0)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            LaserIconOff;                                      // 0x0D90(0x00D0)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            FlashlightIconOn;                                  // 0x0E60(0x00D0)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            FlashlightIconOff;                                 // 0x0F30(0x00D0)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            ChemlightIcon;                                     // 0x1000(0x00D0)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            CirculateTeamLeftIcon;                             // 0x10D0(0x00D0)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            CirculateTeamRightIcon;                            // 0x11A0(0x00D0)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            QueueTeamIcon;                                     // 0x1270(0x00D0)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            DontQueueTeamIcon;                                 // 0x1340(0x00D0)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            MirrorgunIcon;                                     // 0x1410(0x00D0)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            ShieldIcon;                                        // 0x14E0(0x00D0)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            BatteringRamIcon;                                  // 0x15B0(0x00D0)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            LauncherIcon;                                      // 0x1680(0x00D0)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            BreachShotgunIcon;                                 // 0x1750(0x00D0)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            LowReadyLowerIcon;                                 // 0x1820(0x00D0)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            LowReadyRaiseIcon;                                 // 0x18F0(0x00D0)(Edit, NativeAccessSpecifierPublic)
	class UCommandWheel*                          CommandWheel;                                      // 0x19C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19C8[0x8];                                     // 0x19C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerCharacter*                       PlayerCharacter;                                   // 0x19D0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ABaseItem*                              LastEquippedItem;                                  // 0x19D8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_19E0[0x20];                                    // 0x19E0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeKey();
	void ConsoleHotkeysEnabled();
	void DPadDownPressed(bool Pressed);
	void DPadLeftPressed(bool Pressed);
	void DPadRightPressed(bool Pressed);
	void DPadUpPressed(bool Pressed);
	void InventoryChanged(class ABaseItem* Item);
	void ItemEquipped(class ABaseItem* Item);
	void OnChemlightThrown(class APlayerCharacter* PlayerCharacter_0);
	void OnFireModeChanged(class APlayerCharacter* _pc, EFireMode newFireMode, EFireMode _lfm);
	void RefreshHotkeys();
	void ResetIconColors();
	void SetAttachmentIcon();
	void SetCantedSightsHiddenTraining(bool bHidden);
	void SetChemlightHidden(bool bHidden);
	void SetCommandWheelReference(class UCommandWheel* CommandWheelPtr);
	void SetDownIsHidden(bool bHidden);
	void SetHotkeyItemWheelIsHidden(bool bHidden);
	void SetIconActive(class UImage* Icon, bool Active);
	void SetIsHidden(bool bHidden);
	void SetLayout(EConsoleHotkeysLayout Layout);
	void SetLeftIsHidden(bool bHidden);
	void SetLongTacticalIcon();
	void SetLowReadyIcon();
	void SetRightIsHidden(bool bHidden);
	void SetSightIcon();
	void SetUpIsHidden(bool bHidden);
	void UpdateSightIcon(bool bUsingCanted);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConsoleHotkeys">();
	}
	static class UConsoleHotkeys* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConsoleHotkeys>();
	}
};
static_assert(alignof(UConsoleHotkeys) == 0x000010, "Wrong alignment on UConsoleHotkeys");
static_assert(sizeof(UConsoleHotkeys) == 0x001A00, "Wrong size on UConsoleHotkeys");
static_assert(offsetof(UConsoleHotkeys, DpadNavigation) == 0x0002C0, "Member 'UConsoleHotkeys::DpadNavigation' has a wrong offset!");
static_assert(offsetof(UConsoleHotkeys, UpIcon) == 0x0002C8, "Member 'UConsoleHotkeys::UpIcon' has a wrong offset!");
static_assert(offsetof(UConsoleHotkeys, RightIcon) == 0x0002D0, "Member 'UConsoleHotkeys::RightIcon' has a wrong offset!");
static_assert(offsetof(UConsoleHotkeys, DownIcon) == 0x0002D8, "Member 'UConsoleHotkeys::DownIcon' has a wrong offset!");
static_assert(offsetof(UConsoleHotkeys, DownIconCounter) == 0x0002E0, "Member 'UConsoleHotkeys::DownIconCounter' has a wrong offset!");
static_assert(offsetof(UConsoleHotkeys, LeftIcon) == 0x0002E8, "Member 'UConsoleHotkeys::LeftIcon' has a wrong offset!");
static_assert(offsetof(UConsoleHotkeys, HotkeyItemWheel) == 0x0002F0, "Member 'UConsoleHotkeys::HotkeyItemWheel' has a wrong offset!");
static_assert(offsetof(UConsoleHotkeys, IconSwitcher) == 0x0002F8, "Member 'UConsoleHotkeys::IconSwitcher' has a wrong offset!");
static_assert(offsetof(UConsoleHotkeys, NVGOnIcon) == 0x000300, "Member 'UConsoleHotkeys::NVGOnIcon' has a wrong offset!");
static_assert(offsetof(UConsoleHotkeys, NVGOffIcon) == 0x0003D0, "Member 'UConsoleHotkeys::NVGOffIcon' has a wrong offset!");
static_assert(offsetof(UConsoleHotkeys, CycleCantedSightIcon) == 0x0004A0, "Member 'UConsoleHotkeys::CycleCantedSightIcon' has a wrong offset!");
static_assert(offsetof(UConsoleHotkeys, CycleSecondarySightIcon) == 0x000570, "Member 'UConsoleHotkeys::CycleSecondarySightIcon' has a wrong offset!");
static_assert(offsetof(UConsoleHotkeys, CycleNeutralSightIcon) == 0x000640, "Member 'UConsoleHotkeys::CycleNeutralSightIcon' has a wrong offset!");
static_assert(offsetof(UConsoleHotkeys, ToggleNeutralSightIcon) == 0x000710, "Member 'UConsoleHotkeys::ToggleNeutralSightIcon' has a wrong offset!");
static_assert(offsetof(UConsoleHotkeys, ToggleCantedSightIcon) == 0x0007E0, "Member 'UConsoleHotkeys::ToggleCantedSightIcon' has a wrong offset!");
static_assert(offsetof(UConsoleHotkeys, FireModeSafeIcon) == 0x0008B0, "Member 'UConsoleHotkeys::FireModeSafeIcon' has a wrong offset!");
static_assert(offsetof(UConsoleHotkeys, FireModeSingleIcon) == 0x000980, "Member 'UConsoleHotkeys::FireModeSingleIcon' has a wrong offset!");
static_assert(offsetof(UConsoleHotkeys, FireModeBurstIcon) == 0x000A50, "Member 'UConsoleHotkeys::FireModeBurstIcon' has a wrong offset!");
static_assert(offsetof(UConsoleHotkeys, FireModeFullAutoIcon) == 0x000B20, "Member 'UConsoleHotkeys::FireModeFullAutoIcon' has a wrong offset!");
static_assert(offsetof(UConsoleHotkeys, TeamViewIcon) == 0x000BF0, "Member 'UConsoleHotkeys::TeamViewIcon' has a wrong offset!");
static_assert(offsetof(UConsoleHotkeys, LaserIconOn) == 0x000CC0, "Member 'UConsoleHotkeys::LaserIconOn' has a wrong offset!");
static_assert(offsetof(UConsoleHotkeys, LaserIconOff) == 0x000D90, "Member 'UConsoleHotkeys::LaserIconOff' has a wrong offset!");
static_assert(offsetof(UConsoleHotkeys, FlashlightIconOn) == 0x000E60, "Member 'UConsoleHotkeys::FlashlightIconOn' has a wrong offset!");
static_assert(offsetof(UConsoleHotkeys, FlashlightIconOff) == 0x000F30, "Member 'UConsoleHotkeys::FlashlightIconOff' has a wrong offset!");
static_assert(offsetof(UConsoleHotkeys, ChemlightIcon) == 0x001000, "Member 'UConsoleHotkeys::ChemlightIcon' has a wrong offset!");
static_assert(offsetof(UConsoleHotkeys, CirculateTeamLeftIcon) == 0x0010D0, "Member 'UConsoleHotkeys::CirculateTeamLeftIcon' has a wrong offset!");
static_assert(offsetof(UConsoleHotkeys, CirculateTeamRightIcon) == 0x0011A0, "Member 'UConsoleHotkeys::CirculateTeamRightIcon' has a wrong offset!");
static_assert(offsetof(UConsoleHotkeys, QueueTeamIcon) == 0x001270, "Member 'UConsoleHotkeys::QueueTeamIcon' has a wrong offset!");
static_assert(offsetof(UConsoleHotkeys, DontQueueTeamIcon) == 0x001340, "Member 'UConsoleHotkeys::DontQueueTeamIcon' has a wrong offset!");
static_assert(offsetof(UConsoleHotkeys, MirrorgunIcon) == 0x001410, "Member 'UConsoleHotkeys::MirrorgunIcon' has a wrong offset!");
static_assert(offsetof(UConsoleHotkeys, ShieldIcon) == 0x0014E0, "Member 'UConsoleHotkeys::ShieldIcon' has a wrong offset!");
static_assert(offsetof(UConsoleHotkeys, BatteringRamIcon) == 0x0015B0, "Member 'UConsoleHotkeys::BatteringRamIcon' has a wrong offset!");
static_assert(offsetof(UConsoleHotkeys, LauncherIcon) == 0x001680, "Member 'UConsoleHotkeys::LauncherIcon' has a wrong offset!");
static_assert(offsetof(UConsoleHotkeys, BreachShotgunIcon) == 0x001750, "Member 'UConsoleHotkeys::BreachShotgunIcon' has a wrong offset!");
static_assert(offsetof(UConsoleHotkeys, LowReadyLowerIcon) == 0x001820, "Member 'UConsoleHotkeys::LowReadyLowerIcon' has a wrong offset!");
static_assert(offsetof(UConsoleHotkeys, LowReadyRaiseIcon) == 0x0018F0, "Member 'UConsoleHotkeys::LowReadyRaiseIcon' has a wrong offset!");
static_assert(offsetof(UConsoleHotkeys, CommandWheel) == 0x0019C0, "Member 'UConsoleHotkeys::CommandWheel' has a wrong offset!");
static_assert(offsetof(UConsoleHotkeys, PlayerCharacter) == 0x0019D0, "Member 'UConsoleHotkeys::PlayerCharacter' has a wrong offset!");
static_assert(offsetof(UConsoleHotkeys, LastEquippedItem) == 0x0019D8, "Member 'UConsoleHotkeys::LastEquippedItem' has a wrong offset!");

// Class ReadyOrNot.ReadyOrNotInputModifierResponseCurveExponential
// 0x0000 (0x0028 - 0x0028)
class UReadyOrNotInputModifierResponseCurveExponential final : public UInputModifier
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotInputModifierResponseCurveExponential">();
	}
	static class UReadyOrNotInputModifierResponseCurveExponential* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotInputModifierResponseCurveExponential>();
	}
};
static_assert(alignof(UReadyOrNotInputModifierResponseCurveExponential) == 0x000008, "Wrong alignment on UReadyOrNotInputModifierResponseCurveExponential");
static_assert(sizeof(UReadyOrNotInputModifierResponseCurveExponential) == 0x000028, "Wrong size on UReadyOrNotInputModifierResponseCurveExponential");

// Class ReadyOrNot.AGNumActiveAI
// 0x0008 (0x0030 - 0x0028)
class UAGNumActiveAI : public UAIActionGate
{
public:
	ETeamType                                     Team;                                              // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         NumAI;                                             // 0x0029(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EComparisonOp                                 ComparisonType;                                    // 0x002A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B[0x5];                                       // 0x002B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGNumActiveAI">();
	}
	static class UAGNumActiveAI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGNumActiveAI>();
	}
};
static_assert(alignof(UAGNumActiveAI) == 0x000008, "Wrong alignment on UAGNumActiveAI");
static_assert(sizeof(UAGNumActiveAI) == 0x000030, "Wrong size on UAGNumActiveAI");
static_assert(offsetof(UAGNumActiveAI, Team) == 0x000028, "Member 'UAGNumActiveAI::Team' has a wrong offset!");
static_assert(offsetof(UAGNumActiveAI, NumAI) == 0x000029, "Member 'UAGNumActiveAI::NumAI' has a wrong offset!");
static_assert(offsetof(UAGNumActiveAI, ComparisonType) == 0x00002A, "Member 'UAGNumActiveAI::ComparisonType' has a wrong offset!");

// Class ReadyOrNot.AG_HasEquippedItem
// 0x0000 (0x0028 - 0x0028)
class UAG_HasEquippedItem : public UAIActionGate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AG_HasEquippedItem">();
	}
	static class UAG_HasEquippedItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAG_HasEquippedItem>();
	}
};
static_assert(alignof(UAG_HasEquippedItem) == 0x000008, "Wrong alignment on UAG_HasEquippedItem");
static_assert(sizeof(UAG_HasEquippedItem) == 0x000028, "Wrong size on UAG_HasEquippedItem");

// Class ReadyOrNot.BpGameplayHelperLib
// 0x0000 (0x0028 - 0x0028)
class UBpGameplayHelperLib final : public UBlueprintFunctionLibrary
{
public:
	static void AddDefaultItemsToPlayer(class AReadyOrNotCharacter* Player);
	static bool ApplyRadialDamageWithSecondTrace(const class UObject* WorldContextObject, float SecondTraceDistance, float SecondTraceRadiusFactor, float BaseDamage, float MinimumDamage, const struct FVector& Origin, float DamageInnerRadius, float DamageOuterRadius, float DamageFalloff, TSubclassOf<class UDamageType> DamageTypeClass, const TArray<class AActor*>& IgnoreActors, class AActor* DamageCauser, class AController* InstigatedByController, ECollisionChannel DamagePreventionChannel);
	static void Array_Sort(const TArray<int32>& TargetArray, bool bAscendingOrder, class FName VariableName);
	static void AttachMagazinesToWeapon(TSubclassOf<class ABaseMagazineWeapon> WeaponClass, class ABaseMagazineWeapon* Weapon);
	static struct FPointDamageEvent CastToPointDamageEvent(const struct FDamageEvent& DamageEvent, EStructureCastPathway* Branches);
	static struct FRadialDamageEvent CastToRadialDamageEvent(const struct FDamageEvent& DamageEvent, EStructureCastPathway* Branches);
	static void ChangeLocalization(const class FString& Target);
	static class FString ConvertDegreeIntoLetter(float Degrees);
	static class FString ConvertFloatToStringMinutes(float Val);
	static class FString ConvertFloatToStringMinutes_Detail(float Val);
	static float ConvertFovToVertical(const class UObject* WorldContextObject, float FOV);
	static EWeaponType ConvertItemTypeToWeaponType(EItemType ItemType);
	static struct FVector2D ConvertSquareVectorToCircle(const struct FVector2D& SquareVector);
	static EItemType ConvertWeaponTypeToItemType(EWeaponType WeaponType);
	static void DeleteLoadout(const class FString& LoadoutName);
	static void DisableInteractionCompForController(class UInteractableComponent* InteractableComponent, class APlayerController* InPlayerController);
	static void DisableInteractionFor(class AActor* InInteractableActor, class APlayerCharacter* InPlayerCharacter);
	static void DisableInteractionForController(class AActor* InInteractableActor, class APlayerController* InPlayerCharacter);
	static void EnableInteractionCompForController(class UInteractableComponent* InteractableComponent, class APlayerController* InPlayerController);
	static void EnableInteractionFor(class AActor* InInteractableActor, class APlayerCharacter* InPlayerCharacter);
	static void EnableInteractionForController(class AActor* InInteractableActor, class APlayerController* InPlayerCharacter);
	static bool EquipLoadoutOnPlayer(const struct FSavedLoadout& Loadout, class AReadyOrNotCharacter* EquipPlayer, const struct FLoadoutEquipOptions& LoadoutEquipOptions);
	static class APlayerCharacter* FindClosestDeadGuyInRadius(const struct FVector& Origin, class AActor* Causer, float Radius, bool bIncludeUnconscious);
	static bool FindPositionAwayFromSwat(class ACyberneticCharacter* Character, const struct FVector& StartingLocation, struct FVector* OutLocation, float Radius, TSubclassOf<class UNavigationQueryFilter> NavFilter, bool bForce);
	static class FString GetAdditionalBugReportInformation(class APlayerController* PC);
	static class UDataTable* GetAILookupDataTable();
	static class UDataTable* GetAmmoLookupDataTable();
	static struct FAnimatedIcon GetAnimatedIconFromTable(class FName RowName, bool* bSuccess);
	static class UDataTable* GetAnimatedIconLookupDataTable();
	static int32 GetAttachmentPointsRemaining(const struct FSavedLoadout& Loadout);
	static bool GetBounceLightEnabled(bool* bBounceLightEnabled);
	static class FString GetBuildDate();
	static class FString GetBuildTime();
	static class UCampaignData* GetCampaignData();
	static class UDataTable* GetCharacterLookOverrideDataTable();
	static class ACivilianCharacter* GetClosestActiveCivilian(const struct FVector& Location, float Distance, bool bMustHaveTarget);
	static class ASuspectCharacter* GetClosestActiveSuspect(const struct FVector& Location, float Distance, bool bMustHaveTarget);
	static class UDataTable* GetConversationLookupDataTable();
	static ECOOPMode GetCoopModeFromModeName(const class FString& InCoopName);
	static class UReadyOrNotProfile* GetCurrentProfile(class UWorld* WorldContext);
	static float GetDistanceBetweenActors(class AActor* Actor1, class AActor* Actor2);
	static float GetDistanceBetweenActors2D(class AActor* Actor1, class AActor* Actor2);
	static class FString GetDMOAddress();
	static class FString GetDMOGameMode();
	static ETeamType GetDMOTeamType();
	static class UDataTable* GetDoorLookupDataTable();
	static class APlayerCharacter* GetFirstAlivePlayerControlledCharacter(class UWorld* WorldContext);
	static class UUserWidget* GetFirstWidgetFromViewport(const class FString& WidgetName);
	static bool GetFlashlightShadows(bool* bFlashLightShadows);
	static bool GetForceFeedbackEnabled(bool* ForceFeedbackEnabled);
	static bool GetForceFeedbackIntensity(float* ForceFeedbackIntensity);
	static bool GetFoV(float* FOV);
	static bool GetFreelookSensitivity(float* Sensitivity);
	static void GetFriendlyMapAndModeFromName(const class FString& InUrl, class FString* OutInternalMapName, class FString* OutFriendlyMap, class FString* OutFriendlyMode);
	static class FString GetFriendlyModeFromECoopMode(const ECOOPMode InCoopMode);
	static class UReadyOrNotGameInstance* GetGameInstance(class UWorld* WorldContext);
	static class UDataTable* GetGameModeSettingsLookupDataTable();
	static bool GetGamepadAimAssistIntensity(class FString* AimAssistIntensity);
	static bool GetGamepadAimSensitivityHorizontal(float* GamepadAimSensitivityHorizontal);
	static bool GetGamepadAimSensitivityVertical(float* GamepadAimSensitivityVertical);
	static class UDataTable* GetGamepadHoldTimesDataTable();
	static bool GetGamepadInvertButtonLayout(bool* bInvertButtonLayout);
	static bool GetGamepadInverted(bool* bInvertVertical, bool* bInvertHorizontal);
	static bool GetGamepadInvertStickLayout(bool* bInvertStickLayout);
	static bool GetGamepadInvertTriggersLayout(bool* bInvertTriggersLayout);
	static bool GetGamepadLookInnerDeadzone(float* GamepadLookInnerDeadzone);
	static bool GetGamepadLookSensitivityHorizontal(float* GamepadLookSensitivityHorizontal);
	static bool GetGamepadLookSensitivitySpeedUp(float* GamepadLookSensitivitySpeedUp);
	static bool GetGamepadLookSensitivityVertical(float* GamepadLookSensitivityVertical);
	static bool GetGamepadMovementInnerDeadzone(float* GamepadMovementInnerDeadzone);
	static bool GetGamepadRadialMenuRequireShoulderRelease(bool* RequireShoulderButtonRelease);
	static bool GetGamepadRadialMenuUseLeftStick(bool* UseLeftStick);
	static bool GetGyroActiveMode(class FString* GyroActiveMode);
	static bool GetGyroHorizontalAimSensitivity(float* GyroHorizontalAimSensitivity);
	static bool GetGyroHorizontalLookSensitivity(float* GyroHorizontalLookSensitivity);
	static bool GetGyroInverted(bool* bInvertGyroVertical, bool* bInvertGyroHorizontal);
	static bool GetGyroVerticalAimSensitivity(float* GyroVerticalAimSensitivity);
	static bool GetGyroVerticalLookSensitivity(float* GyroVerticalLookSensitivity);
	static bool GetHitmarkerSfxEnabled(bool* bHitmarkerSfxEnabled);
	static class UHumanCharacterHUD_V2* GetHUDWidget();
	static class UDataTable* GetInputKeyGamepadIconLookupDataTable();
	static class UItemData* GetItemData(class UWorld* WorldContext);
	static bool GetLastConnectedServerIP(class FString* IP);
	static bool GetLevelAssetData(const class FString& LevelName, struct FAssetData* AssetData);
	static struct FLevelDataLookupTable GetLevelData(class UWorld* WorldContext);
	static TArray<struct FLevelDataLookupTable> GetLevels();
	static class UReadyOrNotSaveGame* GetLoadGameInstance(const class FString& LoadSlotName);
	static class UTexture2D* GetLoadingScreenLevelImage(const class FString& Level);
	static bool GetLoadoutNames(TArray<class FString>* LoadoutNames);
	static bool GetLocalization(class FString* Target);
	static class AReadyOrNotPlayerState* GetLocalPlayerState(class UWorld* World);
	static struct FLevelDataLookupTable GetMapDetailsFromName(const class FString& MapName);
	static class AMapStatisticsSystem* GetMapStatistics(class UWorld* WorldContext);
	static bool GetMicInputGain(float* MicInputGain);
	static bool GetMouseInverted(bool* bInvertVertical, bool* bInvertHorizontal);
	static bool GetMouseSensitivity(float* MouseSensitvity);
	static class UDataTable* GetMoveStyleDataTable();
	static class UReadyOrNotMultiplayerProfile* GetMultiplayerProfile(const class FString& LoadSlotName);
	static class UMusicData* GetMusicData(class UWorld* WorldContext);
	static class UDataTable* GetPairedInteractionDataTable();
	static class UPenetrationData* GetPenetrationData();
	static bool GetPlayerDefaultLoadout(struct FSavedLoadout* OutLoadout);
	static class FString GetProjectName();
	static class FString GetProjectVersion();
	static int32 GetProjectVersionAsInt();
	static bool GetRandomLoadingScreenTip(class FText* Tip);
	static class UDataSingleton* GetRoNData();
	static class UReadyOrNotGameInstance* GetRONGameInstance();
	static bool GetSendMapStatistics(bool* bSendMapStatistics);
	static bool GetShellLifetime(float* ShellLifeTime);
	static bool GetShowControls(bool* bShowControls);
	static bool GetShowFPS(bool* bShowFPS);
	static class UDataTable* GetSpeechLookupDataTable(const class FString& Speaker);
	static class UDataTable* GetSuspectArmourDataTable();
	static class UDataTable* GetTrapLookupDataTable();
	static bool GetUIScaling(float* Scale);
	static bool GetUseMeshpainting(bool* bUseMeshPainting);
	static bool GetVoiceType(EVoiceType* OutVoiceType);
	static bool GetVolumes(float* MasterVolume, float* UIVolume, float* SFXVolume, float* MusicVolume, float* VOIPVolume);
	static float GetWeaponFieldOfView();
	static class UWidgetsData* GetWidgetData();
	static struct FWidgetLookupData GetWidgetDataFromLookupData(const class FString& WidgetName, bool bWarnIfMissing);
	static TArray<class UUserWidget*> GetWidgetsFromViewport(const class FString& WidgetName);
	static class UWorld* GetWorldBP(class APlayerController* PC);
	static class UWorld* GetWorldStatic();
	static bool HasLineOfSight(class AActor* Observer, class AActor* B);
	static bool HasLineOfSightExt(class AActor* Observer, class AActor* B, struct FHitResult* HitResult);
	static bool HasLineOfSightLoc(class UWorld* WorldContext, const struct FVector& A, const struct FVector& B, const TArray<class AActor*>& IgnoredActors, ECollisionChannel CollisionChannel);
	static bool HasWidgetInViewport(const class FString& WidgetName);
	static class UPanelSlot* InsertChildAt(class UWidget* Parent, int32 Index_0, class UWidget* Content);
	static bool IsCommanderMode(const class UObject* WorldContextObject);
	static bool IsConsole(const class UObject* WorldContextObject);
	static bool IsCOOPSupported(const struct FLevelDataLookupTable& LookupTable);
	static bool IsDLCLocked(TSubclassOf<class ABaseItem> Item);
	static bool IsDMOBuild();
	static bool IsDMOMatchMake();
	static bool IsDMOPVPOnly();
	static bool IsEditorBuild();
	static bool IsEmptyItem(TSubclassOf<class ABaseItem> ItemClass);
	static bool IsEnemy(ETeamType TeamOne, ETeamType TeamTwo);
	static bool IsFriendly(class AReadyOrNotGameState* GameState, ETeamType TeamOne, ETeamType TeamTwo);
	static bool IsFriendlyWithMe(class AReadyOrNotGameState* GameState, ETeamType TeamType);
	static bool IsHelmetCompatible(TSubclassOf<class ABaseItem> FacewearClass, TSubclassOf<class ABaseItem> HelmetClass);
	static bool IsInPublicLobbyCooldown(float* SecondsRemaining);
	static bool IsIronmanMode(const class UObject* WorldContextObject);
	static bool IsLeadPlayer(const class UObject* WorldContextObject);
	static bool IsLobby(const class UObject* WorldContextObject);
	static bool IsMultiplayer(const class UObject* WorldContextObject);
	static bool IsObjectiveTarget(class AReadyOrNotCharacter* Target, class AReadyOrNotCharacter* LocalPlayer);
	static bool IsPreMissionBriefingBeforeLoadout();
	static bool IsPvPSupported(const struct FLevelDataLookupTable& LookupTable);
	static bool IsRTXDMOBuild();
	static bool IsShippingBuild();
	static bool IsShowHUDEnabled();
	static bool IsSupporterOnlyBuild();
	static bool IsWidgetOfClassInViewport(class UObject* WorldContextObject, TSubclassOf<class UUserWidget> WidgetClass);
	static bool Load2DReload(bool* b2DReload);
	static bool LoadColorblindMode(EColorVisionDeficiency* ColorVisionDeficiency);
	static bool LoadColorblindStrength(float* ColorblindStrength);
	static bool LoadControlScheme(bool* UsingAlternateControls);
	static bool LoadCurvedHUD(bool* bCurvedHUD);
	static void LoadCustomizationLevels(class UWorld* WorldContext);
	static bool LoadDefaultCommands(ESwatCommand* DefaultCommand, ESwatCommand* DefaultDoorUnknownCommand, ESwatCommand* DefaultDoorOpenCommand, ESwatCommand* DefaultDoorLockedCommand, ESwatCommand* DefaultDoorUnlockedCommand);
	static bool LoadDefaultCommandsAsOption(int32* DefaultCommandOption, int32* DefaultDoorUnknownCommandOption, int32* DefaultDoorOpenCommandOption, int32* DefaultDoorLockedCommandOption, int32* DefaultDoorUnlockedCommandOption);
	static bool LoadDefaultDoorLockedCommand(ESwatCommand* DefaultDoorLockedCommand, int32* DefaultDoorLockedCommandIndex);
	static bool LoadDefaultDoorOpenCommand(ESwatCommand* DefaultDoorOpenCommand, int32* DefaultDoorOpenCommandIndex);
	static bool LoadDefaultDoorUnknownCommand(ESwatCommand* DefaultDoorUnknownCommand, int32* DefaultDoorUnknownCommandIndex);
	static bool LoadDefaultDoorUnlockedCommand(ESwatCommand* DefaultDoorUnlockedCommand, int32* DefaultDoorUnlockedCommandIndex);
	static void LoadDefaultLoadout(struct FSavedLoadout* OutLoadout, const class FString& LoadoutName);
	static bool LoadDefaultSurfaceCommand(ESwatCommand* DefaultCommand, int32* DefaultCommandIndex);
	static bool LoadEmptyMagReloadSettings(EEmptyMagReloadType* EmptyMagReloadType);
	static bool LoadFireModeDisplayOption(int32* FireModeDisplayOption);
	static bool LoadGrenadeSettings(EGrenadeThrowSettingType* GrenadeThrowType);
	static bool LoadHighlightWeapons(bool* bHighlightWeapons);
	static bool LoadHoldCrouch(bool* HoldCrouch);
	static bool LoadHotkeyHintSetting(bool* bShowHotkeyHint);
	static bool LoadHUDSettings(bool* bShowHUD, bool* bCurvedHUD, bool* bShowCompass, bool* bShowWeaponHUD, bool* bShowMagazineHUD, bool* bShowChat, bool* bSwayHUD, bool* b2DReload, float* IconScale, float* QuickThrowScale, int32* FireModeDisplayOption, bool* bShowPlayerNames, bool* bShowButtonPrompts);
	static bool LoadIconScale(float* IconScale);
	static bool LoadItemSelectionStyleSettings(EItemSelectionInterfaceType* ItemSelectionInterface);
	static class ULicenseSave* LoadLicenseSave();
	static bool LoadLoadout(struct FSavedLoadout* Loadout, const class FString& LoadoutName);
	static bool LoadLoadoutAndEquipPlayer(struct FSavedLoadout* Loadout, class AReadyOrNotCharacter* EquipPlayer, const class FString& LoadoutName);
	static bool LoadLowReadyStyle(bool* bUseHighReady);
	static bool LoadMaxShellsInWorld(int32* MaxShells);
	static bool LoadMirrorAntiAliasEnabled(bool* bShowAntiAlias);
	static bool LoadMirrorDecalsEnabled(bool* bShowDecals);
	static bool LoadMirrorDynamicShadowsEnabled(bool* bShowDynamicShadows);
	static bool LoadMirrorEnabledOnlyInLobby(bool* bEnabled);
	static bool LoadMirrorReflectionEnabled(bool* bEnabled);
	static bool LoadMirrorResolutionScale(float* ResolutionScale);
	static bool LoadOptiwandViewMode(EOptiwandViewMode* OptiwandViewMode);
	static bool LoadPiPFPS(bool* bEnabled, float* FPS);
	static bool LoadPiPResolutionScale(float* ResolutionScale);
	static bool LoadPS5AdaptiveAimTriggers(bool* PS5AdaptiveAimTriggers);
	static bool LoadPS5AdaptiveFireTriggers(bool* PS5AdaptiveFireTriggers);
	static bool LoadQuickThrowScale(float* QuickThrowScale);
	static bool LoadReplayEnabled(bool* bReplayEnabled);
	static bool LoadSafeZoneSettings(float* SafeZoneX, float* SafeZoneY);
	static bool LoadScoreReadoutSetting(EScoreReadoutMode* OutScoreReadoutMode);
	static bool LoadSelectedAudioDevice(class FString* OutAudioDevice);
	static bool LoadServersideChecksum(bool* bServerSideChecksumEnabled);
	static bool LoadShotgunSettings(EShotgunReloadType* ShotgunReloadType);
	static bool LoadShowButtonPrompts(bool* bShowButtonPrompts);
	static bool LoadShowChat(bool* bShowChat);
	static bool LoadShowCommandContextHintSetting(bool* bShowCommandContextHint);
	static bool LoadShowCompass(bool* bShowCompass);
	static bool LoadShowHealthIconSetting(bool* bShowHealthIcons);
	static bool LoadShowHesitationBarSetting(bool* bShowHesitationBar);
	static bool LoadShowHUD(bool* bShowHUD);
	static bool LoadShowHUDSetting(bool* bShowHUD);
	static bool LoadShowMagazineHUD(bool* bShowMagazineHUD);
	static bool LoadShowMultiplayerNames(bool* bShowMultiplayerNames);
	static bool LoadShowPlayerIconSetting(bool* bShowPlayerIcon);
	static bool LoadShowPlayerNamesSetting(bool* bShowPlayerNames);
	static bool LoadShowTeamStatus(bool* bShowTeamStatus);
	static bool LoadShowWeaponHUD(bool* ShowWeaponHUD);
	static bool LoadSubtitlesBackgroundOpacity(float* SubtitlesBackgroundOpacity);
	static bool LoadSubtitlesEnabled(bool* bEnableSubtitles);
	static bool LoadSubtitlesLocale(class FString* SubtitlesLocale);
	static bool LoadSubtitlesSize(ESubtitlesSize* SubtitlesSize);
	static bool LoadSubtitlesSpeed(float* SubtitlesSpeed);
	static bool LoadSwayHUD(bool* bSwayHUD);
	static bool LoadTeamViewFPSSetting(bool* bEnabled, int32* TeamViewFPS);
	static bool LoadToggleADS(bool* ToggleADS);
	static bool LoadTogglePS5Gyro(bool* TogglePS5Gyro);
	static bool LoadWorldSpaceActionPrompts(bool* bWorldSpaceActionPrompts);
	static bool LoadZoomADSSetting(bool* bZoomADS);
	static void PlayInterfaceSound(class UWorld* WorldContext, EInterfaceSoundType SoundClass);
	static bool ReloadSettings();
	static void RemoveWidgetFromViewport(const class FString& WidgetName);
	static bool Save2DReload(bool b2DReload);
	static bool SaveColorblindMode(EColorVisionDeficiency ColorVisionDeficiency);
	static bool SaveColorblindStrength(float ColorblindStrength);
	static bool SaveControlScheme(bool UsingAlternateControls);
	static bool SaveCurvedHUD(bool bCurvedHUD);
	static bool SaveDefaultCommand(ESwatCommand DefaultCommand, ESwatCommand DefaultDoorUnknownCommand, ESwatCommand DefaultDoorOpenCommand, ESwatCommand DefaultDoorLockedCommand, ESwatCommand DefaultDoorUnlockedCommand);
	static bool SaveDefaultCommandAsOption(int32 DefaultCommandOption, int32 DefaultDoorUnknownCommandOption, int32 DefaultDoorOpenCommandOption, int32 DefaultDoorLockedCommandOption, int32 DefaultDoorUnlockedCommandOption);
	static bool SaveDefaultDoorLockedCommand(ESwatCommand DefaultDoorLockedCommand, int32 DefaultDoorLockedCommandIndex);
	static bool SaveDefaultDoorOpenCommand(ESwatCommand DefaultDoorOpenCommand, int32 DefaultDoorOpenCommandIndex);
	static bool SaveDefaultDoorUnknownCommand(ESwatCommand DefaultDoorUnknownCommand, int32 DefaultDoorUnknownCommandIndex);
	static bool SaveDefaultDoorUnlockedCommand(ESwatCommand DefaultDoorUnlockedCommand, int32 DefaultDoorUnlockedCommandIndex);
	static bool SaveDefaultSurfaceCommand(ESwatCommand DefaultCommand, int32 DefaultCommandIndex);
	static bool SaveEmptyMagReloadSettings(EEmptyMagReloadType EmptyMagReloadType);
	static bool SaveFireModeDisplayOption(int32 FireModeDisplayOption);
	static bool SaveGrenadeSettings(EGrenadeThrowSettingType GrenadeThrowType);
	static bool SaveHighlightWeapons(bool bHighlightWeapons);
	static bool SaveHitmarkerSfxEnabled(bool bHitmarkerSfxEnabled);
	static bool SaveHoldCrouch(bool HoldCrouch);
	static bool SaveHotkeyHintSetting(bool bShowHotkeyHint);
	static bool SaveHUDSettings(bool bShowHUD, bool bCurvedHUD, bool bShowCompass, bool ShowWeaponHUD, bool bShowMagazineHUD, bool bShowChat, bool bSwayHUD, bool b2DReload, float IconScale, float QuickThrowScale, int32 FireModeDisplayOption, bool bShowMultiplayerNames, bool bShowButtonPrompts);
	static bool SaveIconScale(float IconScale);
	static bool SaveItemSelectionStyleSettings(EItemSelectionInterfaceType ItemSelectionInterface);
	static bool SaveKeybinds();
	static void SaveLicenseSave(class ULicenseSave* LevelStats);
	static bool SaveLoadout(const struct FSavedLoadout& Loadout, const class FString& LoadoutName);
	static bool SaveLowReadyStyle(bool bUseHighReady);
	static bool SaveMasterVolume(float Volume);
	static bool SaveMaxShellsInWorld(int32 NewMaxShells);
	static bool SaveMirrorAntiAliasEnabled(bool bShowAntiAlias);
	static bool SaveMirrorDecalsEnabled(bool bShowDecals);
	static bool SaveMirrorDynamicShadowsEnabled(bool bShowDynamicShadows);
	static bool SaveMirrorEnabledOnlyInLobby(bool bEnabled);
	static bool SaveMirrorReflectionEnabled(bool bEnabled);
	static bool SaveMirrorResolutionScale(float ResolutionScale);
	static bool SaveMusicVolume(float Volume);
	static bool SaveOptiwandViewMode(EOptiwandViewMode OptiwandViewMode);
	static bool SavePiPFPS(bool bEnabled, float FPS);
	static bool SavePiPResolutionScale(float ResolutionScale);
	static bool SavePS5AdaptiveAimTriggers(bool PS5AdaptiveAimTriggers);
	static bool SavePS5AdaptiveFireTriggers(bool PS5AdaptiveFireTriggers);
	static bool SaveQuickThrowScale(float QuickThrowScale);
	static bool SaveReplayEnabled(bool bReplayEnabled);
	static bool SaveSafeZoneSettings(float SafeZoneX, float SafeZoneY);
	static bool SaveScoreReadoutSetting(EScoreReadoutMode InScoreReadoutMode);
	static bool SaveSelectedAudioDevice(const class FString& InAudioDevice);
	static bool SaveServersideChecksum(bool bServerSideChecksumEnabled);
	static bool SaveSettings();
	static bool SaveSFXVolume(float Volume);
	static bool SaveShotgunSettings(EShotgunReloadType ShotgunReloadType);
	static bool SaveShowButtonPrompts(bool bShowButtonPrompts);
	static bool SaveShowChat(bool bShowChat);
	static bool SaveShowCommandContextHintSetting(bool bShowCommandContextHint);
	static bool SaveShowCompass(bool bShowCompass);
	static bool SaveShowHealthIconSetting(bool bShowHealthIcons);
	static bool SaveShowHesitationBarSetting(bool bShowHesitationBar);
	static bool SaveShowHUD(bool bShowHUD);
	static bool SaveShowHUDSetting(bool bShowHUD);
	static bool SaveShowMagazineHUD(bool bShowMagazineHUD);
	static bool SaveShowMultiplayerNames(bool bShowMultiplayerNames);
	static bool SaveShowPlayerIconSetting(bool bShowPlayerIcon);
	static bool SaveShowTeamStatus(bool bShowTeamStatus);
	static bool SaveShowWeaponHUD(bool ShowWeaponHUD);
	static bool SaveSubtitlesBackgroundOpacity(float SubtitlesBackgroundOpacity);
	static bool SaveSubtitlesEnabled(bool bEnableSubtitles);
	static bool SaveSubtitlesLocale(const class FString& SubtitlesLocale);
	static bool SaveSubtitlesSize(ESubtitlesSize SubtitlesSize);
	static bool SaveSubtitlesSpeed(float SubtitlesSpeed);
	static bool SaveSwayHUD(bool bSwayHUD);
	static bool SaveTeamViewSetting(bool bEnabled, int32 TeamViewFPS);
	static bool SaveToggleADS(bool ToggleADS);
	static bool SaveTogglePS5Gyro(bool TogglePS5Gyro);
	static bool SaveUIVolume(float Volume);
	static bool SaveVOIPVolume(float Volume);
	static bool SaveWorldSpaceActionPrompts(bool bWorldSpaceActionPrompts);
	static bool SaveZoomADSSetting(bool bZoomADS);
	static bool SetBounceLightEnabled(bool bBounceLightEnabled);
	static bool SetFlashlightShadows(bool bFlashLightShadows);
	static bool SetForceFeedbackEnabled(bool ForceFeedbackEnabled);
	static bool SetForceFeedbackIntensity(float ForceFeedbackIntensity);
	static bool SetFoV(float FOV);
	static bool SetFreelookSensitivity(float Sensitivity);
	static bool SetGamepadAimAssistIntensity(const class FString& AimAssistIntensity);
	static bool SetGamepadAimSensitivityHorizontal(float GamepadAimSensitivityHorizontal);
	static bool SetGamepadAimSensitivityVertical(float GamepadAimSensitivityVertical);
	static bool SetGamepadInvertButtonLayout(bool bInvertButtonLayout);
	static bool SetGamepadInverted(bool bInvertVertical, bool bInvertHorizontal);
	static bool SetGamepadInvertStickLayout(bool bInvertStickLayout);
	static bool SetGamepadInvertTriggersLayout(bool bInvertTriggersLayout);
	static bool SetGamepadLookInnerDeadzone(float GamepadLookInnerDeadzone);
	static bool SetGamepadLookSensitivityHorizontal(float GamepadLookSensitivityHorizontal);
	static bool SetGamepadLookSensitivitySpeedUp(float GamepadLookSensitivitySpeedUp);
	static bool SetGamepadLookSensitivityVertical(float GamepadLookSensitivityVertical);
	static bool SetGamepadMovementInnerDeadzone(float GamepadMovementInnerDeadzone);
	static bool SetGamepadRadialMenuRequireShoulderRelease(bool RequireShoulderButtonRelease);
	static bool SetGamepadRadialMenuUseLeftStick(bool UseLeftStick);
	static bool SetGyroActiveMode(const class FString& GyroActiveMode);
	static bool SetGyroHorizontalAimSensitivity(float GyroHorizontalAimSensitivity);
	static bool SetGyroHorizontalLookSensitivity(float GyroHorizontalLookSensitivity);
	static bool SetGyroInverted(bool bInvertGyroVertical, bool bInvertGyroHorizontal);
	static bool SetGyroVerticalAimSensitivity(float GyroVerticalAimSensitivity);
	static bool SetGyroVerticalLookSensitivity(float GyroVerticalLookSensitivity);
	static bool SetLastConnectedServerIP(const class FString& IP);
	static bool SetMicInputGain(float MicInputGain);
	static bool SetMouseInverted(bool bInvertVertical, bool bInvertHorizontal);
	static bool SetMouseSensitivity(float MouseSensitivity);
	static bool SetPublicLobbyCooldown(int32 Seconds);
	static bool SetSendMapStatistics(bool bSendMapStatistics);
	static bool SetShellLifetime(float ShellLifeTime);
	static bool SetShowControls(bool bShowControls);
	static bool SetShowFPS(bool bShowFPS);
	static bool SetUIScaling(float Scale);
	static bool SetUseMeshpainting(bool bUseMeshPainting);
	static void SetVoiceType(EVoiceType InVoiceType);
	static void SetWeaponFieldOfView(float InFieldOfView);
	static bool ShouldShowVersionOverlay();
	static void ToggleFriendlyNameplates();
	static void ToggleGrenadeDrawDebug();
	static void TryToggleCameraMesh(const class AReadyOrNotCharacter* Character, bool bShow);
	static void UnloadCustomizationLevels(class UWorld* WorldContext);
	static void UpdateInteractableComponentsWorldSpaceActionPrompts(const class UObject* WorldContextObject, bool bEnableWorldSpaceActionPrompts);

	void ShowLoadoutOnMeshes(const struct FSavedLoadout& Loadout, class USkeletalMeshComponent* BodyMesh, class USkeletalMeshComponent* HeadMesh, class USkeletalMeshComponent* ArmorMesh, class USkeletalMeshComponent* ItemMesh, class UStaticMeshComponent* ItemMagMesh);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BpGameplayHelperLib">();
	}
	static class UBpGameplayHelperLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBpGameplayHelperLib>();
	}
};
static_assert(alignof(UBpGameplayHelperLib) == 0x000008, "Wrong alignment on UBpGameplayHelperLib");
static_assert(sizeof(UBpGameplayHelperLib) == 0x000028, "Wrong size on UBpGameplayHelperLib");

// Class ReadyOrNot.NavArea_SwatDelta
// 0x0000 (0x0048 - 0x0048)
class UNavArea_SwatDelta final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_SwatDelta">();
	}
	static class UNavArea_SwatDelta* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_SwatDelta>();
	}
};
static_assert(alignof(UNavArea_SwatDelta) == 0x000008, "Wrong alignment on UNavArea_SwatDelta");
static_assert(sizeof(UNavArea_SwatDelta) == 0x000048, "Wrong size on UNavArea_SwatDelta");

// Class ReadyOrNot.AG_HasSecondaryRangedItem
// 0x0000 (0x0028 - 0x0028)
class UAG_HasSecondaryRangedItem : public UAIActionGate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AG_HasSecondaryRangedItem">();
	}
	static class UAG_HasSecondaryRangedItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAG_HasSecondaryRangedItem>();
	}
};
static_assert(alignof(UAG_HasSecondaryRangedItem) == 0x000008, "Wrong alignment on UAG_HasSecondaryRangedItem");
static_assert(sizeof(UAG_HasSecondaryRangedItem) == 0x000028, "Wrong size on UAG_HasSecondaryRangedItem");

// Class ReadyOrNot.BaseGrenade
// 0x05F0 (0x11A0 - 0x0BB0)
class ABaseGrenade : public ABaseItem
{
public:
	uint8                                         Pad_BB0[0x8];                                      // 0x0BB0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UPointLightComponent*                   DetonationLight;                                   // 0x0BB8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URadialForceComponent*                  DetonationRadialForce;                             // 0x0BC0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODAudioComponent*                    FMODBounceSoundComponent;                          // 0x0BC8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAIPerceptionStimuliSourceComponent*    DetonationStimuliComp;                             // 0x0BD0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GrenadeBounciness;                                 // 0x0BD8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDetonationTriggersStimuli;                        // 0x0BDC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BDD[0x3];                                      // 0x0BDD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DetonationSoundMaxRange;                           // 0x0BE0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DetonationLoudness;                                // 0x0BE4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DetonationTag;                                     // 0x0BE8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ThrownTag;                                         // 0x0BF0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BounceTag;                                         // 0x0BF8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C00[0x8];                                      // 0x0C00(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AThrownGrenade*                         Thrown;                                            // 0x0C08(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUsedFixedThrowTrajectory : 1;                     // 0x0C10(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_C11[0x7];                                      // 0x0C11(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        FirstBouncePath;                                   // 0x0C18(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FHitResult                             FirstBounceHit;                                    // 0x0C28(0x00E8)(IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_D10[0x8];                                      // 0x0D10(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        SecondBouncePath;                                  // 0x0D18(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FHitResult                             SecondBounceHit;                                   // 0x0D28(0x00E8)(IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_E10[0x8];                                      // 0x0E10(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        ThirdBouncePath;                                   // 0x0E18(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FHitResult                             ThirdBounceHit;                                    // 0x0E28(0x00E8)(IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_F10[0x8];                                      // 0x0F10(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector_NetQuantize>            CompletePath;                                      // 0x0F18(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPublic)
	uint8                                         Pad_F28[0x18];                                     // 0x0F28(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BouncePt1;                                         // 0x0F40(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BouncePt2;                                         // 0x0F44(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BouncePt3;                                         // 0x0F48(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F4C[0x4];                                      // 0x0F4C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DeployGrenadeVoiceLine;                            // 0x0F50(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GrenadeSpeed;                                      // 0x0F60(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F64[0x8];                                      // 0x0F64(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BounceSoundMinImpulse;                             // 0x0F6C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USoundBase*>                     BounceSoundEffects;                                // 0x0F70(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class UParticleSystemComponent*               ActivationEffect;                                  // 0x0F80(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        GrenadeBounceEffect;                               // 0x0F88(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             ActivationSound;                                   // 0x0F90(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActivationTime;                                    // 0x0F98(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActivationElapsedTime;                             // 0x0F9C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActivated;                                        // 0x0FA0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayDetonationEffectsExactlyOnce;                 // 0x0FA1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDetonationEffectsPlayed;                          // 0x0FA2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FA3[0x1];                                      // 0x0FA3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeSinceUsed;                                     // 0x0FA4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeSinceDetonate;                                 // 0x0FA8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FAC[0x1];                                      // 0x0FAC(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	EDrawDebugTrace                               DrawDebugType;                                     // 0x0FAD(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bThrowAsQuickThrow;                                // 0x0FAE(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFastThrowOnceEquipped;                            // 0x0FAF(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFastThrowing;                                     // 0x0FB0(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGrenadeReleased;                                  // 0x0FB1(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FB2[0x6];                                      // 0x0FB2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ThrowImpulse;                                      // 0x0FB8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpImpulse;                                         // 0x0FBC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTriggersActionMusic;                              // 0x0FC0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanThrowGrenade;                                  // 0x0FC1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC2[0x2];                                      // 0x0FC2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DetonationTime;                                    // 0x0FC4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncreaseDamageRadiusOverTime;                     // 0x0FC8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC9[0x7];                                      // 0x0FC9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UnderarmForceScale;                                // 0x0FD0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Drag;                                              // 0x0FD4(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DragAppliedPerBounce;                              // 0x0FD8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DetonationFlashIntensitiy;                         // 0x0FDC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DetonationFlashInterp;                             // 0x0FE0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReDetonationTime;                                  // 0x0FE4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTriggerSFXOnRedetonate;                           // 0x0FE8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FE9[0x3];                                      // 0x0FE9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ThrowDistance;                                     // 0x0FEC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RedotonateCount;                                   // 0x0FF0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bNoMoraleDamage : 1;                               // 0x0FF4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_FF5[0x3];                                      // 0x0FF5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ListenerTriggerDistance;                           // 0x0FF8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FFC[0xC];                                      // 0x0FFC(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                MaxRandomizedForceOnDetonation;                    // 0x1008(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FixedForceOnDetonation;                            // 0x1020(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UParticleSystem*>                DetonationParticles;                               // 0x1038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UParticleSystemComponent*>       SpawnedParticles;                                  // 0x1048(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FRotator                               ParticleSpawnRotation;                             // 0x1058(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UFMODEvent*                             DetonationFMODEvent;                               // 0x1070(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              DetonationEvent;                                   // 0x1078(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideGrenadeOnDetonate;                            // 0x1080(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGrenadeType                                  Type;                                              // 0x1081(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1082[0x6];                                     // 0x1082(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class ABaseGrenade* Grenade)> OnGrenadeDetonated;                  // 0x1088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ABaseGrenade* ThrownGrenade)> OnGrenadeThrown;               // 0x1098(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         RedrawDelayAfterThrow;                             // 0x10A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsed;                                             // 0x10AC(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10AD[0x3];                                     // 0x10AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class AReadyOrNotCharacter*                   ThrownBy;                                          // 0x10B0(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10B8[0x10];                                    // 0x10B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGrenadeDamage>                 DetonationDamage;                                  // 0x10C8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bUseScreenShake;                                   // 0x10D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10D9[0x7];                                     // 0x10D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ULegacyCameraShake>         ExplosionScreenShake;                              // 0x10E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraShakeRadius;                                 // 0x10E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseDetonationDecal;                               // 0x10EC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10ED[0x3];                                     // 0x10ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DetonationDecalTraceDistance;                      // 0x10F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10F4[0x4];                                     // 0x10F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     DetonationDecal;                                   // 0x10F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DetonationDecalSize;                               // 0x1100(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           HideBonesOnUsed;                                   // 0x1118(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         BounceActivationRadius;                            // 0x1128(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_112C[0x4];                                     // 0x112C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             FMODGrenadeBounce;                                 // 0x1130(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1138[0x8];                                     // 0x1138(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GrenadeOcclusionMultiplier;                        // 0x1140(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GrenadeFullOcclusionDepth;                         // 0x1144(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UForceFeedbackEffect*                   ForceFeedbackEffect;                               // 0x1148(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UForceFeedbackAttenuation*              ForceFeedbackAttenuation;                          // 0x1150(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistanceDifference;                             // 0x1158(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InterpStrength;                                    // 0x115C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ClientReplicationFrequency;                        // 0x1160(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1164[0x3C];                                    // 0x1164(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Detonate();
	void DoThrowFast();
	bool IsOutside();
	void Multicast_AddImpulse(const struct FVector& Impulse, const struct FVector& FromLocation);
	void Multicast_DetonationEffects(const struct FVector& CalculatedForce);
	void Multicast_GrenadeThrow(bool bOverarmThrow, const struct FVector& ThrowDirection, const struct FVector& ThrowStart);
	void Multicast_OnDeadDropped();
	void OnGrenadeBounceSoundStopped();
	void OnRep_GrenadePath();
	void OnRep_GrenadeUsed();
	void Server_SetThrowOverarm(bool bThrowOverarm, bool bQuickThrow);
	void Server_StartFastThrow();
	void Server_ThrowGrenade(bool bOverarmThrow, const struct FVector& ThrowDirection, const struct FVector& ThrowStart);
	void Server_UpdateThrowPosition(const struct FVector& Position, const struct FRotator& Rotation, const struct FVector& Velocity);
	void SetFullyPrimed();
	void Throw(bool bLocalOnly, bool bOverarmThrow, const struct FVector& ThrowDirection, const struct FVector& ThrowStart);
	void UpdateServerPath(const TArray<struct FVector_NetQuantize>& Path, int32 Bounce1, int32 Bounce2, int32 Bounce3);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseGrenade">();
	}
	static class ABaseGrenade* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseGrenade>();
	}
};
static_assert(alignof(ABaseGrenade) == 0x000010, "Wrong alignment on ABaseGrenade");
static_assert(sizeof(ABaseGrenade) == 0x0011A0, "Wrong size on ABaseGrenade");
static_assert(offsetof(ABaseGrenade, DetonationLight) == 0x000BB8, "Member 'ABaseGrenade::DetonationLight' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, DetonationRadialForce) == 0x000BC0, "Member 'ABaseGrenade::DetonationRadialForce' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, FMODBounceSoundComponent) == 0x000BC8, "Member 'ABaseGrenade::FMODBounceSoundComponent' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, DetonationStimuliComp) == 0x000BD0, "Member 'ABaseGrenade::DetonationStimuliComp' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, GrenadeBounciness) == 0x000BD8, "Member 'ABaseGrenade::GrenadeBounciness' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, bDetonationTriggersStimuli) == 0x000BDC, "Member 'ABaseGrenade::bDetonationTriggersStimuli' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, DetonationSoundMaxRange) == 0x000BE0, "Member 'ABaseGrenade::DetonationSoundMaxRange' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, DetonationLoudness) == 0x000BE4, "Member 'ABaseGrenade::DetonationLoudness' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, DetonationTag) == 0x000BE8, "Member 'ABaseGrenade::DetonationTag' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, ThrownTag) == 0x000BF0, "Member 'ABaseGrenade::ThrownTag' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, BounceTag) == 0x000BF8, "Member 'ABaseGrenade::BounceTag' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, Thrown) == 0x000C08, "Member 'ABaseGrenade::Thrown' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, FirstBouncePath) == 0x000C18, "Member 'ABaseGrenade::FirstBouncePath' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, FirstBounceHit) == 0x000C28, "Member 'ABaseGrenade::FirstBounceHit' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, SecondBouncePath) == 0x000D18, "Member 'ABaseGrenade::SecondBouncePath' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, SecondBounceHit) == 0x000D28, "Member 'ABaseGrenade::SecondBounceHit' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, ThirdBouncePath) == 0x000E18, "Member 'ABaseGrenade::ThirdBouncePath' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, ThirdBounceHit) == 0x000E28, "Member 'ABaseGrenade::ThirdBounceHit' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, CompletePath) == 0x000F18, "Member 'ABaseGrenade::CompletePath' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, BouncePt1) == 0x000F40, "Member 'ABaseGrenade::BouncePt1' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, BouncePt2) == 0x000F44, "Member 'ABaseGrenade::BouncePt2' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, BouncePt3) == 0x000F48, "Member 'ABaseGrenade::BouncePt3' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, DeployGrenadeVoiceLine) == 0x000F50, "Member 'ABaseGrenade::DeployGrenadeVoiceLine' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, GrenadeSpeed) == 0x000F60, "Member 'ABaseGrenade::GrenadeSpeed' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, BounceSoundMinImpulse) == 0x000F6C, "Member 'ABaseGrenade::BounceSoundMinImpulse' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, BounceSoundEffects) == 0x000F70, "Member 'ABaseGrenade::BounceSoundEffects' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, ActivationEffect) == 0x000F80, "Member 'ABaseGrenade::ActivationEffect' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, GrenadeBounceEffect) == 0x000F88, "Member 'ABaseGrenade::GrenadeBounceEffect' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, ActivationSound) == 0x000F90, "Member 'ABaseGrenade::ActivationSound' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, ActivationTime) == 0x000F98, "Member 'ABaseGrenade::ActivationTime' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, ActivationElapsedTime) == 0x000F9C, "Member 'ABaseGrenade::ActivationElapsedTime' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, bActivated) == 0x000FA0, "Member 'ABaseGrenade::bActivated' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, bPlayDetonationEffectsExactlyOnce) == 0x000FA1, "Member 'ABaseGrenade::bPlayDetonationEffectsExactlyOnce' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, bDetonationEffectsPlayed) == 0x000FA2, "Member 'ABaseGrenade::bDetonationEffectsPlayed' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, TimeSinceUsed) == 0x000FA4, "Member 'ABaseGrenade::TimeSinceUsed' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, TimeSinceDetonate) == 0x000FA8, "Member 'ABaseGrenade::TimeSinceDetonate' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, DrawDebugType) == 0x000FAD, "Member 'ABaseGrenade::DrawDebugType' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, bThrowAsQuickThrow) == 0x000FAE, "Member 'ABaseGrenade::bThrowAsQuickThrow' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, bFastThrowOnceEquipped) == 0x000FAF, "Member 'ABaseGrenade::bFastThrowOnceEquipped' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, bFastThrowing) == 0x000FB0, "Member 'ABaseGrenade::bFastThrowing' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, bGrenadeReleased) == 0x000FB1, "Member 'ABaseGrenade::bGrenadeReleased' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, ThrowImpulse) == 0x000FB8, "Member 'ABaseGrenade::ThrowImpulse' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, UpImpulse) == 0x000FBC, "Member 'ABaseGrenade::UpImpulse' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, bTriggersActionMusic) == 0x000FC0, "Member 'ABaseGrenade::bTriggersActionMusic' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, bCanThrowGrenade) == 0x000FC1, "Member 'ABaseGrenade::bCanThrowGrenade' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, DetonationTime) == 0x000FC4, "Member 'ABaseGrenade::DetonationTime' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, bIncreaseDamageRadiusOverTime) == 0x000FC8, "Member 'ABaseGrenade::bIncreaseDamageRadiusOverTime' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, UnderarmForceScale) == 0x000FD0, "Member 'ABaseGrenade::UnderarmForceScale' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, Drag) == 0x000FD4, "Member 'ABaseGrenade::Drag' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, DragAppliedPerBounce) == 0x000FD8, "Member 'ABaseGrenade::DragAppliedPerBounce' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, DetonationFlashIntensitiy) == 0x000FDC, "Member 'ABaseGrenade::DetonationFlashIntensitiy' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, DetonationFlashInterp) == 0x000FE0, "Member 'ABaseGrenade::DetonationFlashInterp' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, ReDetonationTime) == 0x000FE4, "Member 'ABaseGrenade::ReDetonationTime' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, bTriggerSFXOnRedetonate) == 0x000FE8, "Member 'ABaseGrenade::bTriggerSFXOnRedetonate' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, ThrowDistance) == 0x000FEC, "Member 'ABaseGrenade::ThrowDistance' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, RedotonateCount) == 0x000FF0, "Member 'ABaseGrenade::RedotonateCount' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, ListenerTriggerDistance) == 0x000FF8, "Member 'ABaseGrenade::ListenerTriggerDistance' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, MaxRandomizedForceOnDetonation) == 0x001008, "Member 'ABaseGrenade::MaxRandomizedForceOnDetonation' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, FixedForceOnDetonation) == 0x001020, "Member 'ABaseGrenade::FixedForceOnDetonation' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, DetonationParticles) == 0x001038, "Member 'ABaseGrenade::DetonationParticles' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, SpawnedParticles) == 0x001048, "Member 'ABaseGrenade::SpawnedParticles' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, ParticleSpawnRotation) == 0x001058, "Member 'ABaseGrenade::ParticleSpawnRotation' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, DetonationFMODEvent) == 0x001070, "Member 'ABaseGrenade::DetonationFMODEvent' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, DetonationEvent) == 0x001078, "Member 'ABaseGrenade::DetonationEvent' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, bHideGrenadeOnDetonate) == 0x001080, "Member 'ABaseGrenade::bHideGrenadeOnDetonate' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, Type) == 0x001081, "Member 'ABaseGrenade::Type' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, OnGrenadeDetonated) == 0x001088, "Member 'ABaseGrenade::OnGrenadeDetonated' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, OnGrenadeThrown) == 0x001098, "Member 'ABaseGrenade::OnGrenadeThrown' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, RedrawDelayAfterThrow) == 0x0010A8, "Member 'ABaseGrenade::RedrawDelayAfterThrow' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, bUsed) == 0x0010AC, "Member 'ABaseGrenade::bUsed' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, ThrownBy) == 0x0010B0, "Member 'ABaseGrenade::ThrownBy' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, DetonationDamage) == 0x0010C8, "Member 'ABaseGrenade::DetonationDamage' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, bUseScreenShake) == 0x0010D8, "Member 'ABaseGrenade::bUseScreenShake' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, ExplosionScreenShake) == 0x0010E0, "Member 'ABaseGrenade::ExplosionScreenShake' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, CameraShakeRadius) == 0x0010E8, "Member 'ABaseGrenade::CameraShakeRadius' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, bUseDetonationDecal) == 0x0010EC, "Member 'ABaseGrenade::bUseDetonationDecal' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, DetonationDecalTraceDistance) == 0x0010F0, "Member 'ABaseGrenade::DetonationDecalTraceDistance' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, DetonationDecal) == 0x0010F8, "Member 'ABaseGrenade::DetonationDecal' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, DetonationDecalSize) == 0x001100, "Member 'ABaseGrenade::DetonationDecalSize' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, HideBonesOnUsed) == 0x001118, "Member 'ABaseGrenade::HideBonesOnUsed' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, BounceActivationRadius) == 0x001128, "Member 'ABaseGrenade::BounceActivationRadius' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, FMODGrenadeBounce) == 0x001130, "Member 'ABaseGrenade::FMODGrenadeBounce' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, GrenadeOcclusionMultiplier) == 0x001140, "Member 'ABaseGrenade::GrenadeOcclusionMultiplier' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, GrenadeFullOcclusionDepth) == 0x001144, "Member 'ABaseGrenade::GrenadeFullOcclusionDepth' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, ForceFeedbackEffect) == 0x001148, "Member 'ABaseGrenade::ForceFeedbackEffect' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, ForceFeedbackAttenuation) == 0x001150, "Member 'ABaseGrenade::ForceFeedbackAttenuation' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, MaxDistanceDifference) == 0x001158, "Member 'ABaseGrenade::MaxDistanceDifference' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, InterpStrength) == 0x00115C, "Member 'ABaseGrenade::InterpStrength' has a wrong offset!");
static_assert(offsetof(ABaseGrenade, ClientReplicationFrequency) == 0x001160, "Member 'ABaseGrenade::ClientReplicationFrequency' has a wrong offset!");

// Class ReadyOrNot.AG_HasAnotherGunWithAmmo
// 0x0000 (0x0028 - 0x0028)
class UAG_HasAnotherGunWithAmmo final : public UAIActionGate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AG_HasAnotherGunWithAmmo">();
	}
	static class UAG_HasAnotherGunWithAmmo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAG_HasAnotherGunWithAmmo>();
	}
};
static_assert(alignof(UAG_HasAnotherGunWithAmmo) == 0x000008, "Wrong alignment on UAG_HasAnotherGunWithAmmo");
static_assert(sizeof(UAG_HasAnotherGunWithAmmo) == 0x000028, "Wrong size on UAG_HasAnotherGunWithAmmo");

// Class ReadyOrNot.NavArea_HasBeenOpenedDoor
// 0x0000 (0x0048 - 0x0048)
class UNavArea_HasBeenOpenedDoor final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_HasBeenOpenedDoor">();
	}
	static class UNavArea_HasBeenOpenedDoor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_HasBeenOpenedDoor>();
	}
};
static_assert(alignof(UNavArea_HasBeenOpenedDoor) == 0x000008, "Wrong alignment on UNavArea_HasBeenOpenedDoor");
static_assert(sizeof(UNavArea_HasBeenOpenedDoor) == 0x000048, "Wrong size on UNavArea_HasBeenOpenedDoor");

// Class ReadyOrNot.AG_HasMeleeSecondaryItem
// 0x0000 (0x0028 - 0x0028)
class UAG_HasMeleeSecondaryItem final : public UAIActionGate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AG_HasMeleeSecondaryItem">();
	}
	static class UAG_HasMeleeSecondaryItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAG_HasMeleeSecondaryItem>();
	}
};
static_assert(alignof(UAG_HasMeleeSecondaryItem) == 0x000008, "Wrong alignment on UAG_HasMeleeSecondaryItem");
static_assert(sizeof(UAG_HasMeleeSecondaryItem) == 0x000028, "Wrong size on UAG_HasMeleeSecondaryItem");

// Class ReadyOrNot.AG_HasValidPickupWeapon
// 0x0008 (0x0030 - 0x0028)
class UAG_HasValidPickupWeapon final : public UAIActionGate
{
public:
	float                                         SearchRadius;                                      // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AG_HasValidPickupWeapon">();
	}
	static class UAG_HasValidPickupWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAG_HasValidPickupWeapon>();
	}
};
static_assert(alignof(UAG_HasValidPickupWeapon) == 0x000008, "Wrong alignment on UAG_HasValidPickupWeapon");
static_assert(sizeof(UAG_HasValidPickupWeapon) == 0x000030, "Wrong size on UAG_HasValidPickupWeapon");
static_assert(offsetof(UAG_HasValidPickupWeapon, SearchRadius) == 0x000028, "Member 'UAG_HasValidPickupWeapon::SearchRadius' has a wrong offset!");

// Class ReadyOrNot.CaptureTheFlagGM
// 0x0040 (0x0A10 - 0x09D0)
class ACaptureTheFlagGM final : public AReadyOrNotGameMode_PVP
{
public:
	TMulticastInlineDelegate<void(class APlayerCharacter* CapturedByCharacter, ETeamType CpaturedByTeam)> OnFlagCaptured; // 0x09D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class APlayerCharacter* DroppedByCharacter, ETeamType DroppedByTeam)> OnFlagDropped; // 0x09E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSubclassOf<class ACTF_Flag>                  FlagClassToSpawn;                                  // 0x09F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACTF_Flag*                              Flag;                                              // 0x09F8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A00[0x10];                                     // 0x0A00(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CaptureFlag(class ACTF_Flag* CapturedFlag, class APlayerCharacter* NewFlagBearer);
	class ACTF_FlagSpawnPoint* ChooseFlagSpawnPoint();
	void DropFlag();
	void OnFlagBearerKilled(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CaptureTheFlagGM">();
	}
	static class ACaptureTheFlagGM* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACaptureTheFlagGM>();
	}
};
static_assert(alignof(ACaptureTheFlagGM) == 0x000010, "Wrong alignment on ACaptureTheFlagGM");
static_assert(sizeof(ACaptureTheFlagGM) == 0x000A10, "Wrong size on ACaptureTheFlagGM");
static_assert(offsetof(ACaptureTheFlagGM, OnFlagCaptured) == 0x0009D0, "Member 'ACaptureTheFlagGM::OnFlagCaptured' has a wrong offset!");
static_assert(offsetof(ACaptureTheFlagGM, OnFlagDropped) == 0x0009E0, "Member 'ACaptureTheFlagGM::OnFlagDropped' has a wrong offset!");
static_assert(offsetof(ACaptureTheFlagGM, FlagClassToSpawn) == 0x0009F0, "Member 'ACaptureTheFlagGM::FlagClassToSpawn' has a wrong offset!");
static_assert(offsetof(ACaptureTheFlagGM, Flag) == 0x0009F8, "Member 'ACaptureTheFlagGM::Flag' has a wrong offset!");

// Class ReadyOrNot.ReadyOrNotInputModifierDeadZone
// 0x0010 (0x0038 - 0x0028)
class UReadyOrNotInputModifierDeadZone final : public UInputModifier
{
public:
	EDeadZoneType                                 Type;                                              // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UpperThreshold;                                    // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDeadzoneStick                                DeadzoneStick;                                     // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotInputModifierDeadZone">();
	}
	static class UReadyOrNotInputModifierDeadZone* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotInputModifierDeadZone>();
	}
};
static_assert(alignof(UReadyOrNotInputModifierDeadZone) == 0x000008, "Wrong alignment on UReadyOrNotInputModifierDeadZone");
static_assert(sizeof(UReadyOrNotInputModifierDeadZone) == 0x000038, "Wrong size on UReadyOrNotInputModifierDeadZone");
static_assert(offsetof(UReadyOrNotInputModifierDeadZone, Type) == 0x000028, "Member 'UReadyOrNotInputModifierDeadZone::Type' has a wrong offset!");
static_assert(offsetof(UReadyOrNotInputModifierDeadZone, UpperThreshold) == 0x00002C, "Member 'UReadyOrNotInputModifierDeadZone::UpperThreshold' has a wrong offset!");
static_assert(offsetof(UReadyOrNotInputModifierDeadZone, DeadzoneStick) == 0x000030, "Member 'UReadyOrNotInputModifierDeadZone::DeadzoneStick' has a wrong offset!");

// Class ReadyOrNot.AG_HasValidAmmoCache
// 0x0008 (0x0030 - 0x0028)
class UAG_HasValidAmmoCache final : public UAIActionGate
{
public:
	float                                         SearchRadius;                                      // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AG_HasValidAmmoCache">();
	}
	static class UAG_HasValidAmmoCache* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAG_HasValidAmmoCache>();
	}
};
static_assert(alignof(UAG_HasValidAmmoCache) == 0x000008, "Wrong alignment on UAG_HasValidAmmoCache");
static_assert(sizeof(UAG_HasValidAmmoCache) == 0x000030, "Wrong size on UAG_HasValidAmmoCache");
static_assert(offsetof(UAG_HasValidAmmoCache, SearchRadius) == 0x000028, "Member 'UAG_HasValidAmmoCache::SearchRadius' has a wrong offset!");

// Class ReadyOrNot.ReadyOrNotGameState
// 0x0608 (0x08F8 - 0x02F0)
class AReadyOrNotGameState : public AGameStateBase
{
public:
	uint8                                         Pad_2F0[0x34];                                     // 0x02F0(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RandomStreamSeed;                                  // 0x0324(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_328[0x10];                                     // 0x0328(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         NumSuspectsActive;                                 // 0x0338(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         NumCiviliansActive;                                // 0x0339(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         NumSwatActive;                                     // 0x033A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33B[0x5];                                      // 0x033B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UReadyOrNotVoiceConfig*                 VoiceConfig;                                       // 0x0340(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_348[0x8];                                      // 0x0348(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ULoadout_V2*                            Loadout_V2;                                        // 0x0350(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReadyOrNotLoadoutManager*              LoadoutFunctionLibrary;                            // 0x0358(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerState*                           NextHost;                                          // 0x0360(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MigrationGUID;                                     // 0x0368(0x0010)(Net, ZeroConstructor, RepNotify, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_378[0x4];                                      // 0x0378(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bHasHostFinishedLoading;                           // 0x037C(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_37D[0x3];                                      // 0x037D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ABaseItem*>                      AllItems;                                          // 0x0380(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class AEvidenceActor*>                 AllEvidenceActors;                                 // 0x0390(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class AReportableActor*>               AllReportableActors;                               // 0x03A0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class ATrapActorAttachedToDoor*>       AllDoorTrapActors;                                 // 0x03B0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class ACoverLandmark*>                 AllCoverLandmarks;                                 // 0x03C0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class AWallHoleTraversal*>             AllWallHoles;                                      // 0x03D0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class APairedInteractionDriver*>       AllPairedInteractionActors;                        // 0x03E0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UDataTable*>                     LoadedDataTables;                                  // 0x03F0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class AScoringManager*                        ScoringManager;                                    // 0x0400(0x0008)(Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, class AAIFactionManager*> AIFactionManagers;                                 // 0x0408(0x0050)(UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<class FName, class ASquadManager*>       SquadManagerMap;                                   // 0x0458(0x0050)(UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class AWorldAction*>                   WorldActions;                                      // 0x04A8(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    Rep_GameModeSettings;                              // 0x04B8(0x0010)(Net, NoDestructor, NativeAccessSpecifierPublic)
	float                                         TimeTillGameStartCountdown;                        // 0x04C8(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4CC[0xC];                                      // 0x04CC(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ABadAIAction*>                   BadAIActionActors;                                 // 0x04D8(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bHasLeftLoadOut;                                   // 0x04E8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E9[0x7];                                      // 0x04E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ULevelStreaming*                        PreMissionStreamedLevel;                           // 0x04F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UWorld>                  SubPreMissionPlanningLevel;                        // 0x04F8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_520[0x8];                                      // 0x0520(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ModeName;                                          // 0x0528(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   ModeRules;                                         // 0x0540(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<class AObjective*>                     MissionObjectives;                                 // 0x0558(0x0010)(BlueprintVisible, Net, ZeroConstructor, RepNotify, UObjectWrapper, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnMissionObjectivesUpdated;                        // 0x0568(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UObituaryData*                          ObituaryData;                                      // 0x0578(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnnounceReinforcements;                           // 0x0580(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRadioGlareEnabled;                                // 0x0581(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_582[0x6];                                      // 0x0582(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             ReplenishAllAmmoSound;                             // 0x0588(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ASpectatePawn*>                  SpectatePawns;                                     // 0x0590(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class AReadyOrNotCharacter*>           RedTeamPlayers;                                    // 0x05A0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class AReadyOrNotCharacter*>           BlueTeamPlayers;                                   // 0x05B0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class AThrownItem*>                    AllThrownItems;                                    // 0x05C0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class ADoor*>                          AllDoors;                                          // 0x05D0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class AReadyOrNotCharacter*>           AllReadyOrNotCharacters;                           // 0x05E0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class APlayerCharacter*>               AllPlayerCharacters;                               // 0x05F0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class ACyberneticCharacter*>           AllAICharacters;                                   // 0x0600(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UInteractableComponent*>         AllInteractableComponents;                         // 0x0610(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	class UFMODAudioComponent*                    AnnouncerAudioComponent;                           // 0x0620(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UExperienceManager*                     ExperienceManagerComponent;                        // 0x0628(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalMissionAbuseCount;                            // 0x0630(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_634[0x4];                                      // 0x0634(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TScriptInterface<class IListenForDeath>> DeathListeners;                                  // 0x0638(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TScriptInterface<class IListenForGameStart>> GameStartListeners;                          // 0x0648(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TScriptInterface<class IListenForGameEnd>> GameEndListeners;                              // 0x0658(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bDisableEquipment;                                 // 0x0668(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableCommandChat;                                // 0x0669(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseReinforcements;                                // 0x066A(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_66B[0x1];                                      // 0x066B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Reinforcements_TimeRemaining;                      // 0x066C(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRunWarmup;                                        // 0x0670(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_671[0x7];                                      // 0x0671(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     SceneCapturePlayerCameraClass;                     // 0x0678(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowEnemiesAsSuspects;                            // 0x0680(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_681[0x7];                                      // 0x0681(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FKillFeedData>                  KillFeedData;                                      // 0x0688(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AActor* Causer, class ACharacter* InstigatorCharacter, class ACharacter* KilledCharacter)> OnUpdateKillFeed; // 0x0698(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         ServerTimeUntilNextMap;                            // 0x06A8(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6AC[0x4];                                      // 0x06AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 GameRulesIntroAnnouncerRowName;                    // 0x06B0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWaitingForPlayers;                                // 0x06C0(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C1[0x3];                                      // 0x06C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlanningTimeLeft;                                  // 0x06C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RedTeamWins;                                       // 0x06C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BlueTeamWins;                                      // 0x06CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6D0[0x8];                                      // 0x06D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnWinsUpdated;                                     // 0x06D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         EndPlayTimer;                                      // 0x06E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RoundTimeRemaining;                                // 0x06EC(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseTimelimit;                                     // 0x06F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6F1[0x3];                                      // 0x06F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Scorelimit;                                        // 0x06F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeSinceMatchStarted;                             // 0x06F8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6FC[0x4];                                      // 0x06FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AReferendum*                            CurrentReferendum;                                 // 0x0700(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class AReferendum>>        AllowedReferendumTypes;                            // 0x0708(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bCanShowScoreboard;                                // 0x0718(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsePlanningUICamera;                              // 0x0719(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71A[0x2];                                      // 0x071A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RoundTimeElapsed;                                  // 0x071C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RoundsPlayed;                                      // 0x0720(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RoundsToPlay;                                      // 0x0724(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETeamType                                     RoundWinningTeam;                                  // 0x0728(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETeamType                                     MatchWinningTeam;                                  // 0x0729(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_72A[0x6];                                      // 0x072A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AReadyOrNotPlayerState*>         RoundWinners;                                      // 0x0730(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FRChatMessage& Message)> OnChatMessageReceived;       // 0x0740(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FString                                 MissionName;                                       // 0x0750(0x0010)(Edit, BlueprintVisible, Net, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   MissionDescription;                                // 0x0760(0x0018)(Edit, BlueprintVisible, Net, NativeAccessSpecifierPublic)
	EMatchState                                   MatchState;                                        // 0x0778(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_779[0x7];                                      // 0x0779(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AReadyOrNotCharacter* Character, class AReadyOrNotCharacter* ArrestedBy)> OnCharacterArrested; // 0x0780(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AReadyOrNotCharacter* Character, class AReadyOrNotCharacter* KilledBy)> OnCharacterKilled; // 0x0790(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FString                                 NextURLReplicated;                                 // 0x07A0(0x0010)(Net, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ULevelSequence* LevelSequence)> OnSequenceStarted;           // 0x07B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class FName>                           WhitelistedLabels;                                 // 0x07C0(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPublic)
	TSubclassOf<class UDebugDisplayWidget>        DebugDisplayWidget;                                // 0x07D0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ModeURL_Replicated;                                // 0x07D8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FFloorMapPointData>             DrawingPointData;                                  // 0x07E8(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPublic)
	bool                                          bPvPMode;                                          // 0x07F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanReportToTOC;                                   // 0x07F9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7FA[0x2];                                      // 0x07FA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GametypeDamageModifier;                            // 0x07FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeadDamageModifier;                                // 0x0800(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootDamageModifier;                                // 0x0804(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LegDamageModifier;                                 // 0x0808(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArmDamageModifier;                                 // 0x080C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OtherLimbDamageModifier;                           // 0x0810(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFreeForAll;                                       // 0x0814(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisablePickups;                                   // 0x0815(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bRevivesAllowed : 1;                               // 0x0816(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_817[0x1];                                      // 0x0817(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRChatMessage>                  SavedChatMessages;                                 // 0x0818(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bBallisticsDebug;                                  // 0x0828(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDamageDebug;                                      // 0x0829(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpeechRecognitionDebug;                           // 0x082A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGOAPDebug;                                        // 0x082B(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnnounceTeamReinforcements;                       // 0x082C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_82D[0x3];                                      // 0x082D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Msg_BothTeamsReinforced;                           // 0x0830(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Msg_RedTeamReinforced;                             // 0x0848(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Msg_BlueTeamReinforced;                            // 0x0860(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UChallenge>>         GameModeChallenges;                                // 0x0878(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         bInPlanningMenu : 1;                               // 0x0888(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_889[0x3];                                      // 0x0889(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CustomTimeDilationApplied;                         // 0x088C(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class APlayerController*>              AdminPlayerControllers;                            // 0x0890(0x0010)(Net, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class ATOCManager*                            TOCManager;                                        // 0x08A0(0x0008)(Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CombatMusic;                                       // 0x08A8(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideLevelEffectsInPreMission;                     // 0x08AC(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8AD[0x3];                                      // 0x08AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ADirectionalLight*>              WorldDirectionalLights;                            // 0x08B0(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class APostProcessVolume*>             WorldPostProcessVolumes;                           // 0x08C0(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class AExponentialHeightFog*>          WorldExponentialHeightFogs;                        // 0x08D0(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class AExponentialHeightFog*>          PreMissionExponentialHeightFogs;                   // 0x08E0(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8F0[0x8];                                      // 0x08F0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddDeathListener(TScriptInterface<class IListenForDeath> DeathListener);
	void AddGameEndListener(TScriptInterface<class IListenForGameEnd> GameEndListener);
	void AddGameStartListener(TScriptInterface<class IListenForGameStart> GameStartListener);
	void Client_BindCharacterEvents(class APlayerCharacter* Character);
	class UReadyOrNotProfile* GetCurrentProfile();
	int32 GetCurrentSuspectScore();
	int32 GetCurrentSwatScore();
	TArray<struct FDeploymentStatus> GetDeploymentStatusOfPlayers();
	struct FGameModeSettings GetGameModeSettings();
	class FString GetMapURL();
	int32 GetMaxSuspectScore();
	int32 GetMaxSwatScore();
	void GetNextMapMode(class FString* Map, class FString* Mode);
	TArray<class AReadyOrNotPlayerState*> GetPlayerStatesOfTeam(ETeamType Team);
	void GetPlayerStatesOnTeamOrderedByScore(ETeamType Team, TArray<class AReadyOrNotPlayerState*>* PlayerStates);
	int32 GetRemainingRounds();
	float GetTeamScore(ETeamType Team);
	float GetWinningScore(bool* bUsesScoring);
	bool IsAdminPlayerController(class APlayerController* PlayerController);
	bool IsEveryoneReady();
	void LoadStartupWidgetsAfterLoadingScreen();
	void Multicast_BroadcastChatMessage(const struct FRChatMessage& ChatMessage);
	void Multicast_OnCharacterDied(class AReadyOrNotCharacter* Victim, class AReadyOrNotCharacter* Killer, class AActor* Inflictor);
	void Multicast_OnGameEnded();
	void Multicast_OnGameStarted();
	void Multicast_OnRoundReset();
	void Multicast_PlayAnnouncerForTeam(const class FString& SpeechRowName, ETeamType TeamType);
	void Multicast_PlaySequence(class ULevelSequence* Sequence);
	void Multicast_StopSequence(class ULevelSequence* Sequence);
	void OnAlphaAccessChecked(bool bBanned, const class FString& BanReason);
	void OnAuthenticationResponse(bool bSuccess, bool bSerialFound, bool bSerialValid, const class FString& failedReason);
	void OnLoadoutFinished();
	void OnRep_CustomTimeDilation();
	void OnRep_DrawPointDataChanged();
	void OnRep_MatchState();
	void OnRep_MissionObjectives();
	void OnRep_NextHost();
	void OnRep_StreamSeed();
	void OnRep_WinsUpdated();
	void OnSequenceStartedFunc(class ULevelSequence* LevelSequence);
	void OverWriteModeNameText(const class FText& newModeName);
	void PlayerArrested(class AReadyOrNotCharacter* ArrestedCharacter, class AReadyOrNotCharacter* InstigatorCharacter);
	void PlayerKilled(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter);
	void RemoveDeathListener(TScriptInterface<class IListenForDeath> DeathListener);
	void RemoveGameEndListener(TScriptInterface<class IListenForGameEnd> GameEndListener);
	void RemoveGameStartListener(TScriptInterface<class IListenForGameStart> GameStartListener);
	void ResetReplicatedTimers();
	void SetGlobalSuspendVoiceOver(bool bEnable);
	void SetTimeDilationSynced(float TimeDilation);
	void SkipMVPScreen();
	void UpdateDoorTickIntervals();

	TArray<class AReadyOrNotPlayerController*> GetControllersAvailableForVote() const;
	class FText GetModeText() const;
	class ABadAIAction* GetMostRecentBadAIActionReport() const;
	TArray<class AReadyOrNotPlayerState*> GetPlayersAvailableForVote() const;
	int32 GetTotalMissionAbuseCount() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotGameState">();
	}
	static class AReadyOrNotGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AReadyOrNotGameState>();
	}
};
static_assert(alignof(AReadyOrNotGameState) == 0x000008, "Wrong alignment on AReadyOrNotGameState");
static_assert(sizeof(AReadyOrNotGameState) == 0x0008F8, "Wrong size on AReadyOrNotGameState");
static_assert(offsetof(AReadyOrNotGameState, RandomStreamSeed) == 0x000324, "Member 'AReadyOrNotGameState::RandomStreamSeed' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, NumSuspectsActive) == 0x000338, "Member 'AReadyOrNotGameState::NumSuspectsActive' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, NumCiviliansActive) == 0x000339, "Member 'AReadyOrNotGameState::NumCiviliansActive' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, NumSwatActive) == 0x00033A, "Member 'AReadyOrNotGameState::NumSwatActive' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, VoiceConfig) == 0x000340, "Member 'AReadyOrNotGameState::VoiceConfig' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, Loadout_V2) == 0x000350, "Member 'AReadyOrNotGameState::Loadout_V2' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, LoadoutFunctionLibrary) == 0x000358, "Member 'AReadyOrNotGameState::LoadoutFunctionLibrary' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, NextHost) == 0x000360, "Member 'AReadyOrNotGameState::NextHost' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, MigrationGUID) == 0x000368, "Member 'AReadyOrNotGameState::MigrationGUID' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, bHasHostFinishedLoading) == 0x00037C, "Member 'AReadyOrNotGameState::bHasHostFinishedLoading' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, AllItems) == 0x000380, "Member 'AReadyOrNotGameState::AllItems' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, AllEvidenceActors) == 0x000390, "Member 'AReadyOrNotGameState::AllEvidenceActors' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, AllReportableActors) == 0x0003A0, "Member 'AReadyOrNotGameState::AllReportableActors' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, AllDoorTrapActors) == 0x0003B0, "Member 'AReadyOrNotGameState::AllDoorTrapActors' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, AllCoverLandmarks) == 0x0003C0, "Member 'AReadyOrNotGameState::AllCoverLandmarks' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, AllWallHoles) == 0x0003D0, "Member 'AReadyOrNotGameState::AllWallHoles' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, AllPairedInteractionActors) == 0x0003E0, "Member 'AReadyOrNotGameState::AllPairedInteractionActors' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, LoadedDataTables) == 0x0003F0, "Member 'AReadyOrNotGameState::LoadedDataTables' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, ScoringManager) == 0x000400, "Member 'AReadyOrNotGameState::ScoringManager' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, AIFactionManagers) == 0x000408, "Member 'AReadyOrNotGameState::AIFactionManagers' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, SquadManagerMap) == 0x000458, "Member 'AReadyOrNotGameState::SquadManagerMap' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, WorldActions) == 0x0004A8, "Member 'AReadyOrNotGameState::WorldActions' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, Rep_GameModeSettings) == 0x0004B8, "Member 'AReadyOrNotGameState::Rep_GameModeSettings' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, TimeTillGameStartCountdown) == 0x0004C8, "Member 'AReadyOrNotGameState::TimeTillGameStartCountdown' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, BadAIActionActors) == 0x0004D8, "Member 'AReadyOrNotGameState::BadAIActionActors' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, bHasLeftLoadOut) == 0x0004E8, "Member 'AReadyOrNotGameState::bHasLeftLoadOut' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, PreMissionStreamedLevel) == 0x0004F0, "Member 'AReadyOrNotGameState::PreMissionStreamedLevel' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, SubPreMissionPlanningLevel) == 0x0004F8, "Member 'AReadyOrNotGameState::SubPreMissionPlanningLevel' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, ModeName) == 0x000528, "Member 'AReadyOrNotGameState::ModeName' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, ModeRules) == 0x000540, "Member 'AReadyOrNotGameState::ModeRules' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, MissionObjectives) == 0x000558, "Member 'AReadyOrNotGameState::MissionObjectives' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, OnMissionObjectivesUpdated) == 0x000568, "Member 'AReadyOrNotGameState::OnMissionObjectivesUpdated' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, ObituaryData) == 0x000578, "Member 'AReadyOrNotGameState::ObituaryData' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, bAnnounceReinforcements) == 0x000580, "Member 'AReadyOrNotGameState::bAnnounceReinforcements' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, bRadioGlareEnabled) == 0x000581, "Member 'AReadyOrNotGameState::bRadioGlareEnabled' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, ReplenishAllAmmoSound) == 0x000588, "Member 'AReadyOrNotGameState::ReplenishAllAmmoSound' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, SpectatePawns) == 0x000590, "Member 'AReadyOrNotGameState::SpectatePawns' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, RedTeamPlayers) == 0x0005A0, "Member 'AReadyOrNotGameState::RedTeamPlayers' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, BlueTeamPlayers) == 0x0005B0, "Member 'AReadyOrNotGameState::BlueTeamPlayers' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, AllThrownItems) == 0x0005C0, "Member 'AReadyOrNotGameState::AllThrownItems' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, AllDoors) == 0x0005D0, "Member 'AReadyOrNotGameState::AllDoors' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, AllReadyOrNotCharacters) == 0x0005E0, "Member 'AReadyOrNotGameState::AllReadyOrNotCharacters' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, AllPlayerCharacters) == 0x0005F0, "Member 'AReadyOrNotGameState::AllPlayerCharacters' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, AllAICharacters) == 0x000600, "Member 'AReadyOrNotGameState::AllAICharacters' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, AllInteractableComponents) == 0x000610, "Member 'AReadyOrNotGameState::AllInteractableComponents' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, AnnouncerAudioComponent) == 0x000620, "Member 'AReadyOrNotGameState::AnnouncerAudioComponent' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, ExperienceManagerComponent) == 0x000628, "Member 'AReadyOrNotGameState::ExperienceManagerComponent' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, TotalMissionAbuseCount) == 0x000630, "Member 'AReadyOrNotGameState::TotalMissionAbuseCount' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, DeathListeners) == 0x000638, "Member 'AReadyOrNotGameState::DeathListeners' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, GameStartListeners) == 0x000648, "Member 'AReadyOrNotGameState::GameStartListeners' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, GameEndListeners) == 0x000658, "Member 'AReadyOrNotGameState::GameEndListeners' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, bDisableEquipment) == 0x000668, "Member 'AReadyOrNotGameState::bDisableEquipment' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, bEnableCommandChat) == 0x000669, "Member 'AReadyOrNotGameState::bEnableCommandChat' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, bUseReinforcements) == 0x00066A, "Member 'AReadyOrNotGameState::bUseReinforcements' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, Reinforcements_TimeRemaining) == 0x00066C, "Member 'AReadyOrNotGameState::Reinforcements_TimeRemaining' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, bRunWarmup) == 0x000670, "Member 'AReadyOrNotGameState::bRunWarmup' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, SceneCapturePlayerCameraClass) == 0x000678, "Member 'AReadyOrNotGameState::SceneCapturePlayerCameraClass' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, bShowEnemiesAsSuspects) == 0x000680, "Member 'AReadyOrNotGameState::bShowEnemiesAsSuspects' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, KillFeedData) == 0x000688, "Member 'AReadyOrNotGameState::KillFeedData' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, OnUpdateKillFeed) == 0x000698, "Member 'AReadyOrNotGameState::OnUpdateKillFeed' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, ServerTimeUntilNextMap) == 0x0006A8, "Member 'AReadyOrNotGameState::ServerTimeUntilNextMap' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, GameRulesIntroAnnouncerRowName) == 0x0006B0, "Member 'AReadyOrNotGameState::GameRulesIntroAnnouncerRowName' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, bWaitingForPlayers) == 0x0006C0, "Member 'AReadyOrNotGameState::bWaitingForPlayers' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, PlanningTimeLeft) == 0x0006C4, "Member 'AReadyOrNotGameState::PlanningTimeLeft' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, RedTeamWins) == 0x0006C8, "Member 'AReadyOrNotGameState::RedTeamWins' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, BlueTeamWins) == 0x0006CC, "Member 'AReadyOrNotGameState::BlueTeamWins' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, OnWinsUpdated) == 0x0006D8, "Member 'AReadyOrNotGameState::OnWinsUpdated' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, EndPlayTimer) == 0x0006E8, "Member 'AReadyOrNotGameState::EndPlayTimer' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, RoundTimeRemaining) == 0x0006EC, "Member 'AReadyOrNotGameState::RoundTimeRemaining' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, bUseTimelimit) == 0x0006F0, "Member 'AReadyOrNotGameState::bUseTimelimit' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, Scorelimit) == 0x0006F4, "Member 'AReadyOrNotGameState::Scorelimit' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, TimeSinceMatchStarted) == 0x0006F8, "Member 'AReadyOrNotGameState::TimeSinceMatchStarted' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, CurrentReferendum) == 0x000700, "Member 'AReadyOrNotGameState::CurrentReferendum' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, AllowedReferendumTypes) == 0x000708, "Member 'AReadyOrNotGameState::AllowedReferendumTypes' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, bCanShowScoreboard) == 0x000718, "Member 'AReadyOrNotGameState::bCanShowScoreboard' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, bUsePlanningUICamera) == 0x000719, "Member 'AReadyOrNotGameState::bUsePlanningUICamera' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, RoundTimeElapsed) == 0x00071C, "Member 'AReadyOrNotGameState::RoundTimeElapsed' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, RoundsPlayed) == 0x000720, "Member 'AReadyOrNotGameState::RoundsPlayed' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, RoundsToPlay) == 0x000724, "Member 'AReadyOrNotGameState::RoundsToPlay' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, RoundWinningTeam) == 0x000728, "Member 'AReadyOrNotGameState::RoundWinningTeam' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, MatchWinningTeam) == 0x000729, "Member 'AReadyOrNotGameState::MatchWinningTeam' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, RoundWinners) == 0x000730, "Member 'AReadyOrNotGameState::RoundWinners' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, OnChatMessageReceived) == 0x000740, "Member 'AReadyOrNotGameState::OnChatMessageReceived' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, MissionName) == 0x000750, "Member 'AReadyOrNotGameState::MissionName' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, MissionDescription) == 0x000760, "Member 'AReadyOrNotGameState::MissionDescription' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, MatchState) == 0x000778, "Member 'AReadyOrNotGameState::MatchState' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, OnCharacterArrested) == 0x000780, "Member 'AReadyOrNotGameState::OnCharacterArrested' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, OnCharacterKilled) == 0x000790, "Member 'AReadyOrNotGameState::OnCharacterKilled' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, NextURLReplicated) == 0x0007A0, "Member 'AReadyOrNotGameState::NextURLReplicated' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, OnSequenceStarted) == 0x0007B0, "Member 'AReadyOrNotGameState::OnSequenceStarted' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, WhitelistedLabels) == 0x0007C0, "Member 'AReadyOrNotGameState::WhitelistedLabels' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, DebugDisplayWidget) == 0x0007D0, "Member 'AReadyOrNotGameState::DebugDisplayWidget' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, ModeURL_Replicated) == 0x0007D8, "Member 'AReadyOrNotGameState::ModeURL_Replicated' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, DrawingPointData) == 0x0007E8, "Member 'AReadyOrNotGameState::DrawingPointData' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, bPvPMode) == 0x0007F8, "Member 'AReadyOrNotGameState::bPvPMode' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, bCanReportToTOC) == 0x0007F9, "Member 'AReadyOrNotGameState::bCanReportToTOC' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, GametypeDamageModifier) == 0x0007FC, "Member 'AReadyOrNotGameState::GametypeDamageModifier' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, HeadDamageModifier) == 0x000800, "Member 'AReadyOrNotGameState::HeadDamageModifier' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, FootDamageModifier) == 0x000804, "Member 'AReadyOrNotGameState::FootDamageModifier' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, LegDamageModifier) == 0x000808, "Member 'AReadyOrNotGameState::LegDamageModifier' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, ArmDamageModifier) == 0x00080C, "Member 'AReadyOrNotGameState::ArmDamageModifier' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, OtherLimbDamageModifier) == 0x000810, "Member 'AReadyOrNotGameState::OtherLimbDamageModifier' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, bFreeForAll) == 0x000814, "Member 'AReadyOrNotGameState::bFreeForAll' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, bDisablePickups) == 0x000815, "Member 'AReadyOrNotGameState::bDisablePickups' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, SavedChatMessages) == 0x000818, "Member 'AReadyOrNotGameState::SavedChatMessages' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, bBallisticsDebug) == 0x000828, "Member 'AReadyOrNotGameState::bBallisticsDebug' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, bDamageDebug) == 0x000829, "Member 'AReadyOrNotGameState::bDamageDebug' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, bSpeechRecognitionDebug) == 0x00082A, "Member 'AReadyOrNotGameState::bSpeechRecognitionDebug' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, bGOAPDebug) == 0x00082B, "Member 'AReadyOrNotGameState::bGOAPDebug' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, bAnnounceTeamReinforcements) == 0x00082C, "Member 'AReadyOrNotGameState::bAnnounceTeamReinforcements' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, Msg_BothTeamsReinforced) == 0x000830, "Member 'AReadyOrNotGameState::Msg_BothTeamsReinforced' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, Msg_RedTeamReinforced) == 0x000848, "Member 'AReadyOrNotGameState::Msg_RedTeamReinforced' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, Msg_BlueTeamReinforced) == 0x000860, "Member 'AReadyOrNotGameState::Msg_BlueTeamReinforced' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, GameModeChallenges) == 0x000878, "Member 'AReadyOrNotGameState::GameModeChallenges' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, CustomTimeDilationApplied) == 0x00088C, "Member 'AReadyOrNotGameState::CustomTimeDilationApplied' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, AdminPlayerControllers) == 0x000890, "Member 'AReadyOrNotGameState::AdminPlayerControllers' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, TOCManager) == 0x0008A0, "Member 'AReadyOrNotGameState::TOCManager' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, CombatMusic) == 0x0008A8, "Member 'AReadyOrNotGameState::CombatMusic' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, bHideLevelEffectsInPreMission) == 0x0008AC, "Member 'AReadyOrNotGameState::bHideLevelEffectsInPreMission' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, WorldDirectionalLights) == 0x0008B0, "Member 'AReadyOrNotGameState::WorldDirectionalLights' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, WorldPostProcessVolumes) == 0x0008C0, "Member 'AReadyOrNotGameState::WorldPostProcessVolumes' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, WorldExponentialHeightFogs) == 0x0008D0, "Member 'AReadyOrNotGameState::WorldExponentialHeightFogs' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameState, PreMissionExponentialHeightFogs) == 0x0008E0, "Member 'AReadyOrNotGameState::PreMissionExponentialHeightFogs' has a wrong offset!");

// Class ReadyOrNot.FirefightGS
// 0x0018 (0x0910 - 0x08F8)
class AFirefightGS final : public AReadyOrNotGameState
{
public:
	class FText                                   FreeTextLocalized;                                 // 0x08F8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FirefightGS">();
	}
	static class AFirefightGS* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFirefightGS>();
	}
};
static_assert(alignof(AFirefightGS) == 0x000008, "Wrong alignment on AFirefightGS");
static_assert(sizeof(AFirefightGS) == 0x000910, "Wrong size on AFirefightGS");
static_assert(offsetof(AFirefightGS, FreeTextLocalized) == 0x0008F8, "Member 'AFirefightGS::FreeTextLocalized' has a wrong offset!");

// Class ReadyOrNot.AG_HasEquippedWeapon
// 0x0000 (0x0028 - 0x0028)
class UAG_HasEquippedWeapon : public UAIActionGate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AG_HasEquippedWeapon">();
	}
	static class UAG_HasEquippedWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAG_HasEquippedWeapon>();
	}
};
static_assert(alignof(UAG_HasEquippedWeapon) == 0x000008, "Wrong alignment on UAG_HasEquippedWeapon");
static_assert(sizeof(UAG_HasEquippedWeapon) == 0x000028, "Wrong size on UAG_HasEquippedWeapon");

// Class ReadyOrNot.FootstepFoleyVolume
// 0x0018 (0x02E8 - 0x02D0)
class AFootstepFoleyVolume final : public AVolume
{
public:
	class UFMODEvent*                             FootstepFoleyEvent;                                // 0x02D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             FootstepFoleyEventFirstPerson;                     // 0x02D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNPCsTriggerFootstepFoley;                         // 0x02E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E1[0x7];                                      // 0x02E1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnOverlapEnd(class AActor* OverlappedActor, class AActor* OtherActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FootstepFoleyVolume">();
	}
	static class AFootstepFoleyVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFootstepFoleyVolume>();
	}
};
static_assert(alignof(AFootstepFoleyVolume) == 0x000008, "Wrong alignment on AFootstepFoleyVolume");
static_assert(sizeof(AFootstepFoleyVolume) == 0x0002E8, "Wrong size on AFootstepFoleyVolume");
static_assert(offsetof(AFootstepFoleyVolume, FootstepFoleyEvent) == 0x0002D0, "Member 'AFootstepFoleyVolume::FootstepFoleyEvent' has a wrong offset!");
static_assert(offsetof(AFootstepFoleyVolume, FootstepFoleyEventFirstPerson) == 0x0002D8, "Member 'AFootstepFoleyVolume::FootstepFoleyEventFirstPerson' has a wrong offset!");
static_assert(offsetof(AFootstepFoleyVolume, bNPCsTriggerFootstepFoley) == 0x0002E0, "Member 'AFootstepFoleyVolume::bNPCsTriggerFootstepFoley' has a wrong offset!");

// Class ReadyOrNot.ControlsBind
// 0x00E0 (0x03A0 - 0x02C0)
class UControlsBind : public UUserWidget
{
public:
	bool                                          IsAxis;                                            // 0x02C0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C1[0x3];                                      // 0x02C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BindIndex;                                         // 0x02C4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ListeningForKeystrokes;                            // 0x02C8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C9[0x7];                                      // 0x02C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKey                                   PendingNewKey;                                     // 0x02D0(0x0018)(BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BindName;                                          // 0x02E8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   BindFriendlyName;                                  // 0x02F0(0x0018)(BlueprintVisible, ExposeOnSpawn, NativeAccessSpecifierPublic)
	float                                         AxisScale;                                         // 0x0308(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInputKeyCategoryV2                           KeyCategory;                                       // 0x030C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30D[0x3];                                      // 0x030D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class USettingsMenuGamepad*                   SettingsMenu;                                      // 0x0310(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAxisMappingStruct                     AxisMappingData;                                   // 0x0318(0x0028)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FActionMappingStruct                   ActionMappingData;                                 // 0x0340(0x0028)(BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   UnboundText;                                       // 0x0368(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<class FText>                           ConflictBindFriendlyNamesList;                     // 0x0380(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class UTextBlock*                             BindingText;                                       // 0x0390(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Button_Selected;                                   // 0x0398(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AddConflictingKeybindsToList(class FName MappingName, float Scale, TArray<struct FAxisMappingStruct>* AxesList, TArray<struct FActionMappingStruct>* ActionsList);
	void AddKeybindsToList(const TArray<struct FKeyBinding>& Keybinds, class FName MappingName, float Scale, TArray<struct FAxisMappingStruct>* AxesList, TArray<struct FActionMappingStruct>* ActionsList);
	void BindingFinished();
	class FText CheckConflictingKeybindsAreUnbindable(const TArray<struct FAxisMappingStruct>& AxesList, const TArray<struct FActionMappingStruct>& ActionsList);
	void GetConflictingKeybindsWhenValid(const TArray<struct FAxisMappingStruct>& AxesList, const TArray<struct FActionMappingStruct>& ActionsList, bool* HasConflict, TArray<struct FAxisMappingStruct>* ConflictingAxes, TArray<struct FActionMappingStruct>* ConflictingActions);
	class FText GetConflictingKeybindText(const class FText& RequiredKeybindName);
	void GetInputBindingData(int32 Index_0, struct FAxisMappingStruct* AxisMapping, struct FActionMappingStruct* ActionMapping);
	bool RebindKey(const struct FKey& NewKey);
	void RemoveConflictKeybinds(const TArray<struct FAxisMappingStruct>& AxesList, const TArray<struct FActionMappingStruct>& ActionsList);
	void ResetBinding();
	void SetKeybindingText();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ControlsBind">();
	}
	static class UControlsBind* GetDefaultObj()
	{
		return GetDefaultObjImpl<UControlsBind>();
	}
};
static_assert(alignof(UControlsBind) == 0x000008, "Wrong alignment on UControlsBind");
static_assert(sizeof(UControlsBind) == 0x0003A0, "Wrong size on UControlsBind");
static_assert(offsetof(UControlsBind, IsAxis) == 0x0002C0, "Member 'UControlsBind::IsAxis' has a wrong offset!");
static_assert(offsetof(UControlsBind, BindIndex) == 0x0002C4, "Member 'UControlsBind::BindIndex' has a wrong offset!");
static_assert(offsetof(UControlsBind, ListeningForKeystrokes) == 0x0002C8, "Member 'UControlsBind::ListeningForKeystrokes' has a wrong offset!");
static_assert(offsetof(UControlsBind, PendingNewKey) == 0x0002D0, "Member 'UControlsBind::PendingNewKey' has a wrong offset!");
static_assert(offsetof(UControlsBind, BindName) == 0x0002E8, "Member 'UControlsBind::BindName' has a wrong offset!");
static_assert(offsetof(UControlsBind, BindFriendlyName) == 0x0002F0, "Member 'UControlsBind::BindFriendlyName' has a wrong offset!");
static_assert(offsetof(UControlsBind, AxisScale) == 0x000308, "Member 'UControlsBind::AxisScale' has a wrong offset!");
static_assert(offsetof(UControlsBind, KeyCategory) == 0x00030C, "Member 'UControlsBind::KeyCategory' has a wrong offset!");
static_assert(offsetof(UControlsBind, SettingsMenu) == 0x000310, "Member 'UControlsBind::SettingsMenu' has a wrong offset!");
static_assert(offsetof(UControlsBind, AxisMappingData) == 0x000318, "Member 'UControlsBind::AxisMappingData' has a wrong offset!");
static_assert(offsetof(UControlsBind, ActionMappingData) == 0x000340, "Member 'UControlsBind::ActionMappingData' has a wrong offset!");
static_assert(offsetof(UControlsBind, UnboundText) == 0x000368, "Member 'UControlsBind::UnboundText' has a wrong offset!");
static_assert(offsetof(UControlsBind, ConflictBindFriendlyNamesList) == 0x000380, "Member 'UControlsBind::ConflictBindFriendlyNamesList' has a wrong offset!");
static_assert(offsetof(UControlsBind, BindingText) == 0x000390, "Member 'UControlsBind::BindingText' has a wrong offset!");
static_assert(offsetof(UControlsBind, Button_Selected) == 0x000398, "Member 'UControlsBind::Button_Selected' has a wrong offset!");

// Class ReadyOrNot.ReportableActor
// 0x00E8 (0x0380 - 0x0298)
class AReportableActor final : public AActor
{
public:
	uint8                                         Pad_298[0x20];                                     // 0x0298(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bReportableEnabled;                                // 0x02B8(0x0001)(Edit, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasBeenReported;                                  // 0x02B9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BA[0x6];                                      // 0x02BA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class AReadyOrNotCharacter*                   ReportedBy;                                        // 0x02C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableOnNoMatchingObjective;                     // 0x02C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableWhileMatchingObjectiveHidden;              // 0x02C9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CA[0x6];                                      // 0x02CA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ReportableName;                                    // 0x02D0(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FString                                 ReportVoiceLine;                                   // 0x02E8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseSpecificReportVoiceLines;                      // 0x02F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFallbackToDefaultVoiceLine;                       // 0x02F9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FA[0x6];                                      // 0x02FA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         SpecificReportVoiceLines;                          // 0x0300(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bTocResponseOnReport;                              // 0x0310(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_311[0x7];                                      // 0x0311(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TocResponseVoiceLine;                              // 0x0318(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AReportableActor* ReportableActor, class AReadyOrNotCharacter* Reporter)> OnReported; // 0x0328(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UShapeComponent*                        ShapeComponent;                                    // 0x0338(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVolumeShape                                  Shape;                                             // 0x0340(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_341[0x7];                                      // 0x0341(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                BoxExtents;                                        // 0x0348(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0360(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZHeight;                                           // 0x0364(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        SceneComponent;                                    // 0x0368(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractableComponent*                 InteractableComponent;                             // 0x0370(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UScoringComponent*                      ScoringComponent;                                  // 0x0378(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void DisableReportableIfNoMatchingObjective();
	void OnRep_bReportableEnabled();
	void SetReportableEnabled(bool bEnable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReportableActor">();
	}
	static class AReportableActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AReportableActor>();
	}
};
static_assert(alignof(AReportableActor) == 0x000008, "Wrong alignment on AReportableActor");
static_assert(sizeof(AReportableActor) == 0x000380, "Wrong size on AReportableActor");
static_assert(offsetof(AReportableActor, bReportableEnabled) == 0x0002B8, "Member 'AReportableActor::bReportableEnabled' has a wrong offset!");
static_assert(offsetof(AReportableActor, bHasBeenReported) == 0x0002B9, "Member 'AReportableActor::bHasBeenReported' has a wrong offset!");
static_assert(offsetof(AReportableActor, ReportedBy) == 0x0002C0, "Member 'AReportableActor::ReportedBy' has a wrong offset!");
static_assert(offsetof(AReportableActor, bDisableOnNoMatchingObjective) == 0x0002C8, "Member 'AReportableActor::bDisableOnNoMatchingObjective' has a wrong offset!");
static_assert(offsetof(AReportableActor, bDisableWhileMatchingObjectiveHidden) == 0x0002C9, "Member 'AReportableActor::bDisableWhileMatchingObjectiveHidden' has a wrong offset!");
static_assert(offsetof(AReportableActor, ReportableName) == 0x0002D0, "Member 'AReportableActor::ReportableName' has a wrong offset!");
static_assert(offsetof(AReportableActor, ReportVoiceLine) == 0x0002E8, "Member 'AReportableActor::ReportVoiceLine' has a wrong offset!");
static_assert(offsetof(AReportableActor, bUseSpecificReportVoiceLines) == 0x0002F8, "Member 'AReportableActor::bUseSpecificReportVoiceLines' has a wrong offset!");
static_assert(offsetof(AReportableActor, bFallbackToDefaultVoiceLine) == 0x0002F9, "Member 'AReportableActor::bFallbackToDefaultVoiceLine' has a wrong offset!");
static_assert(offsetof(AReportableActor, SpecificReportVoiceLines) == 0x000300, "Member 'AReportableActor::SpecificReportVoiceLines' has a wrong offset!");
static_assert(offsetof(AReportableActor, bTocResponseOnReport) == 0x000310, "Member 'AReportableActor::bTocResponseOnReport' has a wrong offset!");
static_assert(offsetof(AReportableActor, TocResponseVoiceLine) == 0x000318, "Member 'AReportableActor::TocResponseVoiceLine' has a wrong offset!");
static_assert(offsetof(AReportableActor, OnReported) == 0x000328, "Member 'AReportableActor::OnReported' has a wrong offset!");
static_assert(offsetof(AReportableActor, ShapeComponent) == 0x000338, "Member 'AReportableActor::ShapeComponent' has a wrong offset!");
static_assert(offsetof(AReportableActor, Shape) == 0x000340, "Member 'AReportableActor::Shape' has a wrong offset!");
static_assert(offsetof(AReportableActor, BoxExtents) == 0x000348, "Member 'AReportableActor::BoxExtents' has a wrong offset!");
static_assert(offsetof(AReportableActor, Radius) == 0x000360, "Member 'AReportableActor::Radius' has a wrong offset!");
static_assert(offsetof(AReportableActor, ZHeight) == 0x000364, "Member 'AReportableActor::ZHeight' has a wrong offset!");
static_assert(offsetof(AReportableActor, SceneComponent) == 0x000368, "Member 'AReportableActor::SceneComponent' has a wrong offset!");
static_assert(offsetof(AReportableActor, InteractableComponent) == 0x000370, "Member 'AReportableActor::InteractableComponent' has a wrong offset!");
static_assert(offsetof(AReportableActor, ScoringComponent) == 0x000378, "Member 'AReportableActor::ScoringComponent' has a wrong offset!");

// Class ReadyOrNot.AG_HasWeaponForHostage
// 0x0000 (0x0028 - 0x0028)
class UAG_HasWeaponForHostage final : public UAIActionGate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AG_HasWeaponForHostage">();
	}
	static class UAG_HasWeaponForHostage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAG_HasWeaponForHostage>();
	}
};
static_assert(alignof(UAG_HasWeaponForHostage) == 0x000008, "Wrong alignment on UAG_HasWeaponForHostage");
static_assert(sizeof(UAG_HasWeaponForHostage) == 0x000028, "Wrong size on UAG_HasWeaponForHostage");

// Class ReadyOrNot.ExperienceActionSet
// 0x0020 (0x0050 - 0x0030)
class UExperienceActionSet final : public UPrimaryDataAsset
{
public:
	TArray<class UGameFeatureAction*>             Actions;                                           // 0x0030(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class FString>                         GameFeaturesToEnable;                              // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExperienceActionSet">();
	}
	static class UExperienceActionSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExperienceActionSet>();
	}
};
static_assert(alignof(UExperienceActionSet) == 0x000008, "Wrong alignment on UExperienceActionSet");
static_assert(sizeof(UExperienceActionSet) == 0x000050, "Wrong size on UExperienceActionSet");
static_assert(offsetof(UExperienceActionSet, Actions) == 0x000030, "Member 'UExperienceActionSet::Actions' has a wrong offset!");
static_assert(offsetof(UExperienceActionSet, GameFeaturesToEnable) == 0x000040, "Member 'UExperienceActionSet::GameFeaturesToEnable' has a wrong offset!");

// Class ReadyOrNot.AG_IsSurrendered
// 0x0008 (0x0030 - 0x0028)
class UAG_IsSurrendered : public UAIActionGate
{
public:
	float                                         Time;                                              // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AG_IsSurrendered">();
	}
	static class UAG_IsSurrendered* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAG_IsSurrendered>();
	}
};
static_assert(alignof(UAG_IsSurrendered) == 0x000008, "Wrong alignment on UAG_IsSurrendered");
static_assert(sizeof(UAG_IsSurrendered) == 0x000030, "Wrong size on UAG_IsSurrendered");
static_assert(offsetof(UAG_IsSurrendered, Time) == 0x000028, "Member 'UAG_IsSurrendered::Time' has a wrong offset!");

// Class ReadyOrNot.CommonButtonStyleFMOD
// 0x0010 (0x07D0 - 0x07C0)
class UCommonButtonStyleFMOD : public UCommonButtonStyle
{
public:
	class UFMODEvent*                             OnHoveredEvent;                                    // 0x07C0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             OnClickedEvent;                                    // 0x07C8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommonButtonStyleFMOD">();
	}
	static class UCommonButtonStyleFMOD* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommonButtonStyleFMOD>();
	}
};
static_assert(alignof(UCommonButtonStyleFMOD) == 0x000010, "Wrong alignment on UCommonButtonStyleFMOD");
static_assert(sizeof(UCommonButtonStyleFMOD) == 0x0007D0, "Wrong size on UCommonButtonStyleFMOD");
static_assert(offsetof(UCommonButtonStyleFMOD, OnHoveredEvent) == 0x0007C0, "Member 'UCommonButtonStyleFMOD::OnHoveredEvent' has a wrong offset!");
static_assert(offsetof(UCommonButtonStyleFMOD, OnClickedEvent) == 0x0007C8, "Member 'UCommonButtonStyleFMOD::OnClickedEvent' has a wrong offset!");

// Class ReadyOrNot.NavArea_SuspectC
// 0x0000 (0x0048 - 0x0048)
class UNavArea_SuspectC final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_SuspectC">();
	}
	static class UNavArea_SuspectC* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_SuspectC>();
	}
};
static_assert(alignof(UNavArea_SuspectC) == 0x000008, "Wrong alignment on UNavArea_SuspectC");
static_assert(sizeof(UNavArea_SuspectC) == 0x000048, "Wrong size on UNavArea_SuspectC");

// Class ReadyOrNot.AG_HasUsedZoneAtPriorityLevel
// 0x0010 (0x0038 - 0x0028)
class UAG_HasUsedZoneAtPriorityLevel final : public UAIActionGate
{
public:
	TArray<EZonePriority>                         PriorityList;                                      // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, ExposeOnSpawn, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AG_HasUsedZoneAtPriorityLevel">();
	}
	static class UAG_HasUsedZoneAtPriorityLevel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAG_HasUsedZoneAtPriorityLevel>();
	}
};
static_assert(alignof(UAG_HasUsedZoneAtPriorityLevel) == 0x000008, "Wrong alignment on UAG_HasUsedZoneAtPriorityLevel");
static_assert(sizeof(UAG_HasUsedZoneAtPriorityLevel) == 0x000038, "Wrong size on UAG_HasUsedZoneAtPriorityLevel");
static_assert(offsetof(UAG_HasUsedZoneAtPriorityLevel, PriorityList) == 0x000028, "Member 'UAG_HasUsedZoneAtPriorityLevel::PriorityList' has a wrong offset!");

// Class ReadyOrNot.BaseProfile
// 0x0298 (0x02C0 - 0x0028)
class UBaseProfile : public USaveGame
{
public:
	int32                                         BaseVersion;                                       // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSavedLoadout>                  Loadouts;                                          // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<TSubclassOf<class ABaseItem>, struct FSavedWeaponAttachmentData> AttachmentSaveMap;         // 0x0040(0x0050)(NativeAccessSpecifierPublic)
	TMap<TSubclassOf<class ABaseWeapon>, struct FStoredWeaponAttachments> LoadoutAttachmentSaveMap;  // 0x0090(0x0050)(NativeAccessSpecifierPublic)
	TMap<EItemType, TSubclassOf<class ABaseItem>> SavedWeaponClassOfTypeMap;                         // 0x00E0(0x0050)(UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<TSubclassOf<class ABaseWeapon>, EFireMode> WeaponClassToDefaultFireModeMap;                 // 0x0130(0x0050)(NativeAccessSpecifierPublic)
	TMap<TSubclassOf<class ABaseItem>, struct FSavedWeaponPreset> WeaponToWeaponPresetsMap;          // 0x0180(0x0050)(NativeAccessSpecifierPublic)
	TMap<class FString, struct FSavedLoadout>     LoadoutPresetMap;                                  // 0x01D0(0x0050)(NativeAccessSpecifierPublic)
	TMap<EEquippingSwat, struct FSavedCustomization> Customizations;                                 // 0x0220(0x0050)(NativeAccessSpecifierPublic)
	TMap<class FString, struct FSavedCustomization> CustomizationPresetMap;                          // 0x0270(0x0050)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseProfile">();
	}
	static class UBaseProfile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseProfile>();
	}
};
static_assert(alignof(UBaseProfile) == 0x000008, "Wrong alignment on UBaseProfile");
static_assert(sizeof(UBaseProfile) == 0x0002C0, "Wrong size on UBaseProfile");
static_assert(offsetof(UBaseProfile, BaseVersion) == 0x000028, "Member 'UBaseProfile::BaseVersion' has a wrong offset!");
static_assert(offsetof(UBaseProfile, Loadouts) == 0x000030, "Member 'UBaseProfile::Loadouts' has a wrong offset!");
static_assert(offsetof(UBaseProfile, AttachmentSaveMap) == 0x000040, "Member 'UBaseProfile::AttachmentSaveMap' has a wrong offset!");
static_assert(offsetof(UBaseProfile, LoadoutAttachmentSaveMap) == 0x000090, "Member 'UBaseProfile::LoadoutAttachmentSaveMap' has a wrong offset!");
static_assert(offsetof(UBaseProfile, SavedWeaponClassOfTypeMap) == 0x0000E0, "Member 'UBaseProfile::SavedWeaponClassOfTypeMap' has a wrong offset!");
static_assert(offsetof(UBaseProfile, WeaponClassToDefaultFireModeMap) == 0x000130, "Member 'UBaseProfile::WeaponClassToDefaultFireModeMap' has a wrong offset!");
static_assert(offsetof(UBaseProfile, WeaponToWeaponPresetsMap) == 0x000180, "Member 'UBaseProfile::WeaponToWeaponPresetsMap' has a wrong offset!");
static_assert(offsetof(UBaseProfile, LoadoutPresetMap) == 0x0001D0, "Member 'UBaseProfile::LoadoutPresetMap' has a wrong offset!");
static_assert(offsetof(UBaseProfile, Customizations) == 0x000220, "Member 'UBaseProfile::Customizations' has a wrong offset!");
static_assert(offsetof(UBaseProfile, CustomizationPresetMap) == 0x000270, "Member 'UBaseProfile::CustomizationPresetMap' has a wrong offset!");

// Class ReadyOrNot.AG_HasMissionEventFired
// 0x0010 (0x0038 - 0x0028)
class UAG_HasMissionEventFired final : public UAIActionGate
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayAfterEventFired;                              // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AG_HasMissionEventFired">();
	}
	static class UAG_HasMissionEventFired* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAG_HasMissionEventFired>();
	}
};
static_assert(alignof(UAG_HasMissionEventFired) == 0x000008, "Wrong alignment on UAG_HasMissionEventFired");
static_assert(sizeof(UAG_HasMissionEventFired) == 0x000038, "Wrong size on UAG_HasMissionEventFired");
static_assert(offsetof(UAG_HasMissionEventFired, EventTag) == 0x000028, "Member 'UAG_HasMissionEventFired::EventTag' has a wrong offset!");
static_assert(offsetof(UAG_HasMissionEventFired, DelayAfterEventFired) == 0x000030, "Member 'UAG_HasMissionEventFired::DelayAfterEventFired' has a wrong offset!");

// Class ReadyOrNot.NavArea_CivilianB
// 0x0000 (0x0048 - 0x0048)
class UNavArea_CivilianB final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_CivilianB">();
	}
	static class UNavArea_CivilianB* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_CivilianB>();
	}
};
static_assert(alignof(UNavArea_CivilianB) == 0x000008, "Wrong alignment on UNavArea_CivilianB");
static_assert(sizeof(UNavArea_CivilianB) == 0x000048, "Wrong size on UNavArea_CivilianB");

// Class ReadyOrNot.AG_WorldActionIsAvailable
// 0x0000 (0x0028 - 0x0028)
class UAG_WorldActionIsAvailable final : public UAIActionGate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AG_WorldActionIsAvailable">();
	}
	static class UAG_WorldActionIsAvailable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAG_WorldActionIsAvailable>();
	}
};
static_assert(alignof(UAG_WorldActionIsAvailable) == 0x000008, "Wrong alignment on UAG_WorldActionIsAvailable");
static_assert(sizeof(UAG_WorldActionIsAvailable) == 0x000028, "Wrong size on UAG_WorldActionIsAvailable");

// Class ReadyOrNot.AG_SquadMemberHasTarget
// 0x0000 (0x0028 - 0x0028)
class UAG_SquadMemberHasTarget final : public UAIActionGate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AG_SquadMemberHasTarget">();
	}
	static class UAG_SquadMemberHasTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAG_SquadMemberHasTarget>();
	}
};
static_assert(alignof(UAG_SquadMemberHasTarget) == 0x000008, "Wrong alignment on UAG_SquadMemberHasTarget");
static_assert(sizeof(UAG_SquadMemberHasTarget) == 0x000028, "Wrong size on UAG_SquadMemberHasTarget");

// Class ReadyOrNot.ResourceComponent
// 0x0058 (0x00F8 - 0x00A0)
class UResourceComponent : public UActorComponent
{
public:
	TMulticastInlineDelegate<void()>              OnFullResource;                                    // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(float Resource)> OnLowResource;                                    // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnDepletedResource;                                // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FName                                   ResourceName;                                      // 0x00D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Resource;                                          // 0x00D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxResource;                                       // 0x00DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxResourceLimit;                                  // 0x00E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LowResourceThreshold;                              // 0x00E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OriginalMaxResource;                               // 0x00E8(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LowResource;                                       // 0x00EC(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PreviousResource;                                  // 0x00F0(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bUnlimited : 1;                                    // 0x00F4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_F5[0x3];                                       // 0x00F5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DecreaseResource(const float Amount);
	void DecreaseResourceByRate(const float Rate);
	void DepleteResource();
	void DisableUnlimitedResource();
	void EnableUnlimitedResource();
	void IncreaseResource(const float Amount);
	void IncreaseResourceByRate(const float Rate);
	void ResetResource();
	void Server_DecreaseResource(float Amount);
	void Server_DepleteResource();
	void Server_DisableUnlimitedResource();
	void Server_EnableUnlimitedResource();
	void Server_IncreaseResource(float Amount);
	void Server_InitResource();
	void Server_ResetResource();
	void Server_SetCurrentResourceToMax();
	void Server_SetMaxResource(float NewMaxResource);
	void Server_SetResource(float NewResourceAmount);
	void Server_SetUnlimitedResource(bool bEnabled);
	void Server_ToggleUnlimitedResource();
	void Server_UpdatePreviousResource();
	void SetCurrentResourceToMax();
	void SetMaxResource(const float NewMaxResource);
	void SetResource(const float NewResourceAmount);
	void SetUnlimitedResource(const bool bEnabled);
	void ToggleUnlimitedResource();
	void UpdatePreviousResource();

	float DecreaseResource_Expression(float Amount) const;
	float GetCurrentResource() const;
	float GetHalfResource() const;
	float GetLowResource() const;
	float GetLowResourceThreshold() const;
	float GetMaxResource() const;
	float GetNormalizedResource() const;
	float GetOriginalMaxResource() const;
	float GetPreviousResource() const;
	class FName GetResourceName() const;
	bool HasResource() const;
	float IncreaseResource_Expression(float Amount) const;
	bool IsDepleted() const;
	bool IsFullResource() const;
	bool IsHalfResource() const;
	bool IsLowResource() const;
	bool IsResourceAbove(const float ResourceValue) const;
	bool IsResourceAt(const float ResourceValue) const;
	bool IsResourceAtOrAbove(const float ResourceValue) const;
	bool IsResourceAtOrBelow(const float ResourceValue) const;
	bool IsResourceBelow(const float ResourceValue) const;
	bool IsUnlimitedResourceEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ResourceComponent">();
	}
	static class UResourceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UResourceComponent>();
	}
};
static_assert(alignof(UResourceComponent) == 0x000008, "Wrong alignment on UResourceComponent");
static_assert(sizeof(UResourceComponent) == 0x0000F8, "Wrong size on UResourceComponent");
static_assert(offsetof(UResourceComponent, OnFullResource) == 0x0000A0, "Member 'UResourceComponent::OnFullResource' has a wrong offset!");
static_assert(offsetof(UResourceComponent, OnLowResource) == 0x0000B0, "Member 'UResourceComponent::OnLowResource' has a wrong offset!");
static_assert(offsetof(UResourceComponent, OnDepletedResource) == 0x0000C0, "Member 'UResourceComponent::OnDepletedResource' has a wrong offset!");
static_assert(offsetof(UResourceComponent, ResourceName) == 0x0000D0, "Member 'UResourceComponent::ResourceName' has a wrong offset!");
static_assert(offsetof(UResourceComponent, Resource) == 0x0000D8, "Member 'UResourceComponent::Resource' has a wrong offset!");
static_assert(offsetof(UResourceComponent, MaxResource) == 0x0000DC, "Member 'UResourceComponent::MaxResource' has a wrong offset!");
static_assert(offsetof(UResourceComponent, MaxResourceLimit) == 0x0000E0, "Member 'UResourceComponent::MaxResourceLimit' has a wrong offset!");
static_assert(offsetof(UResourceComponent, LowResourceThreshold) == 0x0000E4, "Member 'UResourceComponent::LowResourceThreshold' has a wrong offset!");
static_assert(offsetof(UResourceComponent, OriginalMaxResource) == 0x0000E8, "Member 'UResourceComponent::OriginalMaxResource' has a wrong offset!");
static_assert(offsetof(UResourceComponent, LowResource) == 0x0000EC, "Member 'UResourceComponent::LowResource' has a wrong offset!");
static_assert(offsetof(UResourceComponent, PreviousResource) == 0x0000F0, "Member 'UResourceComponent::PreviousResource' has a wrong offset!");

// Class ReadyOrNot.HealthComponent
// 0x0000 (0x00F8 - 0x00F8)
class UHealthComponent : public UResourceComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HealthComponent">();
	}
	static class UHealthComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHealthComponent>();
	}
};
static_assert(alignof(UHealthComponent) == 0x000008, "Wrong alignment on UHealthComponent");
static_assert(sizeof(UHealthComponent) == 0x0000F8, "Wrong size on UHealthComponent");

// Class ReadyOrNot.CharacterHealthComponent
// 0x0190 (0x0288 - 0x00F8)
class UCharacterHealthComponent final : public UHealthComponent
{
public:
	TMulticastInlineDelegate<void(ELimbType Limb)> OnLimbFullHealth;                                 // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(ELimbType AffectedLimb, float LimbHealth)> OnLimbLowHealth;        // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(ELimbType Limb)> OnLimbNoHealth;                                   // 0x0118(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(ELimbType Limb)> OnLimbBroken;                                     // 0x0128(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(ELimbType Limb)> OnLimbFullTickets;                                // 0x0138(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(ELimbType Limb)> OnLimbNoTickets;                                  // 0x0148(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EPlayerHealthStatus                           HealthStatus;                                      // 0x0158(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bEnableIncapacitation : 1;                         // 0x0159(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_15A[0x2];                                      // 0x015A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IncapacitationHealthMultiplier;                    // 0x015C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLimbHealthData                        RightLeg;                                          // 0x0160(0x0034)(Edit, BlueprintVisible, BlueprintReadOnly, Net, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FLimbHealthData                        LeftLeg;                                           // 0x0194(0x0034)(Edit, BlueprintVisible, BlueprintReadOnly, Net, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FLimbHealthData                        RightArm;                                          // 0x01C8(0x0034)(Edit, BlueprintVisible, BlueprintReadOnly, Net, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FLimbHealthData                        LeftArm;                                           // 0x01FC(0x0034)(Edit, BlueprintVisible, BlueprintReadOnly, Net, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FLimbHealthData                        Head;                                              // 0x0230(0x0034)(Edit, BlueprintVisible, BlueprintReadOnly, Net, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         bUnlimitedRevives : 1;                             // 0x0264(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Net, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_265[0x3];                                      // 0x0265(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxRevives;                                        // 0x0268(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReviveTime;                                        // 0x026C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReviveTimeDecrement;                               // 0x0270(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReviveOperatingTime;                               // 0x0274(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxReviveHealth;                                   // 0x0278(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         RemainingRevives;                                  // 0x027C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RemainingReviveTime;                               // 0x0280(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RemainingReviveHealth;                             // 0x0284(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static bool IsLimbEqualTo(const struct FLimbHealthData& InLimbHealthData, const struct FLimbHealthData& OtherLimbHealthData);

	void DecreaseLimbHealth(const ELimbType& Limb, const float Amount);
	void DecreaseLimbTickets(const ELimbType& Limb, const int32 Amount);
	void DecreaseRevive();
	void DecreaseReviveHealth(const float Amount);
	bool HalfMaxLimbHealth(const ELimbType& Limb);
	void IncreaseLimbHealth(const ELimbType& Limb, const float Amount);
	void IncreaseLimbTickets(const ELimbType& Limb, const int32 Amount);
	void IncreaseRevive();
	void IncreaseReviveHealth(const float Amount);
	void ResetAllLimbHealth();
	void ResetAllLimbTickets();
	void ResetLimbHealth(const ELimbType& Limb);
	void ResetLimbTickets(const ELimbType& Limb);
	void ResetReviveHealth();
	void ResetRevives();
	void Server_DecreaseLimbHealth(const ELimbType& Limb, float Amount);
	void Server_DecreaseLimbTickets(const ELimbType& Limb, int32 Amount);
	void Server_DecreaseRevive();
	void Server_DecreaseReviveHealth(float Amount);
	void Server_HalfMaxLimbHealth(const ELimbType& Limb);
	void Server_IncreaseLimbHealth(const ELimbType& Limb, float Amount);
	void Server_IncreaseLimbTickets(const ELimbType& Limb, int32 Amount);
	void Server_IncreaseRevive();
	void Server_IncreaseReviveHealth(float Amount);
	void Server_ResetAllLimbHealth();
	void Server_ResetAllLimbTickets();
	void Server_ResetLimbHealth(const ELimbType& Limb);
	void Server_ResetLimbTickets(const ELimbType& Limb);
	void Server_ResetReviveHealth();
	void Server_ResetRevives();
	void Server_SetCurrentLimbHealthToMax(const ELimbType& Limb);
	void Server_SetHealthStatus(EPlayerHealthStatus NewHealthStatus);
	void Server_SetLimbHealth(const ELimbType& Limb, float NewHealthAmount);
	void Server_SetMaxLimbHealth(const ELimbType& Limb, float NewMaxHealth);
	void Server_SetRemainingRevives(int32 NewRemainingRevives);
	void Server_SetReviveHealth(float NewReviveHealth);
	void Server_UpdatePreviousLimbHealth(const ELimbType& Limb);
	void Server_UseAllRemainingLimbTickets(const ELimbType& Limb);
	void SetCurrentLimbHealthToMax(const ELimbType& Limb);
	void SetHealthStatus(EPlayerHealthStatus NewHealthStatus);
	void SetLimbHealth(const ELimbType& Limb, const float NewHealthAmount);
	void SetMaxLimbHealth(const ELimbType& Limb, const float NewMaxHealth);
	void SetRemainingRevives(const int32 NewRemainingRevives);
	void SetReviveHealth(const float NewReviveHealth);
	void UpdatePreviousLimbHealth(const ELimbType& Limb);
	void UseAllLimbTickets(const ELimbType& Limb);

	bool CanUseReviveSystem() const;
	TArray<ELimbType> GetBrokenLimbs() const;
	struct FLimbHealthData GetHeadHealth_Copy() const;
	EPlayerHealthStatus GetHealthStatus() const;
	float GetIncapacitationHealthMultiplier() const;
	struct FLimbHealthData GetLeftArmHealth_Copy() const;
	struct FLimbHealthData GetLeftLegHealth_Copy() const;
	struct FLimbHealthData GetLimb_Copy(const ELimbType& Limb) const;
	float GetMaxReviveHealth() const;
	int32 GetMaxRevives() const;
	float GetRemainingReviveHealth() const;
	int32 GetRemainingRevives() const;
	float GetRemainingReviveTime() const;
	float GetReviveOperatingTime() const;
	struct FLimbHealthData GetRightArmHealth_Copy() const;
	struct FLimbHealthData GetRightLegHealth_Copy() const;
	bool IsAnyLimbAtNoHealth(ELimbType* OutLimbType) const;
	bool IsAnyLimbBelowFullHealth(ELimbType* OutLimbType) const;
	bool IsAnyLimbBroken(ELimbType* OutLimbType) const;
	bool IsIncapacitated() const;
	bool IsIncapacitationEnabled() const;
	bool IsLimbBroken(const ELimbType& Limb) const;
	bool IsLimbFullHealth(const ELimbType& Limb) const;
	bool IsLimbHealthAbove(const ELimbType& Limb, float HealthValue) const;
	bool IsLimbHealthAt(const ELimbType& Limb, float HealthValue) const;
	bool IsLimbHealthAtOrAbove(const ELimbType& Limb, float HealthValue) const;
	bool IsLimbHealthAtOrBelow(const ELimbType& Limb, float HealthValue) const;
	bool IsLimbHealthBelow(const ELimbType& Limb, float HealthValue) const;
	bool IsLimbLowHealth(const ELimbType& Limb) const;
	bool IsLimbNoHealth(const ELimbType& Limb) const;
	bool IsReviveHealthDepleted() const;
	bool IsUsingUnlimitedRevives() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterHealthComponent">();
	}
	static class UCharacterHealthComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterHealthComponent>();
	}
};
static_assert(alignof(UCharacterHealthComponent) == 0x000008, "Wrong alignment on UCharacterHealthComponent");
static_assert(sizeof(UCharacterHealthComponent) == 0x000288, "Wrong size on UCharacterHealthComponent");
static_assert(offsetof(UCharacterHealthComponent, OnLimbFullHealth) == 0x0000F8, "Member 'UCharacterHealthComponent::OnLimbFullHealth' has a wrong offset!");
static_assert(offsetof(UCharacterHealthComponent, OnLimbLowHealth) == 0x000108, "Member 'UCharacterHealthComponent::OnLimbLowHealth' has a wrong offset!");
static_assert(offsetof(UCharacterHealthComponent, OnLimbNoHealth) == 0x000118, "Member 'UCharacterHealthComponent::OnLimbNoHealth' has a wrong offset!");
static_assert(offsetof(UCharacterHealthComponent, OnLimbBroken) == 0x000128, "Member 'UCharacterHealthComponent::OnLimbBroken' has a wrong offset!");
static_assert(offsetof(UCharacterHealthComponent, OnLimbFullTickets) == 0x000138, "Member 'UCharacterHealthComponent::OnLimbFullTickets' has a wrong offset!");
static_assert(offsetof(UCharacterHealthComponent, OnLimbNoTickets) == 0x000148, "Member 'UCharacterHealthComponent::OnLimbNoTickets' has a wrong offset!");
static_assert(offsetof(UCharacterHealthComponent, HealthStatus) == 0x000158, "Member 'UCharacterHealthComponent::HealthStatus' has a wrong offset!");
static_assert(offsetof(UCharacterHealthComponent, IncapacitationHealthMultiplier) == 0x00015C, "Member 'UCharacterHealthComponent::IncapacitationHealthMultiplier' has a wrong offset!");
static_assert(offsetof(UCharacterHealthComponent, RightLeg) == 0x000160, "Member 'UCharacterHealthComponent::RightLeg' has a wrong offset!");
static_assert(offsetof(UCharacterHealthComponent, LeftLeg) == 0x000194, "Member 'UCharacterHealthComponent::LeftLeg' has a wrong offset!");
static_assert(offsetof(UCharacterHealthComponent, RightArm) == 0x0001C8, "Member 'UCharacterHealthComponent::RightArm' has a wrong offset!");
static_assert(offsetof(UCharacterHealthComponent, LeftArm) == 0x0001FC, "Member 'UCharacterHealthComponent::LeftArm' has a wrong offset!");
static_assert(offsetof(UCharacterHealthComponent, Head) == 0x000230, "Member 'UCharacterHealthComponent::Head' has a wrong offset!");
static_assert(offsetof(UCharacterHealthComponent, MaxRevives) == 0x000268, "Member 'UCharacterHealthComponent::MaxRevives' has a wrong offset!");
static_assert(offsetof(UCharacterHealthComponent, ReviveTime) == 0x00026C, "Member 'UCharacterHealthComponent::ReviveTime' has a wrong offset!");
static_assert(offsetof(UCharacterHealthComponent, ReviveTimeDecrement) == 0x000270, "Member 'UCharacterHealthComponent::ReviveTimeDecrement' has a wrong offset!");
static_assert(offsetof(UCharacterHealthComponent, ReviveOperatingTime) == 0x000274, "Member 'UCharacterHealthComponent::ReviveOperatingTime' has a wrong offset!");
static_assert(offsetof(UCharacterHealthComponent, MaxReviveHealth) == 0x000278, "Member 'UCharacterHealthComponent::MaxReviveHealth' has a wrong offset!");
static_assert(offsetof(UCharacterHealthComponent, RemainingRevives) == 0x00027C, "Member 'UCharacterHealthComponent::RemainingRevives' has a wrong offset!");
static_assert(offsetof(UCharacterHealthComponent, RemainingReviveTime) == 0x000280, "Member 'UCharacterHealthComponent::RemainingReviveTime' has a wrong offset!");
static_assert(offsetof(UCharacterHealthComponent, RemainingReviveHealth) == 0x000284, "Member 'UCharacterHealthComponent::RemainingReviveHealth' has a wrong offset!");

// Class ReadyOrNot.ReplaySpringArm
// 0x0000 (0x03A0 - 0x03A0)
class UReplaySpringArm final : public USpringArmComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReplaySpringArm">();
	}
	static class UReplaySpringArm* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReplaySpringArm>();
	}
};
static_assert(alignof(UReplaySpringArm) == 0x000010, "Wrong alignment on UReplaySpringArm");
static_assert(sizeof(UReplaySpringArm) == 0x0003A0, "Wrong size on UReplaySpringArm");

// Class ReadyOrNot.AG_IsRunningSquadRole
// 0x0020 (0x0048 - 0x0028)
class UAG_IsRunningSquadRole final : public UAIActionGate
{
public:
	struct FGameplayTagContainer                  SquadRolesToCheck;                                 // 0x0028(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, ExposeOnSpawn, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AG_IsRunningSquadRole">();
	}
	static class UAG_IsRunningSquadRole* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAG_IsRunningSquadRole>();
	}
};
static_assert(alignof(UAG_IsRunningSquadRole) == 0x000008, "Wrong alignment on UAG_IsRunningSquadRole");
static_assert(sizeof(UAG_IsRunningSquadRole) == 0x000048, "Wrong size on UAG_IsRunningSquadRole");
static_assert(offsetof(UAG_IsRunningSquadRole, SquadRolesToCheck) == 0x000028, "Member 'UAG_IsRunningSquadRole::SquadRolesToCheck' has a wrong offset!");

// Class ReadyOrNot.FootstepFoleyComponent
// 0x0020 (0x05D0 - 0x05B0)
class UFootstepFoleyComponent final : public UBoxComponent
{
public:
	class UFMODEvent*                             SetEventTo;                                        // 0x05B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             SetEventToRemote;                                  // 0x05B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayOnPlayer;                                     // 0x05C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayEveryStep;                                    // 0x05C1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C2[0xE];                                      // 0x05C2(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void StartedOverlapping(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void StoppedOverlapping(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FootstepFoleyComponent">();
	}
	static class UFootstepFoleyComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFootstepFoleyComponent>();
	}
};
static_assert(alignof(UFootstepFoleyComponent) == 0x000010, "Wrong alignment on UFootstepFoleyComponent");
static_assert(sizeof(UFootstepFoleyComponent) == 0x0005D0, "Wrong size on UFootstepFoleyComponent");
static_assert(offsetof(UFootstepFoleyComponent, SetEventTo) == 0x0005B0, "Member 'UFootstepFoleyComponent::SetEventTo' has a wrong offset!");
static_assert(offsetof(UFootstepFoleyComponent, SetEventToRemote) == 0x0005B8, "Member 'UFootstepFoleyComponent::SetEventToRemote' has a wrong offset!");
static_assert(offsetof(UFootstepFoleyComponent, bPlayOnPlayer) == 0x0005C0, "Member 'UFootstepFoleyComponent::bPlayOnPlayer' has a wrong offset!");
static_assert(offsetof(UFootstepFoleyComponent, bPlayEveryStep) == 0x0005C1, "Member 'UFootstepFoleyComponent::bPlayEveryStep' has a wrong offset!");

// Class ReadyOrNot.AG_IsSquadRunningActivity
// 0x0020 (0x0048 - 0x0028)
class UAG_IsSquadRunningActivity final : public UAIActionGate
{
public:
	struct FGameplayTagContainer                  SquadActivitiesToCheck;                            // 0x0028(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, ExposeOnSpawn, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AG_IsSquadRunningActivity">();
	}
	static class UAG_IsSquadRunningActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAG_IsSquadRunningActivity>();
	}
};
static_assert(alignof(UAG_IsSquadRunningActivity) == 0x000008, "Wrong alignment on UAG_IsSquadRunningActivity");
static_assert(sizeof(UAG_IsSquadRunningActivity) == 0x000048, "Wrong size on UAG_IsSquadRunningActivity");
static_assert(offsetof(UAG_IsSquadRunningActivity, SquadActivitiesToCheck) == 0x000028, "Member 'UAG_IsSquadRunningActivity::SquadActivitiesToCheck' has a wrong offset!");

// Class ReadyOrNot.GamepadCommandWheelControlScheme
// 0x0290 (0x06A0 - 0x0410)
class UGamepadCommandWheelControlScheme : public UCommonActivatableWidget
{
public:
	class UWidgetSwitcher*                        WidgetSwitcher;                                    // 0x0410(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         LastUsedControllerIndex;                           // 0x0418(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_41C[0x4];                                      // 0x041C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextBlock*                             txt_XBox_LeftStick;                                // 0x0420(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_XBox_LeftStickPress;                           // 0x0428(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 LinesXBox_LeftStick;                               // 0x0430(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ButtonXBox_LeftStick;                              // 0x0438(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ButtonXBox_LeftStickPress;                         // 0x0440(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_XBox_RB;                                       // 0x0448(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_XBox_RB_Confirm;                               // 0x0450(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_XBox_Dpad_Up;                                  // 0x0458(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_XBox_Dpad_Right;                               // 0x0460(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_XBox_Dpad_Down;                                // 0x0468(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_XBox_Dpad_Left;                                // 0x0470(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 LinesXBox_RB;                                      // 0x0478(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ButtonXBox_RB;                                     // 0x0480(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 LinesXBox_Dpad;                                    // 0x0488(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ButtonXbox_Dpad_Up;                                // 0x0490(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ButtonXbox_Dpad_Right;                             // 0x0498(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ButtonXbox_Dpad_Down;                              // 0x04A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ButtonXbox_Dpad_Left;                              // 0x04A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_XBox_RightStick;                               // 0x04B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_XBox_RightStickPress;                          // 0x04B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 LinesXBox_RightStick;                              // 0x04C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ButtonXBox_RightStick;                             // 0x04C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ButtonXBox_RightStickPress;                        // 0x04D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_XBox_LB;                                       // 0x04D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_XBox_LB_Confirm;                               // 0x04E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_XBox_Y;                                        // 0x04E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_XBox_B;                                        // 0x04F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_XBox_A;                                        // 0x04F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_XBox_X;                                        // 0x0500(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 LinesXBox_LB;                                      // 0x0508(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ButtonXBox_LB;                                     // 0x0510(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 LinesXBox_FaceButtons;                             // 0x0518(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ButtonXbox_Y;                                      // 0x0520(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ButtonXbox_B;                                      // 0x0528(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ButtonXbox_A;                                      // 0x0530(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ButtonXbox_X;                                      // 0x0538(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_PS5_RightStick;                                // 0x0540(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_PS5_R3;                                        // 0x0548(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ButtonPS5_RightStick;                              // 0x0550(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ButtonPS5_R3;                                      // 0x0558(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_PS5_L1;                                        // 0x0560(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_PS5_L1_Confirm;                                // 0x0568(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_PS5_DirCross_Up;                               // 0x0570(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_PS5_DirCross_Right;                            // 0x0578(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_PS5_DirCross_Down;                             // 0x0580(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_PS5_DirCross_Left;                             // 0x0588(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 LinesPS5_R1;                                       // 0x0590(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ButtonPS5_R1;                                      // 0x0598(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 LinesPS5_DirCross;                                 // 0x05A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                ButtonsPS5_DirCross;                               // 0x05A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_PS5_LeftStick;                                 // 0x05B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_PS5_L3;                                        // 0x05B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 LinesPS5_LeftStick;                                // 0x05C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ButtonPS5_LeftStick;                               // 0x05C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ButtonPS5_L3;                                      // 0x05D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 LinesPS5_RightStick;                               // 0x05D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_PS5_R1;                                        // 0x05E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_PS5_R1_Confirm;                                // 0x05E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_PS5_Triangle;                                  // 0x05F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_PS5_Circle;                                    // 0x05F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_PS5_Cross;                                     // 0x0600(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_PS5_Square;                                    // 0x0608(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                LinesPS5_L1;                                       // 0x0610(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ButtonPS5_L1;                                      // 0x0618(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                ButtonsPS5_FaceButtons;                            // 0x0620(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 LinesPS5_FaceButtons;                              // 0x0628(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_630[0x70];                                     // 0x0630(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GamepadCommandWheelControlScheme">();
	}
	static class UGamepadCommandWheelControlScheme* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGamepadCommandWheelControlScheme>();
	}
};
static_assert(alignof(UGamepadCommandWheelControlScheme) == 0x000008, "Wrong alignment on UGamepadCommandWheelControlScheme");
static_assert(sizeof(UGamepadCommandWheelControlScheme) == 0x0006A0, "Wrong size on UGamepadCommandWheelControlScheme");
static_assert(offsetof(UGamepadCommandWheelControlScheme, WidgetSwitcher) == 0x000410, "Member 'UGamepadCommandWheelControlScheme::WidgetSwitcher' has a wrong offset!");
static_assert(offsetof(UGamepadCommandWheelControlScheme, LastUsedControllerIndex) == 0x000418, "Member 'UGamepadCommandWheelControlScheme::LastUsedControllerIndex' has a wrong offset!");
static_assert(offsetof(UGamepadCommandWheelControlScheme, txt_XBox_LeftStick) == 0x000420, "Member 'UGamepadCommandWheelControlScheme::txt_XBox_LeftStick' has a wrong offset!");
static_assert(offsetof(UGamepadCommandWheelControlScheme, txt_XBox_LeftStickPress) == 0x000428, "Member 'UGamepadCommandWheelControlScheme::txt_XBox_LeftStickPress' has a wrong offset!");
static_assert(offsetof(UGamepadCommandWheelControlScheme, LinesXBox_LeftStick) == 0x000430, "Member 'UGamepadCommandWheelControlScheme::LinesXBox_LeftStick' has a wrong offset!");
static_assert(offsetof(UGamepadCommandWheelControlScheme, ButtonXBox_LeftStick) == 0x000438, "Member 'UGamepadCommandWheelControlScheme::ButtonXBox_LeftStick' has a wrong offset!");
static_assert(offsetof(UGamepadCommandWheelControlScheme, ButtonXBox_LeftStickPress) == 0x000440, "Member 'UGamepadCommandWheelControlScheme::ButtonXBox_LeftStickPress' has a wrong offset!");
static_assert(offsetof(UGamepadCommandWheelControlScheme, txt_XBox_RB) == 0x000448, "Member 'UGamepadCommandWheelControlScheme::txt_XBox_RB' has a wrong offset!");
static_assert(offsetof(UGamepadCommandWheelControlScheme, txt_XBox_RB_Confirm) == 0x000450, "Member 'UGamepadCommandWheelControlScheme::txt_XBox_RB_Confirm' has a wrong offset!");
static_assert(offsetof(UGamepadCommandWheelControlScheme, txt_XBox_Dpad_Up) == 0x000458, "Member 'UGamepadCommandWheelControlScheme::txt_XBox_Dpad_Up' has a wrong offset!");
static_assert(offsetof(UGamepadCommandWheelControlScheme, txt_XBox_Dpad_Right) == 0x000460, "Member 'UGamepadCommandWheelControlScheme::txt_XBox_Dpad_Right' has a wrong offset!");
static_assert(offsetof(UGamepadCommandWheelControlScheme, txt_XBox_Dpad_Down) == 0x000468, "Member 'UGamepadCommandWheelControlScheme::txt_XBox_Dpad_Down' has a wrong offset!");
static_assert(offsetof(UGamepadCommandWheelControlScheme, txt_XBox_Dpad_Left) == 0x000470, "Member 'UGamepadCommandWheelControlScheme::txt_XBox_Dpad_Left' has a wrong offset!");
static_assert(offsetof(UGamepadCommandWheelControlScheme, LinesXBox_RB) == 0x000478, "Member 'UGamepadCommandWheelControlScheme::LinesXBox_RB' has a wrong offset!");
static_assert(offsetof(UGamepadCommandWheelControlScheme, ButtonXBox_RB) == 0x000480, "Member 'UGamepadCommandWheelControlScheme::ButtonXBox_RB' has a wrong offset!");
static_assert(offsetof(UGamepadCommandWheelControlScheme, LinesXBox_Dpad) == 0x000488, "Member 'UGamepadCommandWheelControlScheme::LinesXBox_Dpad' has a wrong offset!");
static_assert(offsetof(UGamepadCommandWheelControlScheme, ButtonXbox_Dpad_Up) == 0x000490, "Member 'UGamepadCommandWheelControlScheme::ButtonXbox_Dpad_Up' has a wrong offset!");
static_assert(offsetof(UGamepadCommandWheelControlScheme, ButtonXbox_Dpad_Right) == 0x000498, "Member 'UGamepadCommandWheelControlScheme::ButtonXbox_Dpad_Right' has a wrong offset!");
static_assert(offsetof(UGamepadCommandWheelControlScheme, ButtonXbox_Dpad_Down) == 0x0004A0, "Member 'UGamepadCommandWheelControlScheme::ButtonXbox_Dpad_Down' has a wrong offset!");
static_assert(offsetof(UGamepadCommandWheelControlScheme, ButtonXbox_Dpad_Left) == 0x0004A8, "Member 'UGamepadCommandWheelControlScheme::ButtonXbox_Dpad_Left' has a wrong offset!");
static_assert(offsetof(UGamepadCommandWheelControlScheme, txt_XBox_RightStick) == 0x0004B0, "Member 'UGamepadCommandWheelControlScheme::txt_XBox_RightStick' has a wrong offset!");
static_assert(offsetof(UGamepadCommandWheelControlScheme, txt_XBox_RightStickPress) == 0x0004B8, "Member 'UGamepadCommandWheelControlScheme::txt_XBox_RightStickPress' has a wrong offset!");
static_assert(offsetof(UGamepadCommandWheelControlScheme, LinesXBox_RightStick) == 0x0004C0, "Member 'UGamepadCommandWheelControlScheme::LinesXBox_RightStick' has a wrong offset!");
static_assert(offsetof(UGamepadCommandWheelControlScheme, ButtonXBox_RightStick) == 0x0004C8, "Member 'UGamepadCommandWheelControlScheme::ButtonXBox_RightStick' has a wrong offset!");
static_assert(offsetof(UGamepadCommandWheelControlScheme, ButtonXBox_RightStickPress) == 0x0004D0, "Member 'UGamepadCommandWheelControlScheme::ButtonXBox_RightStickPress' has a wrong offset!");
static_assert(offsetof(UGamepadCommandWheelControlScheme, txt_XBox_LB) == 0x0004D8, "Member 'UGamepadCommandWheelControlScheme::txt_XBox_LB' has a wrong offset!");
static_assert(offsetof(UGamepadCommandWheelControlScheme, txt_XBox_LB_Confirm) == 0x0004E0, "Member 'UGamepadCommandWheelControlScheme::txt_XBox_LB_Confirm' has a wrong offset!");
static_assert(offsetof(UGamepadCommandWheelControlScheme, txt_XBox_Y) == 0x0004E8, "Member 'UGamepadCommandWheelControlScheme::txt_XBox_Y' has a wrong offset!");
static_assert(offsetof(UGamepadCommandWheelControlScheme, txt_XBox_B) == 0x0004F0, "Member 'UGamepadCommandWheelControlScheme::txt_XBox_B' has a wrong offset!");
static_assert(offsetof(UGamepadCommandWheelControlScheme, txt_XBox_A) == 0x0004F8, "Member 'UGamepadCommandWheelControlScheme::txt_XBox_A' has a wrong offset!");
static_assert(offsetof(UGamepadCommandWheelControlScheme, txt_XBox_X) == 0x000500, "Member 'UGamepadCommandWheelControlScheme::txt_XBox_X' has a wrong offset!");
static_assert(offsetof(UGamepadCommandWheelControlScheme, LinesXBox_LB) == 0x000508, "Member 'UGamepadCommandWheelControlScheme::LinesXBox_LB' has a wrong offset!");
static_assert(offsetof(UGamepadCommandWheelControlScheme, ButtonXBox_LB) == 0x000510, "Member 'UGamepadCommandWheelControlScheme::ButtonXBox_LB' has a wrong offset!");
static_assert(offsetof(UGamepadCommandWheelControlScheme, LinesXBox_FaceButtons) == 0x000518, "Member 'UGamepadCommandWheelControlScheme::LinesXBox_FaceButtons' has a wrong offset!");
static_assert(offsetof(UGamepadCommandWheelControlScheme, ButtonXbox_Y) == 0x000520, "Member 'UGamepadCommandWheelControlScheme::ButtonXbox_Y' has a wrong offset!");
static_assert(offsetof(UGamepadCommandWheelControlScheme, ButtonXbox_B) == 0x000528, "Member 'UGamepadCommandWheelControlScheme::ButtonXbox_B' has a wrong offset!");
static_assert(offsetof(UGamepadCommandWheelControlScheme, ButtonXbox_A) == 0x000530, "Member 'UGamepadCommandWheelControlScheme::ButtonXbox_A' has a wrong offset!");
static_assert(offsetof(UGamepadCommandWheelControlScheme, ButtonXbox_X) == 0x000538, "Member 'UGamepadCommandWheelControlScheme::ButtonXbox_X' has a wrong offset!");
static_assert(offsetof(UGamepadCommandWheelControlScheme, txt_PS5_RightStick) == 0x000540, "Member 'UGamepadCommandWheelControlScheme::txt_PS5_RightStick' has a wrong offset!");
static_assert(offsetof(UGamepadCommandWheelControlScheme, txt_PS5_R3) == 0x000548, "Member 'UGamepadCommandWheelControlScheme::txt_PS5_R3' has a wrong offset!");
static_assert(offsetof(UGamepadCommandWheelControlScheme, ButtonPS5_RightStick) == 0x000550, "Member 'UGamepadCommandWheelControlScheme::ButtonPS5_RightStick' has a wrong offset!");
static_assert(offsetof(UGamepadCommandWheelControlScheme, ButtonPS5_R3) == 0x000558, "Member 'UGamepadCommandWheelControlScheme::ButtonPS5_R3' has a wrong offset!");
static_assert(offsetof(UGamepadCommandWheelControlScheme, txt_PS5_L1) == 0x000560, "Member 'UGamepadCommandWheelControlScheme::txt_PS5_L1' has a wrong offset!");
static_assert(offsetof(UGamepadCommandWheelControlScheme, txt_PS5_L1_Confirm) == 0x000568, "Member 'UGamepadCommandWheelControlScheme::txt_PS5_L1_Confirm' has a wrong offset!");
static_assert(offsetof(UGamepadCommandWheelControlScheme, txt_PS5_DirCross_Up) == 0x000570, "Member 'UGamepadCommandWheelControlScheme::txt_PS5_DirCross_Up' has a wrong offset!");
static_assert(offsetof(UGamepadCommandWheelControlScheme, txt_PS5_DirCross_Right) == 0x000578, "Member 'UGamepadCommandWheelControlScheme::txt_PS5_DirCross_Right' has a wrong offset!");
static_assert(offsetof(UGamepadCommandWheelControlScheme, txt_PS5_DirCross_Down) == 0x000580, "Member 'UGamepadCommandWheelControlScheme::txt_PS5_DirCross_Down' has a wrong offset!");
static_assert(offsetof(UGamepadCommandWheelControlScheme, txt_PS5_DirCross_Left) == 0x000588, "Member 'UGamepadCommandWheelControlScheme::txt_PS5_DirCross_Left' has a wrong offset!");
static_assert(offsetof(UGamepadCommandWheelControlScheme, LinesPS5_R1) == 0x000590, "Member 'UGamepadCommandWheelControlScheme::LinesPS5_R1' has a wrong offset!");
static_assert(offsetof(UGamepadCommandWheelControlScheme, ButtonPS5_R1) == 0x000598, "Member 'UGamepadCommandWheelControlScheme::ButtonPS5_R1' has a wrong offset!");
static_assert(offsetof(UGamepadCommandWheelControlScheme, LinesPS5_DirCross) == 0x0005A0, "Member 'UGamepadCommandWheelControlScheme::LinesPS5_DirCross' has a wrong offset!");
static_assert(offsetof(UGamepadCommandWheelControlScheme, ButtonsPS5_DirCross) == 0x0005A8, "Member 'UGamepadCommandWheelControlScheme::ButtonsPS5_DirCross' has a wrong offset!");
static_assert(offsetof(UGamepadCommandWheelControlScheme, txt_PS5_LeftStick) == 0x0005B0, "Member 'UGamepadCommandWheelControlScheme::txt_PS5_LeftStick' has a wrong offset!");
static_assert(offsetof(UGamepadCommandWheelControlScheme, txt_PS5_L3) == 0x0005B8, "Member 'UGamepadCommandWheelControlScheme::txt_PS5_L3' has a wrong offset!");
static_assert(offsetof(UGamepadCommandWheelControlScheme, LinesPS5_LeftStick) == 0x0005C0, "Member 'UGamepadCommandWheelControlScheme::LinesPS5_LeftStick' has a wrong offset!");
static_assert(offsetof(UGamepadCommandWheelControlScheme, ButtonPS5_LeftStick) == 0x0005C8, "Member 'UGamepadCommandWheelControlScheme::ButtonPS5_LeftStick' has a wrong offset!");
static_assert(offsetof(UGamepadCommandWheelControlScheme, ButtonPS5_L3) == 0x0005D0, "Member 'UGamepadCommandWheelControlScheme::ButtonPS5_L3' has a wrong offset!");
static_assert(offsetof(UGamepadCommandWheelControlScheme, LinesPS5_RightStick) == 0x0005D8, "Member 'UGamepadCommandWheelControlScheme::LinesPS5_RightStick' has a wrong offset!");
static_assert(offsetof(UGamepadCommandWheelControlScheme, txt_PS5_R1) == 0x0005E0, "Member 'UGamepadCommandWheelControlScheme::txt_PS5_R1' has a wrong offset!");
static_assert(offsetof(UGamepadCommandWheelControlScheme, txt_PS5_R1_Confirm) == 0x0005E8, "Member 'UGamepadCommandWheelControlScheme::txt_PS5_R1_Confirm' has a wrong offset!");
static_assert(offsetof(UGamepadCommandWheelControlScheme, txt_PS5_Triangle) == 0x0005F0, "Member 'UGamepadCommandWheelControlScheme::txt_PS5_Triangle' has a wrong offset!");
static_assert(offsetof(UGamepadCommandWheelControlScheme, txt_PS5_Circle) == 0x0005F8, "Member 'UGamepadCommandWheelControlScheme::txt_PS5_Circle' has a wrong offset!");
static_assert(offsetof(UGamepadCommandWheelControlScheme, txt_PS5_Cross) == 0x000600, "Member 'UGamepadCommandWheelControlScheme::txt_PS5_Cross' has a wrong offset!");
static_assert(offsetof(UGamepadCommandWheelControlScheme, txt_PS5_Square) == 0x000608, "Member 'UGamepadCommandWheelControlScheme::txt_PS5_Square' has a wrong offset!");
static_assert(offsetof(UGamepadCommandWheelControlScheme, LinesPS5_L1) == 0x000610, "Member 'UGamepadCommandWheelControlScheme::LinesPS5_L1' has a wrong offset!");
static_assert(offsetof(UGamepadCommandWheelControlScheme, ButtonPS5_L1) == 0x000618, "Member 'UGamepadCommandWheelControlScheme::ButtonPS5_L1' has a wrong offset!");
static_assert(offsetof(UGamepadCommandWheelControlScheme, ButtonsPS5_FaceButtons) == 0x000620, "Member 'UGamepadCommandWheelControlScheme::ButtonsPS5_FaceButtons' has a wrong offset!");
static_assert(offsetof(UGamepadCommandWheelControlScheme, LinesPS5_FaceButtons) == 0x000628, "Member 'UGamepadCommandWheelControlScheme::LinesPS5_FaceButtons' has a wrong offset!");

// Class ReadyOrNot.CharacterStatusWidget
// 0x0010 (0x0420 - 0x0410)
class UCharacterStatusWidget : public UCommonActivatableWidget
{
public:
	TArray<class UCharacterProxy*>                CharacterProxies;                                  // 0x0410(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	const TArray<class UCharacterProxy*> GetCharacterProxies();
	void OnCharacterAdded(class UCharacterProxy* CharacterProxy);
	void OnCharacterRemoved(class UCharacterProxy* CharacterProxy);
	void RefreshPlayers();
	void SwapTeams();

	bool CanSwapTeams() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterStatusWidget">();
	}
	static class UCharacterStatusWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterStatusWidget>();
	}
};
static_assert(alignof(UCharacterStatusWidget) == 0x000008, "Wrong alignment on UCharacterStatusWidget");
static_assert(sizeof(UCharacterStatusWidget) == 0x000420, "Wrong size on UCharacterStatusWidget");
static_assert(offsetof(UCharacterStatusWidget, CharacterProxies) == 0x000410, "Member 'UCharacterStatusWidget::CharacterProxies' has a wrong offset!");

// Class ReadyOrNot.ExfilPortal
// 0x0050 (0x02E8 - 0x0298)
class AExfilPortal : public AActor
{
public:
	uint8                                         Pad_298[0x10];                                     // 0x0298(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractableComponent*                 InteractableComponent;                             // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UScoringComponent*                      ScoringComponent;                                  // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          CollisionComponent;                                // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class ASWATCharacter*>                 OverlappingSwatMembers;                            // 0x02C0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<class UStaticMeshComponent*>           CompsToOutline;                                    // 0x02D0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E0[0x1];                                      // 0x02E0(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bShowWarningDialogue;                              // 0x02E1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E2[0x6];                                      // 0x02E2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActorBeginOverlap(class AActor* OverlappedActor, class AActor* OtherActor);
	void ActorEndOverlap(class AActor* OverlappedActor, class AActor* OtherActor);
	void ExfiltrateMission();
	void MulticastEnableExfil(bool bEnable);
	void OnExfilEnabledChange(bool bEnabled);
	void OnExfilSwatMemberKilled(class AReadyOrNotCharacter* Killer, class AReadyOrNotCharacter* KilledMember);
	void OnMissionSoftComplete();
	void OnPlayerInteracted();
	void ServerTriggerExfil();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExfilPortal">();
	}
	static class AExfilPortal* GetDefaultObj()
	{
		return GetDefaultObjImpl<AExfilPortal>();
	}
};
static_assert(alignof(AExfilPortal) == 0x000008, "Wrong alignment on AExfilPortal");
static_assert(sizeof(AExfilPortal) == 0x0002E8, "Wrong size on AExfilPortal");
static_assert(offsetof(AExfilPortal, InteractableComponent) == 0x0002A8, "Member 'AExfilPortal::InteractableComponent' has a wrong offset!");
static_assert(offsetof(AExfilPortal, ScoringComponent) == 0x0002B0, "Member 'AExfilPortal::ScoringComponent' has a wrong offset!");
static_assert(offsetof(AExfilPortal, CollisionComponent) == 0x0002B8, "Member 'AExfilPortal::CollisionComponent' has a wrong offset!");
static_assert(offsetof(AExfilPortal, OverlappingSwatMembers) == 0x0002C0, "Member 'AExfilPortal::OverlappingSwatMembers' has a wrong offset!");
static_assert(offsetof(AExfilPortal, CompsToOutline) == 0x0002D0, "Member 'AExfilPortal::CompsToOutline' has a wrong offset!");
static_assert(offsetof(AExfilPortal, bShowWarningDialogue) == 0x0002E1, "Member 'AExfilPortal::bShowWarningDialogue' has a wrong offset!");

// Class ReadyOrNot.ReadyOrNotAnimInstance
// 0x0250 (0x05A0 - 0x0350)
#pragma pack(push, 0x1)
class alignas(0x10) UReadyOrNotAnimInstance : public UAnimInstance
{
public:
	uint8                                         Pad_348[0x8];                                      // 0x0348(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Velocity;                                          // 0x0350(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x0368(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedHorizontal;                                   // 0x036C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedVertical;                                     // 0x0370(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed;                                          // 0x0374(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Direction;                                         // 0x0378(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ViewPitch;                                         // 0x037C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ViewYaw;                                           // 0x0380(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMoving;                                         // 0x0384(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInAir;                                          // 0x0385(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_386[0x2];                                      // 0x0386(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               HeadLookRotation;                                  // 0x0388(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             ActorTransform;                                    // 0x03A0(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VelocityLocalNormalized;                           // 0x0400(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMoveDirection                                CurrentDirection;                                  // 0x0418(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_419[0x7];                                      // 0x0419(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 WalkSpeedDatabase;                                 // 0x0420(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 JogSpeedDatabase;                                  // 0x0430(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 CrouchWalkSpeedDatabase;                           // 0x0440(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         DirDegreesPerSecond;                               // 0x0450(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForwardDirAngle;                                   // 0x0454(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BackwardDirAngle;                                  // 0x0458(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftDirAngle;                                      // 0x045C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightDirAngle;                                     // 0x0460(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForwardDirDeg;                                     // 0x0464(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BackwardDirDeg;                                    // 0x0468(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftDirDeg;                                        // 0x046C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightDirDeg;                                       // 0x0470(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StrafeForwardDir;                                  // 0x0474(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StrafeBackwardDir;                                 // 0x0478(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StrafeLeftDir;                                     // 0x047C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StrafeRightDir;                                    // 0x0480(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementAlpha;                                     // 0x0484(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementJogAlpha;                                  // 0x0488(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementJogThreshold;                              // 0x048C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LeftFootIKLocation;                                // 0x0490(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightFootIKLocation;                               // 0x04A8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               LeftFootIKRotation;                                // 0x04C0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               RightFootIKRotation;                               // 0x04D8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                HipOffsetVector;                                   // 0x04F0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCrouching;                                        // 0x0508(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsStopping;                                       // 0x0509(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_50A[0x6];                                      // 0x050A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               HeadRotation;                                      // 0x0510(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FCarryArrestedAnimState                CarryArrestedAnimState;                            // 0x0528(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsCarried;                                        // 0x0530(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCarrying;                                       // 0x0531(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMotionBlockType                              CurMotionBlock;                                    // 0x0532(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFalling;                                        // 0x0533(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasPrelanded;                                     // 0x0534(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bJumpRecoveryActive;                               // 0x0535(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_536[0x2];                                      // 0x0536(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         JumpRecoveryAnimTime;                              // 0x0538(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpRecoveryStrength;                              // 0x053C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpRecoveryTime;                                  // 0x0540(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_544[0xC];                                      // 0x0544(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DirAngle;                                          // 0x0550(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DirAngleDegrees;                                   // 0x0554(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMoveDirectionExt                             CurrentDirectionExt;                               // 0x0558(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTeamMLO;                                        // 0x0559(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55A[0x2];                                      // 0x055A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LeftHandIKAlpha;                                   // 0x055C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SprintAlpha;                                       // 0x0560(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDeployableEquipped;                             // 0x0564(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPistol;                                         // 0x0565(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRifle;                                          // 0x0566(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsItem;                                           // 0x0567(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bItemOneHanded;                                    // 0x0568(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsC2Charge;                                       // 0x0569(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLevel1MovementTrigger;                            // 0x056A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLevel2MovementTrigger;                            // 0x056B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLevel3MovementTrigger;                            // 0x056C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCrouchLevel1MovementTrigger;                      // 0x056D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRotationRateReached;                              // 0x056E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_56F[0x1];                                      // 0x056F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DeltaRotation;                                     // 0x0570(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_574[0x1C];                                     // 0x0574(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SprintFPAlpha;                                     // 0x0590(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PelvisMovementBobAlpha;                            // 0x0594(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	EMoveDirectionExt GetCurrentDirectionExtFromYawAngle(float YawAngle);
	struct FRotator GetLookAtRotation();
	EMoveDirectionExt GetOppositeDirectionExt(EMoveDirectionExt CurrentDir);
	float GetWeightFromSlot(class FName SlotName);
	float GetWeightFromSlotInversed(class FName SlotName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotAnimInstance">();
	}
	static class UReadyOrNotAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotAnimInstance>();
	}
};
#pragma pack(pop)
static_assert(alignof(UReadyOrNotAnimInstance) == 0x000010, "Wrong alignment on UReadyOrNotAnimInstance");
static_assert(sizeof(UReadyOrNotAnimInstance) == 0x0005A0, "Wrong size on UReadyOrNotAnimInstance");
static_assert(offsetof(UReadyOrNotAnimInstance, Velocity) == 0x000350, "Member 'UReadyOrNotAnimInstance::Velocity' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, Speed) == 0x000368, "Member 'UReadyOrNotAnimInstance::Speed' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, SpeedHorizontal) == 0x00036C, "Member 'UReadyOrNotAnimInstance::SpeedHorizontal' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, SpeedVertical) == 0x000370, "Member 'UReadyOrNotAnimInstance::SpeedVertical' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, MaxSpeed) == 0x000374, "Member 'UReadyOrNotAnimInstance::MaxSpeed' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, Direction) == 0x000378, "Member 'UReadyOrNotAnimInstance::Direction' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, ViewPitch) == 0x00037C, "Member 'UReadyOrNotAnimInstance::ViewPitch' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, ViewYaw) == 0x000380, "Member 'UReadyOrNotAnimInstance::ViewYaw' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, bIsMoving) == 0x000384, "Member 'UReadyOrNotAnimInstance::bIsMoving' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, bIsInAir) == 0x000385, "Member 'UReadyOrNotAnimInstance::bIsInAir' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, HeadLookRotation) == 0x000388, "Member 'UReadyOrNotAnimInstance::HeadLookRotation' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, ActorTransform) == 0x0003A0, "Member 'UReadyOrNotAnimInstance::ActorTransform' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, VelocityLocalNormalized) == 0x000400, "Member 'UReadyOrNotAnimInstance::VelocityLocalNormalized' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, CurrentDirection) == 0x000418, "Member 'UReadyOrNotAnimInstance::CurrentDirection' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, WalkSpeedDatabase) == 0x000420, "Member 'UReadyOrNotAnimInstance::WalkSpeedDatabase' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, JogSpeedDatabase) == 0x000430, "Member 'UReadyOrNotAnimInstance::JogSpeedDatabase' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, CrouchWalkSpeedDatabase) == 0x000440, "Member 'UReadyOrNotAnimInstance::CrouchWalkSpeedDatabase' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, DirDegreesPerSecond) == 0x000450, "Member 'UReadyOrNotAnimInstance::DirDegreesPerSecond' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, ForwardDirAngle) == 0x000454, "Member 'UReadyOrNotAnimInstance::ForwardDirAngle' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, BackwardDirAngle) == 0x000458, "Member 'UReadyOrNotAnimInstance::BackwardDirAngle' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, LeftDirAngle) == 0x00045C, "Member 'UReadyOrNotAnimInstance::LeftDirAngle' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, RightDirAngle) == 0x000460, "Member 'UReadyOrNotAnimInstance::RightDirAngle' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, ForwardDirDeg) == 0x000464, "Member 'UReadyOrNotAnimInstance::ForwardDirDeg' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, BackwardDirDeg) == 0x000468, "Member 'UReadyOrNotAnimInstance::BackwardDirDeg' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, LeftDirDeg) == 0x00046C, "Member 'UReadyOrNotAnimInstance::LeftDirDeg' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, RightDirDeg) == 0x000470, "Member 'UReadyOrNotAnimInstance::RightDirDeg' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, StrafeForwardDir) == 0x000474, "Member 'UReadyOrNotAnimInstance::StrafeForwardDir' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, StrafeBackwardDir) == 0x000478, "Member 'UReadyOrNotAnimInstance::StrafeBackwardDir' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, StrafeLeftDir) == 0x00047C, "Member 'UReadyOrNotAnimInstance::StrafeLeftDir' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, StrafeRightDir) == 0x000480, "Member 'UReadyOrNotAnimInstance::StrafeRightDir' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, MovementAlpha) == 0x000484, "Member 'UReadyOrNotAnimInstance::MovementAlpha' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, MovementJogAlpha) == 0x000488, "Member 'UReadyOrNotAnimInstance::MovementJogAlpha' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, MovementJogThreshold) == 0x00048C, "Member 'UReadyOrNotAnimInstance::MovementJogThreshold' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, LeftFootIKLocation) == 0x000490, "Member 'UReadyOrNotAnimInstance::LeftFootIKLocation' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, RightFootIKLocation) == 0x0004A8, "Member 'UReadyOrNotAnimInstance::RightFootIKLocation' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, LeftFootIKRotation) == 0x0004C0, "Member 'UReadyOrNotAnimInstance::LeftFootIKRotation' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, RightFootIKRotation) == 0x0004D8, "Member 'UReadyOrNotAnimInstance::RightFootIKRotation' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, HipOffsetVector) == 0x0004F0, "Member 'UReadyOrNotAnimInstance::HipOffsetVector' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, bCrouching) == 0x000508, "Member 'UReadyOrNotAnimInstance::bCrouching' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, bIsStopping) == 0x000509, "Member 'UReadyOrNotAnimInstance::bIsStopping' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, HeadRotation) == 0x000510, "Member 'UReadyOrNotAnimInstance::HeadRotation' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, CarryArrestedAnimState) == 0x000528, "Member 'UReadyOrNotAnimInstance::CarryArrestedAnimState' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, bIsCarried) == 0x000530, "Member 'UReadyOrNotAnimInstance::bIsCarried' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, bIsCarrying) == 0x000531, "Member 'UReadyOrNotAnimInstance::bIsCarrying' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, CurMotionBlock) == 0x000532, "Member 'UReadyOrNotAnimInstance::CurMotionBlock' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, bIsFalling) == 0x000533, "Member 'UReadyOrNotAnimInstance::bIsFalling' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, bHasPrelanded) == 0x000534, "Member 'UReadyOrNotAnimInstance::bHasPrelanded' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, bJumpRecoveryActive) == 0x000535, "Member 'UReadyOrNotAnimInstance::bJumpRecoveryActive' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, JumpRecoveryAnimTime) == 0x000538, "Member 'UReadyOrNotAnimInstance::JumpRecoveryAnimTime' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, JumpRecoveryStrength) == 0x00053C, "Member 'UReadyOrNotAnimInstance::JumpRecoveryStrength' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, JumpRecoveryTime) == 0x000540, "Member 'UReadyOrNotAnimInstance::JumpRecoveryTime' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, DirAngle) == 0x000550, "Member 'UReadyOrNotAnimInstance::DirAngle' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, DirAngleDegrees) == 0x000554, "Member 'UReadyOrNotAnimInstance::DirAngleDegrees' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, CurrentDirectionExt) == 0x000558, "Member 'UReadyOrNotAnimInstance::CurrentDirectionExt' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, bIsTeamMLO) == 0x000559, "Member 'UReadyOrNotAnimInstance::bIsTeamMLO' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, LeftHandIKAlpha) == 0x00055C, "Member 'UReadyOrNotAnimInstance::LeftHandIKAlpha' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, SprintAlpha) == 0x000560, "Member 'UReadyOrNotAnimInstance::SprintAlpha' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, bIsDeployableEquipped) == 0x000564, "Member 'UReadyOrNotAnimInstance::bIsDeployableEquipped' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, bIsPistol) == 0x000565, "Member 'UReadyOrNotAnimInstance::bIsPistol' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, bIsRifle) == 0x000566, "Member 'UReadyOrNotAnimInstance::bIsRifle' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, bIsItem) == 0x000567, "Member 'UReadyOrNotAnimInstance::bIsItem' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, bItemOneHanded) == 0x000568, "Member 'UReadyOrNotAnimInstance::bItemOneHanded' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, bIsC2Charge) == 0x000569, "Member 'UReadyOrNotAnimInstance::bIsC2Charge' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, bLevel1MovementTrigger) == 0x00056A, "Member 'UReadyOrNotAnimInstance::bLevel1MovementTrigger' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, bLevel2MovementTrigger) == 0x00056B, "Member 'UReadyOrNotAnimInstance::bLevel2MovementTrigger' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, bLevel3MovementTrigger) == 0x00056C, "Member 'UReadyOrNotAnimInstance::bLevel3MovementTrigger' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, bCrouchLevel1MovementTrigger) == 0x00056D, "Member 'UReadyOrNotAnimInstance::bCrouchLevel1MovementTrigger' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, bRotationRateReached) == 0x00056E, "Member 'UReadyOrNotAnimInstance::bRotationRateReached' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, DeltaRotation) == 0x000570, "Member 'UReadyOrNotAnimInstance::DeltaRotation' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, SprintFPAlpha) == 0x000590, "Member 'UReadyOrNotAnimInstance::SprintFPAlpha' has a wrong offset!");
static_assert(offsetof(UReadyOrNotAnimInstance, PelvisMovementBobAlpha) == 0x000594, "Member 'UReadyOrNotAnimInstance::PelvisMovementBobAlpha' has a wrong offset!");

// Class ReadyOrNot.RoNAnimInstance_PlayerFP
// 0x00E0 (0x0680 - 0x05A0)
class URoNAnimInstance_PlayerFP : public UReadyOrNotAnimInstance
{
public:
	class UReadyOrNotWeaponAnimData*              LastWeaponAnimData;                                // 0x0598(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReadyOrNotWeaponAnimData*              EditorWeaponAnimData;                              // 0x05A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeanAngleY;                                        // 0x05A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeanAngleZ;                                        // 0x05AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               MeshControlRotation;                               // 0x05B0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                MeshPostureLeanOffset;                             // 0x05C8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MeshWeaponOffset;                                  // 0x05E0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               MeshWeaponRotation;                                // 0x05F8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               MeshWeaponFreeAimRotation;                         // 0x0610(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                MeshWeaponLeanOffset;                              // 0x0628(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               MeshWeaponLeanRotation;                            // 0x0640(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 TPMeshReference;                                   // 0x0658(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LazySpringStrength;                                // 0x0660(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ADS_Movement_Weight;                               // 0x0664(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InteractionSlotAlpha;                              // 0x0668(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultSlotAlpha;                                  // 0x066C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RollMoveInput;                                     // 0x0670(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_674[0xC];                                      // 0x0674(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnC2Detonation();
	void OnHolsterComplete();
	void OnReloadComplete();

	class UAnimSequenceBase* GetPlayerAnimation_FP(EBaseAnimType_FP AnimName) const;
	class UBlendSpace* GetPlayerBlendspace_FP(EBaseBlendspaces_FP BlendspaceName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RoNAnimInstance_PlayerFP">();
	}
	static class URoNAnimInstance_PlayerFP* GetDefaultObj()
	{
		return GetDefaultObjImpl<URoNAnimInstance_PlayerFP>();
	}
};
static_assert(alignof(URoNAnimInstance_PlayerFP) == 0x000010, "Wrong alignment on URoNAnimInstance_PlayerFP");
static_assert(sizeof(URoNAnimInstance_PlayerFP) == 0x000680, "Wrong size on URoNAnimInstance_PlayerFP");
static_assert(offsetof(URoNAnimInstance_PlayerFP, LastWeaponAnimData) == 0x000598, "Member 'URoNAnimInstance_PlayerFP::LastWeaponAnimData' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerFP, EditorWeaponAnimData) == 0x0005A0, "Member 'URoNAnimInstance_PlayerFP::EditorWeaponAnimData' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerFP, LeanAngleY) == 0x0005A8, "Member 'URoNAnimInstance_PlayerFP::LeanAngleY' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerFP, LeanAngleZ) == 0x0005AC, "Member 'URoNAnimInstance_PlayerFP::LeanAngleZ' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerFP, MeshControlRotation) == 0x0005B0, "Member 'URoNAnimInstance_PlayerFP::MeshControlRotation' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerFP, MeshPostureLeanOffset) == 0x0005C8, "Member 'URoNAnimInstance_PlayerFP::MeshPostureLeanOffset' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerFP, MeshWeaponOffset) == 0x0005E0, "Member 'URoNAnimInstance_PlayerFP::MeshWeaponOffset' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerFP, MeshWeaponRotation) == 0x0005F8, "Member 'URoNAnimInstance_PlayerFP::MeshWeaponRotation' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerFP, MeshWeaponFreeAimRotation) == 0x000610, "Member 'URoNAnimInstance_PlayerFP::MeshWeaponFreeAimRotation' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerFP, MeshWeaponLeanOffset) == 0x000628, "Member 'URoNAnimInstance_PlayerFP::MeshWeaponLeanOffset' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerFP, MeshWeaponLeanRotation) == 0x000640, "Member 'URoNAnimInstance_PlayerFP::MeshWeaponLeanRotation' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerFP, TPMeshReference) == 0x000658, "Member 'URoNAnimInstance_PlayerFP::TPMeshReference' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerFP, LazySpringStrength) == 0x000660, "Member 'URoNAnimInstance_PlayerFP::LazySpringStrength' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerFP, ADS_Movement_Weight) == 0x000664, "Member 'URoNAnimInstance_PlayerFP::ADS_Movement_Weight' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerFP, InteractionSlotAlpha) == 0x000668, "Member 'URoNAnimInstance_PlayerFP::InteractionSlotAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerFP, DefaultSlotAlpha) == 0x00066C, "Member 'URoNAnimInstance_PlayerFP::DefaultSlotAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerFP, RollMoveInput) == 0x000670, "Member 'URoNAnimInstance_PlayerFP::RollMoveInput' has a wrong offset!");

// Class ReadyOrNot.AG_TimesInCompliance
// 0x0008 (0x0030 - 0x0028)
class UAG_TimesInCompliance final : public UAIActionGate
{
public:
	int32                                         MaxTimesInCompliance;                              // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AG_TimesInCompliance">();
	}
	static class UAG_TimesInCompliance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAG_TimesInCompliance>();
	}
};
static_assert(alignof(UAG_TimesInCompliance) == 0x000008, "Wrong alignment on UAG_TimesInCompliance");
static_assert(sizeof(UAG_TimesInCompliance) == 0x000030, "Wrong size on UAG_TimesInCompliance");
static_assert(offsetof(UAG_TimesInCompliance, MaxTimesInCompliance) == 0x000028, "Member 'UAG_TimesInCompliance::MaxTimesInCompliance' has a wrong offset!");

// Class ReadyOrNot.FirefightGM
// 0x0060 (0x0A30 - 0x09D0)
class AFirefightGM final : public AReadyOrNotGameMode_PVP
{
public:
	bool                                          bSuddenDeath;                                      // 0x09D0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9D1[0x7];                                      // 0x09D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             TeamKilledSound_SERT_RED;                          // 0x09D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             TeamKilledSound_SERT_BLUE;                         // 0x09E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             MatchLoopMusic;                                    // 0x09E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             MatchStartMusic;                                   // 0x09F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             MatchEndMusic;                                     // 0x09F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSavedLoadout>                  RandomLoadouts;                                    // 0x0A00(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSavedLoadout>                  GeneratedLoadouts;                                 // 0x0A10(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         NumRedSpawned;                                     // 0x0A20(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumBlueSpawned;                                    // 0x0A24(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A28[0x8];                                      // 0x0A28(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetNumberOfActivePlayersOnTeam(ETeamType Team);
	void RegenerateRandomLoadouts();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FirefightGM">();
	}
	static class AFirefightGM* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFirefightGM>();
	}
};
static_assert(alignof(AFirefightGM) == 0x000010, "Wrong alignment on AFirefightGM");
static_assert(sizeof(AFirefightGM) == 0x000A30, "Wrong size on AFirefightGM");
static_assert(offsetof(AFirefightGM, bSuddenDeath) == 0x0009D0, "Member 'AFirefightGM::bSuddenDeath' has a wrong offset!");
static_assert(offsetof(AFirefightGM, TeamKilledSound_SERT_RED) == 0x0009D8, "Member 'AFirefightGM::TeamKilledSound_SERT_RED' has a wrong offset!");
static_assert(offsetof(AFirefightGM, TeamKilledSound_SERT_BLUE) == 0x0009E0, "Member 'AFirefightGM::TeamKilledSound_SERT_BLUE' has a wrong offset!");
static_assert(offsetof(AFirefightGM, MatchLoopMusic) == 0x0009E8, "Member 'AFirefightGM::MatchLoopMusic' has a wrong offset!");
static_assert(offsetof(AFirefightGM, MatchStartMusic) == 0x0009F0, "Member 'AFirefightGM::MatchStartMusic' has a wrong offset!");
static_assert(offsetof(AFirefightGM, MatchEndMusic) == 0x0009F8, "Member 'AFirefightGM::MatchEndMusic' has a wrong offset!");
static_assert(offsetof(AFirefightGM, RandomLoadouts) == 0x000A00, "Member 'AFirefightGM::RandomLoadouts' has a wrong offset!");
static_assert(offsetof(AFirefightGM, GeneratedLoadouts) == 0x000A10, "Member 'AFirefightGM::GeneratedLoadouts' has a wrong offset!");
static_assert(offsetof(AFirefightGM, NumRedSpawned) == 0x000A20, "Member 'AFirefightGM::NumRedSpawned' has a wrong offset!");
static_assert(offsetof(AFirefightGM, NumBlueSpawned) == 0x000A24, "Member 'AFirefightGM::NumBlueSpawned' has a wrong offset!");

// Class ReadyOrNot.AG_NumberOfSquadMembersAlive
// 0x0008 (0x0030 - 0x0028)
class UAG_NumberOfSquadMembersAlive final : public UAIActionGate
{
public:
	int32                                         RequiredNumber;                                    // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyActive;                                       // 0x002C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AG_NumberOfSquadMembersAlive">();
	}
	static class UAG_NumberOfSquadMembersAlive* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAG_NumberOfSquadMembersAlive>();
	}
};
static_assert(alignof(UAG_NumberOfSquadMembersAlive) == 0x000008, "Wrong alignment on UAG_NumberOfSquadMembersAlive");
static_assert(sizeof(UAG_NumberOfSquadMembersAlive) == 0x000030, "Wrong size on UAG_NumberOfSquadMembersAlive");
static_assert(offsetof(UAG_NumberOfSquadMembersAlive, RequiredNumber) == 0x000028, "Member 'UAG_NumberOfSquadMembersAlive::RequiredNumber' has a wrong offset!");
static_assert(offsetof(UAG_NumberOfSquadMembersAlive, bOnlyActive) == 0x00002C, "Member 'UAG_NumberOfSquadMembersAlive::bOnlyActive' has a wrong offset!");

// Class ReadyOrNot.CommonButtonFMOD
// 0x0010 (0x15C0 - 0x15B0)
class UCommonButtonFMOD : public UCommonButtonBase
{
public:
	class UFMODEvent*                             OnHoveredEvent;                                    // 0x15B0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             OnClickedEvent;                                    // 0x15B8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommonButtonFMOD">();
	}
	static class UCommonButtonFMOD* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommonButtonFMOD>();
	}
};
static_assert(alignof(UCommonButtonFMOD) == 0x000010, "Wrong alignment on UCommonButtonFMOD");
static_assert(sizeof(UCommonButtonFMOD) == 0x0015C0, "Wrong size on UCommonButtonFMOD");
static_assert(offsetof(UCommonButtonFMOD, OnHoveredEvent) == 0x0015B0, "Member 'UCommonButtonFMOD::OnHoveredEvent' has a wrong offset!");
static_assert(offsetof(UCommonButtonFMOD, OnClickedEvent) == 0x0015B8, "Member 'UCommonButtonFMOD::OnClickedEvent' has a wrong offset!");

// Class ReadyOrNot.CommonButtonImplementation
// 0x0020 (0x15E0 - 0x15C0)
#pragma pack(push, 0x1)
class alignas(0x10) UCommonButtonImplementation : public UCommonButtonFMOD
{
public:
	bool                                          bOverrideTextStyle;                                // 0x15C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETextJustify                                  LabelJustification;                                // 0x15C1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETextTransformPolicy                          LabelTransformPolicy;                              // 0x15C2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideButtonStyle;                              // 0x15C3(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15C4[0x4];                                     // 0x15C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UCommonButtonStyle>         KeyboardButtonStyle;                               // 0x15C8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UCommonButtonStyle>         GamepadButtonStyle;                                // 0x15D0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	class UCommonTextBlock* BP_GetButtonLabel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommonButtonImplementation">();
	}
	static class UCommonButtonImplementation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommonButtonImplementation>();
	}
};
#pragma pack(pop)
static_assert(alignof(UCommonButtonImplementation) == 0x000010, "Wrong alignment on UCommonButtonImplementation");
static_assert(sizeof(UCommonButtonImplementation) == 0x0015E0, "Wrong size on UCommonButtonImplementation");
static_assert(offsetof(UCommonButtonImplementation, bOverrideTextStyle) == 0x0015C0, "Member 'UCommonButtonImplementation::bOverrideTextStyle' has a wrong offset!");
static_assert(offsetof(UCommonButtonImplementation, LabelJustification) == 0x0015C1, "Member 'UCommonButtonImplementation::LabelJustification' has a wrong offset!");
static_assert(offsetof(UCommonButtonImplementation, LabelTransformPolicy) == 0x0015C2, "Member 'UCommonButtonImplementation::LabelTransformPolicy' has a wrong offset!");
static_assert(offsetof(UCommonButtonImplementation, bOverrideButtonStyle) == 0x0015C3, "Member 'UCommonButtonImplementation::bOverrideButtonStyle' has a wrong offset!");
static_assert(offsetof(UCommonButtonImplementation, KeyboardButtonStyle) == 0x0015C8, "Member 'UCommonButtonImplementation::KeyboardButtonStyle' has a wrong offset!");
static_assert(offsetof(UCommonButtonImplementation, GamepadButtonStyle) == 0x0015D0, "Member 'UCommonButtonImplementation::GamepadButtonStyle' has a wrong offset!");

// Class ReadyOrNot.CommonSpinbox
// 0x0010 (0x15F0 - 0x15E0)
class UCommonSpinbox : public UCommonButtonImplementation
{
public:
	struct FDataTableRowHandle                    ResetToDefaultInputAction;                         // 0x15D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_15E8[0x8];                                     // 0x15E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommonSpinbox">();
	}
	static class UCommonSpinbox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommonSpinbox>();
	}
};
static_assert(alignof(UCommonSpinbox) == 0x000010, "Wrong alignment on UCommonSpinbox");
static_assert(sizeof(UCommonSpinbox) == 0x0015F0, "Wrong size on UCommonSpinbox");
static_assert(offsetof(UCommonSpinbox, ResetToDefaultInputAction) == 0x0015D8, "Member 'UCommonSpinbox::ResetToDefaultInputAction' has a wrong offset!");

// Class ReadyOrNot.RandomizedShippingContainerActor
// 0x0060 (0x02F8 - 0x0298)
class ARandomizedShippingContainerActor final : public AActor
{
public:
	class UStaticMeshComponent*                   ContainerMeshComp;                                 // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   ContainerDecalsComp;                               // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   LeftDoorDecalsComp;                                // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   RightDoorDecalsComp;                               // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UMaterialInterface*>             ContainerMaterials;                                // 0x02B8(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UStaticMesh*>                    ContainerDecals;                                   // 0x02C8(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UStaticMesh*>                    LeftDoorDecals;                                    // 0x02D8(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UStaticMesh*>                    RightDoorDecals;                                   // 0x02E8(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	void RandomizeContainer();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RandomizedShippingContainerActor">();
	}
	static class ARandomizedShippingContainerActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARandomizedShippingContainerActor>();
	}
};
static_assert(alignof(ARandomizedShippingContainerActor) == 0x000008, "Wrong alignment on ARandomizedShippingContainerActor");
static_assert(sizeof(ARandomizedShippingContainerActor) == 0x0002F8, "Wrong size on ARandomizedShippingContainerActor");
static_assert(offsetof(ARandomizedShippingContainerActor, ContainerMeshComp) == 0x000298, "Member 'ARandomizedShippingContainerActor::ContainerMeshComp' has a wrong offset!");
static_assert(offsetof(ARandomizedShippingContainerActor, ContainerDecalsComp) == 0x0002A0, "Member 'ARandomizedShippingContainerActor::ContainerDecalsComp' has a wrong offset!");
static_assert(offsetof(ARandomizedShippingContainerActor, LeftDoorDecalsComp) == 0x0002A8, "Member 'ARandomizedShippingContainerActor::LeftDoorDecalsComp' has a wrong offset!");
static_assert(offsetof(ARandomizedShippingContainerActor, RightDoorDecalsComp) == 0x0002B0, "Member 'ARandomizedShippingContainerActor::RightDoorDecalsComp' has a wrong offset!");
static_assert(offsetof(ARandomizedShippingContainerActor, ContainerMaterials) == 0x0002B8, "Member 'ARandomizedShippingContainerActor::ContainerMaterials' has a wrong offset!");
static_assert(offsetof(ARandomizedShippingContainerActor, ContainerDecals) == 0x0002C8, "Member 'ARandomizedShippingContainerActor::ContainerDecals' has a wrong offset!");
static_assert(offsetof(ARandomizedShippingContainerActor, LeftDoorDecals) == 0x0002D8, "Member 'ARandomizedShippingContainerActor::LeftDoorDecals' has a wrong offset!");
static_assert(offsetof(ARandomizedShippingContainerActor, RightDoorDecals) == 0x0002E8, "Member 'ARandomizedShippingContainerActor::RightDoorDecals' has a wrong offset!");

// Class ReadyOrNot.AG_NumberOfSquadMembersKilled
// 0x0008 (0x0030 - 0x0028)
class UAG_NumberOfSquadMembersKilled final : public UAIActionGate
{
public:
	int32                                         RequiredNumber;                                    // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncludeIncapacitated;                             // 0x002C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AG_NumberOfSquadMembersKilled">();
	}
	static class UAG_NumberOfSquadMembersKilled* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAG_NumberOfSquadMembersKilled>();
	}
};
static_assert(alignof(UAG_NumberOfSquadMembersKilled) == 0x000008, "Wrong alignment on UAG_NumberOfSquadMembersKilled");
static_assert(sizeof(UAG_NumberOfSquadMembersKilled) == 0x000030, "Wrong size on UAG_NumberOfSquadMembersKilled");
static_assert(offsetof(UAG_NumberOfSquadMembersKilled, RequiredNumber) == 0x000028, "Member 'UAG_NumberOfSquadMembersKilled::RequiredNumber' has a wrong offset!");
static_assert(offsetof(UAG_NumberOfSquadMembersKilled, bIncludeIncapacitated) == 0x00002C, "Member 'UAG_NumberOfSquadMembersKilled::bIncludeIncapacitated' has a wrong offset!");

// Class ReadyOrNot.BleedComponent
// 0x0020 (0x00C0 - 0x00A0)
class UBleedComponent final : public UActorComponent
{
public:
	class UFMODEvent*                             BleedEvent;                                        // 0x00A0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsBleeding;                                       // 0x00A8(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bTempStopBleeding;                                 // 0x00B0(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B1[0x3];                                       // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         HealCount;                                         // 0x00B4(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DoHeal();
	void StartBleeding();
	void StopBleeding();

	bool CanHeal() const;
	float GetBleedTime() const;
	float GetHealCount() const;
	bool IsBleeding() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BleedComponent">();
	}
	static class UBleedComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBleedComponent>();
	}
};
static_assert(alignof(UBleedComponent) == 0x000008, "Wrong alignment on UBleedComponent");
static_assert(sizeof(UBleedComponent) == 0x0000C0, "Wrong size on UBleedComponent");
static_assert(offsetof(UBleedComponent, BleedEvent) == 0x0000A0, "Member 'UBleedComponent::BleedEvent' has a wrong offset!");
static_assert(offsetof(UBleedComponent, bIsBleeding) == 0x0000A8, "Member 'UBleedComponent::bIsBleeding' has a wrong offset!");
static_assert(offsetof(UBleedComponent, bTempStopBleeding) == 0x0000B0, "Member 'UBleedComponent::bTempStopBleeding' has a wrong offset!");
static_assert(offsetof(UBleedComponent, HealCount) == 0x0000B4, "Member 'UBleedComponent::HealCount' has a wrong offset!");

// Class ReadyOrNot.AG_NumberOfSquadMembersArrested
// 0x0008 (0x0030 - 0x0028)
class UAG_NumberOfSquadMembersArrested final : public UAIActionGate
{
public:
	int32                                         RequiredNumber;                                    // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AG_NumberOfSquadMembersArrested">();
	}
	static class UAG_NumberOfSquadMembersArrested* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAG_NumberOfSquadMembersArrested>();
	}
};
static_assert(alignof(UAG_NumberOfSquadMembersArrested) == 0x000008, "Wrong alignment on UAG_NumberOfSquadMembersArrested");
static_assert(sizeof(UAG_NumberOfSquadMembersArrested) == 0x000030, "Wrong size on UAG_NumberOfSquadMembersArrested");
static_assert(offsetof(UAG_NumberOfSquadMembersArrested, RequiredNumber) == 0x000028, "Member 'UAG_NumberOfSquadMembersArrested::RequiredNumber' has a wrong offset!");

// Class ReadyOrNot.NavArea_SuspectE
// 0x0000 (0x0048 - 0x0048)
class UNavArea_SuspectE final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_SuspectE">();
	}
	static class UNavArea_SuspectE* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_SuspectE>();
	}
};
static_assert(alignof(UNavArea_SuspectE) == 0x000008, "Wrong alignment on UNavArea_SuspectE");
static_assert(sizeof(UNavArea_SuspectE) == 0x000048, "Wrong size on UNavArea_SuspectE");

// Class ReadyOrNot.AG_SquadMemberThreat
// 0x0008 (0x0030 - 0x0028)
class UAG_SquadMemberThreat final : public UAIActionGate
{
public:
	int32                                         RequiredThreat;                                    // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EComparisonOp                                 ComparisonType;                                    // 0x002C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AG_SquadMemberThreat">();
	}
	static class UAG_SquadMemberThreat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAG_SquadMemberThreat>();
	}
};
static_assert(alignof(UAG_SquadMemberThreat) == 0x000008, "Wrong alignment on UAG_SquadMemberThreat");
static_assert(sizeof(UAG_SquadMemberThreat) == 0x000030, "Wrong size on UAG_SquadMemberThreat");
static_assert(offsetof(UAG_SquadMemberThreat, RequiredThreat) == 0x000028, "Member 'UAG_SquadMemberThreat::RequiredThreat' has a wrong offset!");
static_assert(offsetof(UAG_SquadMemberThreat, ComparisonType) == 0x00002C, "Member 'UAG_SquadMemberThreat::ComparisonType' has a wrong offset!");

// Class ReadyOrNot.AIActionPresetData
// 0x02F0 (0x0320 - 0x0030)
class UAIActionPresetData final : public UDataAsset
{
public:
	struct FAIActionData                          Action;                                            // 0x0030(0x02F0)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIActionPresetData">();
	}
	static class UAIActionPresetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIActionPresetData>();
	}
};
static_assert(alignof(UAIActionPresetData) == 0x000008, "Wrong alignment on UAIActionPresetData");
static_assert(sizeof(UAIActionPresetData) == 0x000320, "Wrong size on UAIActionPresetData");
static_assert(offsetof(UAIActionPresetData, Action) == 0x000030, "Member 'UAIActionPresetData::Action' has a wrong offset!");

// Class ReadyOrNot.ReadyOrNotGameplayEffect
// 0x0030 (0x0058 - 0x0028)
class UReadyOrNotGameplayEffect : public UObject
{
public:
	TMulticastInlineDelegate<void(TSubclassOf<class UReadyOrNotGameplayEffect> InGameplayEffectClass)> OnGameplayEffectExpired; // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AActor*                                 Actor;                                             // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWorld*                                 World;                                             // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_48[0x10];                                      // 0x0048(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyEffect();
	void ApplyEffectFor(float Seconds);
	void Initialize(class AActor* InActor);
	void Multicast_ApplyEffect();
	void Multicast_ApplyEffectFor(float Seconds);
	void Multicast_Initialize(class AActor* InActor);
	void Multicast_ResetEffect();
	void OnEffectExpired();
	void ResetEffect();
	void Server_ApplyEffect(bool bMulticast);
	void Server_ApplyEffectFor(float Seconds, bool bMulticast);
	void Server_Initialize(class AActor* InActor, bool bMulticast);
	void Server_ResetEffect(bool bMulticast);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotGameplayEffect">();
	}
	static class UReadyOrNotGameplayEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotGameplayEffect>();
	}
};
static_assert(alignof(UReadyOrNotGameplayEffect) == 0x000008, "Wrong alignment on UReadyOrNotGameplayEffect");
static_assert(sizeof(UReadyOrNotGameplayEffect) == 0x000058, "Wrong size on UReadyOrNotGameplayEffect");
static_assert(offsetof(UReadyOrNotGameplayEffect, OnGameplayEffectExpired) == 0x000028, "Member 'UReadyOrNotGameplayEffect::OnGameplayEffectExpired' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameplayEffect, Actor) == 0x000038, "Member 'UReadyOrNotGameplayEffect::Actor' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameplayEffect, World) == 0x000040, "Member 'UReadyOrNotGameplayEffect::World' has a wrong offset!");

// Class ReadyOrNot.RespondToPlayerGaze
// 0x0000 (0x0000 - 0x0000)
class IRespondToPlayerGaze final
{
public:
	void OnPlayerGazeEnded(class APlayerCharacter* Gazer);
	void OnPlayerGazeStarted(class APlayerCharacter* Gazer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RespondToPlayerGaze">();
	}
	static class IRespondToPlayerGaze* GetDefaultObj()
	{
		return GetDefaultObjImpl<IRespondToPlayerGaze>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IRespondToPlayerGaze) == 0x000001, "Wrong alignment on IRespondToPlayerGaze");
static_assert(sizeof(IRespondToPlayerGaze) == 0x000001, "Wrong size on IRespondToPlayerGaze");

// Class ReadyOrNot.AIArchetypeData
// 0x0118 (0x0148 - 0x0030)
class UAIArchetypeData final : public UDataAsset
{
public:
	class FString                                 Name_0;                                            // 0x0030(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bEnableAlertActions : 1;                           // 0x0040(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAIActionDataContainer>         AlertActions;                                      // 0x0048(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bEnableUnalertActions : 1;                         // 0x0058(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAIActionDataContainer>         UnalertActions;                                    // 0x0060(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bEnableSuspiciousActions : 1;                      // 0x0070(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAIActionDataContainer>         SuspiciousActions;                                 // 0x0078(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bEnableContinuousActions : 1;                      // 0x0088(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAIActionData_NameOnly>         ContinuousActions;                                 // 0x0090(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FAIActionDataContainer>         ContinuousActionsCache;                            // 0x00A0(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bEnableCombatMoveActions : 1;                      // 0x00B0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAIActionDataContainer>         CombatMoveActions;                                 // 0x00B8(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bEnableTraitActions : 1;                           // 0x00C8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAITraitActionData>             TraitActions;                                      // 0x00D0(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bEnableSquadActions : 1;                           // 0x00E0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_E1[0x7];                                       // 0x00E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAISquadActionDataContainer>    SquadActions;                                      // 0x00E8(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bOverrideAimSettings : 1;                          // 0x00F8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_F9[0x3];                                       // 0x00F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FocalPointInterpSpeed;                             // 0x00FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAlphaBlendOption                             FocalPointInterpCurve;                             // 0x0100(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_101[0x3];                                      // 0x0101(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FocusTurnSpeed;                                    // 0x0104(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnDegreesPerSecond;                              // 0x0108(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActorRotationInterpStandingSpeed;                  // 0x010C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActorRotationInterpMovingSpeed;                    // 0x0110(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimOffsetInterpSpeed;                              // 0x0114(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIgnoreDamageHitReactions : 1;                     // 0x0118(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_119[0x7];                                      // 0x0119(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EAIAwarenessState>                     AllowCombatMoveInState;                            // 0x0120(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bSuppressionRequiresLOSOnLastKnownEnemyPosition : 1; // 0x0130(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAccuracyOverride : 1;                             // 0x0130(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_131[0x3];                                      // 0x0131(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Accuracy;                                          // 0x0134(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bMoraleOverride : 1;                               // 0x0138(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_139[0x3];                                      // 0x0139(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinMorale;                                         // 0x013C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxMorale;                                         // 0x0140(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bDisableVO : 1;                                    // 0x0144(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_145[0x3];                                      // 0x0145(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIArchetypeData">();
	}
	static class UAIArchetypeData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIArchetypeData>();
	}
};
static_assert(alignof(UAIArchetypeData) == 0x000008, "Wrong alignment on UAIArchetypeData");
static_assert(sizeof(UAIArchetypeData) == 0x000148, "Wrong size on UAIArchetypeData");
static_assert(offsetof(UAIArchetypeData, Name_0) == 0x000030, "Member 'UAIArchetypeData::Name_0' has a wrong offset!");
static_assert(offsetof(UAIArchetypeData, AlertActions) == 0x000048, "Member 'UAIArchetypeData::AlertActions' has a wrong offset!");
static_assert(offsetof(UAIArchetypeData, UnalertActions) == 0x000060, "Member 'UAIArchetypeData::UnalertActions' has a wrong offset!");
static_assert(offsetof(UAIArchetypeData, SuspiciousActions) == 0x000078, "Member 'UAIArchetypeData::SuspiciousActions' has a wrong offset!");
static_assert(offsetof(UAIArchetypeData, ContinuousActions) == 0x000090, "Member 'UAIArchetypeData::ContinuousActions' has a wrong offset!");
static_assert(offsetof(UAIArchetypeData, ContinuousActionsCache) == 0x0000A0, "Member 'UAIArchetypeData::ContinuousActionsCache' has a wrong offset!");
static_assert(offsetof(UAIArchetypeData, CombatMoveActions) == 0x0000B8, "Member 'UAIArchetypeData::CombatMoveActions' has a wrong offset!");
static_assert(offsetof(UAIArchetypeData, TraitActions) == 0x0000D0, "Member 'UAIArchetypeData::TraitActions' has a wrong offset!");
static_assert(offsetof(UAIArchetypeData, SquadActions) == 0x0000E8, "Member 'UAIArchetypeData::SquadActions' has a wrong offset!");
static_assert(offsetof(UAIArchetypeData, FocalPointInterpSpeed) == 0x0000FC, "Member 'UAIArchetypeData::FocalPointInterpSpeed' has a wrong offset!");
static_assert(offsetof(UAIArchetypeData, FocalPointInterpCurve) == 0x000100, "Member 'UAIArchetypeData::FocalPointInterpCurve' has a wrong offset!");
static_assert(offsetof(UAIArchetypeData, FocusTurnSpeed) == 0x000104, "Member 'UAIArchetypeData::FocusTurnSpeed' has a wrong offset!");
static_assert(offsetof(UAIArchetypeData, TurnDegreesPerSecond) == 0x000108, "Member 'UAIArchetypeData::TurnDegreesPerSecond' has a wrong offset!");
static_assert(offsetof(UAIArchetypeData, ActorRotationInterpStandingSpeed) == 0x00010C, "Member 'UAIArchetypeData::ActorRotationInterpStandingSpeed' has a wrong offset!");
static_assert(offsetof(UAIArchetypeData, ActorRotationInterpMovingSpeed) == 0x000110, "Member 'UAIArchetypeData::ActorRotationInterpMovingSpeed' has a wrong offset!");
static_assert(offsetof(UAIArchetypeData, AimOffsetInterpSpeed) == 0x000114, "Member 'UAIArchetypeData::AimOffsetInterpSpeed' has a wrong offset!");
static_assert(offsetof(UAIArchetypeData, AllowCombatMoveInState) == 0x000120, "Member 'UAIArchetypeData::AllowCombatMoveInState' has a wrong offset!");
static_assert(offsetof(UAIArchetypeData, Accuracy) == 0x000134, "Member 'UAIArchetypeData::Accuracy' has a wrong offset!");
static_assert(offsetof(UAIArchetypeData, MinMorale) == 0x00013C, "Member 'UAIArchetypeData::MinMorale' has a wrong offset!");
static_assert(offsetof(UAIArchetypeData, MaxMorale) == 0x000140, "Member 'UAIArchetypeData::MaxMorale' has a wrong offset!");

// Class ReadyOrNot.GamepadButtonImage
// 0x0018 (0x02D8 - 0x02C0)
class UGamepadButtonImage : public UUserWidget
{
public:
	class UDataTable*                             ImageSet;                                          // 0x02C0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 ButtonImage;                                       // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TagOrId;                                           // 0x02D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	struct FSlateBrush GetBrush(const class FString& GamepadName);
	void SetBrush();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GamepadButtonImage">();
	}
	static class UGamepadButtonImage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGamepadButtonImage>();
	}
};
static_assert(alignof(UGamepadButtonImage) == 0x000008, "Wrong alignment on UGamepadButtonImage");
static_assert(sizeof(UGamepadButtonImage) == 0x0002D8, "Wrong size on UGamepadButtonImage");
static_assert(offsetof(UGamepadButtonImage, ImageSet) == 0x0002C0, "Member 'UGamepadButtonImage::ImageSet' has a wrong offset!");
static_assert(offsetof(UGamepadButtonImage, ButtonImage) == 0x0002C8, "Member 'UGamepadButtonImage::ButtonImage' has a wrong offset!");
static_assert(offsetof(UGamepadButtonImage, TagOrId) == 0x0002D0, "Member 'UGamepadButtonImage::TagOrId' has a wrong offset!");

// Class ReadyOrNot.BaseTriggerable
// 0x0018 (0x02B0 - 0x0298)
class ABaseTriggerable final : public AActor
{
public:
	class USceneComponent*                        SceneComponent;                                    // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bActivate;                                         // 0x02A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A1[0x3];                                      // 0x02A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ActivateDelay;                                     // 0x02A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeactivateDelay;                                   // 0x02A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsActive;                                         // 0x02AC(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AD[0x3];                                      // 0x02AD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Activate();
	void Deactivate();
	void Stop();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseTriggerable">();
	}
	static class ABaseTriggerable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseTriggerable>();
	}
};
static_assert(alignof(ABaseTriggerable) == 0x000008, "Wrong alignment on ABaseTriggerable");
static_assert(sizeof(ABaseTriggerable) == 0x0002B0, "Wrong size on ABaseTriggerable");
static_assert(offsetof(ABaseTriggerable, SceneComponent) == 0x000298, "Member 'ABaseTriggerable::SceneComponent' has a wrong offset!");
static_assert(offsetof(ABaseTriggerable, bActivate) == 0x0002A0, "Member 'ABaseTriggerable::bActivate' has a wrong offset!");
static_assert(offsetof(ABaseTriggerable, ActivateDelay) == 0x0002A4, "Member 'ABaseTriggerable::ActivateDelay' has a wrong offset!");
static_assert(offsetof(ABaseTriggerable, DeactivateDelay) == 0x0002A8, "Member 'ABaseTriggerable::DeactivateDelay' has a wrong offset!");
static_assert(offsetof(ABaseTriggerable, bIsActive) == 0x0002AC, "Member 'ABaseTriggerable::bIsActive' has a wrong offset!");

// Class ReadyOrNot.AICombatMovesWidget
// 0x0030 (0x02F0 - 0x02C0)
class UAICombatMovesWidget final : public UUserWidget
{
public:
	class UVerticalBox*                           CombatMoves_VerticalBox;                           // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             AIName_TextBlock;                                  // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                NextAI_Button;                                     // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACyberneticCharacter*                   CurrentAI;                                         // 0x02D8(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UAICombatMovesWidgetEntry>  WidgetEntryClass;                                  // 0x02E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UUserWidget>                AIWorldWidgetClass;                                // 0x02E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnNextAIButtonClicked();
	void SetAIToFocus(class ACyberneticCharacter* CyberneticCharacter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AICombatMovesWidget">();
	}
	static class UAICombatMovesWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAICombatMovesWidget>();
	}
};
static_assert(alignof(UAICombatMovesWidget) == 0x000008, "Wrong alignment on UAICombatMovesWidget");
static_assert(sizeof(UAICombatMovesWidget) == 0x0002F0, "Wrong size on UAICombatMovesWidget");
static_assert(offsetof(UAICombatMovesWidget, CombatMoves_VerticalBox) == 0x0002C0, "Member 'UAICombatMovesWidget::CombatMoves_VerticalBox' has a wrong offset!");
static_assert(offsetof(UAICombatMovesWidget, AIName_TextBlock) == 0x0002C8, "Member 'UAICombatMovesWidget::AIName_TextBlock' has a wrong offset!");
static_assert(offsetof(UAICombatMovesWidget, NextAI_Button) == 0x0002D0, "Member 'UAICombatMovesWidget::NextAI_Button' has a wrong offset!");
static_assert(offsetof(UAICombatMovesWidget, CurrentAI) == 0x0002D8, "Member 'UAICombatMovesWidget::CurrentAI' has a wrong offset!");
static_assert(offsetof(UAICombatMovesWidget, WidgetEntryClass) == 0x0002E0, "Member 'UAICombatMovesWidget::WidgetEntryClass' has a wrong offset!");
static_assert(offsetof(UAICombatMovesWidget, AIWorldWidgetClass) == 0x0002E8, "Member 'UAICombatMovesWidget::AIWorldWidgetClass' has a wrong offset!");

// Class ReadyOrNot.NavArea_SuspectA
// 0x0000 (0x0048 - 0x0048)
class UNavArea_SuspectA final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_SuspectA">();
	}
	static class UNavArea_SuspectA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_SuspectA>();
	}
};
static_assert(alignof(UNavArea_SuspectA) == 0x000008, "Wrong alignment on UNavArea_SuspectA");
static_assert(sizeof(UNavArea_SuspectA) == 0x000048, "Wrong size on UNavArea_SuspectA");

// Class ReadyOrNot.AICombatMovesWidgetEntry
// 0x0020 (0x02E0 - 0x02C0)
class UAICombatMovesWidgetEntry final : public UUserWidget
{
public:
	class UTextBlock*                             CombatAction_TextBlock;                            // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             SuccessfulConsiderations_TextBlock;                // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             FailedConsiderations_TextBlock;                    // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             RunTime_TextBlock;                                 // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AICombatMovesWidgetEntry">();
	}
	static class UAICombatMovesWidgetEntry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAICombatMovesWidgetEntry>();
	}
};
static_assert(alignof(UAICombatMovesWidgetEntry) == 0x000008, "Wrong alignment on UAICombatMovesWidgetEntry");
static_assert(sizeof(UAICombatMovesWidgetEntry) == 0x0002E0, "Wrong size on UAICombatMovesWidgetEntry");
static_assert(offsetof(UAICombatMovesWidgetEntry, CombatAction_TextBlock) == 0x0002C0, "Member 'UAICombatMovesWidgetEntry::CombatAction_TextBlock' has a wrong offset!");
static_assert(offsetof(UAICombatMovesWidgetEntry, SuccessfulConsiderations_TextBlock) == 0x0002C8, "Member 'UAICombatMovesWidgetEntry::SuccessfulConsiderations_TextBlock' has a wrong offset!");
static_assert(offsetof(UAICombatMovesWidgetEntry, FailedConsiderations_TextBlock) == 0x0002D0, "Member 'UAICombatMovesWidgetEntry::FailedConsiderations_TextBlock' has a wrong offset!");
static_assert(offsetof(UAICombatMovesWidgetEntry, RunTime_TextBlock) == 0x0002D8, "Member 'UAICombatMovesWidgetEntry::RunTime_TextBlock' has a wrong offset!");

// Class ReadyOrNot.AIData
// 0x0000 (0x0030 - 0x0030)
class UAIData final : public UDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIData">();
	}
	static class UAIData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIData>();
	}
};
static_assert(alignof(UAIData) == 0x000008, "Wrong alignment on UAIData");
static_assert(sizeof(UAIData) == 0x000030, "Wrong size on UAIData");

// Class ReadyOrNot.CanIssueCommandOn
// 0x0000 (0x0000 - 0x0000)
class ICanIssueCommandOn final
{
public:
	bool CanIssueCommand() const;
	class AActor* GetCommandActor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CanIssueCommandOn">();
	}
	static class ICanIssueCommandOn* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICanIssueCommandOn>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ICanIssueCommandOn) == 0x000001, "Wrong alignment on ICanIssueCommandOn");
static_assert(sizeof(ICanIssueCommandOn) == 0x000001, "Wrong size on ICanIssueCommandOn");

// Class ReadyOrNot.PersonalizationWidget
// 0x0008 (0x02C8 - 0x02C0)
class UPersonalizationWidget : public UUserWidget
{
public:
	class ACharacterCustomizationPortal*          SpawnedFromPortal;                                 // 0x02C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PersonalizationWidget">();
	}
	static class UPersonalizationWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPersonalizationWidget>();
	}
};
static_assert(alignof(UPersonalizationWidget) == 0x000008, "Wrong alignment on UPersonalizationWidget");
static_assert(sizeof(UPersonalizationWidget) == 0x0002C8, "Wrong size on UPersonalizationWidget");
static_assert(offsetof(UPersonalizationWidget, SpawnedFromPortal) == 0x0002C0, "Member 'UPersonalizationWidget::SpawnedFromPortal' has a wrong offset!");

// Class ReadyOrNot.AIFactionManager
// 0x0058 (0x02F0 - 0x0298)
class AAIFactionManager : public AActor
{
public:
	uint8                                         bGroupIntoTeams : 1;                               // 0x0298(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_299[0x3];                                      // 0x0299(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TeamsOf;                                           // 0x029C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bAssignRandomTeamTactics : 1;                      // 0x02A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_2A1[0x7];                                      // 0x02A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFactionTeamTactics>            TacticsPool;                                       // 0x02A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFactionSuspectTeam>            SuspectTeams;                                      // 0x02B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<class ACyberneticCharacter*>           Characters;                                        // 0x02C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<class ACyberneticCharacter*>           Leaders;                                           // 0x02D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	float                                         TeamBehaviourStrengthReductionSpeed;               // 0x02E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TeamBehaviourOverrideStrength;                     // 0x02EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AlertOtherSuspectsInTeam_Blueprint(class ASuspectCharacter* suspect, class AReadyOrNotCharacter* Enemy);
	bool GetSuspectsInTeam(class ASuspectCharacter* InSuspect, TArray<class ASuspectCharacter*>* OutSuspects, bool bIncludeSelf);
	void OnAIAdded_Blueprint(class ACyberneticCharacter* Character);
	void OnAISpottedEnemy(class ACyberneticCharacter* Spotter, class AReadyOrNotCharacter* Enemy);
	void OnAISpottedEnemy_Blueprint(class ACyberneticCharacter* Spotter, class AReadyOrNotCharacter* Enemy);
	void OnAISpottedFriendly(class ACyberneticCharacter* Spotter, class AReadyOrNotCharacter* Friendly);
	void OnAISpottedFriendly_Blueprint(class ACyberneticCharacter* Spotter, class AReadyOrNotCharacter* Friendly);
	void OnAISpottedNeutral(class ACyberneticCharacter* Spotter, class AReadyOrNotCharacter* Neutral);
	void OnAISpottedNeutral_Blueprint(class ACyberneticCharacter* Spotter, class AReadyOrNotCharacter* Neutral);
	void OnAllAISpawned_Blueprint();

	bool AreTeamSpotsAvailable(int32* OutIndex) const;
	class ASuspectCharacter* FindClosestSuspect(const TArray<class ASuspectCharacter*>& OtherSuspects, class ASuspectCharacter* suspect, float MaxDistance) const;
	TArray<class ACyberneticCharacter*> GetAllCharacters() const;
	TArray<class ACivilianCharacter*> GetAllCivilians() const;
	TArray<class ACyberneticCharacter*> GetAllLeaders() const;
	TArray<class ASuspectCharacter*> GetAllSuspects() const;
	int32 GetTeamIndex(class ASuspectCharacter* InSuspect) const;
	bool GetTeamTacticFor(class ASuspectCharacter* InSuspect, EAITeamTactic* OutTactic) const;
	bool IsSuspectInTeam(class ASuspectCharacter* InSuspect, struct FFactionSuspectTeam* OutTeam) const;
	bool IsTeamFull(const struct FFactionSuspectTeam& InTeam) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIFactionManager">();
	}
	static class AAIFactionManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAIFactionManager>();
	}
};
static_assert(alignof(AAIFactionManager) == 0x000008, "Wrong alignment on AAIFactionManager");
static_assert(sizeof(AAIFactionManager) == 0x0002F0, "Wrong size on AAIFactionManager");
static_assert(offsetof(AAIFactionManager, TeamsOf) == 0x00029C, "Member 'AAIFactionManager::TeamsOf' has a wrong offset!");
static_assert(offsetof(AAIFactionManager, TacticsPool) == 0x0002A8, "Member 'AAIFactionManager::TacticsPool' has a wrong offset!");
static_assert(offsetof(AAIFactionManager, SuspectTeams) == 0x0002B8, "Member 'AAIFactionManager::SuspectTeams' has a wrong offset!");
static_assert(offsetof(AAIFactionManager, Characters) == 0x0002C8, "Member 'AAIFactionManager::Characters' has a wrong offset!");
static_assert(offsetof(AAIFactionManager, Leaders) == 0x0002D8, "Member 'AAIFactionManager::Leaders' has a wrong offset!");
static_assert(offsetof(AAIFactionManager, TeamBehaviourStrengthReductionSpeed) == 0x0002E8, "Member 'AAIFactionManager::TeamBehaviourStrengthReductionSpeed' has a wrong offset!");
static_assert(offsetof(AAIFactionManager, TeamBehaviourOverrideStrength) == 0x0002EC, "Member 'AAIFactionManager::TeamBehaviourOverrideStrength' has a wrong offset!");

// Class ReadyOrNot.AnimNotify_SearchLandmark
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_SearchLandmark final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_SearchLandmark">();
	}
	static class UAnimNotify_SearchLandmark* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_SearchLandmark>();
	}
};
static_assert(alignof(UAnimNotify_SearchLandmark) == 0x000008, "Wrong alignment on UAnimNotify_SearchLandmark");
static_assert(sizeof(UAnimNotify_SearchLandmark) == 0x000038, "Wrong size on UAnimNotify_SearchLandmark");

// Class ReadyOrNot.AimTrigger
// 0x0008 (0x0058 - 0x0050)
class UAimTrigger final : public UInputTrigger
{
public:
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AimTrigger">();
	}
	static class UAimTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAimTrigger>();
	}
};
static_assert(alignof(UAimTrigger) == 0x000008, "Wrong alignment on UAimTrigger");
static_assert(sizeof(UAimTrigger) == 0x000058, "Wrong size on UAimTrigger");

// Class ReadyOrNot.StunDamage
// 0x0770 (0x07B0 - 0x0040)
class UStunDamage : public UDamageType
{
public:
	bool                                          bProjectileStun;                                   // 0x0040(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ULegacyCameraShake>         StunShake;                                         // 0x0048(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPostProcessSettings                   PostProcessSettings;                               // 0x0050(0x06E0)(Edit, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UAnimMontage*                           HitMontage_3P;                                     // 0x0730(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               CameraRotationOffset;                              // 0x0738(0x0018)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         AppliedSpeed;                                      // 0x0750(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxMovementSpeedWhenStunned;                       // 0x0754(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DoorDamageMultiplier;                              // 0x0758(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDamageAllDoorPiecesAtOnce;                        // 0x075C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanPushDoorWithForce;                             // 0x075D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_75E[0x2];                                      // 0x075E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DoorPushScale;                                     // 0x0760(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_764[0x4];                                      // 0x0764(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundCue*                              ImpactSound;                                       // 0x0768(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStunType                                     StunType;                                          // 0x0770(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayAudioWhenHit;                                 // 0x0771(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_772[0x6];                                      // 0x0772(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             StunSoundEffect;                                   // 0x0778(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCauseHealthDamage;                                // 0x0780(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCausesSuppression;                                // 0x0781(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBreaksDestructibles;                              // 0x0782(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_783[0x1];                                      // 0x0783(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SuppressionAmount;                                 // 0x0784(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ULegacyCameraShake>         SuppressionCameraShake;                            // 0x0788(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMustBeLookingAtDamageCauser;                      // 0x0790(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStunLocksAim;                                     // 0x0791(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_792[0x2];                                      // 0x0792(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StunSpeedMultiplier;                               // 0x0794(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponDownLengthOnStun;                            // 0x0798(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNonLethal;                                        // 0x079C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79D[0x3];                                      // 0x079D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LessThanLethalAmount;                              // 0x07A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditionalUpcloseDamageIncrease;                   // 0x07A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditionalHeadDamageIncrease;                      // 0x07A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSwatAIIsAbuse;                                    // 0x07AC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChildAIIsAbuse;                                   // 0x07AD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCompliantIsAbuse;                                 // 0x07AE(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bArrestedIsAbuse;                                  // 0x07AF(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void ScriptedStunEvent(class AReadyOrNotCharacter* Victim, float* Damage, const struct FDamageEvent& DamageEvent, class AController* EventInstigator, class AActor* DamageCauser) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StunDamage">();
	}
	static class UStunDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStunDamage>();
	}
};
static_assert(alignof(UStunDamage) == 0x000010, "Wrong alignment on UStunDamage");
static_assert(sizeof(UStunDamage) == 0x0007B0, "Wrong size on UStunDamage");
static_assert(offsetof(UStunDamage, bProjectileStun) == 0x000040, "Member 'UStunDamage::bProjectileStun' has a wrong offset!");
static_assert(offsetof(UStunDamage, StunShake) == 0x000048, "Member 'UStunDamage::StunShake' has a wrong offset!");
static_assert(offsetof(UStunDamage, PostProcessSettings) == 0x000050, "Member 'UStunDamage::PostProcessSettings' has a wrong offset!");
static_assert(offsetof(UStunDamage, HitMontage_3P) == 0x000730, "Member 'UStunDamage::HitMontage_3P' has a wrong offset!");
static_assert(offsetof(UStunDamage, CameraRotationOffset) == 0x000738, "Member 'UStunDamage::CameraRotationOffset' has a wrong offset!");
static_assert(offsetof(UStunDamage, AppliedSpeed) == 0x000750, "Member 'UStunDamage::AppliedSpeed' has a wrong offset!");
static_assert(offsetof(UStunDamage, MaxMovementSpeedWhenStunned) == 0x000754, "Member 'UStunDamage::MaxMovementSpeedWhenStunned' has a wrong offset!");
static_assert(offsetof(UStunDamage, DoorDamageMultiplier) == 0x000758, "Member 'UStunDamage::DoorDamageMultiplier' has a wrong offset!");
static_assert(offsetof(UStunDamage, bDamageAllDoorPiecesAtOnce) == 0x00075C, "Member 'UStunDamage::bDamageAllDoorPiecesAtOnce' has a wrong offset!");
static_assert(offsetof(UStunDamage, bCanPushDoorWithForce) == 0x00075D, "Member 'UStunDamage::bCanPushDoorWithForce' has a wrong offset!");
static_assert(offsetof(UStunDamage, DoorPushScale) == 0x000760, "Member 'UStunDamage::DoorPushScale' has a wrong offset!");
static_assert(offsetof(UStunDamage, ImpactSound) == 0x000768, "Member 'UStunDamage::ImpactSound' has a wrong offset!");
static_assert(offsetof(UStunDamage, StunType) == 0x000770, "Member 'UStunDamage::StunType' has a wrong offset!");
static_assert(offsetof(UStunDamage, bPlayAudioWhenHit) == 0x000771, "Member 'UStunDamage::bPlayAudioWhenHit' has a wrong offset!");
static_assert(offsetof(UStunDamage, StunSoundEffect) == 0x000778, "Member 'UStunDamage::StunSoundEffect' has a wrong offset!");
static_assert(offsetof(UStunDamage, bCauseHealthDamage) == 0x000780, "Member 'UStunDamage::bCauseHealthDamage' has a wrong offset!");
static_assert(offsetof(UStunDamage, bCausesSuppression) == 0x000781, "Member 'UStunDamage::bCausesSuppression' has a wrong offset!");
static_assert(offsetof(UStunDamage, bBreaksDestructibles) == 0x000782, "Member 'UStunDamage::bBreaksDestructibles' has a wrong offset!");
static_assert(offsetof(UStunDamage, SuppressionAmount) == 0x000784, "Member 'UStunDamage::SuppressionAmount' has a wrong offset!");
static_assert(offsetof(UStunDamage, SuppressionCameraShake) == 0x000788, "Member 'UStunDamage::SuppressionCameraShake' has a wrong offset!");
static_assert(offsetof(UStunDamage, bMustBeLookingAtDamageCauser) == 0x000790, "Member 'UStunDamage::bMustBeLookingAtDamageCauser' has a wrong offset!");
static_assert(offsetof(UStunDamage, bStunLocksAim) == 0x000791, "Member 'UStunDamage::bStunLocksAim' has a wrong offset!");
static_assert(offsetof(UStunDamage, StunSpeedMultiplier) == 0x000794, "Member 'UStunDamage::StunSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(UStunDamage, WeaponDownLengthOnStun) == 0x000798, "Member 'UStunDamage::WeaponDownLengthOnStun' has a wrong offset!");
static_assert(offsetof(UStunDamage, bNonLethal) == 0x00079C, "Member 'UStunDamage::bNonLethal' has a wrong offset!");
static_assert(offsetof(UStunDamage, LessThanLethalAmount) == 0x0007A0, "Member 'UStunDamage::LessThanLethalAmount' has a wrong offset!");
static_assert(offsetof(UStunDamage, AdditionalUpcloseDamageIncrease) == 0x0007A4, "Member 'UStunDamage::AdditionalUpcloseDamageIncrease' has a wrong offset!");
static_assert(offsetof(UStunDamage, AdditionalHeadDamageIncrease) == 0x0007A8, "Member 'UStunDamage::AdditionalHeadDamageIncrease' has a wrong offset!");
static_assert(offsetof(UStunDamage, bSwatAIIsAbuse) == 0x0007AC, "Member 'UStunDamage::bSwatAIIsAbuse' has a wrong offset!");
static_assert(offsetof(UStunDamage, bChildAIIsAbuse) == 0x0007AD, "Member 'UStunDamage::bChildAIIsAbuse' has a wrong offset!");
static_assert(offsetof(UStunDamage, bCompliantIsAbuse) == 0x0007AE, "Member 'UStunDamage::bCompliantIsAbuse' has a wrong offset!");
static_assert(offsetof(UStunDamage, bArrestedIsAbuse) == 0x0007AF, "Member 'UStunDamage::bArrestedIsAbuse' has a wrong offset!");

// Class ReadyOrNot.PepperballDamageType
// 0x0010 (0x07C0 - 0x07B0)
class UPepperballDamageType : public UStunDamage
{
public:
	float                                         StunDurationHeadshot;                              // 0x07B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StunDurationLeg;                                   // 0x07B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7B8[0x8];                                      // 0x07B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PepperballDamageType">();
	}
	static class UPepperballDamageType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPepperballDamageType>();
	}
};
static_assert(alignof(UPepperballDamageType) == 0x000010, "Wrong alignment on UPepperballDamageType");
static_assert(sizeof(UPepperballDamageType) == 0x0007C0, "Wrong size on UPepperballDamageType");
static_assert(offsetof(UPepperballDamageType, StunDurationHeadshot) == 0x0007B0, "Member 'UPepperballDamageType::StunDurationHeadshot' has a wrong offset!");
static_assert(offsetof(UPepperballDamageType, StunDurationLeg) == 0x0007B4, "Member 'UPepperballDamageType::StunDurationLeg' has a wrong offset!");

// Class ReadyOrNot.AimTriggerPressed
// 0x0000 (0x0050 - 0x0050)
class UAimTriggerPressed final : public UInputTrigger
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AimTriggerPressed">();
	}
	static class UAimTriggerPressed* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAimTriggerPressed>();
	}
};
static_assert(alignof(UAimTriggerPressed) == 0x000008, "Wrong alignment on UAimTriggerPressed");
static_assert(sizeof(UAimTriggerPressed) == 0x000050, "Wrong size on UAimTriggerPressed");

// Class ReadyOrNot.AISelectionDebugWidget
// 0x0008 (0x02C8 - 0x02C0)
class UAISelectionDebugWidget final : public UUserWidget
{
public:
	class UTextBlock*                             AIName_TextBlock;                                  // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISelectionDebugWidget">();
	}
	static class UAISelectionDebugWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISelectionDebugWidget>();
	}
};
static_assert(alignof(UAISelectionDebugWidget) == 0x000008, "Wrong alignment on UAISelectionDebugWidget");
static_assert(sizeof(UAISelectionDebugWidget) == 0x0002C8, "Wrong size on UAISelectionDebugWidget");
static_assert(offsetof(UAISelectionDebugWidget, AIName_TextBlock) == 0x0002C0, "Member 'UAISelectionDebugWidget::AIName_TextBlock' has a wrong offset!");

// Class ReadyOrNot.AnimNotify_MirrorDoor
// 0x0008 (0x0040 - 0x0038)
class UAnimNotify_MirrorDoor final : public UAnimNotify
{
public:
	uint8                                         bMirrorFinish : 1;                                 // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_MirrorDoor">();
	}
	static class UAnimNotify_MirrorDoor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_MirrorDoor>();
	}
};
static_assert(alignof(UAnimNotify_MirrorDoor) == 0x000008, "Wrong alignment on UAnimNotify_MirrorDoor");
static_assert(sizeof(UAnimNotify_MirrorDoor) == 0x000040, "Wrong size on UAnimNotify_MirrorDoor");

// Class ReadyOrNot.NavArea_CivilianD
// 0x0000 (0x0048 - 0x0048)
class UNavArea_CivilianD final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_CivilianD">();
	}
	static class UNavArea_CivilianD* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_CivilianD>();
	}
};
static_assert(alignof(UNavArea_CivilianD) == 0x000008, "Wrong alignment on UNavArea_CivilianD");
static_assert(sizeof(UNavArea_CivilianD) == 0x000048, "Wrong size on UNavArea_CivilianD");

// Class ReadyOrNot.AISpawn
// 0x00E0 (0x0378 - 0x0298)
class AAISpawn final : public AActor
{
public:
	uint8                                         bEnabled : 1;                                      // 0x0298(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bAllowExplosiveVestSpawn;                          // 0x0299(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29A[0x2];                                      // 0x029A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpawnChance;                                       // 0x029C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         GroupID;                                           // 0x02A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A1[0x9F];                                     // 0x02A1(0x009F)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSpawnData>                     SpawnArray;                                        // 0x0340(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TSubclassOf<class ABaseWeapon>                GlobalWeaponOverride;                              // 0x0350(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAIArchetypeData*                       ArchetypeOverride;                                 // 0x0358(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACyberneticCharacter*                   SpawnedCharacter;                                  // 0x0360(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        DefaultScene;                                      // 0x0368(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UArrowComponent*                        SpawnDirection;                                    // 0x0370(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static ETeamType GetSpawningTeamType(const struct FSpawnData& Sd);

	bool DoSpawn();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISpawn">();
	}
	static class AAISpawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAISpawn>();
	}
};
static_assert(alignof(AAISpawn) == 0x000008, "Wrong alignment on AAISpawn");
static_assert(sizeof(AAISpawn) == 0x000378, "Wrong size on AAISpawn");
static_assert(offsetof(AAISpawn, bAllowExplosiveVestSpawn) == 0x000299, "Member 'AAISpawn::bAllowExplosiveVestSpawn' has a wrong offset!");
static_assert(offsetof(AAISpawn, SpawnChance) == 0x00029C, "Member 'AAISpawn::SpawnChance' has a wrong offset!");
static_assert(offsetof(AAISpawn, GroupID) == 0x0002A0, "Member 'AAISpawn::GroupID' has a wrong offset!");
static_assert(offsetof(AAISpawn, SpawnArray) == 0x000340, "Member 'AAISpawn::SpawnArray' has a wrong offset!");
static_assert(offsetof(AAISpawn, GlobalWeaponOverride) == 0x000350, "Member 'AAISpawn::GlobalWeaponOverride' has a wrong offset!");
static_assert(offsetof(AAISpawn, ArchetypeOverride) == 0x000358, "Member 'AAISpawn::ArchetypeOverride' has a wrong offset!");
static_assert(offsetof(AAISpawn, SpawnedCharacter) == 0x000360, "Member 'AAISpawn::SpawnedCharacter' has a wrong offset!");
static_assert(offsetof(AAISpawn, DefaultScene) == 0x000368, "Member 'AAISpawn::DefaultScene' has a wrong offset!");
static_assert(offsetof(AAISpawn, SpawnDirection) == 0x000370, "Member 'AAISpawn::SpawnDirection' has a wrong offset!");

// Class ReadyOrNot.BlockList
// 0x0018 (0x0428 - 0x0410)
class UBlockList : public UCommonActivatableWidget
{
public:
	class UCommonListView*                        BlockListView;                                     // 0x0410(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UBlockListData*>                 BlockList;                                         // 0x0418(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void PopulateBlockList(class UUserWidget* BlockListRef);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlockList">();
	}
	static class UBlockList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlockList>();
	}
};
static_assert(alignof(UBlockList) == 0x000008, "Wrong alignment on UBlockList");
static_assert(sizeof(UBlockList) == 0x000428, "Wrong size on UBlockList");
static_assert(offsetof(UBlockList, BlockListView) == 0x000410, "Member 'UBlockList::BlockListView' has a wrong offset!");
static_assert(offsetof(UBlockList, BlockList) == 0x000418, "Member 'UBlockList::BlockList' has a wrong offset!");

// Class ReadyOrNot.NavQuery_Swat
// 0x0000 (0x0048 - 0x0048)
class UNavQuery_Swat : public UNavigationQueryFilter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavQuery_Swat">();
	}
	static class UNavQuery_Swat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavQuery_Swat>();
	}
};
static_assert(alignof(UNavQuery_Swat) == 0x000008, "Wrong alignment on UNavQuery_Swat");
static_assert(sizeof(UNavQuery_Swat) == 0x000048, "Wrong size on UNavQuery_Swat");

// Class ReadyOrNot.AmmoComponent
// 0x0008 (0x0100 - 0x00F8)
class UAmmoComponent final : public UResourceComponent
{
public:
	float                                         AmmoUsagePerSecond;                                // 0x00F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetAmmoUsagePerSecond() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AmmoComponent">();
	}
	static class UAmmoComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAmmoComponent>();
	}
};
static_assert(alignof(UAmmoComponent) == 0x000008, "Wrong alignment on UAmmoComponent");
static_assert(sizeof(UAmmoComponent) == 0x000100, "Wrong size on UAmmoComponent");
static_assert(offsetof(UAmmoComponent, AmmoUsagePerSecond) == 0x0000F8, "Member 'UAmmoComponent::AmmoUsagePerSecond' has a wrong offset!");

// Class ReadyOrNot.AmmoRefillBox
// 0x0038 (0x02D0 - 0x0298)
class AAmmoRefillBox final : public AActor
{
public:
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractableComponent*                 InteractableComponent;                             // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A8[0x8];                                      // 0x02A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AReadyOrNotCharacter*                   RefillCharacter;                                   // 0x02B0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B8[0x18];                                     // 0x02B8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AmmoRefillBox">();
	}
	static class AAmmoRefillBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAmmoRefillBox>();
	}
};
static_assert(alignof(AAmmoRefillBox) == 0x000008, "Wrong alignment on AAmmoRefillBox");
static_assert(sizeof(AAmmoRefillBox) == 0x0002D0, "Wrong size on AAmmoRefillBox");
static_assert(offsetof(AAmmoRefillBox, InteractableComponent) == 0x0002A0, "Member 'AAmmoRefillBox::InteractableComponent' has a wrong offset!");
static_assert(offsetof(AAmmoRefillBox, RefillCharacter) == 0x0002B0, "Member 'AAmmoRefillBox::RefillCharacter' has a wrong offset!");

// Class ReadyOrNot.MissionEventCondition
// 0x0018 (0x0040 - 0x0028)
class UMissionEventCondition : public UObject
{
public:
	class AMissionEventController*                Owner;                                             // 0x0028(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWorld*                                 World;                                             // 0x0030(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInstance;                                       // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsNot;                                            // 0x0039(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTriggered;                                      // 0x003A(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B[0x5];                                       // 0x003B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionEventCondition">();
	}
	static class UMissionEventCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionEventCondition>();
	}
};
static_assert(alignof(UMissionEventCondition) == 0x000008, "Wrong alignment on UMissionEventCondition");
static_assert(sizeof(UMissionEventCondition) == 0x000040, "Wrong size on UMissionEventCondition");
static_assert(offsetof(UMissionEventCondition, Owner) == 0x000028, "Member 'UMissionEventCondition::Owner' has a wrong offset!");
static_assert(offsetof(UMissionEventCondition, World) == 0x000030, "Member 'UMissionEventCondition::World' has a wrong offset!");
static_assert(offsetof(UMissionEventCondition, bIsInstance) == 0x000038, "Member 'UMissionEventCondition::bIsInstance' has a wrong offset!");
static_assert(offsetof(UMissionEventCondition, bIsNot) == 0x000039, "Member 'UMissionEventCondition::bIsNot' has a wrong offset!");
static_assert(offsetof(UMissionEventCondition, bIsTriggered) == 0x00003A, "Member 'UMissionEventCondition::bIsTriggered' has a wrong offset!");

// Class ReadyOrNot.PlacedC2Explosive
// 0x01D8 (0x0470 - 0x0298)
class APlacedC2Explosive : public AActor
{
public:
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystemComponent*               ExplosionComp;                                     // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 MeshComp;                                          // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODAudioComponent*                    AudioComponent;                                    // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractableComponent*                 C2InteractableComponent;                           // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAIPerceptionStimuliSourceComponent*    PerceptionStimuliComp;                             // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARadialForceActor*                      RadialForce;                                       // 0x02C8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AC2Explosive*                           ConnectedC2Explosive;                              // 0x02D0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            PlacedByController;                                // 0x02D8(0x0008)(Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ABaseItem>                  ItemInventoryClass;                                // 0x02E0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageToInflict;                                   // 0x02E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDamageToInflict;                                // 0x02EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageType>                DamageType;                                        // 0x02F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageInnerRadius;                                 // 0x02F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageOuterRadius;                                 // 0x02FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplosionPostKillTime;                             // 0x0300(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDetonated;                                        // 0x0304(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_305[0x3];                                      // 0x0305(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DoorIntegrityDamage;                               // 0x0308(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30C[0x4];                                      // 0x030C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 TargetItem;                                        // 0x0310(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             FMODC2ExplosionAudio;                              // 0x0318(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             PlacementHit;                                      // 0x0320(0x00E8)(Edit, BlueprintVisible, BlueprintReadOnly, Net, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bUseScreenShake;                                   // 0x0408(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_409[0x7];                                      // 0x0409(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ULegacyCameraShake>         ExplosionScreenShake;                              // 0x0410(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCameraShakeBase*                       ExplosionScreenShakeInst;                          // 0x0418(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraShakeRadius;                                 // 0x0420(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_424[0x4];                                      // 0x0424(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStunDamage>                StunDamageType;                                    // 0x0428(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRemovedViaMultitool;                              // 0x0430(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_431[0xF];                                      // 0x0431(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsBeingRemoved;                                   // 0x0440(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_441[0x7];                                      // 0x0441(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AReadyOrNotCharacter*                   IsBeingRemovedBy;                                  // 0x0448(0x0008)(Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         C2OcclusionMultiplier;                             // 0x0450(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         C2FullOcclusionDepth;                              // 0x0454(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UForceFeedbackEffect*                   ForceFeedbackEffect;                               // 0x0458(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UForceFeedbackAttenuation*              ForceFeedbackAttenuation;                          // 0x0460(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_468[0x8];                                      // 0x0468(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class USkeletalMeshComponent* GetMeshComp();
	void Multicast_OnC2Detonated();
	void PostExplosionKill();
	void RemoveFromTarget();
	void Server_DetonateC2();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlacedC2Explosive">();
	}
	static class APlacedC2Explosive* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlacedC2Explosive>();
	}
};
static_assert(alignof(APlacedC2Explosive) == 0x000008, "Wrong alignment on APlacedC2Explosive");
static_assert(sizeof(APlacedC2Explosive) == 0x000470, "Wrong size on APlacedC2Explosive");
static_assert(offsetof(APlacedC2Explosive, ExplosionComp) == 0x0002A0, "Member 'APlacedC2Explosive::ExplosionComp' has a wrong offset!");
static_assert(offsetof(APlacedC2Explosive, MeshComp) == 0x0002A8, "Member 'APlacedC2Explosive::MeshComp' has a wrong offset!");
static_assert(offsetof(APlacedC2Explosive, AudioComponent) == 0x0002B0, "Member 'APlacedC2Explosive::AudioComponent' has a wrong offset!");
static_assert(offsetof(APlacedC2Explosive, C2InteractableComponent) == 0x0002B8, "Member 'APlacedC2Explosive::C2InteractableComponent' has a wrong offset!");
static_assert(offsetof(APlacedC2Explosive, PerceptionStimuliComp) == 0x0002C0, "Member 'APlacedC2Explosive::PerceptionStimuliComp' has a wrong offset!");
static_assert(offsetof(APlacedC2Explosive, RadialForce) == 0x0002C8, "Member 'APlacedC2Explosive::RadialForce' has a wrong offset!");
static_assert(offsetof(APlacedC2Explosive, ConnectedC2Explosive) == 0x0002D0, "Member 'APlacedC2Explosive::ConnectedC2Explosive' has a wrong offset!");
static_assert(offsetof(APlacedC2Explosive, PlacedByController) == 0x0002D8, "Member 'APlacedC2Explosive::PlacedByController' has a wrong offset!");
static_assert(offsetof(APlacedC2Explosive, ItemInventoryClass) == 0x0002E0, "Member 'APlacedC2Explosive::ItemInventoryClass' has a wrong offset!");
static_assert(offsetof(APlacedC2Explosive, DamageToInflict) == 0x0002E8, "Member 'APlacedC2Explosive::DamageToInflict' has a wrong offset!");
static_assert(offsetof(APlacedC2Explosive, MinDamageToInflict) == 0x0002EC, "Member 'APlacedC2Explosive::MinDamageToInflict' has a wrong offset!");
static_assert(offsetof(APlacedC2Explosive, DamageType) == 0x0002F0, "Member 'APlacedC2Explosive::DamageType' has a wrong offset!");
static_assert(offsetof(APlacedC2Explosive, DamageInnerRadius) == 0x0002F8, "Member 'APlacedC2Explosive::DamageInnerRadius' has a wrong offset!");
static_assert(offsetof(APlacedC2Explosive, DamageOuterRadius) == 0x0002FC, "Member 'APlacedC2Explosive::DamageOuterRadius' has a wrong offset!");
static_assert(offsetof(APlacedC2Explosive, ExplosionPostKillTime) == 0x000300, "Member 'APlacedC2Explosive::ExplosionPostKillTime' has a wrong offset!");
static_assert(offsetof(APlacedC2Explosive, bDetonated) == 0x000304, "Member 'APlacedC2Explosive::bDetonated' has a wrong offset!");
static_assert(offsetof(APlacedC2Explosive, DoorIntegrityDamage) == 0x000308, "Member 'APlacedC2Explosive::DoorIntegrityDamage' has a wrong offset!");
static_assert(offsetof(APlacedC2Explosive, TargetItem) == 0x000310, "Member 'APlacedC2Explosive::TargetItem' has a wrong offset!");
static_assert(offsetof(APlacedC2Explosive, FMODC2ExplosionAudio) == 0x000318, "Member 'APlacedC2Explosive::FMODC2ExplosionAudio' has a wrong offset!");
static_assert(offsetof(APlacedC2Explosive, PlacementHit) == 0x000320, "Member 'APlacedC2Explosive::PlacementHit' has a wrong offset!");
static_assert(offsetof(APlacedC2Explosive, bUseScreenShake) == 0x000408, "Member 'APlacedC2Explosive::bUseScreenShake' has a wrong offset!");
static_assert(offsetof(APlacedC2Explosive, ExplosionScreenShake) == 0x000410, "Member 'APlacedC2Explosive::ExplosionScreenShake' has a wrong offset!");
static_assert(offsetof(APlacedC2Explosive, ExplosionScreenShakeInst) == 0x000418, "Member 'APlacedC2Explosive::ExplosionScreenShakeInst' has a wrong offset!");
static_assert(offsetof(APlacedC2Explosive, CameraShakeRadius) == 0x000420, "Member 'APlacedC2Explosive::CameraShakeRadius' has a wrong offset!");
static_assert(offsetof(APlacedC2Explosive, StunDamageType) == 0x000428, "Member 'APlacedC2Explosive::StunDamageType' has a wrong offset!");
static_assert(offsetof(APlacedC2Explosive, bRemovedViaMultitool) == 0x000430, "Member 'APlacedC2Explosive::bRemovedViaMultitool' has a wrong offset!");
static_assert(offsetof(APlacedC2Explosive, bIsBeingRemoved) == 0x000440, "Member 'APlacedC2Explosive::bIsBeingRemoved' has a wrong offset!");
static_assert(offsetof(APlacedC2Explosive, IsBeingRemovedBy) == 0x000448, "Member 'APlacedC2Explosive::IsBeingRemovedBy' has a wrong offset!");
static_assert(offsetof(APlacedC2Explosive, C2OcclusionMultiplier) == 0x000450, "Member 'APlacedC2Explosive::C2OcclusionMultiplier' has a wrong offset!");
static_assert(offsetof(APlacedC2Explosive, C2FullOcclusionDepth) == 0x000454, "Member 'APlacedC2Explosive::C2FullOcclusionDepth' has a wrong offset!");
static_assert(offsetof(APlacedC2Explosive, ForceFeedbackEffect) == 0x000458, "Member 'APlacedC2Explosive::ForceFeedbackEffect' has a wrong offset!");
static_assert(offsetof(APlacedC2Explosive, ForceFeedbackAttenuation) == 0x000460, "Member 'APlacedC2Explosive::ForceFeedbackAttenuation' has a wrong offset!");

// Class ReadyOrNot.AnimatedDecal
// 0x0098 (0x0378 - 0x02E0)
class AAnimatedDecal : public APooledActor
{
public:
	class UDecalComponent*                        Decal;                                             // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimationTimescale;                                // 0x02E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EC[0x4];                                      // 0x02EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     AnimationCurve;                                    // 0x02F0(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static float GetRuntimeFloatCurveValue(const struct FRuntimeFloatCurve& Curve, float Time);

	void SetAnimatedDecalMaterial(class UMaterialInterface* Material);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimatedDecal">();
	}
	static class AAnimatedDecal* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAnimatedDecal>();
	}
};
static_assert(alignof(AAnimatedDecal) == 0x000008, "Wrong alignment on AAnimatedDecal");
static_assert(sizeof(AAnimatedDecal) == 0x000378, "Wrong size on AAnimatedDecal");
static_assert(offsetof(AAnimatedDecal, Decal) == 0x0002E0, "Member 'AAnimatedDecal::Decal' has a wrong offset!");
static_assert(offsetof(AAnimatedDecal, AnimationTimescale) == 0x0002E8, "Member 'AAnimatedDecal::AnimationTimescale' has a wrong offset!");
static_assert(offsetof(AAnimatedDecal, AnimationCurve) == 0x0002F0, "Member 'AAnimatedDecal::AnimationCurve' has a wrong offset!");

// Class ReadyOrNot.BaseWeapon
// 0x0700 (0x12B0 - 0x0BB0)
#pragma pack(push, 0x1)
class alignas(0x10) ABaseWeapon : public ABaseItem
{
public:
	bool                                          bPistolGrip;                                       // 0x0BB0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFireMode                                     FiremodeBeforeSafe;                                // 0x0BB1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_BB2[0x6];                                      // 0x0BB2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAmmoTypeData                          CurrentAmmoType;                                   // 0x0BB8(0x0170)(Edit, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_D28[0x8];                                      // 0x0D28(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             AmmoDataTable;                                     // 0x0D30(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           AmmunitionTypes;                                   // 0x0D38(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UReadyOrNotLoadoutManager*              LoadoutFunctionLibrary;                            // 0x0D48(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UArrowComponent*                        BulletSpawn;                                       // 0x0D50(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UArrowComponent*                        ShellSpawn;                                        // 0x0D58(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystemComponent*               ShellParticle;                                     // 0x0D60(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USpotLightComponent*                    Flashlight;                                        // 0x0D68(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UScopedWeaponAttachment*                ScopeAttachment;                                   // 0x0D70(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWeaponAttachment*                      MuzzleAttachment;                                  // 0x0D78(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWeaponAttachment*                      UnderbarrelAttachment;                             // 0x0D80(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWeaponAttachment*                      OverbarrelAttachment;                              // 0x0D88(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWeaponAttachment*                      StockAttachment;                                   // 0x0D90(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWeaponAttachment*                      GripAttachment;                                    // 0x0D98(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWeaponAttachment*                      IlluminatorAttachment;                             // 0x0DA0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWeaponAttachment*                      AmmunitionAttachment;                              // 0x0DA8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODAudioComponent*                    ADSAudioComponent;                                 // 0x0DB0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODAudioComponent*                    ADSEndAudioComponent;                              // 0x0DB8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODAudioComponent*                    ADSAudioComponents[0x5];                           // 0x0DC0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODAudioComponent*                    ADSEndAudioComponents[0x5];                        // 0x0DE8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E10[0x4];                                      // 0x0E10(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AttachmentPoints;                                  // 0x0E14(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSupressed;                                        // 0x0E18(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E19[0x7];                                      // 0x0E19(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               AimAssistRotation;                                 // 0x0E20(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_E38[0x8];                                      // 0x0E38(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(EFireMode newFireMode)> OnFireModeChanged;                         // 0x0E40(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EFireMode                                     CurrentFireMode;                                   // 0x0E50(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFireMode                                     DefaultFireMode;                                   // 0x0E51(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E52[0x6];                                      // 0x0E52(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EFireMode>                             AvailableFireModes;                                // 0x0E58(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         BurstBulletCount;                                  // 0x0E68(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasSafeMode;                                      // 0x0E6C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E6D[0x3];                                      // 0x0E6D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AddedMagazineCountFromAttachments;                 // 0x0E70(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Optics_UI_Socket;                                  // 0x0E74(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Grip_UI_Socket;                                    // 0x0E7C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Muzzle_UI_Socket;                                  // 0x0E84(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Stock_UI_Socket;                                   // 0x0E8C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Magazine_UI_Socket;                                // 0x0E94(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ADSZoom;                                           // 0x0E9C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ADSZoomInSpeed;                                    // 0x0EA0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ADSZoomOutSpeed;                                   // 0x0EA4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageType>                DefaultDamageType;                                 // 0x0EA8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageType>                DamageType;                                        // 0x0EB0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ULegacyCameraShake>         FireCameraShake;                                   // 0x0EB8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCameraShakeBase*                       FireCameraShakeInst;                               // 0x0EC0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     DamageOverRange;                                   // 0x0EC8(0x0088)(Edit, NativeAccessSpecifierPublic)
	float                                         Damage;                                            // 0x0F50(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageSeverityMultiplier;                          // 0x0F54(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageSeverityChance;                              // 0x0F58(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BleedoutDamageMultiplier;                          // 0x0F5C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BleedoutDamageChance;                              // 0x0F60(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultDamage;                                     // 0x0F64(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FireRate;                                          // 0x0F68(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinFireRateAI;                                     // 0x0F6C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxFireRateAI;                                     // 0x0F70(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BulletsFiredUntilFullyAccurate;                    // 0x0F74(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProjectileMovementSpeed;                           // 0x0F78(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bArmorPiercing;                                    // 0x0F7C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F7D[0x3];                                      // 0x0F7D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AImpactEffect>              ImpactEffects;                                     // 0x0F80(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AImpactEffect>              RicochetEffects;                                   // 0x0F88(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        RicochetParticleSystem;                            // 0x0F90(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             RicochetEvent;                                     // 0x0F98(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     SpallingDecal;                                     // 0x0FA0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        SpallingParticleSystem;                            // 0x0FA8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             SpallingEvent;                                     // 0x0FB0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AImpactEffect>              ExitEffects;                                       // 0x0FB8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Wobble;                                            // 0x0FC0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialWobbleDelay;                                // 0x0FC4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttachBulletOnHit;                                // 0x0FC8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC9[0x3];                                      // 0x0FC9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BulletPhysicsImpulseMultiplier;                    // 0x0FCC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDestroyBulletOnHit;                               // 0x0FD0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FD1[0x7];                                      // 0x0FD1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMesh*                          BulletProjectileMesh;                              // 0x0FD8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            FakeProjectileMeshStatic;                          // 0x0FE0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            BulletProjectileMeshStatic;                        // 0x0FE8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BulletProjectileScale;                             // 0x0FF0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ABaseShell>                 ShellClass;                                        // 0x1008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            ShellMesh;                                         // 0x1010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FRotator>                       RecoilPattern;                                     // 0x1018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1028[0x4];                                     // 0x1028(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BulletDrag;                                        // 0x102C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilInterpSpeed;                                 // 0x1030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ADSRecoilMultiplier;                               // 0x1034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ADSSpreadMultiplier;                               // 0x1038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilReturnRate;                                  // 0x103C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreAmmoTypeSpread;                             // 0x1040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1041[0x7];                                     // 0x1041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               SpreadPattern;                                     // 0x1048(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1060[0x4];                                     // 0x1060(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpreadReturnRate;                                  // 0x1064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               PendingSpread;                                     // 0x1068(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               fireDirection;                                     // 0x1080(0x0018)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         GlimmerIntensity;                                  // 0x1098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpawnProjectileCount;                              // 0x109C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FirstShotRecoil;                                   // 0x10A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FirstShotSpread;                                   // 0x10A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FirstShotResetTime;                                // 0x10A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VelocitySpreadMultiplier;                          // 0x10AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VelocityRecoilMultiplier;                          // 0x10B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilMultiplierPitch;                             // 0x10B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilMultiplierYaw;                               // 0x10B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RefireDelay;                                       // 0x10BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilReturnPercentage;                            // 0x10C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilReturnInterpSpeed;                           // 0x10C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10C8[0x2A];                                    // 0x10C8(0x002A)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAcceptsScopeAttachments;                          // 0x10F2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAcceptsMuzzleAttachments;                         // 0x10F3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAcceptsUnderbarrelAttachments;                    // 0x10F4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAcceptsOverbarrelAttachments;                     // 0x10F5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAcceptsStockAttachments;                          // 0x10F6(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAcceptsGripAttachments;                           // 0x10F7(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAcceptsIlluminatorAttachments;                    // 0x10F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAcceptsAmmunitionAttachments;                     // 0x10F9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10FA[0x6];                                     // 0x10FA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UScopedWeaponAttachment>> AvailableScopeAttachments;                    // 0x1100(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UWeaponAttachment>>  AvailableMuzzleAttachments;                        // 0x1110(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UWeaponAttachment>>  AvailableUnderbarrelAttachments;                   // 0x1120(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UWeaponAttachment>>  AvailableOverbarrelAttachments;                    // 0x1130(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UWeaponAttachment>>  AvailableStockAttachments;                         // 0x1140(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UWeaponAttachment>>  AvailableGripAttachments;                          // 0x1150(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UWeaponAttachment>>  AvailableIlluminatorAttachments;                   // 0x1160(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UWeaponAttachment>>  AvailableAmmunitionAttachments;                    // 0x1170(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bCalculateProcRecoil;                              // 0x1180(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1181[0x3];                                     // 0x1181(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RecoilDampStrength;                                // 0x1184(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilFireTime;                                    // 0x1188(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilFireStrength;                                // 0x118C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilFireStrengthFirst;                           // 0x1190(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilAngleStrength;                               // 0x1194(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilRandomness;                                  // 0x1198(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilFireADSModifier;                             // 0x119C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilAngleADSModifier;                            // 0x11A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11A4[0x4];                                     // 0x11A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               RecoilRotationBuildup;                             // 0x11A8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RecoilPositionBuildup;                             // 0x11C0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilBuildupADSModifier;                          // 0x11D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RecoilHasBuildup;                                  // 0x11DC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11DD[0x3];                                     // 0x11DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RecoilBuildupDampStrength;                         // 0x11E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11E4[0x4C];                                    // 0x11E4(0x004C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ProcRecoil_Trans;                                  // 0x1230(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ProcRecoil_Rot;                                    // 0x1248(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                ProcRecoil_Trans_Buildup;                          // 0x1260(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ProcRecoil_Rot_Buildup;                            // 0x1278(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         CurrentHighTimer;                                  // 0x1290(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReloadHighTimer;                                   // 0x1294(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FireHighTimer;                                     // 0x1298(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EquipHighTimer;                                    // 0x129C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseScopeMask;                                     // 0x12A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         TriggerEffectStartPosition;                        // 0x12A1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         TriggerEffectEndPosition;                          // 0x12A2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         TriggerEffectStrength;                             // 0x12A3(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayFireSelectPartAnims;                          // 0x12A4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12A5[0x3];                                     // 0x12A5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddAttachment(class UClass* Class_0, bool bReplicateAttachment);
	void AddMagazineCountFromAttachments(float AddAmount);
	bool CanAddAttachment(class UClass* AttachmentClass);
	bool CanReload();
	void DisableGlimmer();
	void EnableGlimmer();
	class ULaserAttachment* GetLaserAttachment();
	class ULightAttachment* GetLightAttachment();
	struct FRotator GetRecoil();
	struct FRotator GetSpread();
	void OnAimDownSights(bool bWasAiming);
	void OnEndAimDownSights(bool bWasAiming);
	void OnFireAtBulletSpawn();
	void OnWeaponFired(const struct FRotator& fireDirection_0);
	void OnWeaponFiredEnd();
	void OnWeaponReloadComplete();
	void OnWeaponReloadStarted();
	void PlayFiringModeAnimation();
	void RemoveAttachment(bool bScopedAttachment, bool bMuzzleAttachment, bool bUnderbarrelAttachment, bool bOverbarrelAttachment, bool bStockAttachment, bool bGripAttachment, bool bIlluminatorAttachment, bool bAmmunitionAttachment);
	void ResetRecoilSettingsToDefault();
	void UpdateStoredAttachments(TSubclassOf<class UWeaponAttachment> Attachment);

	EWeaponUnderbarrelAnimationType GetUnderbarrelAnimationType() const;
	bool IsLessLethalWeapon() const;
	bool IsLethalWeapon() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseWeapon">();
	}
	static class ABaseWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseWeapon>();
	}
};
#pragma pack(pop)
static_assert(alignof(ABaseWeapon) == 0x000010, "Wrong alignment on ABaseWeapon");
static_assert(sizeof(ABaseWeapon) == 0x0012B0, "Wrong size on ABaseWeapon");
static_assert(offsetof(ABaseWeapon, bPistolGrip) == 0x000BB0, "Member 'ABaseWeapon::bPistolGrip' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, FiremodeBeforeSafe) == 0x000BB1, "Member 'ABaseWeapon::FiremodeBeforeSafe' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, CurrentAmmoType) == 0x000BB8, "Member 'ABaseWeapon::CurrentAmmoType' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, AmmoDataTable) == 0x000D30, "Member 'ABaseWeapon::AmmoDataTable' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, AmmunitionTypes) == 0x000D38, "Member 'ABaseWeapon::AmmunitionTypes' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, LoadoutFunctionLibrary) == 0x000D48, "Member 'ABaseWeapon::LoadoutFunctionLibrary' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, BulletSpawn) == 0x000D50, "Member 'ABaseWeapon::BulletSpawn' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, ShellSpawn) == 0x000D58, "Member 'ABaseWeapon::ShellSpawn' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, ShellParticle) == 0x000D60, "Member 'ABaseWeapon::ShellParticle' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, Flashlight) == 0x000D68, "Member 'ABaseWeapon::Flashlight' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, ScopeAttachment) == 0x000D70, "Member 'ABaseWeapon::ScopeAttachment' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, MuzzleAttachment) == 0x000D78, "Member 'ABaseWeapon::MuzzleAttachment' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, UnderbarrelAttachment) == 0x000D80, "Member 'ABaseWeapon::UnderbarrelAttachment' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, OverbarrelAttachment) == 0x000D88, "Member 'ABaseWeapon::OverbarrelAttachment' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, StockAttachment) == 0x000D90, "Member 'ABaseWeapon::StockAttachment' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, GripAttachment) == 0x000D98, "Member 'ABaseWeapon::GripAttachment' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, IlluminatorAttachment) == 0x000DA0, "Member 'ABaseWeapon::IlluminatorAttachment' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, AmmunitionAttachment) == 0x000DA8, "Member 'ABaseWeapon::AmmunitionAttachment' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, ADSAudioComponent) == 0x000DB0, "Member 'ABaseWeapon::ADSAudioComponent' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, ADSEndAudioComponent) == 0x000DB8, "Member 'ABaseWeapon::ADSEndAudioComponent' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, ADSAudioComponents) == 0x000DC0, "Member 'ABaseWeapon::ADSAudioComponents' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, ADSEndAudioComponents) == 0x000DE8, "Member 'ABaseWeapon::ADSEndAudioComponents' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, AttachmentPoints) == 0x000E14, "Member 'ABaseWeapon::AttachmentPoints' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, bSupressed) == 0x000E18, "Member 'ABaseWeapon::bSupressed' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, AimAssistRotation) == 0x000E20, "Member 'ABaseWeapon::AimAssistRotation' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, OnFireModeChanged) == 0x000E40, "Member 'ABaseWeapon::OnFireModeChanged' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, CurrentFireMode) == 0x000E50, "Member 'ABaseWeapon::CurrentFireMode' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, DefaultFireMode) == 0x000E51, "Member 'ABaseWeapon::DefaultFireMode' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, AvailableFireModes) == 0x000E58, "Member 'ABaseWeapon::AvailableFireModes' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, BurstBulletCount) == 0x000E68, "Member 'ABaseWeapon::BurstBulletCount' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, bHasSafeMode) == 0x000E6C, "Member 'ABaseWeapon::bHasSafeMode' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, AddedMagazineCountFromAttachments) == 0x000E70, "Member 'ABaseWeapon::AddedMagazineCountFromAttachments' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, Optics_UI_Socket) == 0x000E74, "Member 'ABaseWeapon::Optics_UI_Socket' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, Grip_UI_Socket) == 0x000E7C, "Member 'ABaseWeapon::Grip_UI_Socket' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, Muzzle_UI_Socket) == 0x000E84, "Member 'ABaseWeapon::Muzzle_UI_Socket' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, Stock_UI_Socket) == 0x000E8C, "Member 'ABaseWeapon::Stock_UI_Socket' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, Magazine_UI_Socket) == 0x000E94, "Member 'ABaseWeapon::Magazine_UI_Socket' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, ADSZoom) == 0x000E9C, "Member 'ABaseWeapon::ADSZoom' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, ADSZoomInSpeed) == 0x000EA0, "Member 'ABaseWeapon::ADSZoomInSpeed' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, ADSZoomOutSpeed) == 0x000EA4, "Member 'ABaseWeapon::ADSZoomOutSpeed' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, DefaultDamageType) == 0x000EA8, "Member 'ABaseWeapon::DefaultDamageType' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, DamageType) == 0x000EB0, "Member 'ABaseWeapon::DamageType' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, FireCameraShake) == 0x000EB8, "Member 'ABaseWeapon::FireCameraShake' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, FireCameraShakeInst) == 0x000EC0, "Member 'ABaseWeapon::FireCameraShakeInst' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, DamageOverRange) == 0x000EC8, "Member 'ABaseWeapon::DamageOverRange' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, Damage) == 0x000F50, "Member 'ABaseWeapon::Damage' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, DamageSeverityMultiplier) == 0x000F54, "Member 'ABaseWeapon::DamageSeverityMultiplier' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, DamageSeverityChance) == 0x000F58, "Member 'ABaseWeapon::DamageSeverityChance' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, BleedoutDamageMultiplier) == 0x000F5C, "Member 'ABaseWeapon::BleedoutDamageMultiplier' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, BleedoutDamageChance) == 0x000F60, "Member 'ABaseWeapon::BleedoutDamageChance' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, DefaultDamage) == 0x000F64, "Member 'ABaseWeapon::DefaultDamage' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, FireRate) == 0x000F68, "Member 'ABaseWeapon::FireRate' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, MinFireRateAI) == 0x000F6C, "Member 'ABaseWeapon::MinFireRateAI' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, MaxFireRateAI) == 0x000F70, "Member 'ABaseWeapon::MaxFireRateAI' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, BulletsFiredUntilFullyAccurate) == 0x000F74, "Member 'ABaseWeapon::BulletsFiredUntilFullyAccurate' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, ProjectileMovementSpeed) == 0x000F78, "Member 'ABaseWeapon::ProjectileMovementSpeed' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, bArmorPiercing) == 0x000F7C, "Member 'ABaseWeapon::bArmorPiercing' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, ImpactEffects) == 0x000F80, "Member 'ABaseWeapon::ImpactEffects' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, RicochetEffects) == 0x000F88, "Member 'ABaseWeapon::RicochetEffects' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, RicochetParticleSystem) == 0x000F90, "Member 'ABaseWeapon::RicochetParticleSystem' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, RicochetEvent) == 0x000F98, "Member 'ABaseWeapon::RicochetEvent' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, SpallingDecal) == 0x000FA0, "Member 'ABaseWeapon::SpallingDecal' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, SpallingParticleSystem) == 0x000FA8, "Member 'ABaseWeapon::SpallingParticleSystem' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, SpallingEvent) == 0x000FB0, "Member 'ABaseWeapon::SpallingEvent' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, ExitEffects) == 0x000FB8, "Member 'ABaseWeapon::ExitEffects' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, Wobble) == 0x000FC0, "Member 'ABaseWeapon::Wobble' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, InitialWobbleDelay) == 0x000FC4, "Member 'ABaseWeapon::InitialWobbleDelay' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, bAttachBulletOnHit) == 0x000FC8, "Member 'ABaseWeapon::bAttachBulletOnHit' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, BulletPhysicsImpulseMultiplier) == 0x000FCC, "Member 'ABaseWeapon::BulletPhysicsImpulseMultiplier' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, bDestroyBulletOnHit) == 0x000FD0, "Member 'ABaseWeapon::bDestroyBulletOnHit' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, BulletProjectileMesh) == 0x000FD8, "Member 'ABaseWeapon::BulletProjectileMesh' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, FakeProjectileMeshStatic) == 0x000FE0, "Member 'ABaseWeapon::FakeProjectileMeshStatic' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, BulletProjectileMeshStatic) == 0x000FE8, "Member 'ABaseWeapon::BulletProjectileMeshStatic' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, BulletProjectileScale) == 0x000FF0, "Member 'ABaseWeapon::BulletProjectileScale' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, ShellClass) == 0x001008, "Member 'ABaseWeapon::ShellClass' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, ShellMesh) == 0x001010, "Member 'ABaseWeapon::ShellMesh' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, RecoilPattern) == 0x001018, "Member 'ABaseWeapon::RecoilPattern' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, BulletDrag) == 0x00102C, "Member 'ABaseWeapon::BulletDrag' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, RecoilInterpSpeed) == 0x001030, "Member 'ABaseWeapon::RecoilInterpSpeed' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, ADSRecoilMultiplier) == 0x001034, "Member 'ABaseWeapon::ADSRecoilMultiplier' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, ADSSpreadMultiplier) == 0x001038, "Member 'ABaseWeapon::ADSSpreadMultiplier' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, RecoilReturnRate) == 0x00103C, "Member 'ABaseWeapon::RecoilReturnRate' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, bIgnoreAmmoTypeSpread) == 0x001040, "Member 'ABaseWeapon::bIgnoreAmmoTypeSpread' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, SpreadPattern) == 0x001048, "Member 'ABaseWeapon::SpreadPattern' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, SpreadReturnRate) == 0x001064, "Member 'ABaseWeapon::SpreadReturnRate' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, PendingSpread) == 0x001068, "Member 'ABaseWeapon::PendingSpread' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, fireDirection) == 0x001080, "Member 'ABaseWeapon::fireDirection' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, GlimmerIntensity) == 0x001098, "Member 'ABaseWeapon::GlimmerIntensity' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, SpawnProjectileCount) == 0x00109C, "Member 'ABaseWeapon::SpawnProjectileCount' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, FirstShotRecoil) == 0x0010A0, "Member 'ABaseWeapon::FirstShotRecoil' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, FirstShotSpread) == 0x0010A4, "Member 'ABaseWeapon::FirstShotSpread' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, FirstShotResetTime) == 0x0010A8, "Member 'ABaseWeapon::FirstShotResetTime' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, VelocitySpreadMultiplier) == 0x0010AC, "Member 'ABaseWeapon::VelocitySpreadMultiplier' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, VelocityRecoilMultiplier) == 0x0010B0, "Member 'ABaseWeapon::VelocityRecoilMultiplier' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, RecoilMultiplierPitch) == 0x0010B4, "Member 'ABaseWeapon::RecoilMultiplierPitch' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, RecoilMultiplierYaw) == 0x0010B8, "Member 'ABaseWeapon::RecoilMultiplierYaw' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, RefireDelay) == 0x0010BC, "Member 'ABaseWeapon::RefireDelay' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, RecoilReturnPercentage) == 0x0010C0, "Member 'ABaseWeapon::RecoilReturnPercentage' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, RecoilReturnInterpSpeed) == 0x0010C4, "Member 'ABaseWeapon::RecoilReturnInterpSpeed' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, bAcceptsScopeAttachments) == 0x0010F2, "Member 'ABaseWeapon::bAcceptsScopeAttachments' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, bAcceptsMuzzleAttachments) == 0x0010F3, "Member 'ABaseWeapon::bAcceptsMuzzleAttachments' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, bAcceptsUnderbarrelAttachments) == 0x0010F4, "Member 'ABaseWeapon::bAcceptsUnderbarrelAttachments' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, bAcceptsOverbarrelAttachments) == 0x0010F5, "Member 'ABaseWeapon::bAcceptsOverbarrelAttachments' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, bAcceptsStockAttachments) == 0x0010F6, "Member 'ABaseWeapon::bAcceptsStockAttachments' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, bAcceptsGripAttachments) == 0x0010F7, "Member 'ABaseWeapon::bAcceptsGripAttachments' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, bAcceptsIlluminatorAttachments) == 0x0010F8, "Member 'ABaseWeapon::bAcceptsIlluminatorAttachments' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, bAcceptsAmmunitionAttachments) == 0x0010F9, "Member 'ABaseWeapon::bAcceptsAmmunitionAttachments' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, AvailableScopeAttachments) == 0x001100, "Member 'ABaseWeapon::AvailableScopeAttachments' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, AvailableMuzzleAttachments) == 0x001110, "Member 'ABaseWeapon::AvailableMuzzleAttachments' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, AvailableUnderbarrelAttachments) == 0x001120, "Member 'ABaseWeapon::AvailableUnderbarrelAttachments' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, AvailableOverbarrelAttachments) == 0x001130, "Member 'ABaseWeapon::AvailableOverbarrelAttachments' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, AvailableStockAttachments) == 0x001140, "Member 'ABaseWeapon::AvailableStockAttachments' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, AvailableGripAttachments) == 0x001150, "Member 'ABaseWeapon::AvailableGripAttachments' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, AvailableIlluminatorAttachments) == 0x001160, "Member 'ABaseWeapon::AvailableIlluminatorAttachments' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, AvailableAmmunitionAttachments) == 0x001170, "Member 'ABaseWeapon::AvailableAmmunitionAttachments' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, bCalculateProcRecoil) == 0x001180, "Member 'ABaseWeapon::bCalculateProcRecoil' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, RecoilDampStrength) == 0x001184, "Member 'ABaseWeapon::RecoilDampStrength' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, RecoilFireTime) == 0x001188, "Member 'ABaseWeapon::RecoilFireTime' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, RecoilFireStrength) == 0x00118C, "Member 'ABaseWeapon::RecoilFireStrength' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, RecoilFireStrengthFirst) == 0x001190, "Member 'ABaseWeapon::RecoilFireStrengthFirst' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, RecoilAngleStrength) == 0x001194, "Member 'ABaseWeapon::RecoilAngleStrength' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, RecoilRandomness) == 0x001198, "Member 'ABaseWeapon::RecoilRandomness' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, RecoilFireADSModifier) == 0x00119C, "Member 'ABaseWeapon::RecoilFireADSModifier' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, RecoilAngleADSModifier) == 0x0011A0, "Member 'ABaseWeapon::RecoilAngleADSModifier' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, RecoilRotationBuildup) == 0x0011A8, "Member 'ABaseWeapon::RecoilRotationBuildup' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, RecoilPositionBuildup) == 0x0011C0, "Member 'ABaseWeapon::RecoilPositionBuildup' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, RecoilBuildupADSModifier) == 0x0011D8, "Member 'ABaseWeapon::RecoilBuildupADSModifier' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, RecoilHasBuildup) == 0x0011DC, "Member 'ABaseWeapon::RecoilHasBuildup' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, RecoilBuildupDampStrength) == 0x0011E0, "Member 'ABaseWeapon::RecoilBuildupDampStrength' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, ProcRecoil_Trans) == 0x001230, "Member 'ABaseWeapon::ProcRecoil_Trans' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, ProcRecoil_Rot) == 0x001248, "Member 'ABaseWeapon::ProcRecoil_Rot' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, ProcRecoil_Trans_Buildup) == 0x001260, "Member 'ABaseWeapon::ProcRecoil_Trans_Buildup' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, ProcRecoil_Rot_Buildup) == 0x001278, "Member 'ABaseWeapon::ProcRecoil_Rot_Buildup' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, CurrentHighTimer) == 0x001290, "Member 'ABaseWeapon::CurrentHighTimer' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, ReloadHighTimer) == 0x001294, "Member 'ABaseWeapon::ReloadHighTimer' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, FireHighTimer) == 0x001298, "Member 'ABaseWeapon::FireHighTimer' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, EquipHighTimer) == 0x00129C, "Member 'ABaseWeapon::EquipHighTimer' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, bUseScopeMask) == 0x0012A0, "Member 'ABaseWeapon::bUseScopeMask' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, TriggerEffectStartPosition) == 0x0012A1, "Member 'ABaseWeapon::TriggerEffectStartPosition' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, TriggerEffectEndPosition) == 0x0012A2, "Member 'ABaseWeapon::TriggerEffectEndPosition' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, TriggerEffectStrength) == 0x0012A3, "Member 'ABaseWeapon::TriggerEffectStrength' has a wrong offset!");
static_assert(offsetof(ABaseWeapon, bPlayFireSelectPartAnims) == 0x0012A4, "Member 'ABaseWeapon::bPlayFireSelectPartAnims' has a wrong offset!");

// Class ReadyOrNot.BaseMagazineWeapon
// 0x0490 (0x1740 - 0x12B0)
#pragma pack(push, 0x1)
class alignas(0x10) ABaseMagazineWeapon : public ABaseWeapon
{
public:
	uint8                                         Pad_12A8[0x8];                                     // 0x12A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystemComponent*               MuzzleFlashParticleComponent;                      // 0x12B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystemComponent*               MuzzleSmokeParticleComponent;                      // 0x12B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystemComponent*               HeatSmokeParticleComponent;                        // 0x12C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystemComponent*               RicochetParticleComponent;                         // 0x12C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystemComponent*               RicochetParticleComponents[0x5];                   // 0x12D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12F8[0x38];                                    // 0x12F8(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODAudioComponent*                    FiringAudioComp;                                   // 0x1330(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CartridgeText;                                     // 0x1338(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RPMText;                                           // 0x1348(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BarrelLengthText;                                  // 0x1358(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CapacityText;                                      // 0x1368(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MuzzleVelocityText;                                // 0x1378(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SupressionStrength;                                // 0x1388(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_138C[0x4];                                     // 0x138C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ULegacyCameraShake>         SupressionCameraShake;                             // 0x1390(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpawnNoTrail;                                     // 0x1398(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1399[0x7];                                     // 0x1399(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ABulletTracer*>                  BulletTracers;                                     // 0x13A0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class ABaseShell*>                     SpawnedShells;                                     // 0x13B0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ABaseMagazineWeapon* Weapon, bool bServer)> OnWeaponFire;    // 0x13C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ABaseMagazineWeapon* Weapon, bool bServer)> OnWeaponDryFire; // 0x13D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_13E0[0x20];                                    // 0x13E0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bBufferFireInput;                                  // 0x1400(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1401[0x13];                                    // 0x1401(0x0013)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bReloading;                                        // 0x1414(0x0001)(Edit, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCancelReloading;                                  // 0x1415(0x0001)(Edit, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHitScan;                                          // 0x1416(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpawnTracer;                                      // 0x1417(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNoSpawnTracerForFiringPlayer;                     // 0x1418(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1419[0xB];                                     // 0x1419(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MuzzleFlashParticleSocket;                         // 0x1424(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MuzzleSmokeParticleSocket;                         // 0x142C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1434[0x4];                                     // 0x1434(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           GunTails_Handle;                                   // 0x1438(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowParticlesWhenFiring;                          // 0x1440(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1441[0x7];                                     // 0x1441(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UDamageType>                ArmorPiercingDamageType;                           // 0x1448(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        ProjectileAttachedParticle;                        // 0x1450(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawBlood;                                        // 0x1458(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1459[0x7];                                     // 0x1459(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ABulletProjectile>          FakeBulletProjectile;                              // 0x1460(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ABulletProjectile>          BulletProjectile;                                  // 0x1468(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ABulletProjectile>          ArmorPiercingBulletProjectile;                     // 0x1470(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PenetrationDistance;                               // 0x1478(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_147C[0x4];                                     // 0x147C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            BreachShell;                                       // 0x1480(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            BeanbagShell;                                      // 0x1488(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            BuckShotShell;                                     // 0x1490(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            SlugShell;                                         // 0x1498(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MagazineSocket;                                    // 0x14A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FMagazine>                      Magazines;                                         // 0x14A8(0x0010)(Edit, BlueprintVisible, Net, ZeroConstructor, Transient, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         MagIndex;                                          // 0x14B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NextMagIndex;                                      // 0x14BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HideBoneWhenNotReloading;                          // 0x14C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DesiredAmmoType;                                   // 0x14C8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bInfiniteAmmo : 1;                                 // 0x14CC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_14CD[0x3];                                     // 0x14CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         QueuedAmmoType;                                    // 0x14D0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBulletInChamberOnReload;                          // 0x14D4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTacReloadWhenEmpty;                               // 0x14D5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14D6[0x2];                                     // 0x14D6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AmmoMax;                                           // 0x14D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LockIntegrityMinDamage;                            // 0x14DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LockIntegrityMaxDamage;                            // 0x14E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoseMagOnReload;                                  // 0x14E4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpawnShell;                                       // 0x14E5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14E6[0x2];                                     // 0x14E6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpawnShellDelay;                                   // 0x14E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14EC[0x4];                                     // 0x14EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             ShellBounceFMODAudio;                              // 0x14F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14F8[0x14];                                    // 0x14F8(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ImpactDecalScale;                                  // 0x150C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AImpactEffect*                          ImpactEffects_Instance;                            // 0x1510(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AImpactEffect*>                  SpawnedImpactEffects;                              // 0x1518(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class FName                                   Magazine_HandSocket;                               // 0x1528(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowAmmoTypesOnHUD;                               // 0x1530(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1531[0x7];                                     // 0x1531(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 MoraleHighReloadTableOverride;                     // 0x1538(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MoraleMediumReloadTableOverride;                   // 0x1548(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MoraleLowReloadTableOverride;                      // 0x1558(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1568[0x8];                                     // 0x1568(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ABulletProjectile*                      LastSpawnedProjectile;                             // 0x1570(0x0008)(Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1578[0x8];                                     // 0x1578(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MagCheckOverrideSocket;                            // 0x1580(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasVisibleMags;                                   // 0x1588(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1589[0x3];                                     // 0x1589(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Mag_01_Socket;                                     // 0x158C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Mag_01_Bullets_Socket;                             // 0x1594(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Mag_01_Extra_Socket;                               // 0x159C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15A4[0x4];                                     // 0x15A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   Mag_01_Comp;                                       // 0x15A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   Mag_01_Comp_TPOnly;                                // 0x15B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowBulletsWhenEmpty;                             // 0x15B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15B9[0x7];                                     // 0x15B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   Mag_01_Bullets_Comp;                               // 0x15C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   Mag_01_Extra_Comp;                                 // 0x15C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   Mag_ReloadInterpFix_Comp;                          // 0x15D0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15D8[0x70];                                    // 0x15D8(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            Mag_01_Static;                                     // 0x1648(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            Mag_01_FMJ_Bullets_Static;                         // 0x1650(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            Mag_01_HP_Bullets_Static;                          // 0x1658(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            Mag_01_Extra_Static;                               // 0x1660(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Mag_02_Socket;                                     // 0x1668(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Mag_02_Bullets_Socket;                             // 0x1670(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Mag_02_Extra_Socket;                               // 0x1678(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   Mag_02_Comp;                                       // 0x1680(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   Mag_02_Bullets_Comp;                               // 0x1688(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   Mag_02_Extra_Comp;                                 // 0x1690(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            Mag_02_Static;                                     // 0x1698(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            Mag_02_FMJ_Bullets_Static;                         // 0x16A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            Mag_02_HP_Bullets_Static;                          // 0x16A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            Mag_02_Extra_Static;                               // 0x16B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseFireLoopAnims;                                 // 0x16B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16B9[0x7];                                     // 0x16B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             MagCheckIcon_Empty;                                // 0x16C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             MagCheckIcon_Full;                                 // 0x16C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             DroppedMagazineHitEvent;                           // 0x16D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeatPerShot;                                       // 0x16D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeatThreshold;                                     // 0x16DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeatMax;                                           // 0x16E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeatDissipation;                                   // 0x16E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentHeat;                                       // 0x16E8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeatMinimumTime;                                   // 0x16EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeatTime;                                          // 0x16F0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHeatEffectPlayed;                                 // 0x16F4(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16F5[0x3];                                     // 0x16F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MagazineWeightFull;                                // 0x16F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MagazineWeightEmpty;                               // 0x16FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagazineCountDefault;                              // 0x1700(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagazineCountMin;                                  // 0x1704(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagazineCountMax;                                  // 0x1708(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_170C[0x4];                                     // 0x170C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MagazineLabel;                                     // 0x1710(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasBeenDisassembled;                              // 0x1718(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1719[0x3];                                     // 0x1719(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GunshotOcclusionMultiplier;                        // 0x171C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GunshotFullOcclusionDepth;                         // 0x1720(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShootingYellBias;                                  // 0x1724(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTwoHandedPistol;                                  // 0x1728(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHeavyRifle;                                       // 0x1729(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_172A[0x2];                                     // 0x172A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RagdollImpulseMultiplier;                          // 0x172C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UForceFeedbackEffect*                   ForceFeedbackEffect;                               // 0x1730(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void Client_HitscanDebug(bool bSuccess, const struct FVector& Center, const struct FVector& Extent, const struct FVector& ImpactPoint);
	void FindNextMagIndex();
	float GetAmmoWeight(int32 Count);
	int32 GetMagazineCount();
	void GivenAmmoFromAmmoBag();
	void Multicast_HandleSupression(const struct FVector_NetQuantize100& DirectionNet, const struct FVector_NetQuantize100& SpawnLoc);
	void Multicast_OnFire(const struct FVector_NetQuantize100& DirectionNet, const struct FVector_NetQuantize100& SpawnLoc, int32 Seed);
	void Multicast_PerformHitscan(const struct FHitscanShot& HitscanShot, bool bLocalOnly, int32 Seed);
	void Multicast_SimulateFireForViewTargets(const struct FVector_NetQuantize100& DirectionNet, const struct FVector_NetQuantize100& SpawnLoc, int32 Seed);
	void Multicast_SpawnParticleEffects(bool bSkipAuthority, bool bSkipLocalOwner);
	void Multicast_SpawnShell(bool bOnlyLocallyControlled, bool bSkipLocallyControlled);
	void OnFire(const struct FRotator& Direction, const struct FVector& SpawnLoc);
	void OnNewFireModeAnimEvent(EFireMode newFireMode);
	void OnReloadAnimEvent(EReloadAnimEvent Type);
	void PlayBulletWhizz(float Pan);
	void PlaySound(class USoundCue* Cue);
	float RemoveAmmo(float Value);
	void ReplenishAmmo();
	void Server_AddMagazine(const struct FMagazine& Magazine);
	void Server_HitscanHit(const struct FHitResult& HitResult, float Time, const struct FVector& TraceBegin, float Distance, float Penetration, int32 AmmoTypeIndex);
	void Server_NextMagazine();
	void Server_OnFire(const struct FRotator& Direction, const struct FVector& SpawnLoc, int32 Seed);
	void Server_SetCancelReloading(bool bNewValue);
	void Server_SetDesiredAmmoTypeIndex(int32 Index_0);
	void Server_SetReloading(bool bIsReloading);
	void Server_SetTacticalReload(bool bIsTacticalReload);
	void SetMagazineCount(int32 Count, const TArray<class FName>& AmmoTypes);

	bool AllMagsEmpty() const;
	float GetAmmo() const;
	float GetAmmoInMagazine(int32 Index_0) const;
	float GetCurrentAmmoPercentage() const;
	struct FMagazine GetCurrentMagazine() const;
	float GetMagazineAmmoPercentage(int32 MagazineIndex) const;
	class FText GetMagazineScreenName(const struct FMagazine& Magazine) const;
	float GetNextAmmo() const;
	bool HasAmmo() const;
	bool HasAnyAmmo() const;
	bool HasAnyAmmoOfType(class FName AmmoType) const;
	bool InBurstMode() const;
	bool InFullAutoMode() const;
	bool InSafeMode() const;
	bool InSingleMode() const;
	bool IsPistolWithShield() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseMagazineWeapon">();
	}
	static class ABaseMagazineWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseMagazineWeapon>();
	}
};
#pragma pack(pop)
static_assert(alignof(ABaseMagazineWeapon) == 0x000010, "Wrong alignment on ABaseMagazineWeapon");
static_assert(sizeof(ABaseMagazineWeapon) == 0x001740, "Wrong size on ABaseMagazineWeapon");
static_assert(offsetof(ABaseMagazineWeapon, MuzzleFlashParticleComponent) == 0x0012B0, "Member 'ABaseMagazineWeapon::MuzzleFlashParticleComponent' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, MuzzleSmokeParticleComponent) == 0x0012B8, "Member 'ABaseMagazineWeapon::MuzzleSmokeParticleComponent' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, HeatSmokeParticleComponent) == 0x0012C0, "Member 'ABaseMagazineWeapon::HeatSmokeParticleComponent' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, RicochetParticleComponent) == 0x0012C8, "Member 'ABaseMagazineWeapon::RicochetParticleComponent' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, RicochetParticleComponents) == 0x0012D0, "Member 'ABaseMagazineWeapon::RicochetParticleComponents' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, FiringAudioComp) == 0x001330, "Member 'ABaseMagazineWeapon::FiringAudioComp' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, CartridgeText) == 0x001338, "Member 'ABaseMagazineWeapon::CartridgeText' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, RPMText) == 0x001348, "Member 'ABaseMagazineWeapon::RPMText' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, BarrelLengthText) == 0x001358, "Member 'ABaseMagazineWeapon::BarrelLengthText' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, CapacityText) == 0x001368, "Member 'ABaseMagazineWeapon::CapacityText' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, MuzzleVelocityText) == 0x001378, "Member 'ABaseMagazineWeapon::MuzzleVelocityText' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, SupressionStrength) == 0x001388, "Member 'ABaseMagazineWeapon::SupressionStrength' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, SupressionCameraShake) == 0x001390, "Member 'ABaseMagazineWeapon::SupressionCameraShake' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, bSpawnNoTrail) == 0x001398, "Member 'ABaseMagazineWeapon::bSpawnNoTrail' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, BulletTracers) == 0x0013A0, "Member 'ABaseMagazineWeapon::BulletTracers' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, SpawnedShells) == 0x0013B0, "Member 'ABaseMagazineWeapon::SpawnedShells' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, OnWeaponFire) == 0x0013C0, "Member 'ABaseMagazineWeapon::OnWeaponFire' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, OnWeaponDryFire) == 0x0013D0, "Member 'ABaseMagazineWeapon::OnWeaponDryFire' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, bBufferFireInput) == 0x001400, "Member 'ABaseMagazineWeapon::bBufferFireInput' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, bReloading) == 0x001414, "Member 'ABaseMagazineWeapon::bReloading' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, bCancelReloading) == 0x001415, "Member 'ABaseMagazineWeapon::bCancelReloading' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, bHitScan) == 0x001416, "Member 'ABaseMagazineWeapon::bHitScan' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, bSpawnTracer) == 0x001417, "Member 'ABaseMagazineWeapon::bSpawnTracer' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, bNoSpawnTracerForFiringPlayer) == 0x001418, "Member 'ABaseMagazineWeapon::bNoSpawnTracerForFiringPlayer' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, MuzzleFlashParticleSocket) == 0x001424, "Member 'ABaseMagazineWeapon::MuzzleFlashParticleSocket' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, MuzzleSmokeParticleSocket) == 0x00142C, "Member 'ABaseMagazineWeapon::MuzzleSmokeParticleSocket' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, GunTails_Handle) == 0x001438, "Member 'ABaseMagazineWeapon::GunTails_Handle' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, bShowParticlesWhenFiring) == 0x001440, "Member 'ABaseMagazineWeapon::bShowParticlesWhenFiring' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, ArmorPiercingDamageType) == 0x001448, "Member 'ABaseMagazineWeapon::ArmorPiercingDamageType' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, ProjectileAttachedParticle) == 0x001450, "Member 'ABaseMagazineWeapon::ProjectileAttachedParticle' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, bDrawBlood) == 0x001458, "Member 'ABaseMagazineWeapon::bDrawBlood' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, FakeBulletProjectile) == 0x001460, "Member 'ABaseMagazineWeapon::FakeBulletProjectile' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, BulletProjectile) == 0x001468, "Member 'ABaseMagazineWeapon::BulletProjectile' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, ArmorPiercingBulletProjectile) == 0x001470, "Member 'ABaseMagazineWeapon::ArmorPiercingBulletProjectile' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, PenetrationDistance) == 0x001478, "Member 'ABaseMagazineWeapon::PenetrationDistance' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, BreachShell) == 0x001480, "Member 'ABaseMagazineWeapon::BreachShell' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, BeanbagShell) == 0x001488, "Member 'ABaseMagazineWeapon::BeanbagShell' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, BuckShotShell) == 0x001490, "Member 'ABaseMagazineWeapon::BuckShotShell' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, SlugShell) == 0x001498, "Member 'ABaseMagazineWeapon::SlugShell' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, MagazineSocket) == 0x0014A0, "Member 'ABaseMagazineWeapon::MagazineSocket' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, Magazines) == 0x0014A8, "Member 'ABaseMagazineWeapon::Magazines' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, MagIndex) == 0x0014B8, "Member 'ABaseMagazineWeapon::MagIndex' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, NextMagIndex) == 0x0014BC, "Member 'ABaseMagazineWeapon::NextMagIndex' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, HideBoneWhenNotReloading) == 0x0014C0, "Member 'ABaseMagazineWeapon::HideBoneWhenNotReloading' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, DesiredAmmoType) == 0x0014C8, "Member 'ABaseMagazineWeapon::DesiredAmmoType' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, QueuedAmmoType) == 0x0014D0, "Member 'ABaseMagazineWeapon::QueuedAmmoType' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, bBulletInChamberOnReload) == 0x0014D4, "Member 'ABaseMagazineWeapon::bBulletInChamberOnReload' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, bTacReloadWhenEmpty) == 0x0014D5, "Member 'ABaseMagazineWeapon::bTacReloadWhenEmpty' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, AmmoMax) == 0x0014D8, "Member 'ABaseMagazineWeapon::AmmoMax' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, LockIntegrityMinDamage) == 0x0014DC, "Member 'ABaseMagazineWeapon::LockIntegrityMinDamage' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, LockIntegrityMaxDamage) == 0x0014E0, "Member 'ABaseMagazineWeapon::LockIntegrityMaxDamage' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, bLoseMagOnReload) == 0x0014E4, "Member 'ABaseMagazineWeapon::bLoseMagOnReload' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, bSpawnShell) == 0x0014E5, "Member 'ABaseMagazineWeapon::bSpawnShell' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, SpawnShellDelay) == 0x0014E8, "Member 'ABaseMagazineWeapon::SpawnShellDelay' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, ShellBounceFMODAudio) == 0x0014F0, "Member 'ABaseMagazineWeapon::ShellBounceFMODAudio' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, ImpactDecalScale) == 0x00150C, "Member 'ABaseMagazineWeapon::ImpactDecalScale' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, ImpactEffects_Instance) == 0x001510, "Member 'ABaseMagazineWeapon::ImpactEffects_Instance' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, SpawnedImpactEffects) == 0x001518, "Member 'ABaseMagazineWeapon::SpawnedImpactEffects' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, Magazine_HandSocket) == 0x001528, "Member 'ABaseMagazineWeapon::Magazine_HandSocket' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, bShowAmmoTypesOnHUD) == 0x001530, "Member 'ABaseMagazineWeapon::bShowAmmoTypesOnHUD' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, MoraleHighReloadTableOverride) == 0x001538, "Member 'ABaseMagazineWeapon::MoraleHighReloadTableOverride' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, MoraleMediumReloadTableOverride) == 0x001548, "Member 'ABaseMagazineWeapon::MoraleMediumReloadTableOverride' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, MoraleLowReloadTableOverride) == 0x001558, "Member 'ABaseMagazineWeapon::MoraleLowReloadTableOverride' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, LastSpawnedProjectile) == 0x001570, "Member 'ABaseMagazineWeapon::LastSpawnedProjectile' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, MagCheckOverrideSocket) == 0x001580, "Member 'ABaseMagazineWeapon::MagCheckOverrideSocket' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, bHasVisibleMags) == 0x001588, "Member 'ABaseMagazineWeapon::bHasVisibleMags' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, Mag_01_Socket) == 0x00158C, "Member 'ABaseMagazineWeapon::Mag_01_Socket' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, Mag_01_Bullets_Socket) == 0x001594, "Member 'ABaseMagazineWeapon::Mag_01_Bullets_Socket' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, Mag_01_Extra_Socket) == 0x00159C, "Member 'ABaseMagazineWeapon::Mag_01_Extra_Socket' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, Mag_01_Comp) == 0x0015A8, "Member 'ABaseMagazineWeapon::Mag_01_Comp' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, Mag_01_Comp_TPOnly) == 0x0015B0, "Member 'ABaseMagazineWeapon::Mag_01_Comp_TPOnly' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, bShowBulletsWhenEmpty) == 0x0015B8, "Member 'ABaseMagazineWeapon::bShowBulletsWhenEmpty' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, Mag_01_Bullets_Comp) == 0x0015C0, "Member 'ABaseMagazineWeapon::Mag_01_Bullets_Comp' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, Mag_01_Extra_Comp) == 0x0015C8, "Member 'ABaseMagazineWeapon::Mag_01_Extra_Comp' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, Mag_ReloadInterpFix_Comp) == 0x0015D0, "Member 'ABaseMagazineWeapon::Mag_ReloadInterpFix_Comp' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, Mag_01_Static) == 0x001648, "Member 'ABaseMagazineWeapon::Mag_01_Static' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, Mag_01_FMJ_Bullets_Static) == 0x001650, "Member 'ABaseMagazineWeapon::Mag_01_FMJ_Bullets_Static' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, Mag_01_HP_Bullets_Static) == 0x001658, "Member 'ABaseMagazineWeapon::Mag_01_HP_Bullets_Static' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, Mag_01_Extra_Static) == 0x001660, "Member 'ABaseMagazineWeapon::Mag_01_Extra_Static' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, Mag_02_Socket) == 0x001668, "Member 'ABaseMagazineWeapon::Mag_02_Socket' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, Mag_02_Bullets_Socket) == 0x001670, "Member 'ABaseMagazineWeapon::Mag_02_Bullets_Socket' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, Mag_02_Extra_Socket) == 0x001678, "Member 'ABaseMagazineWeapon::Mag_02_Extra_Socket' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, Mag_02_Comp) == 0x001680, "Member 'ABaseMagazineWeapon::Mag_02_Comp' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, Mag_02_Bullets_Comp) == 0x001688, "Member 'ABaseMagazineWeapon::Mag_02_Bullets_Comp' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, Mag_02_Extra_Comp) == 0x001690, "Member 'ABaseMagazineWeapon::Mag_02_Extra_Comp' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, Mag_02_Static) == 0x001698, "Member 'ABaseMagazineWeapon::Mag_02_Static' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, Mag_02_FMJ_Bullets_Static) == 0x0016A0, "Member 'ABaseMagazineWeapon::Mag_02_FMJ_Bullets_Static' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, Mag_02_HP_Bullets_Static) == 0x0016A8, "Member 'ABaseMagazineWeapon::Mag_02_HP_Bullets_Static' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, Mag_02_Extra_Static) == 0x0016B0, "Member 'ABaseMagazineWeapon::Mag_02_Extra_Static' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, bUseFireLoopAnims) == 0x0016B8, "Member 'ABaseMagazineWeapon::bUseFireLoopAnims' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, MagCheckIcon_Empty) == 0x0016C0, "Member 'ABaseMagazineWeapon::MagCheckIcon_Empty' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, MagCheckIcon_Full) == 0x0016C8, "Member 'ABaseMagazineWeapon::MagCheckIcon_Full' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, DroppedMagazineHitEvent) == 0x0016D0, "Member 'ABaseMagazineWeapon::DroppedMagazineHitEvent' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, HeatPerShot) == 0x0016D8, "Member 'ABaseMagazineWeapon::HeatPerShot' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, HeatThreshold) == 0x0016DC, "Member 'ABaseMagazineWeapon::HeatThreshold' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, HeatMax) == 0x0016E0, "Member 'ABaseMagazineWeapon::HeatMax' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, HeatDissipation) == 0x0016E4, "Member 'ABaseMagazineWeapon::HeatDissipation' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, CurrentHeat) == 0x0016E8, "Member 'ABaseMagazineWeapon::CurrentHeat' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, HeatMinimumTime) == 0x0016EC, "Member 'ABaseMagazineWeapon::HeatMinimumTime' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, HeatTime) == 0x0016F0, "Member 'ABaseMagazineWeapon::HeatTime' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, bHeatEffectPlayed) == 0x0016F4, "Member 'ABaseMagazineWeapon::bHeatEffectPlayed' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, MagazineWeightFull) == 0x0016F8, "Member 'ABaseMagazineWeapon::MagazineWeightFull' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, MagazineWeightEmpty) == 0x0016FC, "Member 'ABaseMagazineWeapon::MagazineWeightEmpty' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, MagazineCountDefault) == 0x001700, "Member 'ABaseMagazineWeapon::MagazineCountDefault' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, MagazineCountMin) == 0x001704, "Member 'ABaseMagazineWeapon::MagazineCountMin' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, MagazineCountMax) == 0x001708, "Member 'ABaseMagazineWeapon::MagazineCountMax' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, MagazineLabel) == 0x001710, "Member 'ABaseMagazineWeapon::MagazineLabel' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, bHasBeenDisassembled) == 0x001718, "Member 'ABaseMagazineWeapon::bHasBeenDisassembled' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, GunshotOcclusionMultiplier) == 0x00171C, "Member 'ABaseMagazineWeapon::GunshotOcclusionMultiplier' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, GunshotFullOcclusionDepth) == 0x001720, "Member 'ABaseMagazineWeapon::GunshotFullOcclusionDepth' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, ShootingYellBias) == 0x001724, "Member 'ABaseMagazineWeapon::ShootingYellBias' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, bTwoHandedPistol) == 0x001728, "Member 'ABaseMagazineWeapon::bTwoHandedPistol' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, bHeavyRifle) == 0x001729, "Member 'ABaseMagazineWeapon::bHeavyRifle' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, RagdollImpulseMultiplier) == 0x00172C, "Member 'ABaseMagazineWeapon::RagdollImpulseMultiplier' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeapon, ForceFeedbackEffect) == 0x001730, "Member 'ABaseMagazineWeapon::ForceFeedbackEffect' has a wrong offset!");

// Class ReadyOrNot.Shotgun
// 0x0070 (0x17B0 - 0x1740)
class AShotgun : public ABaseMagazineWeapon
{
public:
	uint8                                         bIsSawnOff : 1;                                    // 0x1738(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1739[0x3];                                     // 0x1739(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxShells;                                         // 0x173C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 Shells;                                            // 0x1740(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPublic)
	TArray<int32>                                 OriginalShellCounts;                               // 0x1750(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         MaxShellsInWeapon;                                 // 0x1760(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ShellsPerSlot;                                     // 0x1764(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShellWeight;                                       // 0x1768(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_176C[0x4];                                     // 0x176C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            CurrentShellMesh;                                  // 0x1770(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTapReload;                                        // 0x1778(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1779[0x7];                                     // 0x1779(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FShotgunVisuals                        ShotgunVisuals;                                    // 0x1780(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bBlockingFireAnimation;                            // 0x1790(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1791[0x3];                                     // 0x1791(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ShellsInRack;                                      // 0x1794(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UShellRackShellComponent*>       ShellMeshComponents;                               // 0x1798(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_17A8[0x8];                                     // 0x17A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CheckReloadSettings();
	void FinishedLoadingShellFromRack();
	void LoadNextShellInRack();
	void OnRep_ShellsReplicated();
	void PlayReloadLoop();
	void RefreshEntireShellRack();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Shotgun">();
	}
	static class AShotgun* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShotgun>();
	}
};
static_assert(alignof(AShotgun) == 0x000010, "Wrong alignment on AShotgun");
static_assert(sizeof(AShotgun) == 0x0017B0, "Wrong size on AShotgun");
static_assert(offsetof(AShotgun, MaxShells) == 0x00173C, "Member 'AShotgun::MaxShells' has a wrong offset!");
static_assert(offsetof(AShotgun, Shells) == 0x001740, "Member 'AShotgun::Shells' has a wrong offset!");
static_assert(offsetof(AShotgun, OriginalShellCounts) == 0x001750, "Member 'AShotgun::OriginalShellCounts' has a wrong offset!");
static_assert(offsetof(AShotgun, MaxShellsInWeapon) == 0x001760, "Member 'AShotgun::MaxShellsInWeapon' has a wrong offset!");
static_assert(offsetof(AShotgun, ShellsPerSlot) == 0x001764, "Member 'AShotgun::ShellsPerSlot' has a wrong offset!");
static_assert(offsetof(AShotgun, ShellWeight) == 0x001768, "Member 'AShotgun::ShellWeight' has a wrong offset!");
static_assert(offsetof(AShotgun, CurrentShellMesh) == 0x001770, "Member 'AShotgun::CurrentShellMesh' has a wrong offset!");
static_assert(offsetof(AShotgun, bTapReload) == 0x001778, "Member 'AShotgun::bTapReload' has a wrong offset!");
static_assert(offsetof(AShotgun, ShotgunVisuals) == 0x001780, "Member 'AShotgun::ShotgunVisuals' has a wrong offset!");
static_assert(offsetof(AShotgun, bBlockingFireAnimation) == 0x001790, "Member 'AShotgun::bBlockingFireAnimation' has a wrong offset!");
static_assert(offsetof(AShotgun, ShellsInRack) == 0x001794, "Member 'AShotgun::ShellsInRack' has a wrong offset!");
static_assert(offsetof(AShotgun, ShellMeshComponents) == 0x001798, "Member 'AShotgun::ShellMeshComponents' has a wrong offset!");

// Class ReadyOrNot.AnimatedIconWidget
// 0x0100 (0x03C0 - 0x02C0)
class UAnimatedIconWidget : public UUserWidget
{
public:
	TArray<class UImage*>                         IconImages;                                        // 0x02C0(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	int32                                         CurrentIndex;                                      // 0x02D0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ElapsedTime;                                       // 0x02D4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bPaused : 1;                                       // 0x02D8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2D9[0x7];                                      // 0x02D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UOverlay*                               InteractCircle_Overlay;                            // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USizeBox*                               InteractIcon_SizeBox;                              // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        IconSwitcher;                                      // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Frame_1;                                           // 0x02F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Frame_2;                                           // 0x0300(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Frame_3;                                           // 0x0308(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Frame_4;                                           // 0x0310(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Frame_5;                                           // 0x0318(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Frame_6;                                           // 0x0320(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Frame_7;                                           // 0x0328(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Frame_8;                                           // 0x0330(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 FrameImages[0x8];                                  // 0x0338(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ProgressCircle_Image;                              // 0x0378(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       Anim_Interact;                                     // 0x0380(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       Anim_Focus;                                        // 0x0388(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           InteractionInvalidTintColor;                       // 0x0390(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     ProgressCircleMaterial;                            // 0x03A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ProgressParamName;                                 // 0x03A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractableComponent*                 ParentComponent;                                   // 0x03B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               MID_ProgressCircle;                                // 0x03B8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void PauseIconAnim();
	void PlayFocusAnim(bool bReverse);
	void PlayInteractAnim();
	void SetActiveIcon(int32 Index_0);
	void SetCurrentProgress(float Percent);
	void SetInteractIconSize(float InInteractCircleSize, float InInteractIconSize);
	void SetInteractState(bool bValid);
	void StopFocusAnim();
	void StopInteractAnim();
	void UnPauseIconAnim();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimatedIconWidget">();
	}
	static class UAnimatedIconWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimatedIconWidget>();
	}
};
static_assert(alignof(UAnimatedIconWidget) == 0x000008, "Wrong alignment on UAnimatedIconWidget");
static_assert(sizeof(UAnimatedIconWidget) == 0x0003C0, "Wrong size on UAnimatedIconWidget");
static_assert(offsetof(UAnimatedIconWidget, IconImages) == 0x0002C0, "Member 'UAnimatedIconWidget::IconImages' has a wrong offset!");
static_assert(offsetof(UAnimatedIconWidget, CurrentIndex) == 0x0002D0, "Member 'UAnimatedIconWidget::CurrentIndex' has a wrong offset!");
static_assert(offsetof(UAnimatedIconWidget, ElapsedTime) == 0x0002D4, "Member 'UAnimatedIconWidget::ElapsedTime' has a wrong offset!");
static_assert(offsetof(UAnimatedIconWidget, InteractCircle_Overlay) == 0x0002E0, "Member 'UAnimatedIconWidget::InteractCircle_Overlay' has a wrong offset!");
static_assert(offsetof(UAnimatedIconWidget, InteractIcon_SizeBox) == 0x0002E8, "Member 'UAnimatedIconWidget::InteractIcon_SizeBox' has a wrong offset!");
static_assert(offsetof(UAnimatedIconWidget, IconSwitcher) == 0x0002F0, "Member 'UAnimatedIconWidget::IconSwitcher' has a wrong offset!");
static_assert(offsetof(UAnimatedIconWidget, Frame_1) == 0x0002F8, "Member 'UAnimatedIconWidget::Frame_1' has a wrong offset!");
static_assert(offsetof(UAnimatedIconWidget, Frame_2) == 0x000300, "Member 'UAnimatedIconWidget::Frame_2' has a wrong offset!");
static_assert(offsetof(UAnimatedIconWidget, Frame_3) == 0x000308, "Member 'UAnimatedIconWidget::Frame_3' has a wrong offset!");
static_assert(offsetof(UAnimatedIconWidget, Frame_4) == 0x000310, "Member 'UAnimatedIconWidget::Frame_4' has a wrong offset!");
static_assert(offsetof(UAnimatedIconWidget, Frame_5) == 0x000318, "Member 'UAnimatedIconWidget::Frame_5' has a wrong offset!");
static_assert(offsetof(UAnimatedIconWidget, Frame_6) == 0x000320, "Member 'UAnimatedIconWidget::Frame_6' has a wrong offset!");
static_assert(offsetof(UAnimatedIconWidget, Frame_7) == 0x000328, "Member 'UAnimatedIconWidget::Frame_7' has a wrong offset!");
static_assert(offsetof(UAnimatedIconWidget, Frame_8) == 0x000330, "Member 'UAnimatedIconWidget::Frame_8' has a wrong offset!");
static_assert(offsetof(UAnimatedIconWidget, FrameImages) == 0x000338, "Member 'UAnimatedIconWidget::FrameImages' has a wrong offset!");
static_assert(offsetof(UAnimatedIconWidget, ProgressCircle_Image) == 0x000378, "Member 'UAnimatedIconWidget::ProgressCircle_Image' has a wrong offset!");
static_assert(offsetof(UAnimatedIconWidget, Anim_Interact) == 0x000380, "Member 'UAnimatedIconWidget::Anim_Interact' has a wrong offset!");
static_assert(offsetof(UAnimatedIconWidget, Anim_Focus) == 0x000388, "Member 'UAnimatedIconWidget::Anim_Focus' has a wrong offset!");
static_assert(offsetof(UAnimatedIconWidget, InteractionInvalidTintColor) == 0x000390, "Member 'UAnimatedIconWidget::InteractionInvalidTintColor' has a wrong offset!");
static_assert(offsetof(UAnimatedIconWidget, ProgressCircleMaterial) == 0x0003A0, "Member 'UAnimatedIconWidget::ProgressCircleMaterial' has a wrong offset!");
static_assert(offsetof(UAnimatedIconWidget, ProgressParamName) == 0x0003A8, "Member 'UAnimatedIconWidget::ProgressParamName' has a wrong offset!");
static_assert(offsetof(UAnimatedIconWidget, ParentComponent) == 0x0003B0, "Member 'UAnimatedIconWidget::ParentComponent' has a wrong offset!");
static_assert(offsetof(UAnimatedIconWidget, MID_ProgressCircle) == 0x0003B8, "Member 'UAnimatedIconWidget::MID_ProgressCircle' has a wrong offset!");

// Class ReadyOrNot.PickupEvidenceByTag
// 0x0008 (0x0328 - 0x0320)
class APickupEvidenceByTag final : public AObjective
{
public:
	class FName                                   EvidenceTag;                                       // 0x0320(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static bool HasCollectedEvidenceByTag(const class FName& Tag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PickupEvidenceByTag">();
	}
	static class APickupEvidenceByTag* GetDefaultObj()
	{
		return GetDefaultObjImpl<APickupEvidenceByTag>();
	}
};
static_assert(alignof(APickupEvidenceByTag) == 0x000008, "Wrong alignment on APickupEvidenceByTag");
static_assert(sizeof(APickupEvidenceByTag) == 0x000328, "Wrong size on APickupEvidenceByTag");
static_assert(offsetof(APickupEvidenceByTag, EvidenceTag) == 0x000320, "Member 'APickupEvidenceByTag::EvidenceTag' has a wrong offset!");

// Class ReadyOrNot.AnimatedIconWidgetWithActionPrompt
// 0x0040 (0x0400 - 0x03C0)
class UAnimatedIconWidgetWithActionPrompt final : public UAnimatedIconWidget
{
public:
	class UVerticalBox*                           VerticalBox;                                       // 0x03C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               InteractIcon_Overlay;                              // 0x03C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScaleBox*                              PlayerActionPrompt_ScaleBox;                       // 0x03D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlayerActionPromptWidget*              PlayerActionPrompt_Widget;                         // 0x03D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlayerActionPromptWidget*              PlayerActionPrompt_Widget2;                        // 0x03E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlayerActionPromptWidget*              PlayerActionPrompt_Widget3;                        // 0x03E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlayerActionPromptWidget*              PlayerActionPrompt_Widget4;                        // 0x03F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ActionPromptBackground_Image;                      // 0x03F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimatedIconWidgetWithActionPrompt">();
	}
	static class UAnimatedIconWidgetWithActionPrompt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimatedIconWidgetWithActionPrompt>();
	}
};
static_assert(alignof(UAnimatedIconWidgetWithActionPrompt) == 0x000008, "Wrong alignment on UAnimatedIconWidgetWithActionPrompt");
static_assert(sizeof(UAnimatedIconWidgetWithActionPrompt) == 0x000400, "Wrong size on UAnimatedIconWidgetWithActionPrompt");
static_assert(offsetof(UAnimatedIconWidgetWithActionPrompt, VerticalBox) == 0x0003C0, "Member 'UAnimatedIconWidgetWithActionPrompt::VerticalBox' has a wrong offset!");
static_assert(offsetof(UAnimatedIconWidgetWithActionPrompt, InteractIcon_Overlay) == 0x0003C8, "Member 'UAnimatedIconWidgetWithActionPrompt::InteractIcon_Overlay' has a wrong offset!");
static_assert(offsetof(UAnimatedIconWidgetWithActionPrompt, PlayerActionPrompt_ScaleBox) == 0x0003D0, "Member 'UAnimatedIconWidgetWithActionPrompt::PlayerActionPrompt_ScaleBox' has a wrong offset!");
static_assert(offsetof(UAnimatedIconWidgetWithActionPrompt, PlayerActionPrompt_Widget) == 0x0003D8, "Member 'UAnimatedIconWidgetWithActionPrompt::PlayerActionPrompt_Widget' has a wrong offset!");
static_assert(offsetof(UAnimatedIconWidgetWithActionPrompt, PlayerActionPrompt_Widget2) == 0x0003E0, "Member 'UAnimatedIconWidgetWithActionPrompt::PlayerActionPrompt_Widget2' has a wrong offset!");
static_assert(offsetof(UAnimatedIconWidgetWithActionPrompt, PlayerActionPrompt_Widget3) == 0x0003E8, "Member 'UAnimatedIconWidgetWithActionPrompt::PlayerActionPrompt_Widget3' has a wrong offset!");
static_assert(offsetof(UAnimatedIconWidgetWithActionPrompt, PlayerActionPrompt_Widget4) == 0x0003F0, "Member 'UAnimatedIconWidgetWithActionPrompt::PlayerActionPrompt_Widget4' has a wrong offset!");
static_assert(offsetof(UAnimatedIconWidgetWithActionPrompt, ActionPromptBackground_Image) == 0x0003F8, "Member 'UAnimatedIconWidgetWithActionPrompt::ActionPromptBackground_Image' has a wrong offset!");

// Class ReadyOrNot.AnimatedIconWidget_Imprint
// 0x0010 (0x02D0 - 0x02C0)
class UAnimatedIconWidget_Imprint : public UUserWidget
{
public:
	class UImage*                                 Icon_Image;                                        // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       ImprintAnimation;                                  // 0x02C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Init(const struct FVector& InWorldLocation, class UTexture2D* InIconImage);
	void SetIconImage(class UTexture2D* NewIconImage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimatedIconWidget_Imprint">();
	}
	static class UAnimatedIconWidget_Imprint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimatedIconWidget_Imprint>();
	}
};
static_assert(alignof(UAnimatedIconWidget_Imprint) == 0x000008, "Wrong alignment on UAnimatedIconWidget_Imprint");
static_assert(sizeof(UAnimatedIconWidget_Imprint) == 0x0002D0, "Wrong size on UAnimatedIconWidget_Imprint");
static_assert(offsetof(UAnimatedIconWidget_Imprint, Icon_Image) == 0x0002C0, "Member 'UAnimatedIconWidget_Imprint::Icon_Image' has a wrong offset!");
static_assert(offsetof(UAnimatedIconWidget_Imprint, ImprintAnimation) == 0x0002C8, "Member 'UAnimatedIconWidget_Imprint::ImprintAnimation' has a wrong offset!");

// Class ReadyOrNot.AnimNotify_PushQueuedDoor
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_PushQueuedDoor final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_PushQueuedDoor">();
	}
	static class UAnimNotify_PushQueuedDoor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_PushQueuedDoor>();
	}
};
static_assert(alignof(UAnimNotify_PushQueuedDoor) == 0x000008, "Wrong alignment on UAnimNotify_PushQueuedDoor");
static_assert(sizeof(UAnimNotify_PushQueuedDoor) == 0x000038, "Wrong size on UAnimNotify_PushQueuedDoor");

// Class ReadyOrNot.ReadyOrNotNavigationSystem
// 0x0000 (0x1590 - 0x1590)
class UReadyOrNotNavigationSystem final : public UNavigationSystemV1
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotNavigationSystem">();
	}
	static class UReadyOrNotNavigationSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotNavigationSystem>();
	}
};
static_assert(alignof(UReadyOrNotNavigationSystem) == 0x000008, "Wrong alignment on UReadyOrNotNavigationSystem");
static_assert(sizeof(UReadyOrNotNavigationSystem) == 0x001590, "Wrong size on UReadyOrNotNavigationSystem");

// Class ReadyOrNot.AnimCharacterMovementLibrary
// 0x0000 (0x0028 - 0x0028)
class UAnimCharacterMovementLibrary final : public UBlueprintFunctionLibrary
{
public:
	static float CalculateDirAngle(const struct FVector& CurVel, const struct FRotator& CurActorRotation, const struct FRotator& DirRotation, float ClampMin, float ClampMax, float CurDirAngle);
	static EAnimCardinalDirection GetCardinalDirectionFromAngle(EAnimCardinalDirection PreviousCardinalDirection, float DirectionAngleInDegrees, float DeadZoneAngle);
	static struct FVector PredictGroundMovementPivotLocation(const struct FAnimCharacterMovementSnapshot& MovementSnapshot, float GroundFriction);
	static struct FVector PredictGroundMovementStopLocation(const struct FAnimCharacterMovementSnapshot& MovementSnapshot, const struct FAnimCharacterMovementPredictionSnapshot& PredictionSnapshot);
	static const class UAnimSequence* SelectAnimForCardinalDirection(EAnimCardinalDirection CardinalDirection, const struct FCardinalDirectionAnimSet& AnimSet);
	static void UpdateCharacterMovementSnapshot(const struct FTransform& WorldTransform, const struct FVector& WorldVelocity, const struct FVector& WorldAcceleration, bool bIsOnGround, float RootYawOffset, struct FAnimCharacterMovementSnapshot& Snapshot);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimCharacterMovementLibrary">();
	}
	static class UAnimCharacterMovementLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimCharacterMovementLibrary>();
	}
};
static_assert(alignof(UAnimCharacterMovementLibrary) == 0x000008, "Wrong alignment on UAnimCharacterMovementLibrary");
static_assert(sizeof(UAnimCharacterMovementLibrary) == 0x000028, "Wrong size on UAnimCharacterMovementLibrary");

// Class ReadyOrNot.ReadyOrNotSessionData
// 0x00B8 (0x00E0 - 0x0028)
class UReadyOrNotSessionData final : public USaveGame
{
public:
	class FString                                 SaveSlotName;                                      // 0x0028(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        UserIndex;                                         // 0x0038(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, int32>                    SavedTeamKillData;                                 // 0x0040(0x0050)(NativeAccessSpecifierPublic)
	TMap<class FString, class FString>            BanReasonData;                                     // 0x0090(0x0050)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotSessionData">();
	}
	static class UReadyOrNotSessionData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotSessionData>();
	}
};
static_assert(alignof(UReadyOrNotSessionData) == 0x000008, "Wrong alignment on UReadyOrNotSessionData");
static_assert(sizeof(UReadyOrNotSessionData) == 0x0000E0, "Wrong size on UReadyOrNotSessionData");
static_assert(offsetof(UReadyOrNotSessionData, SaveSlotName) == 0x000028, "Member 'UReadyOrNotSessionData::SaveSlotName' has a wrong offset!");
static_assert(offsetof(UReadyOrNotSessionData, UserIndex) == 0x000038, "Member 'UReadyOrNotSessionData::UserIndex' has a wrong offset!");
static_assert(offsetof(UReadyOrNotSessionData, SavedTeamKillData) == 0x000040, "Member 'UReadyOrNotSessionData::SavedTeamKillData' has a wrong offset!");
static_assert(offsetof(UReadyOrNotSessionData, BanReasonData) == 0x000090, "Member 'UReadyOrNotSessionData::BanReasonData' has a wrong offset!");

// Class ReadyOrNot.AnimDistanceMatchingLibrary
// 0x0000 (0x0028 - 0x0028)
class UAnimDistanceMatchingLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void CalculateDistanceMatchingStates(float DeltaTime, class ACharacter* CurrentCharacter, class UCharacterMovementComponent* CurrentMovementComponent, EDistanceMatchingType* DistanceMatchingCurrentState, const struct FAnimCharacterMovementSnapshot& MovementSnapshot, const struct FAnimCharacterMovementPredictionSnapshot& PredictionSnapshot, class UWorld* TargetWorld, float MinPivotAngle, const TArray<class AActor*>& ActorsToIgnore, struct FVector* LastActorLocation, struct FCardinalDirectionSnapshot* PivotingCardinalDirSnapShot, struct FPredictionResult* StartMarker, struct FPredictionResult* StopMarker, struct FPredictionResult* PivotMarker, struct FPredictionResult* TakeOffMarker, struct FPredictionResult* ApexMarker, struct FPredictionResult* LandingMarker, bool* bSMStartRuleset, bool* bSMStopRuleset, bool bIsAICharacter, bool bShowDebug);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimDistanceMatchingLibrary">();
	}
	static class UAnimDistanceMatchingLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimDistanceMatchingLibrary>();
	}
};
static_assert(alignof(UAnimDistanceMatchingLibrary) == 0x000008, "Wrong alignment on UAnimDistanceMatchingLibrary");
static_assert(sizeof(UAnimDistanceMatchingLibrary) == 0x000028, "Wrong size on UAnimDistanceMatchingLibrary");

// Class ReadyOrNot.AnimInputCapsuleLocomotionBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UAnimInputCapsuleLocomotionBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void UpdateCapsuleLocomotionAnimInput(const class APawn* Pawn, struct FAnimInput_CapsuleLocomotion& CapsuleLocomotionAnimInput);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimInputCapsuleLocomotionBlueprintLibrary">();
	}
	static class UAnimInputCapsuleLocomotionBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimInputCapsuleLocomotionBlueprintLibrary>();
	}
};
static_assert(alignof(UAnimInputCapsuleLocomotionBlueprintLibrary) == 0x000008, "Wrong alignment on UAnimInputCapsuleLocomotionBlueprintLibrary");
static_assert(sizeof(UAnimInputCapsuleLocomotionBlueprintLibrary) == 0x000028, "Wrong size on UAnimInputCapsuleLocomotionBlueprintLibrary");

// Class ReadyOrNot.AnimNotifyState_SpawnLight
// 0x0038 (0x0068 - 0x0030)
class UAnimNotifyState_SpawnLight final : public UAnimNotifyState
{
public:
	struct FLinearColor                           LightColor;                                        // 0x0030(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         StartIntensity;                                    // 0x0040(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MiddleIntensity;                                   // 0x0044(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         EndIntensity;                                      // 0x0048(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         InterpSpeed;                                       // 0x004C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APointLight*                            PointLight;                                        // 0x0050(0x0008)(BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxDuration;                                       // 0x0058(0x0004)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CurrentDuration;                                   // 0x005C(0x0004)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   SocketName;                                        // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_SpawnLight">();
	}
	static class UAnimNotifyState_SpawnLight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_SpawnLight>();
	}
};
static_assert(alignof(UAnimNotifyState_SpawnLight) == 0x000008, "Wrong alignment on UAnimNotifyState_SpawnLight");
static_assert(sizeof(UAnimNotifyState_SpawnLight) == 0x000068, "Wrong size on UAnimNotifyState_SpawnLight");
static_assert(offsetof(UAnimNotifyState_SpawnLight, LightColor) == 0x000030, "Member 'UAnimNotifyState_SpawnLight::LightColor' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_SpawnLight, StartIntensity) == 0x000040, "Member 'UAnimNotifyState_SpawnLight::StartIntensity' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_SpawnLight, MiddleIntensity) == 0x000044, "Member 'UAnimNotifyState_SpawnLight::MiddleIntensity' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_SpawnLight, EndIntensity) == 0x000048, "Member 'UAnimNotifyState_SpawnLight::EndIntensity' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_SpawnLight, InterpSpeed) == 0x00004C, "Member 'UAnimNotifyState_SpawnLight::InterpSpeed' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_SpawnLight, PointLight) == 0x000050, "Member 'UAnimNotifyState_SpawnLight::PointLight' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_SpawnLight, MaxDuration) == 0x000058, "Member 'UAnimNotifyState_SpawnLight::MaxDuration' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_SpawnLight, CurrentDuration) == 0x00005C, "Member 'UAnimNotifyState_SpawnLight::CurrentDuration' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_SpawnLight, SocketName) == 0x000060, "Member 'UAnimNotifyState_SpawnLight::SocketName' has a wrong offset!");

// Class ReadyOrNot.ReadyOrNotCharacter
// 0x1320 (0x19A0 - 0x0680)
class AReadyOrNotCharacter : public ACharacter
{
public:
	uint8                                         Pad_678[0x78];                                     // 0x0678(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 CustomizationFaceMesh;                             // 0x06F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        CustomizationHelmet;                               // 0x06F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USkeletalMeshComponent*>         CustomizationSkeletalMeshes;                       // 0x0700(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UStaticMeshComponent*>           CustomizationStaticMeshes;                         // 0x0710(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         CustomizationActors;                               // 0x0720(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FSavedCustomization                    Customization;                                     // 0x0730(0x0140)(Net, RepNotify, NativeAccessSpecifierPublic)
	uint8                                         Pad_870[0x68];                                     // 0x0870(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 MeshGearSlot;                                      // 0x08D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractableComponent*                 InteractableComponent;                             // 0x08E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UObjectiveMarkerComponent*              PlayerMarkerComponent;                             // 0x08E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 FaceMesh;                                          // 0x08F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODAudioPropagationComponent*         FMODAudioPropagationComp;                          // 0x08F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODAudioComponent*                    FMODVoiceAudioComp;                                // 0x0900(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCharacterHealthComponent*              CharacterHealth;                                   // 0x0908(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInventoryComponent*                    InventoryComp;                                     // 0x0910(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAIPerceptionStimuliSourceComponent*    PerceptionStimuliComp;                             // 0x0918(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGibComponent*                          GibComponent;                                      // 0x0920(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPhysicalAnimationComponent*            PhysicalAnimationComp;                             // 0x0928(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkinnedDecalSampler*                   SkinnedDecalSampler;                               // 0x0930(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URagdollComponent*                      RagdollComponent;                                  // 0x0938(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               BloodEntryParticleComponent;                       // 0x0940(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               ArmourImpactParticleComponent;                     // 0x0948(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UDecalComponent*>                BloodSplatterDecalComponents;                      // 0x0950(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_960[0x8];                                      // 0x0960(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUASAimAssistTargetComponent*           AimAssistTargetComponent;                          // 0x0968(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_970[0x70];                                     // 0x0970(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               ReplicatedControlRotation;                         // 0x09E0(0x0018)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter)> OnCharacterKilled; // 0x09F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AReadyOrNotCharacter* IncapacitatedCharacter, class AReadyOrNotCharacter* InstigatorCharacter)> OnCharacterIncapacitated; // 0x0A08(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AReadyOrNotCharacter* Character, class ABaseMagazineWeapon* Weapon, const struct FVector& fireDirection)> OnWeaponFire; // 0x0A18(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AReadyOrNotCharacter* Character, class ABaseMagazineWeapon* Weapon, const struct FVector& fireDirection)> OnWeaponDryFire; // 0x0A28(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AReadyOrNotCharacter* DownedCharacter, class AReadyOrNotCharacter* InstigatorCharacter)> OnPlayerDowned; // 0x0A38(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(float Damage, class AActor* Causer, class ACharacter* InstigatorCharacter, class ACharacter* HitCharacter, const class UBulletDamageType* DamageEvent)> OnPointDamageReceived; // 0x0A48(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(float Damage, class AActor* Causer, class ACharacter* InstigatorCharacter, class ACharacter* HitCharacter, const class UStunDamage* DamageEvent)> OnStunDamageReceived; // 0x0A58(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ACharacter* Freed, class ACharacter* Freer)> OnPlayerFreed;  // 0x0A68(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(float Damage, class FName HitBone)> OnPlayerHit;                   // 0x0A78(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(float Damage, class FName HitBone)> OnPlayerArmorHit;              // 0x0A88(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class ABaseItem*                              ThrownItem;                                        // 0x0A98(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnGetupComplete;                                   // 0x0AA0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ABaseItem* InThrownItem)> OnItemThrown_FromAnimNotify;       // 0x0AB0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnDoorLockPickBegin_FromAnimNotify;                // 0x0AC0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnDoorLockPickEnd_FromAnimNotify;                  // 0x0AD0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnDoorChecked_FromAnimNotify;                      // 0x0AE0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnC2Placed_FromAnimNotify;                         // 0x0AF0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnC2Detonate_FromAnimNotify;                       // 0x0B00(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnTrapDisarmBegin_FromAnimNotify;                  // 0x0B10(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnTrapDisarmEnd_FromAnimNotify;                    // 0x0B20(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnMirrorDoorStarted_FromAnimNotify;                // 0x0B30(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnMirrorDoorFinished_FromAnimNotify;               // 0x0B40(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnStartDoorWedgePlacement_FromAnimNotify;          // 0x0B50(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnEndDoorWedgePlacement_FromAnimNotify;            // 0x0B60(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_B70[0x30];                                     // 0x0B70(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCharacterDamageEvent                  LastDamageEvent;                                   // 0x0BA0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC8[0x2];                                      // 0x0BC8(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bBulletForceTransferred;                           // 0x0BCA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BCB[0x1];                                      // 0x0BCB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinimumBodyFallImpulse;                            // 0x0BCC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxRagdollSounds;                                  // 0x0BD0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RagdollSoundsPlayed;                               // 0x0BD4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             BodyFallEvent;                                     // 0x0BD8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BE0[0x8];                                      // 0x0BE0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundSource*                           BodyFallSoundSource;                               // 0x0BE8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCapsuleCollisionRagdolled;                        // 0x0BF0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCapsuleFloorAngleRagdolled;                       // 0x0BF1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BF2[0x2];                                      // 0x0BF2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CapsuleCollisionRagdollTriggerThreshold;           // 0x0BF4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CapsuleFloorAngleRagdollTriggerThreshold;          // 0x0BF8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CapsuleFloorAngleRagdollDelayThreshold;            // 0x0BFC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlendingAnim2Ragdoll;                             // 0x0C00(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C01[0xF];                                      // 0x0C01(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Anim2RagdollPelvisWakeUpTime;                      // 0x0C10(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C14[0xC];                                      // 0x0C14(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundSource*                           VoiceSoundSource;                                  // 0x0C20(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C28[0x1D0];                                    // 0x0C28(0x01D0)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bBlendInPhysics;                                   // 0x0DF8(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStartBlendInIncapacitation;                       // 0x0DF9(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlendInIncapacitation;                            // 0x0DFA(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DFB[0x1];                                      // 0x0DFB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IncapacitationBlendTime;                           // 0x0DFC(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IncapacitationBlendOutTime;                        // 0x0E00(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E04[0x4];                                      // 0x0E04(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          IncapacitationLoopAnim;                            // 0x0E08(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendInterpAmount;                                 // 0x0E10(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E14[0xC];                                      // 0x0E14(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FinalBlendInTime;                                  // 0x0E20(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E24[0x4];                                      // 0x0E24(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendInAfterStartOfAnim;                           // 0x0E28(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIsPreviewCharacter : 1;                           // 0x0E2C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_E2D[0xB];                                      // 0x0E2D(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	class AReadyOrNotCharacter*                   ArrestedBy;                                        // 0x0E38(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AReadyOrNotCharacter*                   KilledBy;                                          // 0x0E40(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AReadyOrNotCharacter*                   IncapacitatedBy;                                   // 0x0E48(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterDeathReason                         DeathReason;                                       // 0x0E50(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E51[0x7];                                      // 0x0E51(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* DamagedCharacter, class AActor* DamageCauser, float Damage, float HealthRemaining)> OnCharacterTakeDamage; // 0x0E58(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(EStunType StunType, bool bIsImmune)> OnAIStunnedPlaySound;         // 0x0E68(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AReadyOrNotCharacter* StunnedCharacter, float Duration, EStunType StunType, class AActor* DamageCauser)> OnStunnedEvent; // 0x0E78(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(EStunType StunType)> OnStunnedEndedEvent;                          // 0x0E88(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AReadyOrNotCharacter* InstigatorCharacter)> OnMeleeHitTaken; // 0x0E98(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class FName>                           HeadBones;                                         // 0x0EA8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           UpperBody;                                         // 0x0EB8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_EC8[0x10];                                     // 0x0EC8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           LowerBody;                                         // 0x0ED8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           R_Leg;                                             // 0x0EE8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           L_Leg;                                             // 0x0EF8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           L_Foot;                                            // 0x0F08(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           R_Foot;                                            // 0x0F18(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           L_Arm;                                             // 0x0F28(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           R_Arm;                                             // 0x0F38(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           L_Hand;                                            // 0x0F48(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           R_Hand;                                            // 0x0F58(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bLowReadyPointUp;                                  // 0x0F68(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLowReadyPointDown;                                // 0x0F69(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F6A[0x2];                                      // 0x0F6A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LowReadyDistance;                                  // 0x0F6C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F70[0x8];                                      // 0x0F70(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UCapsuleComponent*>              LowReadyIgnoredCapsules;                           // 0x0F78(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         bIsCrouching : 1;                                  // 0x0F88(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_F89[0x3];                                      // 0x0F89(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         QuickLeanAmount;                                   // 0x0F8C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         QuickLeanIntensity;                                // 0x0F90(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         QuickLeanInterpSpeed;                              // 0x0F94(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FreeLeanX;                                         // 0x0F98(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FreeLeanZ;                                         // 0x0F9C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFreeLeaning;                                      // 0x0FA0(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLeaning;                                        // 0x0FA1(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLeaningLeft;                                      // 0x0FA2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLeaningRight;                                     // 0x0FA3(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLeaningUp;                                        // 0x0FA4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLeaningDown;                                      // 0x0FA5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FA6[0xE];                                      // 0x0FA6(0x000E)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bLeanLeftToggle;                                   // 0x0FB4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLeanRightToggle;                                  // 0x0FB5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FB6[0x2];                                      // 0x0FB6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODAudioComponent*                    LeanAudioComponent;                                // 0x0FB8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODEvent*                             LeanAudioEvent;                                    // 0x0FC0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LeanMovementValue;                                 // 0x0FC8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FCC[0x4];                                      // 0x0FCC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LeanPos_CurrentFrame;                              // 0x0FD0(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                LeanPos_LastFrame;                                 // 0x0FE8(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESquadPosition                                SquadPosition;                                     // 0x1000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETeamType                                     DefaultTeam;                                       // 0x1001(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1002[0x6];                                     // 0x1002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             FPMeleeImpactFMODEvent;                            // 0x1008(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODEvent*                             TPMeleeImpactFMODEvent;                            // 0x1010(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        MeleeImpactParticle;                               // 0x1018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ULegacyCameraShake>         MeleeCameraShake;                                  // 0x1020(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MeleeRange;                                        // 0x1028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MeleeDamage;                                       // 0x102C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   MeleeDamageType;                                   // 0x1030(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class AReadyOrNotCharacter* ArrestedCharacter, class AReadyOrNotCharacter* InstigatorCharacter)> OnPlayerArrested; // 0x1058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AReadyOrNotCharacter* ArrestedCharacter, class AReadyOrNotCharacter* InstigatorCharacter)> OnPlayerArrestStart; // 0x1068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AReadyOrNotCharacter* ArrestedCharacter, class AReadyOrNotCharacter* InstigatorCharacter)> OnPlayerArrestedCanceled; // 0x1078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AReadyOrNotCharacter*                   PendingAutoReport;                                 // 0x1088(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AReadyOrNotCharacter* Character)> OnArrested;                // 0x1090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FCarryArrestedAnimState                Rep_CarryArrestedAnimState;                        // 0x10A0(0x0008)(BlueprintVisible, Net, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bPreArrested;                                      // 0x10A8(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10A9[0x7];                                     // 0x10A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AStaticMeshActor*                       PreArrestCuffsActor;                               // 0x10B0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSurrendered;                                      // 0x10B8(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSurrenderComplete;                                // 0x10B9(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10BA[0x16];                                    // 0x10BA(0x0016)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bOrderedToRotateForArrest : 1;                     // 0x10D0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_10D1[0x7];                                     // 0x10D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class APlacedZipcuffs*                        PlacedZipcuffs;                                    // 0x10D8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class APlacedZipcuffs>            SpawnedZipcuffsClass;                              // 0x10E0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class APlacedZipcuffs>            SpawnedFPZipcuffsClass;                            // 0x10E8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ZipcuffBone;                                       // 0x10F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsBeingCarried;                                   // 0x10F8(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCarryingDead;                                     // 0x10F9(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10FA[0x6];                                     // 0x10FA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class AReadyOrNotCharacter*                   CarriedByCharacter;                                // 0x1100(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AReadyOrNotCharacter*                   ThrownByCharacter;                                 // 0x1108(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AReadyOrNotCharacter*                   PendingCarryCharacter;                             // 0x1110(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AReadyOrNotCharacter*                   CurrentCarryCharacter;                             // 0x1118(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ASkeletalMeshActor*                     FakeCarryCharacterMesh;                            // 0x1120(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentCarryConfirmTime;                           // 0x1128(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_112C[0x4];                                     // 0x112C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          CarryMasterIdleLoop;                               // 0x1130(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          CarrySlaveIdleLoop;                                // 0x1138(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxCarryConfirmTime;                               // 0x1140(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxRagdollArrestConfirmTime;                       // 0x1144(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentRagdollArrestConfirmTime;                   // 0x1148(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_114C[0x4];                                     // 0x114C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AReadyOrNotCharacter*                   PendingRagdollArrestCharacter;                     // 0x1150(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AReadyOrNotCharacter*                   CurrentRagdollArrestCharacter;                     // 0x1158(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AReadyOrNotCharacter*                   LastCharacterMakingArrest;                         // 0x1160(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AReadyOrNotCharacter*                   CurrentlyArresting;                                // 0x1168(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsBeingArrested;                                  // 0x1170(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bArrestComplete;                                   // 0x1171(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bArrestedAsRagdoll;                                // 0x1172(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bArrestedAsRagdoll_Flipped;                        // 0x1173(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPairedInteractionPlaying;                       // 0x1174(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNoTeamDamage;                                     // 0x1175(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableInteraction;                               // 0x1176(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPrimed;                                           // 0x1177(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverarmThrow;                                     // 0x1178(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1179[0x7];                                     // 0x1179(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AReadyOrNotCharacter* Character, class ABaseItem* LastItemBeforeQuickThrow, class ABaseItem* QuickThrowGrenade)> OnQuickThrowStart; // 0x1180(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ABaseItem* QuickThrowGrenade)> OnQuickThrowEnd;              // 0x1190(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnCarryingChanged;                                 // 0x11A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_11B0[0x1];                                     // 0x11B0(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsStrafing;                                       // 0x11B1(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11B2[0x6];                                     // 0x11B2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, class UAnimMontage*>      PlayedTableMontageMap3P;                           // 0x11B8(0x0050)(UObjectWrapper, NativeAccessSpecifierPublic)
	class FString                                 LastTableMontagePlayed;                            // 0x1208(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1218[0x78];                                    // 0x1218(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCharacterLookOverride                 CharacterLookOverride;                             // 0x1290(0x00D0)(Edit, EditConst, NativeAccessSpecifierPublic)
	class FString                                 Rep_CharacterLookOverride;                         // 0x1360(0x0010)(Net, ZeroConstructor, RepNotify, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<TSubclassOf<class ABaseArmour>, class USkeletalMesh*> ArmorOverrideMapTP;                   // 0x1370(0x0050)(Edit, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class USkeletalMesh*                          Rep_BodyMesh;                                      // 0x13C0(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMesh*                          Rep_FaceMesh;                                      // 0x13C8(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMesh*                          Rep_FPMesh;                                        // 0x13D0(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class UAnimMontage*, float>              AnimMontageCooldown;                               // 0x13D8(0x0050)(Protected, NativeAccessSpecifierProtected)
	class UPoseAsset*                             CurrentFaceROM;                                    // 0x1428(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AnimationBlockingTime;                             // 0x1430(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1434[0x24];                                    // 0x1434(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	class ATOCManager*                            TOCManager;                                        // 0x1458(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ULegacyCameraShake>         ReportToTOC_PVP_CameraShake;                       // 0x1460(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 TOCLine;                                           // 0x1468(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 SpeechCharacterName;                               // 0x1478(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1488[0x8];                                     // 0x1488(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bHasBeenReported;                                  // 0x1490(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1491[0x3];                                     // 0x1491(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpeakCooldown;                                     // 0x1494(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             ReportPlayerDeadFMODEvent;                         // 0x1498(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             ReportPlayerArrestedFMODEvent;                     // 0x14A0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             ReportPlayerGeneralFMODEvent;                      // 0x14A8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AReadyOrNotCharacter* Speaker)> OnVoiceAudioStoppedDelegate; // 0x14B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_14C0[0x18];                                    // 0x14C0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, float>                    SpeechCooldownMap;                                 // 0x14D8(0x0050)(Protected, NativeAccessSpecifierProtected)
	class UFMODEvent*                             FMODVoiceLine2D;                                   // 0x1528(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODEvent*                             FMODVoiceLineSpatalized;                           // 0x1530(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1538[0x8];                                     // 0x1538(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FSuppressionData>    BoneSuppressionAmount;                             // 0x1540(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool bHeadDamaged, bool bBodyDamaged, bool bLeftArmDamaged, bool bRightArmDamaged, bool bLeftLegDamaged, bool bRightLegDamaged, bool bLeftFootDamaged, bool bRightFootDamaged)> OnBodyPartDamaged; // 0x1590(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         bBodyHit : 1;                                      // 0x15A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRightFootHit : 1;                                 // 0x15A0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bLeftFootHit : 1;                                  // 0x15A0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bBlockedByBodyArmor : 1;                           // 0x15A0(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bBlockedByHeadArmor : 1;                           // 0x15A0(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_15A1[0x1F];                                    // 0x15A1(0x001F)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EGibAreas, float>                        DismembermentDamageMap;                            // 0x15C0(0x0050)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	TArray<class FName>                           DamageExcludedBones;                               // 0x1610(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	uint8                                         Pad_1620[0x10];                                    // 0x1620(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GasDamageAccumulated;                              // 0x1630(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GasDamageDecay;                                    // 0x1634(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1638[0x8];                                     // 0x1638(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bGodMode : 1;                                      // 0x1640(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bNoTarget;                                         // 0x1641(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1642[0x6];                                     // 0x1642(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        ArmorImpactEffect;                                 // 0x1648(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBloodData*                             Blood;                                             // 0x1650(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ABaseWeapon*>                    DamagedByWeapons;                                  // 0x1658(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_1668[0x8];                                     // 0x1668(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bRepStunned;                                       // 0x1670(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EStunType                                     RepStunnedWith;                                    // 0x1671(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1672[0x56];                                    // 0x1672(0x0056)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bHasEverBeenStunned : 1;                           // 0x16C8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_16C9[0x17];                                    // 0x16C9(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AReadyOrNotCharacter*>           AITrackingMe;                                      // 0x16E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class AReadyOrNotCharacter*>           DamagedByCharacters;                               // 0x16F0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FVector                                OriginalSpawnLocation;                             // 0x1700(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AActor* Evidence)> OnEvidenceCollected;                      // 0x1718(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1728[0x8];                                     // 0x1728(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 PendingEvidence;                                   // 0x1730(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsCollectingEvidence;                             // 0x1738(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCollectionAnimHasTriggered;                       // 0x1739(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_173A[0x6];                                     // 0x173A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           CollectingLoopAnim1P;                              // 0x1740(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           CollectingLoopAnim3P;                              // 0x1748(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODEvent*                             Reward;                                            // 0x1750(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECharacterEmotion                             CurrentEmotion;                                    // 0x1758(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1759[0x3];                                     // 0x1759(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FacialAnimationOverrideTime;                       // 0x175C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FacialAnimationBlend;                              // 0x1760(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FacialAnimationBlendTarget;                        // 0x1764(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FacialAnimationBlendDecay;                         // 0x1768(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         FacialAnimationPriority;                           // 0x176C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAiming;                                           // 0x1770(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMovementLocked;                                   // 0x1771(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAimLocked;                                        // 0x1772(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bActionsLocked;                                    // 0x1773(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bItemSelectionLocked;                              // 0x1774(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCommandMenuLocked;                                // 0x1775(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bGamepadCommandWheelLocked;                        // 0x1776(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCommandMenuHidden;                                // 0x1777(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bItemMenuLocked;                                   // 0x1778(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bWeaponAttachmentsLocked;                          // 0x1779(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCantedSightLocked;                                // 0x177A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTabletLocked;                                     // 0x177B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bConsoleHotkeysHidden;                             // 0x177C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bConsoleHotkeysItemWheelHidden;                    // 0x177D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOptiwandLocked;                                   // 0x177E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bChemlightLocked;                                  // 0x177F(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bGamepadTeamCameraLocked;                          // 0x1780(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1781[0x7];                                     // 0x1781(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ADoor*                                  QueuedDoorToOpen;                                  // 0x1788(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADoor*                                  QueuedDoorToClose;                                 // 0x1790(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADoor*                                  LastKickedDoor;                                    // 0x1798(0x0008)(Net, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractionsData*                      DoorKickInteractionFront;                          // 0x17A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractionsData*                      DoorKickInteractionBack;                           // 0x17A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractionsData*                      DoorKickFailureInteractionFront;                   // 0x17B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractionsData*                      DoorKickFailureInteractionBack;                    // 0x17B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractionsData*                      DoorKickBreakInteractionFront;                     // 0x17C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractionsData*                      DoorKickBreakInteractionBack;                      // 0x17C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractionsData*                      CarryArrestedInteractionData;                      // 0x17D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractionsData*                      DropArrestedInteractionData;                       // 0x17D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractionsData*                      ThrowArrestedInteractionData;                      // 0x17E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class AReadyOrNotCharacter* ItemOwner, class ABaseItem* Item)> Event_OnItemPrimaryUse; // 0x17E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bNVGOn;                                            // 0x17F8(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17F9[0x7];                                     // 0x17F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AReadyOrNotCharacter* Character, bool bOn)> OnNightVisionGogglesToggled; // 0x1800(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1810[0x28];                                    // 0x1810(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bShouldPlayFootstepFoley;                          // 0x1838(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPlayEveryStep;                                    // 0x1839(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_183A[0x6];                                     // 0x183A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AImpactEffect>              FootstepImpactEffectFast;                          // 0x1840(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AImpactEffect>              FootstepImpactEffectSlow;                          // 0x1848(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODEvent*                             CurrentFootstepFoleyEvent;                         // 0x1850(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODEvent*                             CurrentFootstepFoleyEventRemote;                   // 0x1858(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODEvent*                             FootstepsLocal;                                    // 0x1860(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODEvent*                             FootstepsRemote;                                   // 0x1868(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODEvent*                             MovementFoley;                                     // 0x1870(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MovementFoleySocket;                               // 0x1878(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPhysicsAsset*                          DefaultRagdollPhysAsset;                           // 0x1880(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPhysicsAsset*                          DefaultAlivePhysAsset;                             // 0x1888(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPhysicsAsset*                          CuffedRagdollPhysAsset;                            // 0x1890(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPhysicsAsset*                          Rep_ActiveRagdollPhysAsset;                        // 0x1898(0x0008)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, RepNotify, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsRelevant;                                       // 0x18A0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18A1[0x7];                                     // 0x18A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ANeutralizeSuspectByTag*                NeutralizeSuspectTag;                              // 0x18A8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UAnimMontage*>                   TorsoDeathAnims;                                   // 0x18B0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UAnimMontage*>                   HeadDeathAnims;                                    // 0x18C0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UAnimMontage*>                   LeftArmDeathAnims;                                 // 0x18D0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UAnimMontage*>                   RightArmDeathAnims;                                // 0x18E0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UAnimMontage*>                   LeftLegDeathAnims;                                 // 0x18F0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UAnimMontage*>                   RightLegDeathAnims;                                // 0x1900(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class UAnimMontage*                           CurrentDeathMontage;                               // 0x1910(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bPlayingDeathMontage : 1;                          // 0x1918(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bStartedPlayingDeath : 1;                          // 0x1918(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	struct FRonReplicatedAcceleration             ReplicatedAcceleration;                            // 0x1919(0x0003)(Net, Transient, RepNotify, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ReplicatedMaxSpeed;                                // 0x191C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsBlendRagdollNotifyActive;                       // 0x1920(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1921[0x3];                                     // 0x1921(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FootstepOcclusionMultiplier;                       // 0x1924(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootstepFullOcclusionDepth;                        // 0x1928(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_192C[0x4];                                     // 0x192C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         AnimNotifyAttachments;                             // 0x1930(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1940[0x8];                                     // 0x1940(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCharacterSnapshot>             Snapshots;                                         // 0x1948(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          CurrentLipSyncAnimation;                           // 0x1958(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1960[0x20];                                    // 0x1960(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  GameplayTags;                                      // 0x1980(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static bool IsOnSameTeam(class AReadyOrNotCharacter* A, class AReadyOrNotCharacter* B);

	void ApplyDamageToBone(float* Damage, const class FName& HitBone, const struct FPointDamageEvent& DamageEvent, class AController* EventInstigator, class AActor* DamageCauser);
	void Arrest(class AReadyOrNotCharacter* PlayerMakingArrest);
	void ArrestComplete(class AReadyOrNotCharacter* PlayerMakingArrest, class AZipcuffs* Zipcuffs);
	void BeginEvidenceCollection_COOP(class AActor* InEvidenceActor, class UInteractableComponent* CollectionInteractableComp, float CollectionTime);
	void CalculateLeanMovement(float DeltaTime);
	void CancelArrest(class AReadyOrNotCharacter* PlayerMakingArrest);
	void Client_OnBodyPartDamaged(bool bInHeadHit, bool bInBodyHit, bool bInLeftArmHit, bool bInRightArmHit, bool bInLeftLegHit, bool bInRightLegHit, bool bInLeftFootHit, bool bInRightFootHit);
	void Client_Play1PMontage(class UAnimMontage* NewMontage, float PlayRate);
	void Client_PlayFMODEvent2D(class UFMODEvent* Event);
	void Client_PlayMeleeImpactEffects();
	void Client_PlayScreenShake(TSubclassOf<class ULegacyCameraShake> CameraShake);
	void Client_SetControlRotation(const struct FRotator& NewRotation);
	void CollectPendingEvidence();
	void CompleteEvidenceCollection_COOP(class AActor* InEvidenceActor);
	bool DamageHitHead(const struct FPointDamageEvent& DamageEvent);
	void DecreaseHealth(float Amount);
	void DepleteHealth();
	void DisableNightVisionGoggles();
	void DisableRagdoll();
	void EnableNightVisionGoggles();
	void EnableRagdoll(float Duration);
	void EndEvidenceCollection_COOP(class UInteractableComponent* CollectionInteractableComp);
	void EndPepperSprayed();
	void EndStun(EStunType StunType);
	void ForceMeshUsingOverride(class USkeletalMesh* InFPMesh, class USkeletalMesh* InTPMesh, class USkeletalMesh* InFaceMesh);
	bool GetConsoleHotkeysHidden();
	float GetDeltaRotationToCharacter(class AReadyOrNotCharacter* Character);
	bool GetFMODFootstepParameters(int32* Stance, int32* Speed, int32* Surface);
	float GetLeanAmount(const struct FVector& LeanDirection, float LeanAmount, float MaxLeanAmount);
	void HandleTeamChanged(ETeamType Team);
	void Incapacitate();
	void IncreaseHealth(float Amount);
	bool IsCurrentlyFlashed();
	bool IsCurrentlySprayed();
	bool IsCurrentlyStung();
	bool IsNotifyStateActiveByName(const class FString& NotifyClassName, const class FString& SlotName);
	bool IsOutside();
	bool IsPepperSprayedLocationValid(const struct FHitResult& Hit, class APepperspray* Pepperspray);
	void KickDoor(class ADoor* Door);
	void Kill();
	void Lean(float Val);
	void LeanRight(float Val);
	void LeanUp(float Val);
	void LockAim();
	void LockAllActions();
	void LockCantedSight();
	void LockCommandMenu();
	void LockItemMenu();
	void LockItemSelection();
	void LockMovement();
	void LockMovementAndActions();
	void LockTablet();
	void LockWeaponAttachments();
	void Multicast_AddMoveIgnoreActor(class AReadyOrNotCharacter* MoveIgnoreCharacter, bool bAdd);
	void Multicast_ChangeFaceEmotion(ECharacterEmotion NewEmotion, float OverrideTime, float Blend, float BlendDecay, int32 Priority);
	void Multicast_DisableRagdoll();
	void Multicast_EnableRagdoll(float Duration);
	void Multicast_EnableRagdollBlendIn();
	void Multicast_InflictSuppression(const struct FSuppressionData& SuppressionData, TSubclassOf<class ULegacyCameraShake> CameraShake, bool bLessLethal);
	void Multicast_InflictSuppression_NoLineOfSight(const struct FSuppressionData& SuppressionData, TSubclassOf<class ULegacyCameraShake> CameraShake, bool bLessLethal);
	void Multicast_OnExplosiveVestDetonation();
	void Multicast_OnIncapacitated(class FName LastBone);
	void Multicast_OnKilled(class FName LastBoneHit, class AActor* DamageCauser);
	void Multicast_OnTargetReported();
	void Multicast_PauseAllAnims(bool bPaused);
	void Multicast_Play3PMontage(class UAnimMontage* NewMontage, float StartTime, float PlayRate, bool bFromClient);
	void Multicast_PlayDeathAnimation(class UAnimMontage* Montage);
	void Multicast_PlayMeleeImpactEffects(class UFMODEvent* ImpactSound, class UParticleSystem* ImpactParticle);
	void Multicast_PlayNonLocal3PMontage(class UAnimMontage* NewMontage);
	void Multicast_PlayRawVO(const class FString& SpecificFileName, const class FString& OverrideSpeakerName, bool bIgnoreIfAlreadyPlaying);
	void Multicast_SavePoseSnapshot(const class FName& SnapshotName);
	void Multicast_SpawnArterialBloodEffects(const struct FHitResult& HitResult, class FName Artery);
	void Multicast_SpawnBloodEffects(const struct FHitResult& Hit, float WoundSize, class AController* HitInstigator);
	void Multicast_SpawnDismembermentEffects(EGibAreas GibArea, const struct FHitResult& HitResult);
	void Multicast_Stop1PMontage(class UAnimMontage* Montage, float BlendoutTime);
	void Multicast_Stop3PMontage(class UAnimMontage* Montage, float BlendoutTime);
	void Multicast_TakeDamage(float Damage, const struct FDamageEvent& DamageEvent, class AReadyOrNotCharacter* InstigatorCharacter, class AActor* DamageCauser);
	void OnActorSpawned(class AActor* Actor);
	void OnArteryBleedParticleCollision(class FName EventName, float EmitterTime, int32 ParticleTime, const struct FVector& Location, const struct FVector& Velocity, const struct FVector& Direction, const struct FVector& Normal, class FName BoneName, class UPhysicalMaterial* PhysMat);
	void OnBodyFallAudioStop();
	void OnCapsuleHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void OnCarryDropComplete(class AActor* Driver, class AActor* Slave);
	void OnCarryDropComplete_Driver(class AActor* Driver);
	void OnCarryDropComplete_Slave(class AActor* Slave);
	void OnCarryPickupComplete(class AActor* Driver, class AActor* Slave);
	void OnCarryPickupComplete_Driver(class AActor* Driver);
	void OnCarryPickupComplete_Slave(class AActor* Slave);
	void OnCarryThrowComplete(class AActor* Driver, class AActor* Slave);
	void OnCarryThrowComplete_Driver(class AActor* Driver);
	void OnCarryThrowComplete_Slave(class AActor* Slave);
	void OnDeadHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void OnDismembermentParticleCollision(class FName EventName, float EmitterTime, int32 ParticleTime, const struct FVector& Location, const struct FVector& Velocity, const struct FVector& Direction, const struct FVector& Normal, class FName BoneName, class UPhysicalMaterial* PhysMat);
	void OnEquippedWeaponDryFire(class ABaseMagazineWeapon* Weapon, bool bServer);
	void OnEquippedWeaponFire(class ABaseMagazineWeapon* Weapon, bool bServer);
	void OnEquippedWeaponMagCheck(class ABaseMagazineWeapon* Weapon);
	void OnHealthDepleted();
	void OnIncapacitated(class AReadyOrNotCharacter* InstigatorCharacter);
	void OnItemEquipped(class ABaseItem* NewEquippedItem);
	void OnItemHolstered(class ABaseItem* HolsteredItem);
	void OnKilled(class AReadyOrNotCharacter* InstigatorCharacter);
	void OnLeanEnd();
	void OnLeanStart();
	void OnMeshHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void OnRagdollBlendStop(class URagdollComponent* InRagdollComponent);
	void OnRagdollPhysBodyHit(class URagdollComponent* InRagdollComponent, const struct FVector& Impulse, const struct FHitResult& Hit);
	void OnRagdollStart(class URagdollComponent* InRagdollComponent);
	void OnRep_ActiveRagdollPhysAsset();
	void OnRep_CharacterLookOverride();
	void OnRep_ControlRotation();
	void OnRep_CurrentCarryCharacterChanged();
	void OnRep_CurrentRagdollArrestCharacterChanged();
	void OnRep_Customization();
	void OnRep_MeshReplicated();
	void OnRep_PreArrested();
	void OnRep_ReplicatedAcceleration();
	void OnRep_Surrendered();
	void OnVoiceAudioStopped();
	void OnYellExecute();
	bool OpenDoor(class ADoor* Door, bool bOpenDoor);
	void PickupEvidence(class AActor* InEvidence);
	void Play1PMontage(class UAnimMontage* NewMontage, float PlayRate);
	void Play1PMontageDeferred(class UAnimMontage* Montage, const class FString& AnimationName);
	void Play3PMontage(class UAnimMontage* NewMontage, float StartTime, float PlayRate);
	void Play3PMontageDeferred(class UAnimMontage* Montage, const class FString& AnimationName);
	class UAnimMontage* PlayMontageFromTable(const class FString& Animation);
	class UAnimMontage* PlayMontageFromTableWithIndex(const class FString& Animation, int32 Index_0);
	class APairedInteractionDriver* PlayPairedInteraction(class UInteractionsData* InteractionData, class AActor* Driver, class AActor* Slave, class ABaseItem* OptionalItem);
	void PlayRadioSelectAnimation();
	void PlayRandomDebugConversation();
	void PlayRandomDebugVoiceLine(const class FString& Line);
	bool PlayRawVO(const class FString& VoiceLine, const class FString& OverrideSpeakerName, bool bIgnoreIfAlreadyPlaying);
	void PlayRawVOWithCooldown(const class FString& VoiceLine, float Cooldown, const class FString& OverrideSpeakerName);
	void PlayReportSpeech(const class FString& VoiceLine, const class FString& InTOCLine);
	void PlayROEViolateTOCResponse();
	void PlaySpecificDebugVoiceLine(const class FString& Filename);
	void PlayTOCResponse(const class FString& Line, bool bIsNetworked, ETOCPriority Priority, bool bCanPrefix, float Delay);
	void RagdollArrestTarget(class AReadyOrNotCharacter* RagdollCharacter);
	void RequestAnim2RagdollBlend(float Duration);
	void ResetHealth();
	void ResetPhysicsAsset();
	void Server_ApplyPointDamage(class AActor* DamagedActor, float BaseDamage, const struct FVector& HitFromDirection, const struct FHitResult& HitInfo, class AController* EventInstigator, class AActor* DamageCauser, TSubclassOf<class UDamageType> DamageTypeClass);
	void Server_CarryArrestedTarget(class AReadyOrNotCharacter* ArrestedCharacter);
	void Server_ChangeTPMesh(class USkeletalMesh* Body, class USkeletalMesh* Face);
	void Server_DoMelee();
	void Server_DoubleTapInteract(class UObject* Interactable, class UInteractableComponent* InInteractableComponent);
	void Server_DropArrestedTarget(class AReadyOrNotCharacter* ArrestedCharacter);
	void Server_EndInteract(class UObject* Interactable, class UInteractableComponent* InInteractableComponent);
	void Server_EndInteract_PrimaryUse(class UObject* Interactable, class UInteractableComponent* InInteractableComponent);
	void Server_Incapacitate();
	void Server_Interact(class UObject* Interactable, class UInteractableComponent* InInteractableComponent);
	void Server_Interact_PrimaryUse(class UObject* Interactable, class UInteractableComponent* InInteractableComponent);
	void Server_KickBreakQueuedDoor();
	void Server_KickFailQueuedDoor();
	void Server_KickQueuedDoor();
	void Server_Kill();
	void Server_MeleeInteract(class UObject* Interactable, class UInteractableComponent* InInteractableComponent);
	void Server_Play3PMontage(class UAnimMontage* NewMontage, float StartTime, float PlayRate, bool bFromClient);
	void Server_PlayNonLocal3PMontage(class UAnimMontage* NewMontage);
	void Server_PlayTOCConversation();
	void Server_RepNVGOn(bool bIsOn);
	void Server_ReportTarget(class AActor* Character);
	void Server_ReportToTOC(class AActor* Actor, bool bPlayAnimation, bool bTocResponse);
	void Server_ThrowArrestedTarget(class AReadyOrNotCharacter* ArrestedCharacter);
	void Server_UpdateLean(float QuickLean, float newFreeLeanY, float NewFreeLeanZ);
	void Server_VoiceLine(const class FString& VO, const class FString& SpeakersName, bool bTeamPrefix);
	void Server_Yell();
	void SpawnBloodPool();
	void SpawnFootstepEffect();
	void StartBeingTasered(float PingStunDuration, class ATaser* WeaponUsed);
	void StartPepperSprayed(class APepperspray* PeppersprayUsed);
	void StartStun(EStunType StunType, class AActor* StunCauser);
	void StopFPAnimMontage(class UAnimMontage* AnimMontage, float BlendoutTime);
	void StopTPAnimMontage(class UAnimMontage* AnimMontage);
	void StopTPMontage(class UAnimMontage* AnimMontage, float BlendoutTime);
	void StopTPMontageFromTable(const class FString& Animation, float BlendoutTime);
	void TestPhysicalAnimationComponent();
	void ToggleFreeLean();
	void ToggleLeanLeft(bool bADSIsActive);
	void ToggleLeanRight(bool bADSIsActive);
	void ToggleNightvisionGoggles();
	void UnlockAim();
	void UnlockAllActions();
	void UnlockCantedSight();
	void UnlockCommandMenu();
	void UnlockItemMenu();
	void UnlockItemSelection();
	void UnlockMovement();
	void UnlockMovementAndActions();
	void UnlockTablet();
	void UnlockWeaponAttachments();
	void UpdateOverridesFromCharacterLookOverrideDataTable(const class FString& LookOverride);

	bool AnyBodyPartHit() const;
	bool CanArrest() const;
	bool CanArrestRagdoll() const;
	bool CanBePickedUp() const;
	bool CanCarryCharacter(class AReadyOrNotCharacter* CharacterToPickup) const;
	bool CanDropCharacter(class AReadyOrNotCharacter* CharacterToDrop) const;
	bool CanMelee() const;
	bool CanYell() const;
	bool DoesMontageFromTableExist(const class FString& Animation) const;
	TArray<class AActor*> GetCollisionIgnoredActors() const;
	TArray<class UPrimitiveComponent*> GetCollisionIgnoredComponents() const;
	float GetCurrentHealth() const;
	float GetCurrentReviveHealth() const;
	float GetCurrentReviveTime() const;
	float GetCurrentStunDuration() const;
	float GetCurrentStunTime() const;
	EAnimWeaponType GetCurrentWeaponAnimType() const;
	class ABaseItem* GetEquippedItem() const;
	class ABaseMagazineWeapon* GetEquippedWeapon() const;
	class UCharacterHealthComponent* GetHealthComponent() const;
	EPlayerHealthStatus GetHealthStatus() const;
	class FString GetLastTableMontagePlayed() const;
	struct FLimbHealthData GetLimbHealth(ELimbType Limb) const;
	float GetMaxHealth() const;
	int32 GetMontageAnimCountFromTable(const class FString& Animation) const;
	class UAnimMontage* GetMontageFromTable(const class FString& Animation) const;
	class UAnimMontage* GetMontageFromTableWithIndex(const class FString& Animation, int32 Index_0) const;
	TArray<class ABaseItem*> GetRemovedItems() const;
	float GetSpeakCooldown() const;
	class FString GetSpeechCharacterName() const;
	TArray<class FString> GetTableMontageQueue() const;
	ETeamType GetTeam() const;
	float GetTimeSinceLastBulletDamage() const;
	float GetTimeSinceLastStun() const;
	bool HasBeenReported() const;
	bool HasEverBeenStunned() const;
	bool HasLineOfSightTo(const struct FVector& Location) const;
	bool HasRecentlyTakenDamage(const float Tolerance) const;
	bool HasRecentlyTakenStunDamage(const float Tolerance) const;
	bool Is3PMontagePlaying(const class UAnimMontage* Montage) const;
	bool IsActive() const;
	bool IsActiveForMovement() const;
	bool IsAffectedByDamageType(const class UDamageType* DamageType) const;
	bool IsAffectedByDamageTypeClass(TSubclassOf<class UDamageType> DamageType) const;
	bool IsAnimationBlocking() const;
	bool IsAnyLimbHit() const;
	bool IsAnyTableMontagePlaying(class FString* OutMontage) const;
	bool IsArrested() const;
	bool IsArrestedAndDead() const;
	bool IsArrestedAndIncapacitated() const;
	bool IsArrestedOrSurrendered() const;
	bool IsBeingArrested() const;
	bool IsBeingCarried() const;
	bool IsBeingThrown() const;
	bool IsCarried() const;
	bool IsCarrying() const;
	bool IsCivilian() const;
	bool IsCurrentlyGassed() const;
	bool IsCurrentlyTased() const;
	bool IsDeadNotUnconscious() const;
	bool IsDeadOrUnconscious() const;
	bool IsDowned() const;
	bool IsDropping() const;
	bool IsFullBodyMontagePlaying() const;
	bool IsFullHealth() const;
	bool IsGettingUp() const;
	bool IsHalfHealth() const;
	bool IsHealthDepleted() const;
	bool IsIncapacitated() const;
	bool IsInjured() const;
	bool IsInRagdoll() const;
	bool IsLimbBroken(ELimbType Limb) const;
	bool IsLimbHit(ELimbType Limb) const;
	bool IsLoadingTableMontage() const;
	bool IsLocalPlayer() const;
	bool IsLowHealth() const;
	bool IsMontagePlayingWithTimeRemaining(const class UAnimMontage* Animation, float* TimeRemaining) const;
	bool IsMontageSlotPlaying(class FName SlotName) const;
	bool IsOnlyStunnedWithGas() const;
	bool IsOnSWATTeam() const;
	bool IsPepperSprayed() const;
	bool IsPlayingCarryAnims() const;
	bool IsPlayingNonInterruptibleMontage(const class FString& MontageNameTryingToBePlayed) const;
	bool IsPlayingRootMotionFromMontage() const;
	bool IsRagdollBlending() const;
	bool IsReloading() const;
	bool IsReviveHealthDepleted() const;
	bool IsSpeechTimerActive() const;
	bool IsStartling() const;
	bool IsStunned() const;
	bool IsStunnedWith(EStunType StunType) const;
	bool IsSurrenderComplete() const;
	bool IsSurrendered() const;
	bool IsSurrenderedFor(const float Seconds) const;
	bool IsSuspect() const;
	bool IsTableMontage(class UAnimMontage* Montage) const;
	bool IsTableMontagePlaying(const class FString& Animation) const;
	bool IsTableMontagePlayingWithTimeRemaining(const class FString& Animation, float* TimeRemaining) const;
	bool IsUnconsciousNotDead() const;
	bool IsUpperBodyMontagePlaying() const;
	bool UsingReviveSystem() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotCharacter">();
	}
	static class AReadyOrNotCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AReadyOrNotCharacter>();
	}
};
static_assert(alignof(AReadyOrNotCharacter) == 0x000010, "Wrong alignment on AReadyOrNotCharacter");
static_assert(sizeof(AReadyOrNotCharacter) == 0x0019A0, "Wrong size on AReadyOrNotCharacter");
static_assert(offsetof(AReadyOrNotCharacter, CustomizationFaceMesh) == 0x0006F0, "Member 'AReadyOrNotCharacter::CustomizationFaceMesh' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, CustomizationHelmet) == 0x0006F8, "Member 'AReadyOrNotCharacter::CustomizationHelmet' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, CustomizationSkeletalMeshes) == 0x000700, "Member 'AReadyOrNotCharacter::CustomizationSkeletalMeshes' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, CustomizationStaticMeshes) == 0x000710, "Member 'AReadyOrNotCharacter::CustomizationStaticMeshes' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, CustomizationActors) == 0x000720, "Member 'AReadyOrNotCharacter::CustomizationActors' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, Customization) == 0x000730, "Member 'AReadyOrNotCharacter::Customization' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, MeshGearSlot) == 0x0008D8, "Member 'AReadyOrNotCharacter::MeshGearSlot' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, InteractableComponent) == 0x0008E0, "Member 'AReadyOrNotCharacter::InteractableComponent' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, PlayerMarkerComponent) == 0x0008E8, "Member 'AReadyOrNotCharacter::PlayerMarkerComponent' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, FaceMesh) == 0x0008F0, "Member 'AReadyOrNotCharacter::FaceMesh' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, FMODAudioPropagationComp) == 0x0008F8, "Member 'AReadyOrNotCharacter::FMODAudioPropagationComp' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, FMODVoiceAudioComp) == 0x000900, "Member 'AReadyOrNotCharacter::FMODVoiceAudioComp' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, CharacterHealth) == 0x000908, "Member 'AReadyOrNotCharacter::CharacterHealth' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, InventoryComp) == 0x000910, "Member 'AReadyOrNotCharacter::InventoryComp' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, PerceptionStimuliComp) == 0x000918, "Member 'AReadyOrNotCharacter::PerceptionStimuliComp' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, GibComponent) == 0x000920, "Member 'AReadyOrNotCharacter::GibComponent' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, PhysicalAnimationComp) == 0x000928, "Member 'AReadyOrNotCharacter::PhysicalAnimationComp' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, SkinnedDecalSampler) == 0x000930, "Member 'AReadyOrNotCharacter::SkinnedDecalSampler' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, RagdollComponent) == 0x000938, "Member 'AReadyOrNotCharacter::RagdollComponent' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, BloodEntryParticleComponent) == 0x000940, "Member 'AReadyOrNotCharacter::BloodEntryParticleComponent' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, ArmourImpactParticleComponent) == 0x000948, "Member 'AReadyOrNotCharacter::ArmourImpactParticleComponent' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, BloodSplatterDecalComponents) == 0x000950, "Member 'AReadyOrNotCharacter::BloodSplatterDecalComponents' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, AimAssistTargetComponent) == 0x000968, "Member 'AReadyOrNotCharacter::AimAssistTargetComponent' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, ReplicatedControlRotation) == 0x0009E0, "Member 'AReadyOrNotCharacter::ReplicatedControlRotation' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnCharacterKilled) == 0x0009F8, "Member 'AReadyOrNotCharacter::OnCharacterKilled' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnCharacterIncapacitated) == 0x000A08, "Member 'AReadyOrNotCharacter::OnCharacterIncapacitated' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnWeaponFire) == 0x000A18, "Member 'AReadyOrNotCharacter::OnWeaponFire' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnWeaponDryFire) == 0x000A28, "Member 'AReadyOrNotCharacter::OnWeaponDryFire' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnPlayerDowned) == 0x000A38, "Member 'AReadyOrNotCharacter::OnPlayerDowned' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnPointDamageReceived) == 0x000A48, "Member 'AReadyOrNotCharacter::OnPointDamageReceived' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnStunDamageReceived) == 0x000A58, "Member 'AReadyOrNotCharacter::OnStunDamageReceived' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnPlayerFreed) == 0x000A68, "Member 'AReadyOrNotCharacter::OnPlayerFreed' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnPlayerHit) == 0x000A78, "Member 'AReadyOrNotCharacter::OnPlayerHit' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnPlayerArmorHit) == 0x000A88, "Member 'AReadyOrNotCharacter::OnPlayerArmorHit' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, ThrownItem) == 0x000A98, "Member 'AReadyOrNotCharacter::ThrownItem' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnGetupComplete) == 0x000AA0, "Member 'AReadyOrNotCharacter::OnGetupComplete' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnItemThrown_FromAnimNotify) == 0x000AB0, "Member 'AReadyOrNotCharacter::OnItemThrown_FromAnimNotify' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnDoorLockPickBegin_FromAnimNotify) == 0x000AC0, "Member 'AReadyOrNotCharacter::OnDoorLockPickBegin_FromAnimNotify' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnDoorLockPickEnd_FromAnimNotify) == 0x000AD0, "Member 'AReadyOrNotCharacter::OnDoorLockPickEnd_FromAnimNotify' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnDoorChecked_FromAnimNotify) == 0x000AE0, "Member 'AReadyOrNotCharacter::OnDoorChecked_FromAnimNotify' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnC2Placed_FromAnimNotify) == 0x000AF0, "Member 'AReadyOrNotCharacter::OnC2Placed_FromAnimNotify' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnC2Detonate_FromAnimNotify) == 0x000B00, "Member 'AReadyOrNotCharacter::OnC2Detonate_FromAnimNotify' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnTrapDisarmBegin_FromAnimNotify) == 0x000B10, "Member 'AReadyOrNotCharacter::OnTrapDisarmBegin_FromAnimNotify' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnTrapDisarmEnd_FromAnimNotify) == 0x000B20, "Member 'AReadyOrNotCharacter::OnTrapDisarmEnd_FromAnimNotify' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnMirrorDoorStarted_FromAnimNotify) == 0x000B30, "Member 'AReadyOrNotCharacter::OnMirrorDoorStarted_FromAnimNotify' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnMirrorDoorFinished_FromAnimNotify) == 0x000B40, "Member 'AReadyOrNotCharacter::OnMirrorDoorFinished_FromAnimNotify' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnStartDoorWedgePlacement_FromAnimNotify) == 0x000B50, "Member 'AReadyOrNotCharacter::OnStartDoorWedgePlacement_FromAnimNotify' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnEndDoorWedgePlacement_FromAnimNotify) == 0x000B60, "Member 'AReadyOrNotCharacter::OnEndDoorWedgePlacement_FromAnimNotify' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, LastDamageEvent) == 0x000BA0, "Member 'AReadyOrNotCharacter::LastDamageEvent' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bBulletForceTransferred) == 0x000BCA, "Member 'AReadyOrNotCharacter::bBulletForceTransferred' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, MinimumBodyFallImpulse) == 0x000BCC, "Member 'AReadyOrNotCharacter::MinimumBodyFallImpulse' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, MaxRagdollSounds) == 0x000BD0, "Member 'AReadyOrNotCharacter::MaxRagdollSounds' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, RagdollSoundsPlayed) == 0x000BD4, "Member 'AReadyOrNotCharacter::RagdollSoundsPlayed' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, BodyFallEvent) == 0x000BD8, "Member 'AReadyOrNotCharacter::BodyFallEvent' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, BodyFallSoundSource) == 0x000BE8, "Member 'AReadyOrNotCharacter::BodyFallSoundSource' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bCapsuleCollisionRagdolled) == 0x000BF0, "Member 'AReadyOrNotCharacter::bCapsuleCollisionRagdolled' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bCapsuleFloorAngleRagdolled) == 0x000BF1, "Member 'AReadyOrNotCharacter::bCapsuleFloorAngleRagdolled' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, CapsuleCollisionRagdollTriggerThreshold) == 0x000BF4, "Member 'AReadyOrNotCharacter::CapsuleCollisionRagdollTriggerThreshold' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, CapsuleFloorAngleRagdollTriggerThreshold) == 0x000BF8, "Member 'AReadyOrNotCharacter::CapsuleFloorAngleRagdollTriggerThreshold' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, CapsuleFloorAngleRagdollDelayThreshold) == 0x000BFC, "Member 'AReadyOrNotCharacter::CapsuleFloorAngleRagdollDelayThreshold' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bBlendingAnim2Ragdoll) == 0x000C00, "Member 'AReadyOrNotCharacter::bBlendingAnim2Ragdoll' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, Anim2RagdollPelvisWakeUpTime) == 0x000C10, "Member 'AReadyOrNotCharacter::Anim2RagdollPelvisWakeUpTime' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, VoiceSoundSource) == 0x000C20, "Member 'AReadyOrNotCharacter::VoiceSoundSource' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bBlendInPhysics) == 0x000DF8, "Member 'AReadyOrNotCharacter::bBlendInPhysics' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bStartBlendInIncapacitation) == 0x000DF9, "Member 'AReadyOrNotCharacter::bStartBlendInIncapacitation' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bBlendInIncapacitation) == 0x000DFA, "Member 'AReadyOrNotCharacter::bBlendInIncapacitation' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, IncapacitationBlendTime) == 0x000DFC, "Member 'AReadyOrNotCharacter::IncapacitationBlendTime' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, IncapacitationBlendOutTime) == 0x000E00, "Member 'AReadyOrNotCharacter::IncapacitationBlendOutTime' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, IncapacitationLoopAnim) == 0x000E08, "Member 'AReadyOrNotCharacter::IncapacitationLoopAnim' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, BlendInterpAmount) == 0x000E10, "Member 'AReadyOrNotCharacter::BlendInterpAmount' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, FinalBlendInTime) == 0x000E20, "Member 'AReadyOrNotCharacter::FinalBlendInTime' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, BlendInAfterStartOfAnim) == 0x000E28, "Member 'AReadyOrNotCharacter::BlendInAfterStartOfAnim' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, ArrestedBy) == 0x000E38, "Member 'AReadyOrNotCharacter::ArrestedBy' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, KilledBy) == 0x000E40, "Member 'AReadyOrNotCharacter::KilledBy' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, IncapacitatedBy) == 0x000E48, "Member 'AReadyOrNotCharacter::IncapacitatedBy' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, DeathReason) == 0x000E50, "Member 'AReadyOrNotCharacter::DeathReason' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnCharacterTakeDamage) == 0x000E58, "Member 'AReadyOrNotCharacter::OnCharacterTakeDamage' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnAIStunnedPlaySound) == 0x000E68, "Member 'AReadyOrNotCharacter::OnAIStunnedPlaySound' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnStunnedEvent) == 0x000E78, "Member 'AReadyOrNotCharacter::OnStunnedEvent' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnStunnedEndedEvent) == 0x000E88, "Member 'AReadyOrNotCharacter::OnStunnedEndedEvent' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnMeleeHitTaken) == 0x000E98, "Member 'AReadyOrNotCharacter::OnMeleeHitTaken' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, HeadBones) == 0x000EA8, "Member 'AReadyOrNotCharacter::HeadBones' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, UpperBody) == 0x000EB8, "Member 'AReadyOrNotCharacter::UpperBody' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, LowerBody) == 0x000ED8, "Member 'AReadyOrNotCharacter::LowerBody' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, R_Leg) == 0x000EE8, "Member 'AReadyOrNotCharacter::R_Leg' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, L_Leg) == 0x000EF8, "Member 'AReadyOrNotCharacter::L_Leg' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, L_Foot) == 0x000F08, "Member 'AReadyOrNotCharacter::L_Foot' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, R_Foot) == 0x000F18, "Member 'AReadyOrNotCharacter::R_Foot' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, L_Arm) == 0x000F28, "Member 'AReadyOrNotCharacter::L_Arm' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, R_Arm) == 0x000F38, "Member 'AReadyOrNotCharacter::R_Arm' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, L_Hand) == 0x000F48, "Member 'AReadyOrNotCharacter::L_Hand' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, R_Hand) == 0x000F58, "Member 'AReadyOrNotCharacter::R_Hand' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bLowReadyPointUp) == 0x000F68, "Member 'AReadyOrNotCharacter::bLowReadyPointUp' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bLowReadyPointDown) == 0x000F69, "Member 'AReadyOrNotCharacter::bLowReadyPointDown' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, LowReadyDistance) == 0x000F6C, "Member 'AReadyOrNotCharacter::LowReadyDistance' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, LowReadyIgnoredCapsules) == 0x000F78, "Member 'AReadyOrNotCharacter::LowReadyIgnoredCapsules' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, QuickLeanAmount) == 0x000F8C, "Member 'AReadyOrNotCharacter::QuickLeanAmount' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, QuickLeanIntensity) == 0x000F90, "Member 'AReadyOrNotCharacter::QuickLeanIntensity' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, QuickLeanInterpSpeed) == 0x000F94, "Member 'AReadyOrNotCharacter::QuickLeanInterpSpeed' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, FreeLeanX) == 0x000F98, "Member 'AReadyOrNotCharacter::FreeLeanX' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, FreeLeanZ) == 0x000F9C, "Member 'AReadyOrNotCharacter::FreeLeanZ' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bFreeLeaning) == 0x000FA0, "Member 'AReadyOrNotCharacter::bFreeLeaning' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bIsLeaning) == 0x000FA1, "Member 'AReadyOrNotCharacter::bIsLeaning' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bLeaningLeft) == 0x000FA2, "Member 'AReadyOrNotCharacter::bLeaningLeft' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bLeaningRight) == 0x000FA3, "Member 'AReadyOrNotCharacter::bLeaningRight' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bLeaningUp) == 0x000FA4, "Member 'AReadyOrNotCharacter::bLeaningUp' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bLeaningDown) == 0x000FA5, "Member 'AReadyOrNotCharacter::bLeaningDown' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bLeanLeftToggle) == 0x000FB4, "Member 'AReadyOrNotCharacter::bLeanLeftToggle' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bLeanRightToggle) == 0x000FB5, "Member 'AReadyOrNotCharacter::bLeanRightToggle' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, LeanAudioComponent) == 0x000FB8, "Member 'AReadyOrNotCharacter::LeanAudioComponent' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, LeanAudioEvent) == 0x000FC0, "Member 'AReadyOrNotCharacter::LeanAudioEvent' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, LeanMovementValue) == 0x000FC8, "Member 'AReadyOrNotCharacter::LeanMovementValue' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, LeanPos_CurrentFrame) == 0x000FD0, "Member 'AReadyOrNotCharacter::LeanPos_CurrentFrame' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, LeanPos_LastFrame) == 0x000FE8, "Member 'AReadyOrNotCharacter::LeanPos_LastFrame' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, SquadPosition) == 0x001000, "Member 'AReadyOrNotCharacter::SquadPosition' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, DefaultTeam) == 0x001001, "Member 'AReadyOrNotCharacter::DefaultTeam' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, FPMeleeImpactFMODEvent) == 0x001008, "Member 'AReadyOrNotCharacter::FPMeleeImpactFMODEvent' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, TPMeleeImpactFMODEvent) == 0x001010, "Member 'AReadyOrNotCharacter::TPMeleeImpactFMODEvent' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, MeleeImpactParticle) == 0x001018, "Member 'AReadyOrNotCharacter::MeleeImpactParticle' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, MeleeCameraShake) == 0x001020, "Member 'AReadyOrNotCharacter::MeleeCameraShake' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, MeleeRange) == 0x001028, "Member 'AReadyOrNotCharacter::MeleeRange' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, MeleeDamage) == 0x00102C, "Member 'AReadyOrNotCharacter::MeleeDamage' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, MeleeDamageType) == 0x001030, "Member 'AReadyOrNotCharacter::MeleeDamageType' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnPlayerArrested) == 0x001058, "Member 'AReadyOrNotCharacter::OnPlayerArrested' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnPlayerArrestStart) == 0x001068, "Member 'AReadyOrNotCharacter::OnPlayerArrestStart' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnPlayerArrestedCanceled) == 0x001078, "Member 'AReadyOrNotCharacter::OnPlayerArrestedCanceled' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, PendingAutoReport) == 0x001088, "Member 'AReadyOrNotCharacter::PendingAutoReport' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnArrested) == 0x001090, "Member 'AReadyOrNotCharacter::OnArrested' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, Rep_CarryArrestedAnimState) == 0x0010A0, "Member 'AReadyOrNotCharacter::Rep_CarryArrestedAnimState' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bPreArrested) == 0x0010A8, "Member 'AReadyOrNotCharacter::bPreArrested' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, PreArrestCuffsActor) == 0x0010B0, "Member 'AReadyOrNotCharacter::PreArrestCuffsActor' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bSurrendered) == 0x0010B8, "Member 'AReadyOrNotCharacter::bSurrendered' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bSurrenderComplete) == 0x0010B9, "Member 'AReadyOrNotCharacter::bSurrenderComplete' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, PlacedZipcuffs) == 0x0010D8, "Member 'AReadyOrNotCharacter::PlacedZipcuffs' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, SpawnedZipcuffsClass) == 0x0010E0, "Member 'AReadyOrNotCharacter::SpawnedZipcuffsClass' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, SpawnedFPZipcuffsClass) == 0x0010E8, "Member 'AReadyOrNotCharacter::SpawnedFPZipcuffsClass' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, ZipcuffBone) == 0x0010F0, "Member 'AReadyOrNotCharacter::ZipcuffBone' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bIsBeingCarried) == 0x0010F8, "Member 'AReadyOrNotCharacter::bIsBeingCarried' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bCarryingDead) == 0x0010F9, "Member 'AReadyOrNotCharacter::bCarryingDead' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, CarriedByCharacter) == 0x001100, "Member 'AReadyOrNotCharacter::CarriedByCharacter' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, ThrownByCharacter) == 0x001108, "Member 'AReadyOrNotCharacter::ThrownByCharacter' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, PendingCarryCharacter) == 0x001110, "Member 'AReadyOrNotCharacter::PendingCarryCharacter' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, CurrentCarryCharacter) == 0x001118, "Member 'AReadyOrNotCharacter::CurrentCarryCharacter' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, FakeCarryCharacterMesh) == 0x001120, "Member 'AReadyOrNotCharacter::FakeCarryCharacterMesh' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, CurrentCarryConfirmTime) == 0x001128, "Member 'AReadyOrNotCharacter::CurrentCarryConfirmTime' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, CarryMasterIdleLoop) == 0x001130, "Member 'AReadyOrNotCharacter::CarryMasterIdleLoop' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, CarrySlaveIdleLoop) == 0x001138, "Member 'AReadyOrNotCharacter::CarrySlaveIdleLoop' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, MaxCarryConfirmTime) == 0x001140, "Member 'AReadyOrNotCharacter::MaxCarryConfirmTime' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, MaxRagdollArrestConfirmTime) == 0x001144, "Member 'AReadyOrNotCharacter::MaxRagdollArrestConfirmTime' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, CurrentRagdollArrestConfirmTime) == 0x001148, "Member 'AReadyOrNotCharacter::CurrentRagdollArrestConfirmTime' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, PendingRagdollArrestCharacter) == 0x001150, "Member 'AReadyOrNotCharacter::PendingRagdollArrestCharacter' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, CurrentRagdollArrestCharacter) == 0x001158, "Member 'AReadyOrNotCharacter::CurrentRagdollArrestCharacter' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, LastCharacterMakingArrest) == 0x001160, "Member 'AReadyOrNotCharacter::LastCharacterMakingArrest' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, CurrentlyArresting) == 0x001168, "Member 'AReadyOrNotCharacter::CurrentlyArresting' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bIsBeingArrested) == 0x001170, "Member 'AReadyOrNotCharacter::bIsBeingArrested' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bArrestComplete) == 0x001171, "Member 'AReadyOrNotCharacter::bArrestComplete' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bArrestedAsRagdoll) == 0x001172, "Member 'AReadyOrNotCharacter::bArrestedAsRagdoll' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bArrestedAsRagdoll_Flipped) == 0x001173, "Member 'AReadyOrNotCharacter::bArrestedAsRagdoll_Flipped' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bIsPairedInteractionPlaying) == 0x001174, "Member 'AReadyOrNotCharacter::bIsPairedInteractionPlaying' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bNoTeamDamage) == 0x001175, "Member 'AReadyOrNotCharacter::bNoTeamDamage' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bDisableInteraction) == 0x001176, "Member 'AReadyOrNotCharacter::bDisableInteraction' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bPrimed) == 0x001177, "Member 'AReadyOrNotCharacter::bPrimed' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bOverarmThrow) == 0x001178, "Member 'AReadyOrNotCharacter::bOverarmThrow' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnQuickThrowStart) == 0x001180, "Member 'AReadyOrNotCharacter::OnQuickThrowStart' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnQuickThrowEnd) == 0x001190, "Member 'AReadyOrNotCharacter::OnQuickThrowEnd' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnCarryingChanged) == 0x0011A0, "Member 'AReadyOrNotCharacter::OnCarryingChanged' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bIsStrafing) == 0x0011B1, "Member 'AReadyOrNotCharacter::bIsStrafing' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, PlayedTableMontageMap3P) == 0x0011B8, "Member 'AReadyOrNotCharacter::PlayedTableMontageMap3P' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, LastTableMontagePlayed) == 0x001208, "Member 'AReadyOrNotCharacter::LastTableMontagePlayed' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, CharacterLookOverride) == 0x001290, "Member 'AReadyOrNotCharacter::CharacterLookOverride' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, Rep_CharacterLookOverride) == 0x001360, "Member 'AReadyOrNotCharacter::Rep_CharacterLookOverride' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, ArmorOverrideMapTP) == 0x001370, "Member 'AReadyOrNotCharacter::ArmorOverrideMapTP' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, Rep_BodyMesh) == 0x0013C0, "Member 'AReadyOrNotCharacter::Rep_BodyMesh' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, Rep_FaceMesh) == 0x0013C8, "Member 'AReadyOrNotCharacter::Rep_FaceMesh' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, Rep_FPMesh) == 0x0013D0, "Member 'AReadyOrNotCharacter::Rep_FPMesh' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, AnimMontageCooldown) == 0x0013D8, "Member 'AReadyOrNotCharacter::AnimMontageCooldown' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, CurrentFaceROM) == 0x001428, "Member 'AReadyOrNotCharacter::CurrentFaceROM' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, AnimationBlockingTime) == 0x001430, "Member 'AReadyOrNotCharacter::AnimationBlockingTime' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, TOCManager) == 0x001458, "Member 'AReadyOrNotCharacter::TOCManager' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, ReportToTOC_PVP_CameraShake) == 0x001460, "Member 'AReadyOrNotCharacter::ReportToTOC_PVP_CameraShake' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, TOCLine) == 0x001468, "Member 'AReadyOrNotCharacter::TOCLine' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, SpeechCharacterName) == 0x001478, "Member 'AReadyOrNotCharacter::SpeechCharacterName' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bHasBeenReported) == 0x001490, "Member 'AReadyOrNotCharacter::bHasBeenReported' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, SpeakCooldown) == 0x001494, "Member 'AReadyOrNotCharacter::SpeakCooldown' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, ReportPlayerDeadFMODEvent) == 0x001498, "Member 'AReadyOrNotCharacter::ReportPlayerDeadFMODEvent' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, ReportPlayerArrestedFMODEvent) == 0x0014A0, "Member 'AReadyOrNotCharacter::ReportPlayerArrestedFMODEvent' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, ReportPlayerGeneralFMODEvent) == 0x0014A8, "Member 'AReadyOrNotCharacter::ReportPlayerGeneralFMODEvent' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnVoiceAudioStoppedDelegate) == 0x0014B0, "Member 'AReadyOrNotCharacter::OnVoiceAudioStoppedDelegate' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, SpeechCooldownMap) == 0x0014D8, "Member 'AReadyOrNotCharacter::SpeechCooldownMap' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, FMODVoiceLine2D) == 0x001528, "Member 'AReadyOrNotCharacter::FMODVoiceLine2D' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, FMODVoiceLineSpatalized) == 0x001530, "Member 'AReadyOrNotCharacter::FMODVoiceLineSpatalized' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, BoneSuppressionAmount) == 0x001540, "Member 'AReadyOrNotCharacter::BoneSuppressionAmount' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnBodyPartDamaged) == 0x001590, "Member 'AReadyOrNotCharacter::OnBodyPartDamaged' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, DismembermentDamageMap) == 0x0015C0, "Member 'AReadyOrNotCharacter::DismembermentDamageMap' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, DamageExcludedBones) == 0x001610, "Member 'AReadyOrNotCharacter::DamageExcludedBones' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, GasDamageAccumulated) == 0x001630, "Member 'AReadyOrNotCharacter::GasDamageAccumulated' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, GasDamageDecay) == 0x001634, "Member 'AReadyOrNotCharacter::GasDamageDecay' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bNoTarget) == 0x001641, "Member 'AReadyOrNotCharacter::bNoTarget' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, ArmorImpactEffect) == 0x001648, "Member 'AReadyOrNotCharacter::ArmorImpactEffect' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, Blood) == 0x001650, "Member 'AReadyOrNotCharacter::Blood' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, DamagedByWeapons) == 0x001658, "Member 'AReadyOrNotCharacter::DamagedByWeapons' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bRepStunned) == 0x001670, "Member 'AReadyOrNotCharacter::bRepStunned' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, RepStunnedWith) == 0x001671, "Member 'AReadyOrNotCharacter::RepStunnedWith' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, AITrackingMe) == 0x0016E0, "Member 'AReadyOrNotCharacter::AITrackingMe' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, DamagedByCharacters) == 0x0016F0, "Member 'AReadyOrNotCharacter::DamagedByCharacters' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OriginalSpawnLocation) == 0x001700, "Member 'AReadyOrNotCharacter::OriginalSpawnLocation' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnEvidenceCollected) == 0x001718, "Member 'AReadyOrNotCharacter::OnEvidenceCollected' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, PendingEvidence) == 0x001730, "Member 'AReadyOrNotCharacter::PendingEvidence' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bIsCollectingEvidence) == 0x001738, "Member 'AReadyOrNotCharacter::bIsCollectingEvidence' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bCollectionAnimHasTriggered) == 0x001739, "Member 'AReadyOrNotCharacter::bCollectionAnimHasTriggered' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, CollectingLoopAnim1P) == 0x001740, "Member 'AReadyOrNotCharacter::CollectingLoopAnim1P' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, CollectingLoopAnim3P) == 0x001748, "Member 'AReadyOrNotCharacter::CollectingLoopAnim3P' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, Reward) == 0x001750, "Member 'AReadyOrNotCharacter::Reward' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, CurrentEmotion) == 0x001758, "Member 'AReadyOrNotCharacter::CurrentEmotion' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, FacialAnimationOverrideTime) == 0x00175C, "Member 'AReadyOrNotCharacter::FacialAnimationOverrideTime' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, FacialAnimationBlend) == 0x001760, "Member 'AReadyOrNotCharacter::FacialAnimationBlend' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, FacialAnimationBlendTarget) == 0x001764, "Member 'AReadyOrNotCharacter::FacialAnimationBlendTarget' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, FacialAnimationBlendDecay) == 0x001768, "Member 'AReadyOrNotCharacter::FacialAnimationBlendDecay' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, FacialAnimationPriority) == 0x00176C, "Member 'AReadyOrNotCharacter::FacialAnimationPriority' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bAiming) == 0x001770, "Member 'AReadyOrNotCharacter::bAiming' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bMovementLocked) == 0x001771, "Member 'AReadyOrNotCharacter::bMovementLocked' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bAimLocked) == 0x001772, "Member 'AReadyOrNotCharacter::bAimLocked' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bActionsLocked) == 0x001773, "Member 'AReadyOrNotCharacter::bActionsLocked' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bItemSelectionLocked) == 0x001774, "Member 'AReadyOrNotCharacter::bItemSelectionLocked' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bCommandMenuLocked) == 0x001775, "Member 'AReadyOrNotCharacter::bCommandMenuLocked' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bGamepadCommandWheelLocked) == 0x001776, "Member 'AReadyOrNotCharacter::bGamepadCommandWheelLocked' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bCommandMenuHidden) == 0x001777, "Member 'AReadyOrNotCharacter::bCommandMenuHidden' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bItemMenuLocked) == 0x001778, "Member 'AReadyOrNotCharacter::bItemMenuLocked' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bWeaponAttachmentsLocked) == 0x001779, "Member 'AReadyOrNotCharacter::bWeaponAttachmentsLocked' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bCantedSightLocked) == 0x00177A, "Member 'AReadyOrNotCharacter::bCantedSightLocked' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bTabletLocked) == 0x00177B, "Member 'AReadyOrNotCharacter::bTabletLocked' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bConsoleHotkeysHidden) == 0x00177C, "Member 'AReadyOrNotCharacter::bConsoleHotkeysHidden' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bConsoleHotkeysItemWheelHidden) == 0x00177D, "Member 'AReadyOrNotCharacter::bConsoleHotkeysItemWheelHidden' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bOptiwandLocked) == 0x00177E, "Member 'AReadyOrNotCharacter::bOptiwandLocked' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bChemlightLocked) == 0x00177F, "Member 'AReadyOrNotCharacter::bChemlightLocked' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bGamepadTeamCameraLocked) == 0x001780, "Member 'AReadyOrNotCharacter::bGamepadTeamCameraLocked' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, QueuedDoorToOpen) == 0x001788, "Member 'AReadyOrNotCharacter::QueuedDoorToOpen' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, QueuedDoorToClose) == 0x001790, "Member 'AReadyOrNotCharacter::QueuedDoorToClose' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, LastKickedDoor) == 0x001798, "Member 'AReadyOrNotCharacter::LastKickedDoor' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, DoorKickInteractionFront) == 0x0017A0, "Member 'AReadyOrNotCharacter::DoorKickInteractionFront' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, DoorKickInteractionBack) == 0x0017A8, "Member 'AReadyOrNotCharacter::DoorKickInteractionBack' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, DoorKickFailureInteractionFront) == 0x0017B0, "Member 'AReadyOrNotCharacter::DoorKickFailureInteractionFront' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, DoorKickFailureInteractionBack) == 0x0017B8, "Member 'AReadyOrNotCharacter::DoorKickFailureInteractionBack' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, DoorKickBreakInteractionFront) == 0x0017C0, "Member 'AReadyOrNotCharacter::DoorKickBreakInteractionFront' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, DoorKickBreakInteractionBack) == 0x0017C8, "Member 'AReadyOrNotCharacter::DoorKickBreakInteractionBack' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, CarryArrestedInteractionData) == 0x0017D0, "Member 'AReadyOrNotCharacter::CarryArrestedInteractionData' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, DropArrestedInteractionData) == 0x0017D8, "Member 'AReadyOrNotCharacter::DropArrestedInteractionData' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, ThrowArrestedInteractionData) == 0x0017E0, "Member 'AReadyOrNotCharacter::ThrowArrestedInteractionData' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, Event_OnItemPrimaryUse) == 0x0017E8, "Member 'AReadyOrNotCharacter::Event_OnItemPrimaryUse' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bNVGOn) == 0x0017F8, "Member 'AReadyOrNotCharacter::bNVGOn' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, OnNightVisionGogglesToggled) == 0x001800, "Member 'AReadyOrNotCharacter::OnNightVisionGogglesToggled' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bShouldPlayFootstepFoley) == 0x001838, "Member 'AReadyOrNotCharacter::bShouldPlayFootstepFoley' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bPlayEveryStep) == 0x001839, "Member 'AReadyOrNotCharacter::bPlayEveryStep' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, FootstepImpactEffectFast) == 0x001840, "Member 'AReadyOrNotCharacter::FootstepImpactEffectFast' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, FootstepImpactEffectSlow) == 0x001848, "Member 'AReadyOrNotCharacter::FootstepImpactEffectSlow' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, CurrentFootstepFoleyEvent) == 0x001850, "Member 'AReadyOrNotCharacter::CurrentFootstepFoleyEvent' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, CurrentFootstepFoleyEventRemote) == 0x001858, "Member 'AReadyOrNotCharacter::CurrentFootstepFoleyEventRemote' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, FootstepsLocal) == 0x001860, "Member 'AReadyOrNotCharacter::FootstepsLocal' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, FootstepsRemote) == 0x001868, "Member 'AReadyOrNotCharacter::FootstepsRemote' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, MovementFoley) == 0x001870, "Member 'AReadyOrNotCharacter::MovementFoley' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, MovementFoleySocket) == 0x001878, "Member 'AReadyOrNotCharacter::MovementFoleySocket' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, DefaultRagdollPhysAsset) == 0x001880, "Member 'AReadyOrNotCharacter::DefaultRagdollPhysAsset' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, DefaultAlivePhysAsset) == 0x001888, "Member 'AReadyOrNotCharacter::DefaultAlivePhysAsset' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, CuffedRagdollPhysAsset) == 0x001890, "Member 'AReadyOrNotCharacter::CuffedRagdollPhysAsset' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, Rep_ActiveRagdollPhysAsset) == 0x001898, "Member 'AReadyOrNotCharacter::Rep_ActiveRagdollPhysAsset' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bIsRelevant) == 0x0018A0, "Member 'AReadyOrNotCharacter::bIsRelevant' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, NeutralizeSuspectTag) == 0x0018A8, "Member 'AReadyOrNotCharacter::NeutralizeSuspectTag' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, TorsoDeathAnims) == 0x0018B0, "Member 'AReadyOrNotCharacter::TorsoDeathAnims' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, HeadDeathAnims) == 0x0018C0, "Member 'AReadyOrNotCharacter::HeadDeathAnims' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, LeftArmDeathAnims) == 0x0018D0, "Member 'AReadyOrNotCharacter::LeftArmDeathAnims' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, RightArmDeathAnims) == 0x0018E0, "Member 'AReadyOrNotCharacter::RightArmDeathAnims' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, LeftLegDeathAnims) == 0x0018F0, "Member 'AReadyOrNotCharacter::LeftLegDeathAnims' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, RightLegDeathAnims) == 0x001900, "Member 'AReadyOrNotCharacter::RightLegDeathAnims' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, CurrentDeathMontage) == 0x001910, "Member 'AReadyOrNotCharacter::CurrentDeathMontage' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, ReplicatedAcceleration) == 0x001919, "Member 'AReadyOrNotCharacter::ReplicatedAcceleration' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, ReplicatedMaxSpeed) == 0x00191C, "Member 'AReadyOrNotCharacter::ReplicatedMaxSpeed' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, bIsBlendRagdollNotifyActive) == 0x001920, "Member 'AReadyOrNotCharacter::bIsBlendRagdollNotifyActive' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, FootstepOcclusionMultiplier) == 0x001924, "Member 'AReadyOrNotCharacter::FootstepOcclusionMultiplier' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, FootstepFullOcclusionDepth) == 0x001928, "Member 'AReadyOrNotCharacter::FootstepFullOcclusionDepth' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, AnimNotifyAttachments) == 0x001930, "Member 'AReadyOrNotCharacter::AnimNotifyAttachments' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, Snapshots) == 0x001948, "Member 'AReadyOrNotCharacter::Snapshots' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, CurrentLipSyncAnimation) == 0x001958, "Member 'AReadyOrNotCharacter::CurrentLipSyncAnimation' has a wrong offset!");
static_assert(offsetof(AReadyOrNotCharacter, GameplayTags) == 0x001980, "Member 'AReadyOrNotCharacter::GameplayTags' has a wrong offset!");

// Class ReadyOrNot.PlayerCharacter
// 0x1420 (0x2DC0 - 0x19A0)
#pragma pack(push, 0x1)
class alignas(0x10) APlayerCharacter : public AReadyOrNotCharacter
{
public:
	TArray<class UMeshComponent*>                 CustomizationFirstPersonMeshes;                    // 0x19A0(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UMeshComponent*>                 CustomizationFirstPersonBodyMeshes;                // 0x19B0(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UMaterialInstanceDynamic*>       CustomizationActorMaterials;                       // 0x19C0(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bFirstPersonMeshesDirty;                           // 0x19D0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19D1[0x7];                                     // 0x19D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCameraComponent*                       ThirdPersonCameraComponent;                        // 0x19D8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpringArmComponent*                    ThirdPersonCameraArm;                              // 0x19E0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 Mesh1P;                                            // 0x19E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 MeshBody1P;                                        // 0x19F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCameraComponent*                       FirstPersonCameraComponent;                        // 0x19F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlayerPostProcessing*                  PlayerPostProcessingComp;                          // 0x1A00(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODAudioComponent*                    FMODBreathingAudioComp;                            // 0x1A08(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBleedComponent*                        BleedComponent;                                    // 0x1A10(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScoringComponent*                      ScoringComponent;                                  // 0x1A18(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UItemVisualizationComponent*            PrimaryItemVisualizationComponent;                 // 0x1A20(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UItemVisualizationComponent*            SecondaryItemVisualizationComponent;               // 0x1A28(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UItemVisualizationComponent*            LongTacticalVisualizationComponent;                // 0x1A30(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UItemVisualizationComponent*            HelmetVisualizationComponent;                      // 0x1A38(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UItemVisualizationComponent*            ArmorVisualizationComponent;                       // 0x1A40(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UItemVisualizationComponent*            EquippedItemVisualizationComponent;                // 0x1A48(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCommandWheelActive;                               // 0x1A50(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bItemWheelActive;                                  // 0x1A51(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A52[0x6];                                     // 0x1A52(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMesh*                          Rep_FPBodyMesh;                                    // 0x1A58(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     LastSetMesh1PDynamicMaterial;                      // 0x1A60(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UMaterialInstanceDynamic*>       DynamicWeaponFovMats;                              // 0x1A68(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A78[0x10];                                    // 0x1A78(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class USkeletalMeshComponent*>         MeshComps;                                         // 0x1A88(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A98[0x8];                                     // 0x1A98(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerState*                           LastKnownPlayerState;                              // 0x1AA0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AA8[0x8];                                     // 0x1AA8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               ReplicatedFPMesh;                                  // 0x1AB0(0x0018)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AC8[0x20];                                    // 0x1AC8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CurInputVector;                                    // 0x1AE8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerHandle                           PushOverlappingAI_Handle;                          // 0x1B00(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               Body1PMat;                                         // 0x1B08(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AReadyOrNotCharacter*                   CurrentViewCharacter;                              // 0x1B10(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class APlayerCharacter* Issuer, ESwatCommand CommandIssued)> OnDefaultCommandIssued; // 0x1B18(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AReadyOrNotCharacter* NewViewCharacter)> OnTeamViewSet;      // 0x1B28(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         CurrentTeamViewIndex;                              // 0x1B38(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B3C[0x4];                                     // 0x1B3C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerViewActor*                       PlayerViewActor;                                   // 0x1B40(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class APlayerViewActor>           PlayerViewActorClass;                              // 0x1B48(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerHandle                           TH_TeamViewInput;                                  // 0x1B50(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TeamViewInputHoldTime;                             // 0x1B58(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         surfaceType;                                       // 0x1B5C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         roomType;                                          // 0x1B60(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B64[0x4];                                     // 0x1B64(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PVPSpeakerName;                                    // 0x1B68(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSwatCommandOpen;                                // 0x1B78(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B79[0x7];                                     // 0x1B79(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USwatCommandWidget*                     SwatCommandWidget;                                 // 0x1B80(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B88[0x2];                                     // 0x1B88(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bInCommandMenu;                                    // 0x1B8A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInDevicesMenu;                                    // 0x1B8B(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInTabMenu;                                        // 0x1B8C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFadeToGray;                                       // 0x1B8D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B8E[0x1E];                                    // 0x1B8E(0x001E)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Sensitivity;                                       // 0x1BAC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvertYaw;                                        // 0x1BB0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvertPitch;                                      // 0x1BB1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1BB2[0x2];                                     // 0x1BB2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GamepadLookSensitivityVertical;                    // 0x1BB4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamepadLookSensitivityHorizontal;                  // 0x1BB8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamepadAimSensitivityVertical;                     // 0x1BBC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamepadAimSensitivityHorizontal;                   // 0x1BC0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamepadLookSensitivitySpeedUp;                     // 0x1BC4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamepadMovementInnerDeadzone;                      // 0x1BC8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamepadLookInnerDeadzone;                          // 0x1BCC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GyroVerticalLookSensitivity;                       // 0x1BD0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GyroHorizontalLookSensitivity;                     // 0x1BD4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GyroVerticalAimSensitivity;                        // 0x1BD8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GyroHorizontalAimSensitivity;                      // 0x1BDC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvertGamepadHorizontal;                          // 0x1BE0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvertGamepadVertical;                            // 0x1BE1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvertGyroHorizontal;                             // 0x1BE2(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvertGyroVertical;                               // 0x1BE3(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHoldCrouchGamepad;                                // 0x1BE4(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bToggleADSGamepad;                                 // 0x1BE5(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvertStickLayout;                                // 0x1BE6(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRadialMenuUseLeftStick;                           // 0x1BE7(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRadialMenuShoulderRelease;                        // 0x1BE8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvertButtonLayout;                               // 0x1BE9(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvertTriggersLayout;                             // 0x1BEA(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1BEB[0x5];                                     // 0x1BEB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 GyroActiveMode;                                    // 0x1BF0(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AimAssistIntensity;                                // 0x1C00(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UUserWidget>                HUD_Widget;                                        // 0x1C10(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHumanCharacterHUD_V2*                  HumanCharacterWidget_V2;                           // 0x1C18(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUserWidget*                            MagCheckUI;                                        // 0x1C20(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTeamViewWidget*                        TeamViewWidget;                                    // 0x1C28(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractableComponent*                 LastInteractableComponent;                         // 0x1C30(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABuildingTrigger*                       LastBuildingEntered;                               // 0x1C38(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABuildingTrigger*                       InsideCurrentBuilding;                             // 0x1C40(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADoor*                                  lastHighlightedDoor;                               // 0x1C48(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABaseItem*                              lastHighlightedEvidence;                           // 0x1C50(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APickupMagazineActor*                   lastHighlightedPickupMagazine;                     // 0x1C58(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExitWithFireSelect;                               // 0x1C60(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C61[0x7];                                     // 0x1C61(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerCharacter*                       PreviousPosessedCharacter;                         // 0x1C68(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AController* NewController)> OnClientPossessed;              // 0x1C70(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool bWasHeadshot, float DamageTaken, float HealthRemaining, bool bBlockedByArmour, bool bBlockedByHelmet)> OnPlayerTakenDamageDetails; // 0x1C80(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UFMODEvent*                             CriticalInjuredEvent;                              // 0x1C90(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             FlatlineEvent;                                     // 0x1C98(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             FlatlineEventPvP;                                  // 0x1CA0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             HeadshotEvent;                                     // 0x1CA8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             SAPIPlateHitEvent;                                 // 0x1CB0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bMirroring : 1;                                    // 0x1CB8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1CB9[0x7];                                     // 0x1CB9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bSpawnInventoryItemsOnPossess;                     // 0x1CC0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1CC1[0x7];                                     // 0x1CC1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               FreeLookCache;                                     // 0x1CC8(0x0018)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1CE0[0x1C];                                    // 0x1CE0(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         YellOutEffectLength;                               // 0x1CFC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YelloutEffectRadius;                               // 0x1D00(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowReadyStatus;                                  // 0x1D04(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D05[0x3];                                     // 0x1D05(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class AReadyOrNotPlayerState*                 LastPlayerState;                                   // 0x1D08(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           HitBones;                                          // 0x1D10(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TSubclassOf<class ULegacyCameraShake>         Camera_Hit_Arm_L;                                  // 0x1D20(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ULegacyCameraShake>         Camera_Hit_Arm_R;                                  // 0x1D28(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ULegacyCameraShake>         Camera_Hit_Low;                                    // 0x1D30(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ULegacyCameraShake>         Camera_Hit_Leg_L;                                  // 0x1D38(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ULegacyCameraShake>         Camera_Hit_Leg_R;                                  // 0x1D40(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ULegacyCameraShake>         Camera_Hit_Head_Front;                             // 0x1D48(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ULegacyCameraShake>         Camera_Hit_Head_Back;                              // 0x1D50(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrouchHeight;                                      // 0x1D58(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D5C[0x4];                                     // 0x1D5C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundCue*                              BodyImpactGroundSound;                             // 0x1D60(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Camera_RotationRate;                               // 0x1D68(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class APawn*                                  CurrentlyPiloting;                                 // 0x1D80(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D88[0xE8];                                    // 0x1D88(0x00E8)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerCharacter*                       RevivingPlayer;                                    // 0x1E70(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerCharacter*                       BeingRevivedByPlayer;                              // 0x1E78(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RevivingOperatingTime;                             // 0x1E80(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StunMovementSpeedMultiplier;                       // 0x1E84(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStunAimLocked;                                    // 0x1E88(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E89[0x7];                                     // 0x1E89(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ABaseItem*                              LastEquippedItemBeforeStun;                        // 0x1E90(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E98[0x4];                                     // 0x1E98(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FirstPersonShakeAmount;                            // 0x1E9C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ViewBlendMultiplier;                               // 0x1EA0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1EA4[0x4];                                     // 0x1EA4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BlendedBone;                                       // 0x1EA8(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1EB0[0x8];                                     // 0x1EB0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UAnimInstance>              Replicated_3PAnimInstance;                         // 0x1EB8(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UAnimInstance>              Replicated_1PAnimInstance;                         // 0x1EC0(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UAnimMontage*>                   MontageQueue_3P;                                   // 0x1EC8(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UAnimMontage*>                   MontageQueue_1P;                                   // 0x1ED8(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bGamepadADSActive;                                 // 0x1EE8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1EE9[0x3];                                     // 0x1EE9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HoldingUseTime;                                    // 0x1EEC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHoldingUse;                                       // 0x1EF0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLookingAtEvidenceItem;                            // 0x1EF1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLookingAtDoor;                                    // 0x1EF2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLookingAtHuman;                                   // 0x1EF3(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLookingAtTarget;                                  // 0x1EF4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUserLowReady;                                     // 0x1EF5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceLowReady;                                    // 0x1EF6(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1EF7[0x5];                                     // 0x1EF7(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LowReadyTraceDistance;                             // 0x1EFC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AEvidenceActor*                         LastCollectedEvidence;                             // 0x1F00(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<TSubclassOf<class ABaseArmour>, class USkeletalMesh*> ArmorOverrideMapFP;                   // 0x1F08(0x0050)(Edit, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F58[0x8];                                     // 0x1F58(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class AActor>>             ChemlightClasses;                                  // 0x1F60(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UBasePlayerEffect*>              PlayerEffects;                                     // 0x1F70(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class UBasePlayerEffect*                      RecoilNerfEffect;                                  // 0x1F80(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverrideHeadwearPaperdollTexture : 1;             // 0x1F88(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1F89[0x7];                                     // 0x1F89(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             HeadwearPaperdollTexture_Override;                 // 0x1F90(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             HeadwearPaperdollTexture_Crouch_Override;          // 0x1F98(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLoadout                               DefaultItems;                                      // 0x1FA0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         EquipIndex;                                        // 0x1FC0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FC4[0x4];                                     // 0x1FC4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLoadout>                       RandomLoadoutSelection;                            // 0x1FC8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TSubclassOf<class ULegacyCameraShake>         ForwardShake;                                      // 0x1FD8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ULegacyCameraShake>         RightShake;                                        // 0x1FE0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class APlayerCharacter* PlayerCharacter, EFireMode newFireMode, EFireMode LastFireMode)> OnWeaponFireModeChanged; // 0x1FE8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ABaseWeapon* Weapon)> OnWeaponFired;                         // 0x1FF8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2008[0x10];                                    // 0x2008(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ABloodPool*                             BloodPool;                                         // 0x2018(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CameraRotationRateMeshSpaceMultiplier;             // 0x2020(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MeshspaceRecoilMovementMultiplier;                 // 0x2038(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MeshSpaceMovementMultiplier1P;                     // 0x2050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2054[0x4];                                     // 0x2054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                MeshspaceRecoilMovementMinMax;                     // 0x2058(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UInteractableComponent* InteractableComp)> OnInteract;       // 0x2070(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2080[0x29];                                    // 0x2080(0x0029)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bWeaponDown3P;                                     // 0x20A9(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsWearingHeavyArmour;                             // 0x20AA(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFireLoop;                                         // 0x20AB(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20AC[0x4];                                     // 0x20AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           FullAutoLoop_Handle;                               // 0x20B0(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20B8[0x8];                                     // 0x20B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeSinceAiming;                                   // 0x20C0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20C4[0xC];                                     // 0x20C4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bServerIsBlockingAnimationPlaying;                 // 0x20D0(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20D1[0x7];                                     // 0x20D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(int32 GroupIndex, int32 CategoryIndex)> OnItemGroupSelection_Pressed; // 0x20D8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 GroupIndex, int32 CategoryIndex)> OnItemGroupSelection_Held; // 0x20E8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 GroupIndex, int32 CategoryIndex)> OnItemGroupSelection_Released; // 0x20F8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 GroupIndex, int32 CategoryIndex)> OnItemGroupSelection_ItemChanged; // 0x2108(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bItemGroupSelectionHeld;                           // 0x2118(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2119[0x7];                                     // 0x2119(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnAttachmentLightToggled;                          // 0x2120(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnToggledSight;                                    // 0x2130(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnLowReadyToggled;                                 // 0x2140(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2150[0x10];                                    // 0x2150(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnGamepadCommandsChanged;                          // 0x2160(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnMelee;                                           // 0x2170(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2180[0xC];                                     // 0x2180(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SprintFovFactor;                                   // 0x218C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SprintFovInterpTime;                               // 0x2190(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultFovInterpTime;                              // 0x2194(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2198[0x10];                                    // 0x2198(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class APlayerCharacter* PlayerCharacter)> OnWeaponSwitchAmmoType;  // 0x21A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class APlayerCharacter* PlayerCharacter)> OnChemlightThrown;       // 0x21B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_21C8[0x8];                                     // 0x21C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class APlacedC2Explosive*                     PendingC2Removal;                                  // 0x21D0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABaseGrenade*                           QuickThrowItem;                                    // 0x21D8(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21E0[0x1];                                     // 0x21E0(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bQuickThrowing;                                    // 0x21E1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21E2[0x6];                                     // 0x21E2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AimTime;                                           // 0x21E8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21EC[0x6];                                     // 0x21EC(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bReloadLoop;                                       // 0x21F2(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21F3[0xD];                                     // 0x21F3(0x000D)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class APlayerCharacter* PlayerCharacter)> OnWeaponReload;          // 0x2200(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class APlayerCharacter* PlayerCharacter)> OnWeaponTacticalReload;  // 0x2210(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2220[0x10];                                    // 0x2220(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class ABaseMagazineWeapon* MagazineWeapon)> OnWeaponMagCheck;      // 0x2230(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2240[0x4];                                     // 0x2240(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ForwardStrafeSpeedMultiplier;                      // 0x2244(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BackwardStrafeSpeedMultiplier;                     // 0x2248(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SideStrafeSpeedMultiplier;                         // 0x224C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeanSpeedMultiplier;                               // 0x2250(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedPercentLossPerLegInjury;                      // 0x2254(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedPercentLossWhenCarrying;                      // 0x2258(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCameraFreelookSetting                 FreelookSetting;                                   // 0x225C(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_226C[0x4];                                     // 0x226C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             VaultTraceForward;                                 // 0x2270(0x00E8)(IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FHitResult                             VaultTraceDownClose;                               // 0x2358(0x00E8)(IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FHitResult                             VaultTraceDownMiddle;                              // 0x2440(0x00E8)(IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FHitResult                             VaultTraceDownFar;                                 // 0x2528(0x00E8)(IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bLedgeFound;                                       // 0x2610(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVaulting;                                         // 0x2611(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2612[0x56];                                    // 0x2612(0x0056)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           LastPlayedVaultMontage;                            // 0x2668(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2670[0x8];                                     // 0x2670(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UReadyOrNotInputConfig*                 InputConfig;                                       // 0x2678(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInputMappingContext*                   DefaultMappingContext;                             // 0x2680(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInputMappingContext*                   InvertedMappingContext;                            // 0x2688(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInputMappingContext*                   DefaultTriggersMappingContext;                     // 0x2690(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInputMappingContext*                   InvertedTriggersMappingContext;                    // 0x2698(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MappingPriority;                                   // 0x26A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RunSpeed;                                          // 0x26A4(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAcceleration;                                   // 0x26A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedModifier_AimFocus;                            // 0x26AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedModifier_Aim;                                 // 0x26B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedModifier_Crouch;                              // 0x26B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedModifier_Sprint;                              // 0x26B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedModifier_SprintMax;                           // 0x26BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedModifier_SprintTime;                          // 0x26C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitSpeedMultiplier;                                // 0x26C4(0x0004)(Edit, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SlowDownSpeedMultiplier;                           // 0x26C8(0x0004)(Edit, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         WalkSpeedRampMultiplier;                           // 0x26CC(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SprintSpeedRampUpMultiplier;                       // 0x26D0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CurrentRunSpeedPercent;                            // 0x26D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26D8[0x4];                                     // 0x26D8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxRunSpeedPercent;                                // 0x26DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxCrouchRunSpeedPercent;                          // 0x26E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinWalkSpeedPercent;                               // 0x26E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26E8[0x10];                                    // 0x26E8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LastSetRunSpeed;                                   // 0x26F8(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkSpeedMultiplier;                               // 0x26FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeployableWalkSpeedMultiplier;                     // 0x2700(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHoldingFastWalk;                                  // 0x2704(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHoldingSprint;                                    // 0x2705(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2706[0xE];                                     // 0x2706(0x000E)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bDisableSprinting : 1;                             // 0x2714(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bWalking;                                          // 0x2715(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowPlacement;                                   // 0x2716(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2717[0xA9];                                    // 0x2717(0x00A9)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MeshspaceInterp;                                   // 0x27C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VelocityCameraRollMultiplier;                      // 0x27C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               PendingRecoil;                                     // 0x27C8(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_27E0[0x18];                                    // 0x27E0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RecoilSpeed;                                       // 0x27F8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27FC[0xC];                                     // 0x27FC(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           Last1PMontage;                                     // 0x2808(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, class UAnimMontage*>      PlayedTableMontageMap1P;                           // 0x2810(0x0050)(UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_2860[0x8];                                     // 0x2860(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             JumpStartSound;                                    // 0x2868(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             JumpLandSound;                                     // 0x2870(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODSnapshot*                          InMix;                                             // 0x2878(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODSnapshot*                          OutMix;                                            // 0x2880(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOutMixPlaying;                                    // 0x2888(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2889[0x7];                                     // 0x2889(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             InjuredScreamPVP;                                  // 0x2890(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2898[0x8];                                     // 0x2898(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             DeathScreamPVP;                                    // 0x28A0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODAudioComponent*                    InjuredScreamComponent;                            // 0x28A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28B0[0x4];                                     // 0x28B0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MovementRequiredPerSound;                          // 0x28B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationRequiredPerSound;                          // 0x28B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NegativeVelocityRequiredForLandingSound;           // 0x28BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28C0[0x38];                                    // 0x28C0(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMovementSound>                 WalkSounds;                                        // 0x28F8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   WalkSounds_Environmental;                          // 0x2908(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FMovementSound>                 RunSounds;                                         // 0x2930(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   RunSounds_Environmental;                           // 0x2940(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FMovementSound>                 TurningSounds;                                     // 0x2968(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FMovementSound>                 LandingSounds;                                     // 0x2978(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2988[0x10];                                    // 0x2988(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HitDirectionForward;                               // 0x2998(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitDirectionRight;                                 // 0x299C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29A0[0x10];                                    // 0x29A0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             BreathingBaseEvent;                                // 0x29B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExhaustionLevel;                                   // 0x29B8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExhaustionDissipationRate;                         // 0x29BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExhaustionIncreaseRate;                            // 0x29C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExhaustionThreshold;                               // 0x29C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FearLevel;                                         // 0x29C8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29CC[0x4];                                     // 0x29CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FearDissipationRate;                               // 0x29D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FearSuppressionScale;                              // 0x29D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FearThreshold;                                     // 0x29D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSightTweakMode;                                 // 0x29DC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29DD[0x3];                                     // 0x29DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UUserWidget>                SightTweakerWidgetTemplate;                        // 0x29E0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUserWidget*                            SightTweakerOverlay;                               // 0x29E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SightTweakerPosOffset;                             // 0x29F0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               SightTweakerRotOffset;                             // 0x2A08(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A20[0x10];                                    // 0x2A20(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpawnProtectionTime;                               // 0x2A30(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsThirdPerson;                                    // 0x2A34(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A35[0x3];                                     // 0x2A35(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               Server_BaseAimRotation;                            // 0x2A38(0x0018)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               FreeAimCache;                                      // 0x2A50(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A68[0x8];                                     // 0x2A68(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          IsPlayingInteraction;                              // 0x2A70(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A71[0x9F];                                    // 0x2A71(0x009F)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsStopping;                                       // 0x2B10(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B11[0x7];                                     // 0x2B11(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ALadderSnapZone*                        LadderPlacementZone;                               // 0x2B18(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B20[0xC];                                     // 0x2B20(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MoveForwardInput;                                  // 0x2B2C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveRightInput;                                    // 0x2B30(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B34[0x34];                                    // 0x2B34(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   LeftFootSocketName;                                // 0x2B68(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RighttFootSocketName;                              // 0x2B70(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFootConstEnum                                LeftFootEnum;                                      // 0x2B78(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFootConstEnum                                RightFootEnum;                                     // 0x2B79(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B7A[0x2];                                     // 0x2B7A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FootAdjustOffset;                                  // 0x2B7C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootInterpSpeed;                                   // 0x2B80(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootRotationInterpSpeed;                           // 0x2B84(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HipInterpSpeed;                                    // 0x2B88(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceDistance;                                     // 0x2B8C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceOffset;                                       // 0x2B90(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VelocityThreshold;                                 // 0x2B94(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedBubbleAmount;                                 // 0x2B98(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B9C[0x4];                                     // 0x2B9C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               CurrentMeshRot;                                    // 0x2BA0(0x0018)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BB8[0x2];                                     // 0x2BB8(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIgnoreRotationOverride;                           // 0x2BBA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BBB[0x25];                                    // 0x2BBB(0x0025)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CameraBobTrans;                                    // 0x2BE0(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WeaponBobTrans;                                    // 0x2BF8(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               WeaponBobRot;                                      // 0x2C10(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               CameraBobRot;                                      // 0x2C28(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsSecondarySightActive;                           // 0x2C40(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C41[0x7];                                     // 0x2C41(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(bool bUsingCantedSight)> OnCantedSightToggled;                     // 0x2C48(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bCantedSightEnabled;                               // 0x2C58(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C59[0x17];                                    // 0x2C59(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(bool bUsingSecondarySight, class ABaseMagazineWeapon* Weapon)> OnSecondarySightToggled; // 0x2C70(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bIsPelvisFPMovementBobActive;                      // 0x2C80(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C81[0x3];                                     // 0x2C81(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PelvisFPMovementDamping;                           // 0x2C84(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCopyTPMeshTransformsToFP;                         // 0x2C88(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C89[0x9F];                                    // 0x2C89(0x009F)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserWidget*                            ScoreboardWidget;                                  // 0x2D28(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D30[0x8];                                     // 0x2D30(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCommandInterface*                      CommandInterface;                                  // 0x2D38(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D40[0x10];                                    // 0x2D40(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bItemWheelPressed;                                 // 0x2D50(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D51[0x67];                                    // 0x2D51(0x0067)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AdjustScopeOffsetHorizontal(float NewOffset);
	void AdjustScopeOffsetVertical(float NewOffset);
	void ApplyPlayerEffect(class UBasePlayerEffect* InPlayerEffect, bool bResettable);
	void ApplyPlayerEffectFor(class UBasePlayerEffect* InPlayerEffect, float Seconds);
	void C2Door(class ADoor* Door);
	bool CalculateStopLocation(struct FVector* OutStopLocation, const struct FVector& CurrentLocation, const struct FVector& Velocity, const struct FVector& Acceleration, float Friction, float BrakingDeceleration, float TimeStep, int32 MaxSimulationIterations);
	bool CanQuickThrow();
	void CaptureFPCamera(float DeltaTime);
	void Client_ApplyPlayerEffect(TSubclassOf<class UBasePlayerEffect> InPlayerEffectClass, bool bResettable, bool bMulticast);
	void Client_AutoSelectNewQuickthrowItem(class ABaseGrenade* CallingGrenade);
	void Client_BulletHit(const struct FHitResult& BulletImpact);
	void Client_OnBeginRemoveC2(class APlacedC2Explosive* C2);
	void Client_OnEndRemoveC2();
	void Client_OnPlayerDamage(bool bTakenDamage, float InDamage, class AReadyOrNotCharacter* InstigatorCharacter, class AActor* DamageCauser);
	void Client_OnTakenDamageDetail(bool bWasHeadshot, bool bTorsoShot, bool bLeftArm, bool bLeftLeg, bool bRightArm, bool bRightLeg, float DamageTaken, float RemainingHealth, bool bBlockedByArmour, bool bBlockedByHelmet);
	void Client_PlayPostProcessEffect(const class FName& InPostProcessEffect, class AActor* DamageCauser);
	void Client_PossessedBy(class AController* NewController);
	void Client_ResetPlayerEffect(TSubclassOf<class UBasePlayerEffect> InPlayerEffectClass);
	void Client_SetWalkSpeed(float newWalkSpeed, float newCrouchWalkSpeed);
	void Client_StartPepperSprayed(class APepperspray* Pepperspray, const struct FVector& DamageCauserLocation);
	void Client_StartStun(EStunType StunType, class AActor* StunCauser, const struct FVector& DamageCauserLocation);
	void ClosePlayerView();
	void CreateHUDWidget();
	void CreateTeamViewWidget();
	void CycleFireMode();
	void DebugDetachAllComponentsAndSubComponents();
	void DestroyNonDevelopmentComponents();
	void DrawPermanentMarker();
	void Drone_MoveForward(float Val);
	void Drone_Right(float Val);
	void Drone_Steady();
	void Drone_Throttle(float Val);
	void Drone_Yaw(float Val);
	void EndPrimaryUse();
	void EndQuickThrow();
	void EndSecondaryUse();
	void EquipBatteringRam();
	void EquipBreachingShotgun();
	void EquipC2();
	void EquipCSGas();
	void EquipDetonator();
	void EquipDoorJam();
	void EquipFlashbang();
	class ABaseItem* EquipItemFromGroup_Index(int32 GroupIndex, int32 ItemCategoryIndex);
	class ABaseItem* EquipItemFromGroup_Name(class FName GroupName, int32 ItemCategoryIndex);
	class ABaseItem* EquipItemOfType(EItemCategory ItemCategory);
	void EquipLongTactical();
	void EquipMirrorgun();
	void EquipMultitool();
	bool EquippedWeaponHasFireModes();
	void EquipPepperspray();
	void EquipPrimaryItem();
	void EquipSecondaryItem();
	void EquipStinger();
	void EquipZipcuffs();
	void FadeToBlackDisable();
	void FadeToBlackEnable();
	void FireLaserEyes();
	void ForceFirstDraw();
	void ForceMaxLODs_Items();
	void ForceMaxLODs_Player();
	void GamepadADSPressed();
	void GamepadADSReleased();
	TArray<class APlayerCharacter*> GetAllOtherPlayerCharacters(ETeamType Team);
	class APlayerCharacter* GetClosestPlayerCharacter(ETeamType Team, float* OutClosestDistance, bool bExcludeArrested);
	EFireMode GetFiringMode();
	struct FHitResult GetHitFromCamera(float MaxDistance, const TArray<ECollisionChannel>& CollisionChannels, const struct FRotator& OffsetRotation, const struct FVector& OffsetVector, bool bDrawTrace);
	bool HasBSG();
	bool HasC2();
	bool HasLockpick();
	bool HasNVG();
	bool HasOptiwand();
	bool HasWedge();
	void HidePlayer();
	void IncrementalUse(float Val);
	void InitializeHudWidgetTrainingState();
	bool IsInLightSource(int32* VisibleLightSources, float MinimumLightLevel);
	void JamDoor(class ADoor* Door);
	void LocalArrestFeed(class APlayerCharacter* Arrester, class APlayerCharacter* Victim);
	void LocalDeathFeed(class AReadyOrNotPlayerController* PlayerController);
	void LocalFreeFeed(class APlayerCharacter* Freer, class APlayerCharacter* Victim);
	void LocalKillFeed(class APlayerCharacter* Killer, class APlayerCharacter* Victim, class ABaseItem* Weapon);
	void MagCheck();
	void Melee();
	void Multicast_HideThirdPerson();
	void Multicast_PlayArmourRelatedEffects(class ABaseArmour* Armour, class UParticleSystem* Particle, const struct FTransform& AtTransform);
	void Multicast_PlayInjuredScream();
	void Multicast_PlayPVPSpeech(const class FString& SpeechRowName, ETeamType TeamType);
	void Multicast_PlaySound(class USoundCue* Cue);
	void Multicast_ShowThirdPerson();
	void Multicast_ToggleLaserLight();
	void OnBulletImpact(float DirectionForward, float DirectionRight);
	void OnChatPressed();
	void OnFullHealth();
	void OnItemPrimaryUse(class ABaseItem* Item);
	void OnItemPrimaryUseCompleted(class ABaseItem* Item);
	void OnItemSelectionStyleChanged(EItemSelectionInterfaceType NewItemSelectionInterface);
	void OnJumpLand();
	void OnJumpStart();
	void OnKilledOrGoneUnconciousBP();
	void OnLowHealth(float CurrentHealth);
	void OnLowReadyButtonDown();
	void OnLowReadyButtonUp();
	void OnPlayerEffectExpired(TSubclassOf<class UReadyOrNotGameplayEffect> InPlayerEffectClass);
	void OnRep_BaseAimRotation();
	void OnRep_RunSpeedUpdate();
	void OnRep_StartBoneBlend();
	void OnRep_UpdateAnimInstance();
	void OnSelectDevicePressed(const struct FKey& Key);
	void OnSelectDeviceReleased(const struct FKey& Key);
	void OnSupression(float Strength);
	void OnTabletEquipped(class ABaseItem* NewEquippedItem);
	void OnTeamChatPressed();
	void OnTurn();
	void Ping();
	void PlayVaultAnimation(const struct FVector& ledge, const struct FVector& ledgeWallNormal, const struct FVector& ledgeTraceDown, float ledgeZ, ELedgeWidth ledgeWidth, ELedgeHeight ledgeHeight);
	void PrimaryUse();
	void PrintItemAttachmentListToLog();
	void Reload();
	void ReloadOrMagCheck();
	void ReloadOrMagCheck_Released();
	void RemovePendingC2();
	void ReplenishAllGrenadeAmmo();
	void ReplenishAllMagazineAmmo();
	void ResetLODs_Items();
	void ResetLODS_Player();
	void RestoreInputConfig();
	void ScreenPositionToWeaponFOV(const struct FVector2D& ScreenPosition, struct FVector* WorldPosition, struct FVector* WorldDirection);
	void SecondaryUse();
	void Server_ApplyPlayerEffect(TSubclassOf<class UBasePlayerEffect> InPlayerEffectClass, bool bResettable, bool bMulticast);
	void Server_ApplyPlayerEffectFor(TSubclassOf<class UBasePlayerEffect> InPlayerEffectClass, float Seconds, bool bMulticast);
	void Server_ArrestfeedMessage(class APlayerCharacter* Arrester, class APlayerCharacter* Victim);
	void Server_ChangeFPMesh(class USkeletalMesh* NewFPMesh);
	void Server_ChangeMesh(class USkeletalMesh* FPMesh, class USkeletalMesh* TPMesh, class USkeletalMesh* TPHeadMesh);
	void Server_EndFastWalk();
	void Server_EndPrimaryUse();
	void Server_EquipMultitool(EMultitoolFunctions MultitoolFunction);
	void Server_FastWalk();
	void Server_FinishHealing();
	void Server_FreefeedMessage(class APlayerCharacter* Freer, class APlayerCharacter* Victim);
	void Server_GiveAIMoveTo(class ACyberneticCharacter* AI, const struct FVector& Location);
	void Server_GiveAIMoveToExit(class ACyberneticCharacter* AI);
	void Server_GiveAITurnAroundOrder(class ACyberneticCharacter* AI);
	void Server_InstantSurrenderTarget();
	void Server_InstaStartArrest(class APlayerCharacter* Target);
	void Server_InstaStartFree(class APlayerCharacter* Target);
	void Server_KillfeedMessage(class APlayerCharacter* Killer, class APlayerCharacter* Victim, class ABaseItem* Weapon);
	void Server_LockAim();
	void Server_LockAllActions();
	void Server_LockMovement();
	void Server_LockMovementAndActions();
	void Server_LockMovementAndAim();
	void Server_OnReloadComplete();
	void Server_OnReviveComplete(class APlayerCharacter* PlayerCharacter);
	void Server_Ping();
	void Server_PlayPVPSpeech(const class FString& SpeechRowName, ETeamType TeamType);
	void Server_PlaySound(class USoundCue* Cue);
	void Server_PlayVaultAnimation(const struct FVector& ledge, const struct FVector& legeWallNormal, const struct FVector& ledgeTraceDown, float ledgeZ, ELedgeWidth ledgeWidth, ELedgeHeight ledgeHeight);
	void Server_PrepareForHeal();
	void Server_PrimaryUse();
	void Server_RemoveLadder(class ATelescopicLadder* Ladder);
	void Server_ResetPlayerEffect(TSubclassOf<class UBasePlayerEffect> InPlayerEffectClass, bool bMulticast);
	void Server_SecondaryUse();
	void Server_SetLowReady(bool bUp, bool bLowReady, bool bIsUserLowReady);
	void Server_SetUserLowReady(bool bShouldUserLowReady);
	void Server_SetWalkSpeed(float newWalkSpeed, float newCrouchWalkSpeed);
	void Server_SpawnEjectedMagazine(const struct FTransform& SpawnTransform, class ABaseMagazineWeapon* Weapon);
	void Server_Sprint();
	void Server_StopAIMoveTo(class ACyberneticCharacter* AI);
	void Server_TakeDamage(float Damage, const struct FDamageEvent& DamageEvent, class AController* EventInstigator, class AActor* DamageCauser);
	void Server_TeleportPlayerToLocation(const struct FVector& Location, const struct FVector& Direction);
	void Server_ToggleFastMovement();
	void Server_ToggleGodMode();
	void Server_ToggleLightByClass(ELightRadialSelection LightType);
	void Server_ToggleNoTarget();
	void Server_ToggleWalk();
	void Server_UnlockAim();
	void Server_UnlockAllActions();
	void Server_UnlockMovement();
	void Server_UnlockMovementAndActions();
	void Server_UnlockMovementAndAim();
	void Server_UpdateADS(bool bADS);
	void Server_UpdateCameraRotationRate(const struct FRotator& NewCameraRotRate);
	void Server_UpdateFreeLookCache(const struct FRotator& NewFreeLookCache);
	void Server_UpdateIsBlockingAnimationPlaying(bool bIsBlockingAnimationPlaying);
	void Server_UpdateLastSetRunSpeed(float newRunSpeed);
	void Server_Walk();
	void SetAmmo(const class FString& AmmoType);
	void SetCantedSightEnabledByTrigger(bool Enabled);
	void SetCommandInterfaceActive(bool CommandInterfaceActive);
	void SetForceLowReady(bool bShouldForceLowReady);
	void SetFreelookPitchMax(float NewPitchMaxValue);
	void SetFreelookPitchMin(float NewPitchMinValue);
	void SetFreelookYawMax(float NewYawMaxValue);
	void SetFreelookYawMin(float NewYawMinValue);
	void SetHumanCharacterWidget_V2(class UHumanCharacterHUD_V2* NewHumanCharacterWidget);
	void SetMaxRunSpeed(float newMaxSpeed);
	void SetRunSpeed(float newRunSpeed);
	void SetTabletFocused(bool bFocused);
	void SetWeaponFov(float InFieldOfView);
	void ShowPlayer();
	void StartBleeding();
	void StartChemThrow();
	void StartFreeLook();
	void StartLockPicking(class AActor* Target);
	void StartQuickThrow();
	void StartUsingMultitool(class AActor* Target);
	void StopFPMontageFromTable(const class FString& Animation, float BlendoutTime);
	void StopFreeLook();
	void StopLockPicking(class AActor* Target);
	void StopUsingMultitool(class AActor* Target);
	void TeleportPlayerToLocation(const struct FVector& Location, const struct FVector& Direction);
	void ToggleCrosshairOverlay();
	void ToggleCrouch();
	void ToggleFastMovement();
	void ToggleFreeLook();
	void ToggleFreeThirdPerson();
	void ToggleGodMode();
	void ToggleHUD();
	void ToggleLowReady();
	void ToggleNoTarget();
	void ToggleSecondarySight();
	void ToggleSightTweaker();
	void ToggleSprint();
	void ToggleThirdPerson();
	void ToggleUnderbarrelAttachment();
	void TryNextPlayerView();
	void TryNextPlayerView_Released();
	void UpdateInputMethod(ECommonInputType InputType);
	void UpdateInputModifiers();
	void UpdatePictureInPictureVisibility();
	void UpdateSettings();

	bool CanPingActor(class AActor* Actor) const;
	bool CanUseIncrementalSystem() const;
	bool EquippedWeaponHasLaserAttachment() const;
	bool EquippedWeaponHasLightAttachment() const;
	bool EquippedWeaponHasSecondarySight() const;
	struct FRotator GetAimOffsets() const;
	TArray<class AReadyOrNotCharacter*> GetAvaliablePlayersForTeamView(const bool bIncludeDeadViews) const;
	int32 GetChemlightAmmo() const;
	struct FCameraFreelookSetting GetCurrentFreelookSettings() const;
	int32 GetQuickthrowGrenadeAmmo() const;
	float GetViewPitch() const;
	bool HasChemlightsInInventory() const;
	bool HasGrenadesInInventory() const;
	bool Is1PMontagePlaying(class UAnimMontage* Montage) const;
	bool IsAny1PMontagePlaying() const;
	bool IsFireModeSelectPlaying() const;
	bool IsFreelooking() const;
	bool IsHoldingFastWalk() const;
	bool IsHoldingSprint() const;
	bool IsInCinematicAnimation() const;
	bool IsMagCheckPlaying() const;
	bool IsMoving() const;
	bool IsMovingForward() const;
	bool IsSprinting() const;
	bool IsTabletFocused() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerCharacter">();
	}
	static class APlayerCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayerCharacter>();
	}
};
#pragma pack(pop)
static_assert(alignof(APlayerCharacter) == 0x000010, "Wrong alignment on APlayerCharacter");
static_assert(sizeof(APlayerCharacter) == 0x002DC0, "Wrong size on APlayerCharacter");
static_assert(offsetof(APlayerCharacter, CustomizationFirstPersonMeshes) == 0x0019A0, "Member 'APlayerCharacter::CustomizationFirstPersonMeshes' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, CustomizationFirstPersonBodyMeshes) == 0x0019B0, "Member 'APlayerCharacter::CustomizationFirstPersonBodyMeshes' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, CustomizationActorMaterials) == 0x0019C0, "Member 'APlayerCharacter::CustomizationActorMaterials' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bFirstPersonMeshesDirty) == 0x0019D0, "Member 'APlayerCharacter::bFirstPersonMeshesDirty' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ThirdPersonCameraComponent) == 0x0019D8, "Member 'APlayerCharacter::ThirdPersonCameraComponent' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ThirdPersonCameraArm) == 0x0019E0, "Member 'APlayerCharacter::ThirdPersonCameraArm' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, Mesh1P) == 0x0019E8, "Member 'APlayerCharacter::Mesh1P' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, MeshBody1P) == 0x0019F0, "Member 'APlayerCharacter::MeshBody1P' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, FirstPersonCameraComponent) == 0x0019F8, "Member 'APlayerCharacter::FirstPersonCameraComponent' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, PlayerPostProcessingComp) == 0x001A00, "Member 'APlayerCharacter::PlayerPostProcessingComp' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, FMODBreathingAudioComp) == 0x001A08, "Member 'APlayerCharacter::FMODBreathingAudioComp' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, BleedComponent) == 0x001A10, "Member 'APlayerCharacter::BleedComponent' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ScoringComponent) == 0x001A18, "Member 'APlayerCharacter::ScoringComponent' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, PrimaryItemVisualizationComponent) == 0x001A20, "Member 'APlayerCharacter::PrimaryItemVisualizationComponent' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SecondaryItemVisualizationComponent) == 0x001A28, "Member 'APlayerCharacter::SecondaryItemVisualizationComponent' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, LongTacticalVisualizationComponent) == 0x001A30, "Member 'APlayerCharacter::LongTacticalVisualizationComponent' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, HelmetVisualizationComponent) == 0x001A38, "Member 'APlayerCharacter::HelmetVisualizationComponent' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ArmorVisualizationComponent) == 0x001A40, "Member 'APlayerCharacter::ArmorVisualizationComponent' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, EquippedItemVisualizationComponent) == 0x001A48, "Member 'APlayerCharacter::EquippedItemVisualizationComponent' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bCommandWheelActive) == 0x001A50, "Member 'APlayerCharacter::bCommandWheelActive' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bItemWheelActive) == 0x001A51, "Member 'APlayerCharacter::bItemWheelActive' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, Rep_FPBodyMesh) == 0x001A58, "Member 'APlayerCharacter::Rep_FPBodyMesh' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, LastSetMesh1PDynamicMaterial) == 0x001A60, "Member 'APlayerCharacter::LastSetMesh1PDynamicMaterial' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, DynamicWeaponFovMats) == 0x001A68, "Member 'APlayerCharacter::DynamicWeaponFovMats' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, MeshComps) == 0x001A88, "Member 'APlayerCharacter::MeshComps' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, LastKnownPlayerState) == 0x001AA0, "Member 'APlayerCharacter::LastKnownPlayerState' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ReplicatedFPMesh) == 0x001AB0, "Member 'APlayerCharacter::ReplicatedFPMesh' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, CurInputVector) == 0x001AE8, "Member 'APlayerCharacter::CurInputVector' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, PushOverlappingAI_Handle) == 0x001B00, "Member 'APlayerCharacter::PushOverlappingAI_Handle' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, Body1PMat) == 0x001B08, "Member 'APlayerCharacter::Body1PMat' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, CurrentViewCharacter) == 0x001B10, "Member 'APlayerCharacter::CurrentViewCharacter' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, OnDefaultCommandIssued) == 0x001B18, "Member 'APlayerCharacter::OnDefaultCommandIssued' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, OnTeamViewSet) == 0x001B28, "Member 'APlayerCharacter::OnTeamViewSet' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, CurrentTeamViewIndex) == 0x001B38, "Member 'APlayerCharacter::CurrentTeamViewIndex' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, PlayerViewActor) == 0x001B40, "Member 'APlayerCharacter::PlayerViewActor' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, PlayerViewActorClass) == 0x001B48, "Member 'APlayerCharacter::PlayerViewActorClass' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, TH_TeamViewInput) == 0x001B50, "Member 'APlayerCharacter::TH_TeamViewInput' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, TeamViewInputHoldTime) == 0x001B58, "Member 'APlayerCharacter::TeamViewInputHoldTime' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, surfaceType) == 0x001B5C, "Member 'APlayerCharacter::surfaceType' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, roomType) == 0x001B60, "Member 'APlayerCharacter::roomType' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, PVPSpeakerName) == 0x001B68, "Member 'APlayerCharacter::PVPSpeakerName' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bIsSwatCommandOpen) == 0x001B78, "Member 'APlayerCharacter::bIsSwatCommandOpen' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SwatCommandWidget) == 0x001B80, "Member 'APlayerCharacter::SwatCommandWidget' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bInCommandMenu) == 0x001B8A, "Member 'APlayerCharacter::bInCommandMenu' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bInDevicesMenu) == 0x001B8B, "Member 'APlayerCharacter::bInDevicesMenu' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bInTabMenu) == 0x001B8C, "Member 'APlayerCharacter::bInTabMenu' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bFadeToGray) == 0x001B8D, "Member 'APlayerCharacter::bFadeToGray' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, Sensitivity) == 0x001BAC, "Member 'APlayerCharacter::Sensitivity' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bInvertYaw) == 0x001BB0, "Member 'APlayerCharacter::bInvertYaw' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bInvertPitch) == 0x001BB1, "Member 'APlayerCharacter::bInvertPitch' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, GamepadLookSensitivityVertical) == 0x001BB4, "Member 'APlayerCharacter::GamepadLookSensitivityVertical' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, GamepadLookSensitivityHorizontal) == 0x001BB8, "Member 'APlayerCharacter::GamepadLookSensitivityHorizontal' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, GamepadAimSensitivityVertical) == 0x001BBC, "Member 'APlayerCharacter::GamepadAimSensitivityVertical' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, GamepadAimSensitivityHorizontal) == 0x001BC0, "Member 'APlayerCharacter::GamepadAimSensitivityHorizontal' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, GamepadLookSensitivitySpeedUp) == 0x001BC4, "Member 'APlayerCharacter::GamepadLookSensitivitySpeedUp' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, GamepadMovementInnerDeadzone) == 0x001BC8, "Member 'APlayerCharacter::GamepadMovementInnerDeadzone' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, GamepadLookInnerDeadzone) == 0x001BCC, "Member 'APlayerCharacter::GamepadLookInnerDeadzone' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, GyroVerticalLookSensitivity) == 0x001BD0, "Member 'APlayerCharacter::GyroVerticalLookSensitivity' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, GyroHorizontalLookSensitivity) == 0x001BD4, "Member 'APlayerCharacter::GyroHorizontalLookSensitivity' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, GyroVerticalAimSensitivity) == 0x001BD8, "Member 'APlayerCharacter::GyroVerticalAimSensitivity' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, GyroHorizontalAimSensitivity) == 0x001BDC, "Member 'APlayerCharacter::GyroHorizontalAimSensitivity' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bInvertGamepadHorizontal) == 0x001BE0, "Member 'APlayerCharacter::bInvertGamepadHorizontal' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bInvertGamepadVertical) == 0x001BE1, "Member 'APlayerCharacter::bInvertGamepadVertical' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bInvertGyroHorizontal) == 0x001BE2, "Member 'APlayerCharacter::bInvertGyroHorizontal' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bInvertGyroVertical) == 0x001BE3, "Member 'APlayerCharacter::bInvertGyroVertical' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bHoldCrouchGamepad) == 0x001BE4, "Member 'APlayerCharacter::bHoldCrouchGamepad' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bToggleADSGamepad) == 0x001BE5, "Member 'APlayerCharacter::bToggleADSGamepad' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bInvertStickLayout) == 0x001BE6, "Member 'APlayerCharacter::bInvertStickLayout' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bRadialMenuUseLeftStick) == 0x001BE7, "Member 'APlayerCharacter::bRadialMenuUseLeftStick' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bRadialMenuShoulderRelease) == 0x001BE8, "Member 'APlayerCharacter::bRadialMenuShoulderRelease' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bInvertButtonLayout) == 0x001BE9, "Member 'APlayerCharacter::bInvertButtonLayout' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bInvertTriggersLayout) == 0x001BEA, "Member 'APlayerCharacter::bInvertTriggersLayout' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, GyroActiveMode) == 0x001BF0, "Member 'APlayerCharacter::GyroActiveMode' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, AimAssistIntensity) == 0x001C00, "Member 'APlayerCharacter::AimAssistIntensity' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, HUD_Widget) == 0x001C10, "Member 'APlayerCharacter::HUD_Widget' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, HumanCharacterWidget_V2) == 0x001C18, "Member 'APlayerCharacter::HumanCharacterWidget_V2' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, MagCheckUI) == 0x001C20, "Member 'APlayerCharacter::MagCheckUI' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, TeamViewWidget) == 0x001C28, "Member 'APlayerCharacter::TeamViewWidget' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, LastInteractableComponent) == 0x001C30, "Member 'APlayerCharacter::LastInteractableComponent' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, LastBuildingEntered) == 0x001C38, "Member 'APlayerCharacter::LastBuildingEntered' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, InsideCurrentBuilding) == 0x001C40, "Member 'APlayerCharacter::InsideCurrentBuilding' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, lastHighlightedDoor) == 0x001C48, "Member 'APlayerCharacter::lastHighlightedDoor' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, lastHighlightedEvidence) == 0x001C50, "Member 'APlayerCharacter::lastHighlightedEvidence' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, lastHighlightedPickupMagazine) == 0x001C58, "Member 'APlayerCharacter::lastHighlightedPickupMagazine' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bExitWithFireSelect) == 0x001C60, "Member 'APlayerCharacter::bExitWithFireSelect' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, PreviousPosessedCharacter) == 0x001C68, "Member 'APlayerCharacter::PreviousPosessedCharacter' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, OnClientPossessed) == 0x001C70, "Member 'APlayerCharacter::OnClientPossessed' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, OnPlayerTakenDamageDetails) == 0x001C80, "Member 'APlayerCharacter::OnPlayerTakenDamageDetails' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, CriticalInjuredEvent) == 0x001C90, "Member 'APlayerCharacter::CriticalInjuredEvent' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, FlatlineEvent) == 0x001C98, "Member 'APlayerCharacter::FlatlineEvent' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, FlatlineEventPvP) == 0x001CA0, "Member 'APlayerCharacter::FlatlineEventPvP' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, HeadshotEvent) == 0x001CA8, "Member 'APlayerCharacter::HeadshotEvent' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SAPIPlateHitEvent) == 0x001CB0, "Member 'APlayerCharacter::SAPIPlateHitEvent' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bSpawnInventoryItemsOnPossess) == 0x001CC0, "Member 'APlayerCharacter::bSpawnInventoryItemsOnPossess' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, FreeLookCache) == 0x001CC8, "Member 'APlayerCharacter::FreeLookCache' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, YellOutEffectLength) == 0x001CFC, "Member 'APlayerCharacter::YellOutEffectLength' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, YelloutEffectRadius) == 0x001D00, "Member 'APlayerCharacter::YelloutEffectRadius' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bShowReadyStatus) == 0x001D04, "Member 'APlayerCharacter::bShowReadyStatus' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, LastPlayerState) == 0x001D08, "Member 'APlayerCharacter::LastPlayerState' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, HitBones) == 0x001D10, "Member 'APlayerCharacter::HitBones' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, Camera_Hit_Arm_L) == 0x001D20, "Member 'APlayerCharacter::Camera_Hit_Arm_L' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, Camera_Hit_Arm_R) == 0x001D28, "Member 'APlayerCharacter::Camera_Hit_Arm_R' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, Camera_Hit_Low) == 0x001D30, "Member 'APlayerCharacter::Camera_Hit_Low' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, Camera_Hit_Leg_L) == 0x001D38, "Member 'APlayerCharacter::Camera_Hit_Leg_L' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, Camera_Hit_Leg_R) == 0x001D40, "Member 'APlayerCharacter::Camera_Hit_Leg_R' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, Camera_Hit_Head_Front) == 0x001D48, "Member 'APlayerCharacter::Camera_Hit_Head_Front' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, Camera_Hit_Head_Back) == 0x001D50, "Member 'APlayerCharacter::Camera_Hit_Head_Back' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, CrouchHeight) == 0x001D58, "Member 'APlayerCharacter::CrouchHeight' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, BodyImpactGroundSound) == 0x001D60, "Member 'APlayerCharacter::BodyImpactGroundSound' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, Camera_RotationRate) == 0x001D68, "Member 'APlayerCharacter::Camera_RotationRate' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, CurrentlyPiloting) == 0x001D80, "Member 'APlayerCharacter::CurrentlyPiloting' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, RevivingPlayer) == 0x001E70, "Member 'APlayerCharacter::RevivingPlayer' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, BeingRevivedByPlayer) == 0x001E78, "Member 'APlayerCharacter::BeingRevivedByPlayer' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, RevivingOperatingTime) == 0x001E80, "Member 'APlayerCharacter::RevivingOperatingTime' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, StunMovementSpeedMultiplier) == 0x001E84, "Member 'APlayerCharacter::StunMovementSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bStunAimLocked) == 0x001E88, "Member 'APlayerCharacter::bStunAimLocked' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, LastEquippedItemBeforeStun) == 0x001E90, "Member 'APlayerCharacter::LastEquippedItemBeforeStun' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, FirstPersonShakeAmount) == 0x001E9C, "Member 'APlayerCharacter::FirstPersonShakeAmount' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ViewBlendMultiplier) == 0x001EA0, "Member 'APlayerCharacter::ViewBlendMultiplier' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, BlendedBone) == 0x001EA8, "Member 'APlayerCharacter::BlendedBone' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, Replicated_3PAnimInstance) == 0x001EB8, "Member 'APlayerCharacter::Replicated_3PAnimInstance' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, Replicated_1PAnimInstance) == 0x001EC0, "Member 'APlayerCharacter::Replicated_1PAnimInstance' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, MontageQueue_3P) == 0x001EC8, "Member 'APlayerCharacter::MontageQueue_3P' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, MontageQueue_1P) == 0x001ED8, "Member 'APlayerCharacter::MontageQueue_1P' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bGamepadADSActive) == 0x001EE8, "Member 'APlayerCharacter::bGamepadADSActive' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, HoldingUseTime) == 0x001EEC, "Member 'APlayerCharacter::HoldingUseTime' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bHoldingUse) == 0x001EF0, "Member 'APlayerCharacter::bHoldingUse' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bLookingAtEvidenceItem) == 0x001EF1, "Member 'APlayerCharacter::bLookingAtEvidenceItem' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bLookingAtDoor) == 0x001EF2, "Member 'APlayerCharacter::bLookingAtDoor' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bLookingAtHuman) == 0x001EF3, "Member 'APlayerCharacter::bLookingAtHuman' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bLookingAtTarget) == 0x001EF4, "Member 'APlayerCharacter::bLookingAtTarget' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bUserLowReady) == 0x001EF5, "Member 'APlayerCharacter::bUserLowReady' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bForceLowReady) == 0x001EF6, "Member 'APlayerCharacter::bForceLowReady' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, LowReadyTraceDistance) == 0x001EFC, "Member 'APlayerCharacter::LowReadyTraceDistance' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, LastCollectedEvidence) == 0x001F00, "Member 'APlayerCharacter::LastCollectedEvidence' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ArmorOverrideMapFP) == 0x001F08, "Member 'APlayerCharacter::ArmorOverrideMapFP' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ChemlightClasses) == 0x001F60, "Member 'APlayerCharacter::ChemlightClasses' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, PlayerEffects) == 0x001F70, "Member 'APlayerCharacter::PlayerEffects' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, RecoilNerfEffect) == 0x001F80, "Member 'APlayerCharacter::RecoilNerfEffect' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, HeadwearPaperdollTexture_Override) == 0x001F90, "Member 'APlayerCharacter::HeadwearPaperdollTexture_Override' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, HeadwearPaperdollTexture_Crouch_Override) == 0x001F98, "Member 'APlayerCharacter::HeadwearPaperdollTexture_Crouch_Override' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, DefaultItems) == 0x001FA0, "Member 'APlayerCharacter::DefaultItems' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, EquipIndex) == 0x001FC0, "Member 'APlayerCharacter::EquipIndex' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, RandomLoadoutSelection) == 0x001FC8, "Member 'APlayerCharacter::RandomLoadoutSelection' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ForwardShake) == 0x001FD8, "Member 'APlayerCharacter::ForwardShake' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, RightShake) == 0x001FE0, "Member 'APlayerCharacter::RightShake' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, OnWeaponFireModeChanged) == 0x001FE8, "Member 'APlayerCharacter::OnWeaponFireModeChanged' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, OnWeaponFired) == 0x001FF8, "Member 'APlayerCharacter::OnWeaponFired' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, BloodPool) == 0x002018, "Member 'APlayerCharacter::BloodPool' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, CameraRotationRateMeshSpaceMultiplier) == 0x002020, "Member 'APlayerCharacter::CameraRotationRateMeshSpaceMultiplier' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, MeshspaceRecoilMovementMultiplier) == 0x002038, "Member 'APlayerCharacter::MeshspaceRecoilMovementMultiplier' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, MeshSpaceMovementMultiplier1P) == 0x002050, "Member 'APlayerCharacter::MeshSpaceMovementMultiplier1P' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, MeshspaceRecoilMovementMinMax) == 0x002058, "Member 'APlayerCharacter::MeshspaceRecoilMovementMinMax' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, OnInteract) == 0x002070, "Member 'APlayerCharacter::OnInteract' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bWeaponDown3P) == 0x0020A9, "Member 'APlayerCharacter::bWeaponDown3P' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bIsWearingHeavyArmour) == 0x0020AA, "Member 'APlayerCharacter::bIsWearingHeavyArmour' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bFireLoop) == 0x0020AB, "Member 'APlayerCharacter::bFireLoop' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, FullAutoLoop_Handle) == 0x0020B0, "Member 'APlayerCharacter::FullAutoLoop_Handle' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, TimeSinceAiming) == 0x0020C0, "Member 'APlayerCharacter::TimeSinceAiming' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bServerIsBlockingAnimationPlaying) == 0x0020D0, "Member 'APlayerCharacter::bServerIsBlockingAnimationPlaying' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, OnItemGroupSelection_Pressed) == 0x0020D8, "Member 'APlayerCharacter::OnItemGroupSelection_Pressed' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, OnItemGroupSelection_Held) == 0x0020E8, "Member 'APlayerCharacter::OnItemGroupSelection_Held' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, OnItemGroupSelection_Released) == 0x0020F8, "Member 'APlayerCharacter::OnItemGroupSelection_Released' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, OnItemGroupSelection_ItemChanged) == 0x002108, "Member 'APlayerCharacter::OnItemGroupSelection_ItemChanged' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bItemGroupSelectionHeld) == 0x002118, "Member 'APlayerCharacter::bItemGroupSelectionHeld' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, OnAttachmentLightToggled) == 0x002120, "Member 'APlayerCharacter::OnAttachmentLightToggled' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, OnToggledSight) == 0x002130, "Member 'APlayerCharacter::OnToggledSight' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, OnLowReadyToggled) == 0x002140, "Member 'APlayerCharacter::OnLowReadyToggled' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, OnGamepadCommandsChanged) == 0x002160, "Member 'APlayerCharacter::OnGamepadCommandsChanged' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, OnMelee) == 0x002170, "Member 'APlayerCharacter::OnMelee' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SprintFovFactor) == 0x00218C, "Member 'APlayerCharacter::SprintFovFactor' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SprintFovInterpTime) == 0x002190, "Member 'APlayerCharacter::SprintFovInterpTime' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, DefaultFovInterpTime) == 0x002194, "Member 'APlayerCharacter::DefaultFovInterpTime' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, OnWeaponSwitchAmmoType) == 0x0021A8, "Member 'APlayerCharacter::OnWeaponSwitchAmmoType' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, OnChemlightThrown) == 0x0021B8, "Member 'APlayerCharacter::OnChemlightThrown' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, PendingC2Removal) == 0x0021D0, "Member 'APlayerCharacter::PendingC2Removal' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, QuickThrowItem) == 0x0021D8, "Member 'APlayerCharacter::QuickThrowItem' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bQuickThrowing) == 0x0021E1, "Member 'APlayerCharacter::bQuickThrowing' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, AimTime) == 0x0021E8, "Member 'APlayerCharacter::AimTime' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bReloadLoop) == 0x0021F2, "Member 'APlayerCharacter::bReloadLoop' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, OnWeaponReload) == 0x002200, "Member 'APlayerCharacter::OnWeaponReload' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, OnWeaponTacticalReload) == 0x002210, "Member 'APlayerCharacter::OnWeaponTacticalReload' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, OnWeaponMagCheck) == 0x002230, "Member 'APlayerCharacter::OnWeaponMagCheck' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ForwardStrafeSpeedMultiplier) == 0x002244, "Member 'APlayerCharacter::ForwardStrafeSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, BackwardStrafeSpeedMultiplier) == 0x002248, "Member 'APlayerCharacter::BackwardStrafeSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SideStrafeSpeedMultiplier) == 0x00224C, "Member 'APlayerCharacter::SideStrafeSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, LeanSpeedMultiplier) == 0x002250, "Member 'APlayerCharacter::LeanSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SpeedPercentLossPerLegInjury) == 0x002254, "Member 'APlayerCharacter::SpeedPercentLossPerLegInjury' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SpeedPercentLossWhenCarrying) == 0x002258, "Member 'APlayerCharacter::SpeedPercentLossWhenCarrying' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, FreelookSetting) == 0x00225C, "Member 'APlayerCharacter::FreelookSetting' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, VaultTraceForward) == 0x002270, "Member 'APlayerCharacter::VaultTraceForward' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, VaultTraceDownClose) == 0x002358, "Member 'APlayerCharacter::VaultTraceDownClose' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, VaultTraceDownMiddle) == 0x002440, "Member 'APlayerCharacter::VaultTraceDownMiddle' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, VaultTraceDownFar) == 0x002528, "Member 'APlayerCharacter::VaultTraceDownFar' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bLedgeFound) == 0x002610, "Member 'APlayerCharacter::bLedgeFound' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bVaulting) == 0x002611, "Member 'APlayerCharacter::bVaulting' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, LastPlayedVaultMontage) == 0x002668, "Member 'APlayerCharacter::LastPlayedVaultMontage' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, InputConfig) == 0x002678, "Member 'APlayerCharacter::InputConfig' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, DefaultMappingContext) == 0x002680, "Member 'APlayerCharacter::DefaultMappingContext' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, InvertedMappingContext) == 0x002688, "Member 'APlayerCharacter::InvertedMappingContext' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, DefaultTriggersMappingContext) == 0x002690, "Member 'APlayerCharacter::DefaultTriggersMappingContext' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, InvertedTriggersMappingContext) == 0x002698, "Member 'APlayerCharacter::InvertedTriggersMappingContext' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, MappingPriority) == 0x0026A0, "Member 'APlayerCharacter::MappingPriority' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, RunSpeed) == 0x0026A4, "Member 'APlayerCharacter::RunSpeed' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, MaxAcceleration) == 0x0026A8, "Member 'APlayerCharacter::MaxAcceleration' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SpeedModifier_AimFocus) == 0x0026AC, "Member 'APlayerCharacter::SpeedModifier_AimFocus' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SpeedModifier_Aim) == 0x0026B0, "Member 'APlayerCharacter::SpeedModifier_Aim' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SpeedModifier_Crouch) == 0x0026B4, "Member 'APlayerCharacter::SpeedModifier_Crouch' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SpeedModifier_Sprint) == 0x0026B8, "Member 'APlayerCharacter::SpeedModifier_Sprint' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SpeedModifier_SprintMax) == 0x0026BC, "Member 'APlayerCharacter::SpeedModifier_SprintMax' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SpeedModifier_SprintTime) == 0x0026C0, "Member 'APlayerCharacter::SpeedModifier_SprintTime' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, HitSpeedMultiplier) == 0x0026C4, "Member 'APlayerCharacter::HitSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SlowDownSpeedMultiplier) == 0x0026C8, "Member 'APlayerCharacter::SlowDownSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, WalkSpeedRampMultiplier) == 0x0026CC, "Member 'APlayerCharacter::WalkSpeedRampMultiplier' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SprintSpeedRampUpMultiplier) == 0x0026D0, "Member 'APlayerCharacter::SprintSpeedRampUpMultiplier' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, CurrentRunSpeedPercent) == 0x0026D4, "Member 'APlayerCharacter::CurrentRunSpeedPercent' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, MaxRunSpeedPercent) == 0x0026DC, "Member 'APlayerCharacter::MaxRunSpeedPercent' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, MaxCrouchRunSpeedPercent) == 0x0026E0, "Member 'APlayerCharacter::MaxCrouchRunSpeedPercent' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, MinWalkSpeedPercent) == 0x0026E4, "Member 'APlayerCharacter::MinWalkSpeedPercent' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, LastSetRunSpeed) == 0x0026F8, "Member 'APlayerCharacter::LastSetRunSpeed' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, WalkSpeedMultiplier) == 0x0026FC, "Member 'APlayerCharacter::WalkSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, DeployableWalkSpeedMultiplier) == 0x002700, "Member 'APlayerCharacter::DeployableWalkSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bHoldingFastWalk) == 0x002704, "Member 'APlayerCharacter::bHoldingFastWalk' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bHoldingSprint) == 0x002705, "Member 'APlayerCharacter::bHoldingSprint' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bWalking) == 0x002715, "Member 'APlayerCharacter::bWalking' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bAllowPlacement) == 0x002716, "Member 'APlayerCharacter::bAllowPlacement' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, MeshspaceInterp) == 0x0027C0, "Member 'APlayerCharacter::MeshspaceInterp' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, VelocityCameraRollMultiplier) == 0x0027C4, "Member 'APlayerCharacter::VelocityCameraRollMultiplier' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, PendingRecoil) == 0x0027C8, "Member 'APlayerCharacter::PendingRecoil' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, RecoilSpeed) == 0x0027F8, "Member 'APlayerCharacter::RecoilSpeed' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, Last1PMontage) == 0x002808, "Member 'APlayerCharacter::Last1PMontage' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, PlayedTableMontageMap1P) == 0x002810, "Member 'APlayerCharacter::PlayedTableMontageMap1P' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, JumpStartSound) == 0x002868, "Member 'APlayerCharacter::JumpStartSound' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, JumpLandSound) == 0x002870, "Member 'APlayerCharacter::JumpLandSound' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, InMix) == 0x002878, "Member 'APlayerCharacter::InMix' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, OutMix) == 0x002880, "Member 'APlayerCharacter::OutMix' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bOutMixPlaying) == 0x002888, "Member 'APlayerCharacter::bOutMixPlaying' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, InjuredScreamPVP) == 0x002890, "Member 'APlayerCharacter::InjuredScreamPVP' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, DeathScreamPVP) == 0x0028A0, "Member 'APlayerCharacter::DeathScreamPVP' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, InjuredScreamComponent) == 0x0028A8, "Member 'APlayerCharacter::InjuredScreamComponent' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, MovementRequiredPerSound) == 0x0028B4, "Member 'APlayerCharacter::MovementRequiredPerSound' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, RotationRequiredPerSound) == 0x0028B8, "Member 'APlayerCharacter::RotationRequiredPerSound' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, NegativeVelocityRequiredForLandingSound) == 0x0028BC, "Member 'APlayerCharacter::NegativeVelocityRequiredForLandingSound' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, WalkSounds) == 0x0028F8, "Member 'APlayerCharacter::WalkSounds' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, WalkSounds_Environmental) == 0x002908, "Member 'APlayerCharacter::WalkSounds_Environmental' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, RunSounds) == 0x002930, "Member 'APlayerCharacter::RunSounds' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, RunSounds_Environmental) == 0x002940, "Member 'APlayerCharacter::RunSounds_Environmental' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, TurningSounds) == 0x002968, "Member 'APlayerCharacter::TurningSounds' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, LandingSounds) == 0x002978, "Member 'APlayerCharacter::LandingSounds' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, HitDirectionForward) == 0x002998, "Member 'APlayerCharacter::HitDirectionForward' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, HitDirectionRight) == 0x00299C, "Member 'APlayerCharacter::HitDirectionRight' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, BreathingBaseEvent) == 0x0029B0, "Member 'APlayerCharacter::BreathingBaseEvent' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ExhaustionLevel) == 0x0029B8, "Member 'APlayerCharacter::ExhaustionLevel' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ExhaustionDissipationRate) == 0x0029BC, "Member 'APlayerCharacter::ExhaustionDissipationRate' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ExhaustionIncreaseRate) == 0x0029C0, "Member 'APlayerCharacter::ExhaustionIncreaseRate' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ExhaustionThreshold) == 0x0029C4, "Member 'APlayerCharacter::ExhaustionThreshold' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, FearLevel) == 0x0029C8, "Member 'APlayerCharacter::FearLevel' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, FearDissipationRate) == 0x0029D0, "Member 'APlayerCharacter::FearDissipationRate' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, FearSuppressionScale) == 0x0029D4, "Member 'APlayerCharacter::FearSuppressionScale' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, FearThreshold) == 0x0029D8, "Member 'APlayerCharacter::FearThreshold' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bIsSightTweakMode) == 0x0029DC, "Member 'APlayerCharacter::bIsSightTweakMode' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SightTweakerWidgetTemplate) == 0x0029E0, "Member 'APlayerCharacter::SightTweakerWidgetTemplate' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SightTweakerOverlay) == 0x0029E8, "Member 'APlayerCharacter::SightTweakerOverlay' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SightTweakerPosOffset) == 0x0029F0, "Member 'APlayerCharacter::SightTweakerPosOffset' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SightTweakerRotOffset) == 0x002A08, "Member 'APlayerCharacter::SightTweakerRotOffset' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SpawnProtectionTime) == 0x002A30, "Member 'APlayerCharacter::SpawnProtectionTime' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bIsThirdPerson) == 0x002A34, "Member 'APlayerCharacter::bIsThirdPerson' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, Server_BaseAimRotation) == 0x002A38, "Member 'APlayerCharacter::Server_BaseAimRotation' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, FreeAimCache) == 0x002A50, "Member 'APlayerCharacter::FreeAimCache' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, IsPlayingInteraction) == 0x002A70, "Member 'APlayerCharacter::IsPlayingInteraction' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bIsStopping) == 0x002B10, "Member 'APlayerCharacter::bIsStopping' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, LadderPlacementZone) == 0x002B18, "Member 'APlayerCharacter::LadderPlacementZone' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, MoveForwardInput) == 0x002B2C, "Member 'APlayerCharacter::MoveForwardInput' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, MoveRightInput) == 0x002B30, "Member 'APlayerCharacter::MoveRightInput' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, LeftFootSocketName) == 0x002B68, "Member 'APlayerCharacter::LeftFootSocketName' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, RighttFootSocketName) == 0x002B70, "Member 'APlayerCharacter::RighttFootSocketName' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, LeftFootEnum) == 0x002B78, "Member 'APlayerCharacter::LeftFootEnum' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, RightFootEnum) == 0x002B79, "Member 'APlayerCharacter::RightFootEnum' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, FootAdjustOffset) == 0x002B7C, "Member 'APlayerCharacter::FootAdjustOffset' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, FootInterpSpeed) == 0x002B80, "Member 'APlayerCharacter::FootInterpSpeed' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, FootRotationInterpSpeed) == 0x002B84, "Member 'APlayerCharacter::FootRotationInterpSpeed' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, HipInterpSpeed) == 0x002B88, "Member 'APlayerCharacter::HipInterpSpeed' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, TraceDistance) == 0x002B8C, "Member 'APlayerCharacter::TraceDistance' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, TraceOffset) == 0x002B90, "Member 'APlayerCharacter::TraceOffset' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, VelocityThreshold) == 0x002B94, "Member 'APlayerCharacter::VelocityThreshold' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SpeedBubbleAmount) == 0x002B98, "Member 'APlayerCharacter::SpeedBubbleAmount' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, CurrentMeshRot) == 0x002BA0, "Member 'APlayerCharacter::CurrentMeshRot' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bIgnoreRotationOverride) == 0x002BBA, "Member 'APlayerCharacter::bIgnoreRotationOverride' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, CameraBobTrans) == 0x002BE0, "Member 'APlayerCharacter::CameraBobTrans' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, WeaponBobTrans) == 0x002BF8, "Member 'APlayerCharacter::WeaponBobTrans' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, WeaponBobRot) == 0x002C10, "Member 'APlayerCharacter::WeaponBobRot' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, CameraBobRot) == 0x002C28, "Member 'APlayerCharacter::CameraBobRot' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bIsSecondarySightActive) == 0x002C40, "Member 'APlayerCharacter::bIsSecondarySightActive' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, OnCantedSightToggled) == 0x002C48, "Member 'APlayerCharacter::OnCantedSightToggled' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bCantedSightEnabled) == 0x002C58, "Member 'APlayerCharacter::bCantedSightEnabled' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, OnSecondarySightToggled) == 0x002C70, "Member 'APlayerCharacter::OnSecondarySightToggled' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bIsPelvisFPMovementBobActive) == 0x002C80, "Member 'APlayerCharacter::bIsPelvisFPMovementBobActive' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, PelvisFPMovementDamping) == 0x002C84, "Member 'APlayerCharacter::PelvisFPMovementDamping' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bCopyTPMeshTransformsToFP) == 0x002C88, "Member 'APlayerCharacter::bCopyTPMeshTransformsToFP' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ScoreboardWidget) == 0x002D28, "Member 'APlayerCharacter::ScoreboardWidget' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, CommandInterface) == 0x002D38, "Member 'APlayerCharacter::CommandInterface' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bItemWheelPressed) == 0x002D50, "Member 'APlayerCharacter::bItemWheelPressed' has a wrong offset!");

// Class ReadyOrNot.AnimNotify_AIDoorBreachKick
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_AIDoorBreachKick final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_AIDoorBreachKick">();
	}
	static class UAnimNotify_AIDoorBreachKick* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_AIDoorBreachKick>();
	}
};
static_assert(alignof(UAnimNotify_AIDoorBreachKick) == 0x000008, "Wrong alignment on UAnimNotify_AIDoorBreachKick");
static_assert(sizeof(UAnimNotify_AIDoorBreachKick) == 0x000038, "Wrong size on UAnimNotify_AIDoorBreachKick");

// Class ReadyOrNot.Projectile
// 0x0048 (0x02E0 - 0x0298)
class AProjectile : public AActor
{
public:
	class UBulletProjectileMovementComponent*     MovementComp;                                      // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USphereComponent*                       CollisionComp;                                     // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A8[0x20];                                     // 0x02A8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             ProjectileHitSound;                                // 0x02C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D0[0x8];                                      // 0x02D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AImpactEffect>              ImpactEffectsClass;                                // 0x02D8(0x0008)(Edit, BlueprintVisible, Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void Multicast_SpawnImpactEffects(const struct FHitResult& Hit, TSubclassOf<class AImpactEffect> EffectsClass, float DecalScale, bool bExitImpact, bool bArmorImpact);
	void OnHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Projectile">();
	}
	static class AProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectile>();
	}
};
static_assert(alignof(AProjectile) == 0x000008, "Wrong alignment on AProjectile");
static_assert(sizeof(AProjectile) == 0x0002E0, "Wrong size on AProjectile");
static_assert(offsetof(AProjectile, MovementComp) == 0x000298, "Member 'AProjectile::MovementComp' has a wrong offset!");
static_assert(offsetof(AProjectile, CollisionComp) == 0x0002A0, "Member 'AProjectile::CollisionComp' has a wrong offset!");
static_assert(offsetof(AProjectile, ProjectileHitSound) == 0x0002C8, "Member 'AProjectile::ProjectileHitSound' has a wrong offset!");
static_assert(offsetof(AProjectile, ImpactEffectsClass) == 0x0002D8, "Member 'AProjectile::ImpactEffectsClass' has a wrong offset!");

// Class ReadyOrNot.AnimNotify_AIDoorBreachRam
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_AIDoorBreachRam final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_AIDoorBreachRam">();
	}
	static class UAnimNotify_AIDoorBreachRam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_AIDoorBreachRam>();
	}
};
static_assert(alignof(UAnimNotify_AIDoorBreachRam) == 0x000008, "Wrong alignment on UAnimNotify_AIDoorBreachRam");
static_assert(sizeof(UAnimNotify_AIDoorBreachRam) == 0x000038, "Wrong size on UAnimNotify_AIDoorBreachRam");

// Class ReadyOrNot.WorldBuildingActivity
// 0x00B0 (0x02A0 - 0x01F0)
class UWorldBuildingActivity : public UBaseActivity
{
public:
	bool                                          bShouldHolsterWeapon;                              // 0x01F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldSurrenderFromActivity;                      // 0x01F1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequireRotationMatch;                             // 0x01F2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F3[0x25];                                     // 0x01F3(0x0025)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               FinalRotationOffset;                               // 0x0218(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bOneShotAnimationDataTable;                        // 0x0230(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_231[0x7];                                      // 0x0231(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TableMontageName;                                  // 0x0238(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Loop;                                              // 0x0248(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageStart;                                      // 0x0250(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           MontageEnd;                                        // 0x0258(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           MontageAbruptEnd;                                  // 0x0260(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 StartActivitySpeech;                               // 0x0268(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 FinishActivitySpeech;                              // 0x0278(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           TableMontageAnim;                                  // 0x0288(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_290[0x10];                                     // 0x0290(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnterAbruptEndState();
	void EnterCompleteState();
	void EnterEndState();
	void EnterLoopState();
	void EnterMoveToState();
	void EnterStartState();
	void SetRotation(const struct FRotator& NewRotator);
	void TickLoopState(float DeltaTime, float Uptime);
	void TickMoveToState(float DeltaTime, float Uptime);

	struct FRotator GetRotationOffset() const;
	bool IsSetupCorrectly() const;
	bool ShouldComplete() const;
	bool ShouldEnd() const;
	bool ShouldEndAbruptly() const;
	bool ShouldLoop() const;
	bool ShouldStart() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldBuildingActivity">();
	}
	static class UWorldBuildingActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWorldBuildingActivity>();
	}
};
static_assert(alignof(UWorldBuildingActivity) == 0x000008, "Wrong alignment on UWorldBuildingActivity");
static_assert(sizeof(UWorldBuildingActivity) == 0x0002A0, "Wrong size on UWorldBuildingActivity");
static_assert(offsetof(UWorldBuildingActivity, bShouldHolsterWeapon) == 0x0001F0, "Member 'UWorldBuildingActivity::bShouldHolsterWeapon' has a wrong offset!");
static_assert(offsetof(UWorldBuildingActivity, bShouldSurrenderFromActivity) == 0x0001F1, "Member 'UWorldBuildingActivity::bShouldSurrenderFromActivity' has a wrong offset!");
static_assert(offsetof(UWorldBuildingActivity, bRequireRotationMatch) == 0x0001F2, "Member 'UWorldBuildingActivity::bRequireRotationMatch' has a wrong offset!");
static_assert(offsetof(UWorldBuildingActivity, FinalRotationOffset) == 0x000218, "Member 'UWorldBuildingActivity::FinalRotationOffset' has a wrong offset!");
static_assert(offsetof(UWorldBuildingActivity, bOneShotAnimationDataTable) == 0x000230, "Member 'UWorldBuildingActivity::bOneShotAnimationDataTable' has a wrong offset!");
static_assert(offsetof(UWorldBuildingActivity, TableMontageName) == 0x000238, "Member 'UWorldBuildingActivity::TableMontageName' has a wrong offset!");
static_assert(offsetof(UWorldBuildingActivity, Loop) == 0x000248, "Member 'UWorldBuildingActivity::Loop' has a wrong offset!");
static_assert(offsetof(UWorldBuildingActivity, MontageStart) == 0x000250, "Member 'UWorldBuildingActivity::MontageStart' has a wrong offset!");
static_assert(offsetof(UWorldBuildingActivity, MontageEnd) == 0x000258, "Member 'UWorldBuildingActivity::MontageEnd' has a wrong offset!");
static_assert(offsetof(UWorldBuildingActivity, MontageAbruptEnd) == 0x000260, "Member 'UWorldBuildingActivity::MontageAbruptEnd' has a wrong offset!");
static_assert(offsetof(UWorldBuildingActivity, StartActivitySpeech) == 0x000268, "Member 'UWorldBuildingActivity::StartActivitySpeech' has a wrong offset!");
static_assert(offsetof(UWorldBuildingActivity, FinishActivitySpeech) == 0x000278, "Member 'UWorldBuildingActivity::FinishActivitySpeech' has a wrong offset!");
static_assert(offsetof(UWorldBuildingActivity, TableMontageAnim) == 0x000288, "Member 'UWorldBuildingActivity::TableMontageAnim' has a wrong offset!");

// Class ReadyOrNot.PlaceTrapActivity
// 0x0010 (0x02B0 - 0x02A0)
class UPlaceTrapActivity final : public UWorldBuildingActivity
{
public:
	class ADoor*                                  Door;                                              // 0x02A0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A8[0x8];                                      // 0x02A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTrapPlacementInterrupted();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlaceTrapActivity">();
	}
	static class UPlaceTrapActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlaceTrapActivity>();
	}
};
static_assert(alignof(UPlaceTrapActivity) == 0x000008, "Wrong alignment on UPlaceTrapActivity");
static_assert(sizeof(UPlaceTrapActivity) == 0x0002B0, "Wrong size on UPlaceTrapActivity");
static_assert(offsetof(UPlaceTrapActivity, Door) == 0x0002A0, "Member 'UPlaceTrapActivity::Door' has a wrong offset!");

// Class ReadyOrNot.AnimNotify_AIDoorBreachShotgun
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_AIDoorBreachShotgun final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_AIDoorBreachShotgun">();
	}
	static class UAnimNotify_AIDoorBreachShotgun* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_AIDoorBreachShotgun>();
	}
};
static_assert(alignof(UAnimNotify_AIDoorBreachShotgun) == 0x000008, "Wrong alignment on UAnimNotify_AIDoorBreachShotgun");
static_assert(sizeof(UAnimNotify_AIDoorBreachShotgun) == 0x000038, "Wrong size on UAnimNotify_AIDoorBreachShotgun");

// Class ReadyOrNot.AnimNotify_AIThrowGrenade
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_AIThrowGrenade final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_AIThrowGrenade">();
	}
	static class UAnimNotify_AIThrowGrenade* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_AIThrowGrenade>();
	}
};
static_assert(alignof(UAnimNotify_AIThrowGrenade) == 0x000008, "Wrong alignment on UAnimNotify_AIThrowGrenade");
static_assert(sizeof(UAnimNotify_AIThrowGrenade) == 0x000038, "Wrong size on UAnimNotify_AIThrowGrenade");

// Class ReadyOrNot.AnimNotify_SetStrafe
// 0x0008 (0x0040 - 0x0038)
class UAnimNotify_SetStrafe final : public UAnimNotify
{
public:
	bool                                          bSetStrafe;                                        // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_SetStrafe">();
	}
	static class UAnimNotify_SetStrafe* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_SetStrafe>();
	}
};
static_assert(alignof(UAnimNotify_SetStrafe) == 0x000008, "Wrong alignment on UAnimNotify_SetStrafe");
static_assert(sizeof(UAnimNotify_SetStrafe) == 0x000040, "Wrong size on UAnimNotify_SetStrafe");
static_assert(offsetof(UAnimNotify_SetStrafe, bSetStrafe) == 0x000038, "Member 'UAnimNotify_SetStrafe::bSetStrafe' has a wrong offset!");

// Class ReadyOrNot.ReadyOrNotAISense_Sight
// 0x00C8 (0x0140 - 0x0078)
class UReadyOrNotAISense_Sight final : public UAISense
{
public:
	uint8                                         Pad_78[0xC8];                                      // 0x0078(0x00C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotAISense_Sight">();
	}
	static class UReadyOrNotAISense_Sight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotAISense_Sight>();
	}
};
static_assert(alignof(UReadyOrNotAISense_Sight) == 0x000008, "Wrong alignment on UReadyOrNotAISense_Sight");
static_assert(sizeof(UReadyOrNotAISense_Sight) == 0x000140, "Wrong size on UReadyOrNotAISense_Sight");

// Class ReadyOrNot.AnimNotify_AIThrowGrenadeComplete
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_AIThrowGrenadeComplete final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_AIThrowGrenadeComplete">();
	}
	static class UAnimNotify_AIThrowGrenadeComplete* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_AIThrowGrenadeComplete>();
	}
};
static_assert(alignof(UAnimNotify_AIThrowGrenadeComplete) == 0x000008, "Wrong alignment on UAnimNotify_AIThrowGrenadeComplete");
static_assert(sizeof(UAnimNotify_AIThrowGrenadeComplete) == 0x000038, "Wrong size on UAnimNotify_AIThrowGrenadeComplete");

// Class ReadyOrNot.CommonFooterButton
// 0x0010 (0x15F0 - 0x15E0)
class UCommonFooterButton : public UCommonButtonImplementation
{
public:
	struct FDataTableRowHandle                    TriggeringInputActionVisual;                       // 0x15D8(0x0010)(NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_15E8[0x8];                                     // 0x15E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetTriggeringInputActionVisual(const struct FDataTableRowHandle& InputActionRrw);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommonFooterButton">();
	}
	static class UCommonFooterButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommonFooterButton>();
	}
};
static_assert(alignof(UCommonFooterButton) == 0x000010, "Wrong alignment on UCommonFooterButton");
static_assert(sizeof(UCommonFooterButton) == 0x0015F0, "Wrong size on UCommonFooterButton");
static_assert(offsetof(UCommonFooterButton, TriggeringInputActionVisual) == 0x0015D8, "Member 'UCommonFooterButton::TriggeringInputActionVisual' has a wrong offset!");

// Class ReadyOrNot.AnimNotify_AIThrowPendingItem
// 0x00A8 (0x00E0 - 0x0038)
class UAnimNotify_AIThrowPendingItem final : public UAnimNotify
{
public:
	class FName                                   BoneToSpawnOn;                                     // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                LandingLocation;                                   // 0x0040(0x0018)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             RelativeTransform;                                 // 0x0060(0x0060)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bCustomThrowDirection : 1;                         // 0x00C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               ThrowDirection;                                    // 0x00C8(0x0018)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_AIThrowPendingItem">();
	}
	static class UAnimNotify_AIThrowPendingItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_AIThrowPendingItem>();
	}
};
static_assert(alignof(UAnimNotify_AIThrowPendingItem) == 0x000010, "Wrong alignment on UAnimNotify_AIThrowPendingItem");
static_assert(sizeof(UAnimNotify_AIThrowPendingItem) == 0x0000E0, "Wrong size on UAnimNotify_AIThrowPendingItem");
static_assert(offsetof(UAnimNotify_AIThrowPendingItem, BoneToSpawnOn) == 0x000038, "Member 'UAnimNotify_AIThrowPendingItem::BoneToSpawnOn' has a wrong offset!");
static_assert(offsetof(UAnimNotify_AIThrowPendingItem, LandingLocation) == 0x000040, "Member 'UAnimNotify_AIThrowPendingItem::LandingLocation' has a wrong offset!");
static_assert(offsetof(UAnimNotify_AIThrowPendingItem, RelativeTransform) == 0x000060, "Member 'UAnimNotify_AIThrowPendingItem::RelativeTransform' has a wrong offset!");
static_assert(offsetof(UAnimNotify_AIThrowPendingItem, ThrowDirection) == 0x0000C8, "Member 'UAnimNotify_AIThrowPendingItem::ThrowDirection' has a wrong offset!");

// Class ReadyOrNot.ReadyOrNotCommonRichTextBlock
// 0x0010 (0x08F0 - 0x08E0)
class UReadyOrNotCommonRichTextBlock final : public UCommonRichTextBlock
{
public:
	uint8                                         Pad_8D8[0x18];                                     // 0x08D8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ResetTextScroll();
	void StartTextScroll();
	void SuspendTextScroll();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotCommonRichTextBlock">();
	}
	static class UReadyOrNotCommonRichTextBlock* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotCommonRichTextBlock>();
	}
};
static_assert(alignof(UReadyOrNotCommonRichTextBlock) == 0x000010, "Wrong alignment on UReadyOrNotCommonRichTextBlock");
static_assert(sizeof(UReadyOrNotCommonRichTextBlock) == 0x0008F0, "Wrong size on UReadyOrNotCommonRichTextBlock");

// Class ReadyOrNot.AnimNotify_ApplyArteryDamage
// 0x0008 (0x0040 - 0x0038)
class UAnimNotify_ApplyArteryDamage final : public UAnimNotify
{
public:
	class FName                                   ArteryBoneName;                                    // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_ApplyArteryDamage">();
	}
	static class UAnimNotify_ApplyArteryDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_ApplyArteryDamage>();
	}
};
static_assert(alignof(UAnimNotify_ApplyArteryDamage) == 0x000008, "Wrong alignment on UAnimNotify_ApplyArteryDamage");
static_assert(sizeof(UAnimNotify_ApplyArteryDamage) == 0x000040, "Wrong size on UAnimNotify_ApplyArteryDamage");
static_assert(offsetof(UAnimNotify_ApplyArteryDamage, ArteryBoneName) == 0x000038, "Member 'UAnimNotify_ApplyArteryDamage::ArteryBoneName' has a wrong offset!");

// Class ReadyOrNot.AnimNotify_ApplyMeleeDamage
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_ApplyMeleeDamage final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_ApplyMeleeDamage">();
	}
	static class UAnimNotify_ApplyMeleeDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_ApplyMeleeDamage>();
	}
};
static_assert(alignof(UAnimNotify_ApplyMeleeDamage) == 0x000008, "Wrong alignment on UAnimNotify_ApplyMeleeDamage");
static_assert(sizeof(UAnimNotify_ApplyMeleeDamage) == 0x000038, "Wrong size on UAnimNotify_ApplyMeleeDamage");

// Class ReadyOrNot.BaseShell
// 0x0038 (0x0318 - 0x02E0)
class ABaseShell : public APooledActor
{
public:
	class UStaticMeshComponent*                   ShellMesh;                                         // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMaterialInstanceDynamic*>       MID_ShellMesh;                                     // 0x02E8(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	EShellType                                    ShellType;                                         // 0x02F8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F9[0x7];                                      // 0x02F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             ShellBounceFMODAudio;                              // 0x0300(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShellNormalizeMax;                                 // 0x0308(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShellNormalizeMin;                                 // 0x030C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_310[0x8];                                      // 0x0310(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseShell">();
	}
	static class ABaseShell* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseShell>();
	}
};
static_assert(alignof(ABaseShell) == 0x000008, "Wrong alignment on ABaseShell");
static_assert(sizeof(ABaseShell) == 0x000318, "Wrong size on ABaseShell");
static_assert(offsetof(ABaseShell, ShellMesh) == 0x0002E0, "Member 'ABaseShell::ShellMesh' has a wrong offset!");
static_assert(offsetof(ABaseShell, MID_ShellMesh) == 0x0002E8, "Member 'ABaseShell::MID_ShellMesh' has a wrong offset!");
static_assert(offsetof(ABaseShell, ShellType) == 0x0002F8, "Member 'ABaseShell::ShellType' has a wrong offset!");
static_assert(offsetof(ABaseShell, ShellBounceFMODAudio) == 0x000300, "Member 'ABaseShell::ShellBounceFMODAudio' has a wrong offset!");
static_assert(offsetof(ABaseShell, ShellNormalizeMax) == 0x000308, "Member 'ABaseShell::ShellNormalizeMax' has a wrong offset!");
static_assert(offsetof(ABaseShell, ShellNormalizeMin) == 0x00030C, "Member 'ABaseShell::ShellNormalizeMin' has a wrong offset!");

// Class ReadyOrNot.ReadyOrNotLoadoutManager
// 0x0420 (0x0448 - 0x0028)
class UReadyOrNotLoadoutManager final : public UObject
{
public:
	uint8                                         Pad_28[0x50];                                      // 0x0028(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<TSubclassOf<class ABaseWeapon>, struct FStoredWeaponAttachments> StoredAttachmentsByWeapon; // 0x0078(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class FString& Name, const struct FSavedLoadout& Loadout)> OnPresetApplied; // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnAvailablePresetsChanged;                         // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const class FString& Name)> OnCustomizationPresetApplied;          // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_100[0x50];                                     // 0x0100(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSavedLoadout                          ActiveLoadout;                                     // 0x0150(0x02E8)(NativeAccessSpecifierPrivate)
	EEquippingSwat                                ActiveSwatMember;                                  // 0x0438(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_439[0x7];                                      // 0x0439(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ULoadoutManager*                        LoadoutManager;                                    // 0x0440(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void ApplyCustomizationPreset(const class FString& Name_0);
	void ApplyPreset(const class FString& Name_0);
	bool AttachmentIsEquipped(TSubclassOf<class UWeaponAttachment> WeaponAttachment, EWeaponAttachmentType AttachmentType);
	void CustomizationPresetApplied(const class FString& Name_0);
	void CustomizationPresetsChanged();
	void DecrementGrenadeSlotCount(TSubclassOf<class ABaseItem> SlotItem);
	void DecrementPrimarySlotCount(class FName AmmoType);
	void DecrementSecondarySlotCount(class FName AmmoType);
	void DecrementTacticalSlotCount(TSubclassOf<class ABaseItem> SlotItem);
	void DeleteCustomizationPreset(const class FString& Name_0);
	void DeletePreset(const class FString& Name_0);
	void DoSaveActiveLoadout();
	void DoSaveLoadout(EEquippingSwat SwatMember, const struct FSavedLoadout& Loadout);
	EEquippingSwat FStringToEquippingSwat(const class FString& Name_0);
	class UArmourMaterial* GetActiveArmorMaterial();
	TSubclassOf<class ABaseItem> GetActiveBodyArmor();
	TSubclassOf<class ABaseItem> GetActiveFacewear();
	TSubclassOf<class ABaseItem> GetActiveHeadwear();
	TSubclassOf<class ABaseItem> GetActiveHelmetMount();
	struct FSavedLoadout GetActiveLoadout();
	TSubclassOf<class ABaseItem> GetActiveLongTactical();
	ENVGStyle GetActiveNvgStyle();
	TSubclassOf<class ABaseWeapon> GetActivePrimary();
	TSubclassOf<class UWeaponAttachment> GetActivePrimaryAttachmentByType(EWeaponAttachmentType AttachmentType);
	TSubclassOf<class ABaseWeapon> GetActiveSecondary();
	TSubclassOf<class UWeaponAttachment> GetActiveSecondaryAttachmentByType(EWeaponAttachmentType AttachmentType);
	EEquippingSwat GetActiveSwatMember();
	class FString GetActiveSwatMemberLabel();
	class FText GetAmmunitionCaliber(class FName AmmunitionName);
	class FText GetAmmunitionDescription(class FName AmmunitionName);
	class FText GetAmmunitionDisplayName(class FName AmmunitionName);
	EArmourCoverage GetArmorCoverage();
	class FText GetArmorCoverageText(EArmourCoverage Coverage);
	TArray<class UArmourMaterial*> GetArmorMaterials();
	TArray<TSubclassOf<class UWeaponAttachment>> GetAttachmentByWeaponAndType(class ABaseWeapon* Weapon, EWeaponAttachmentType Type);
	TArray<EWeaponAttachmentType> GetAvailableAttachmentTypesByWeapon(TSubclassOf<class ABaseWeapon> BaseWeapon);
	TSoftObjectPtr<class UTexture2D> GetBodyArmorItemImage(class ABaseItem* Item);
	TArray<class ABaseItem*> GetBodyArmors();
	class FText GetCurrentPresetDisplayName();
	int32 GetCurrentSlotCount();
	struct FSavedLoadout GetDefaultPreset();
	TArray<class ABaseItem*> GetFacewears();
	int32 GetGrenadeSlotCount(TSubclassOf<class ABaseItem> SlotItem);
	TSoftObjectPtr<class UTexture2D> GetHeadwearItemImage(class ABaseItem* Item);
	TArray<class ABaseItem*> GetHeadwears();
	TArray<class ABaseItem*> GetHelmetMounts();
	TArray<class ABaseItem*> GetItemsByLoadoutCategory(ELoadoutCategory LoadoutCategory);
	TSoftObjectPtr<class UTexture2D> GetLongTacticalItemImage(class ABaseItem* Item);
	int32 GetMaximumSlotCount();
	struct FSavedLoadout GetPreset(const class FString& Name_0);
	int32 GetPreviewCurrentSlotCount(const struct FSavedLoadout& PreviewLoadout);
	int32 GetPreviewGrenadeSlotCount(const struct FSavedLoadout& PreviewLoadout, TSubclassOf<class ABaseItem> SlotItem);
	int32 GetPreviewMaximumSlotCount(const struct FSavedLoadout& PreviewLoadout);
	int32 GetPreviewPrimarySlotCount(const struct FSavedLoadout& PreviewLoadout, class FName AmmoType);
	int32 GetPreviewSecondarySlotCount(const struct FSavedLoadout& PreviewLoadout, class FName AmmoType);
	int32 GetPreviewSlotCount(const struct FSavedLoadout& PreviewLoadout, TSubclassOf<class ABaseItem> SlotItem);
	int32 GetPreviewTacticalSlotCount(const struct FSavedLoadout& PreviewLoadout, TSubclassOf<class ABaseItem> SlotItem);
	TArray<class FName> GetPrimaryAmmoTypes();
	int32 GetPrimarySlotCount(class FName AmmoType);
	TSoftObjectPtr<class UTexture2D> GetPrimaryWeaponImage(class ABaseItem* Item);
	TArray<class FName> GetSecondaryAmmoTypes();
	int32 GetSecondarySlotCount(class FName AmmoType);
	TSoftObjectPtr<class UTexture2D> GetSecondaryWeaponImage(class ABaseItem* Item);
	int32 GetSlotCount(TSubclassOf<class ABaseItem> SlotItem);
	class UWeaponAttachment* GetStoredAttachmentByWeaponAndType(TSubclassOf<class ABaseWeapon> Weapon, EWeaponAttachmentType Type);
	int32 GetTacticalSlotCount(TSubclassOf<class ABaseItem> SlotItem);
	void IncrementGrenadeSlotCount(TSubclassOf<class ABaseItem> SlotItem);
	void IncrementPrimarySlotCount(class FName AmmoType);
	void IncrementSecondarySlotCount(class FName AmmoType);
	void IncrementTacticalSlotCount(TSubclassOf<class ABaseItem> SlotItem);
	bool ItemIsInActiveLoadout(TSubclassOf<class ABaseItem> Item);
	EEquippingSwat NextActiveSwatMember();
	EEquippingSwat PreviousActiveSwatMember();
	void ResetCustomizationToDefault();
	void ResetLoadoutToDefault();
	void SanitizeActiveLoadout();
	void SaveCustomizationPreset(const class FString& Name_0);
	void SavePreset(const class FString& Name_0, bool bSaveCustomization);
	void SetActiveBodyArmor(TSubclassOf<class ABaseItem> Armor);
	void SetActiveFacewear(TSubclassOf<class ABaseItem> Facewear);
	void SetActiveHeadwear(TSubclassOf<class ABaseItem> Headwear);
	void SetActiveHelmetMount(TSubclassOf<class ABaseItem> HelmetMount);
	void SetActiveLoadout(const struct FSavedLoadout& Loadout);
	void SetActiveLoadoutByName(const class FString& LoadoutName);
	void SetActiveLongTactical(TSubclassOf<class ABaseItem> LongTactical);
	void SetActiveNvgStyle(ENVGStyle NvgStyle);
	void SetActivePrimary(TSubclassOf<class ABaseWeapon> Primary);
	void SetActivePrimarySkin(TSubclassOf<class USkinComponent> Skin);
	void SetActiveSecondary(TSubclassOf<class ABaseWeapon> Secondary);
	void SetActiveSecondarySkin(TSubclassOf<class USkinComponent> Skin);
	void SetActiveSwatMember(EEquippingSwat SwatMember);
	void SetArmorCoverage(EArmourCoverage ArmorCoverage);
	void SetArmorMaterial(class UArmourMaterial* ArmorMaterial);
	void SetPrimaryAttachment(TSubclassOf<class UWeaponAttachment> WeaponAttachment, EWeaponAttachmentType AttachmentType);
	void SetSecondaryAttachment(TSubclassOf<class UWeaponAttachment> WeaponAttachment, EWeaponAttachmentType AttachmentType);
	void UnequipPresetFromSwatMember(EEquippingSwat SwatMember);
	void UpdateCustomizationPresetName(const class FString& OldName, const class FString& NewName);

	TArray<class FString> GetAllPresetNames() const;
	class FString GetCurrentCustomizationPresetName() const;
	class FString GetCustomizationPresetBySwat(EEquippingSwat SwatMember) const;
	TArray<class FString> GetCustomizationPresetNames() const;
	class FText GetDefaultCustomizationPresetName() const;
	class FText GetDefaultPresetName() const;
	class FText GetNextDefaultPresetName(const TArray<class FString>& PresetNames) const;
	bool IsCurrentCustomizationPresetDirty() const;
	void UpdatePresetName(const class FString& OldName, const class FString& NewName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotLoadoutManager">();
	}
	static class UReadyOrNotLoadoutManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotLoadoutManager>();
	}
};
static_assert(alignof(UReadyOrNotLoadoutManager) == 0x000008, "Wrong alignment on UReadyOrNotLoadoutManager");
static_assert(sizeof(UReadyOrNotLoadoutManager) == 0x000448, "Wrong size on UReadyOrNotLoadoutManager");
static_assert(offsetof(UReadyOrNotLoadoutManager, StoredAttachmentsByWeapon) == 0x000078, "Member 'UReadyOrNotLoadoutManager::StoredAttachmentsByWeapon' has a wrong offset!");
static_assert(offsetof(UReadyOrNotLoadoutManager, OnPresetApplied) == 0x0000C8, "Member 'UReadyOrNotLoadoutManager::OnPresetApplied' has a wrong offset!");
static_assert(offsetof(UReadyOrNotLoadoutManager, OnAvailablePresetsChanged) == 0x0000D8, "Member 'UReadyOrNotLoadoutManager::OnAvailablePresetsChanged' has a wrong offset!");
static_assert(offsetof(UReadyOrNotLoadoutManager, OnCustomizationPresetApplied) == 0x0000F0, "Member 'UReadyOrNotLoadoutManager::OnCustomizationPresetApplied' has a wrong offset!");
static_assert(offsetof(UReadyOrNotLoadoutManager, ActiveLoadout) == 0x000150, "Member 'UReadyOrNotLoadoutManager::ActiveLoadout' has a wrong offset!");
static_assert(offsetof(UReadyOrNotLoadoutManager, ActiveSwatMember) == 0x000438, "Member 'UReadyOrNotLoadoutManager::ActiveSwatMember' has a wrong offset!");
static_assert(offsetof(UReadyOrNotLoadoutManager, LoadoutManager) == 0x000440, "Member 'UReadyOrNotLoadoutManager::LoadoutManager' has a wrong offset!");

// Class ReadyOrNot.AnimNotify_ArrestCancelComplete
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_ArrestCancelComplete final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_ArrestCancelComplete">();
	}
	static class UAnimNotify_ArrestCancelComplete* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_ArrestCancelComplete>();
	}
};
static_assert(alignof(UAnimNotify_ArrestCancelComplete) == 0x000008, "Wrong alignment on UAnimNotify_ArrestCancelComplete");
static_assert(sizeof(UAnimNotify_ArrestCancelComplete) == 0x000038, "Wrong size on UAnimNotify_ArrestCancelComplete");

// Class ReadyOrNot.InteractionsData
// 0x0090 (0x00C0 - 0x0030)
class UInteractionsData : public UDataAsset
{
public:
	class FName                                   InteractionName;                                   // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bLooping : 1;                                      // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowDeadDriverInteraction : 1;                   // 0x0038(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowDeadSlaveInteraction : 1;                    // 0x0038(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowAimOffsetDuringInteraction : 1;              // 0x0038(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bApplyRelativeOffsetBeforePlaying : 1;             // 0x0038(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseSyncBone : 1;                                  // 0x0038(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSweepEnvironment : 1;                             // 0x0038(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDoNotApplyRelativeOffset : 1;                     // 0x0038(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                RelativePosOffsetToDriver;                         // 0x0040(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RelativeRotOffsetToDriver;                         // 0x0058(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         CancelDurationLength;                              // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bHolsterItemBeforePlaying : 1;                     // 0x0074(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bInstantHolster : 1;                               // 0x0074(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEquipLastItemAfterPlaying : 1;                    // 0x0074(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUpdateSlaveTransform : 1;                         // 0x0074(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUpdateTransformsInstantly : 1;                    // 0x0074(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIndependentFinishes : 1;                          // 0x0074(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseDriverFPMotion : 1;                            // 0x0074(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_75[0x3];                                       // 0x0075(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           DriverMontage;                                     // 0x0078(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           DriverMontage_FP;                                  // 0x0080(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TriggerTolerance;                                  // 0x0088(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DriverBlendDuration;                               // 0x008C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseSlaveFPMotion : 1;                             // 0x0090(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           SlaveMontage;                                      // 0x0098(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           SlaveMontage_FP;                                   // 0x00A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bMatchDriverYaw : 1;                               // 0x00A8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A9[0x3];                                       // 0x00A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MatchedYawOffset;                                  // 0x00AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bHasSharedItemAnim : 1;                            // 0x00B0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           SharedItemMontage;                                 // 0x00B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class APairedInteractionDriver* IsPairedInteractionPlayingOn(class AActor* Target);

	class APairedInteractionDriver* PlayPairedInteraction(class AActor* Driver, class AActor* Slave, class ABaseItem* OptionalItem);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionsData">();
	}
	static class UInteractionsData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionsData>();
	}
};
static_assert(alignof(UInteractionsData) == 0x000008, "Wrong alignment on UInteractionsData");
static_assert(sizeof(UInteractionsData) == 0x0000C0, "Wrong size on UInteractionsData");
static_assert(offsetof(UInteractionsData, InteractionName) == 0x000030, "Member 'UInteractionsData::InteractionName' has a wrong offset!");
static_assert(offsetof(UInteractionsData, RelativePosOffsetToDriver) == 0x000040, "Member 'UInteractionsData::RelativePosOffsetToDriver' has a wrong offset!");
static_assert(offsetof(UInteractionsData, RelativeRotOffsetToDriver) == 0x000058, "Member 'UInteractionsData::RelativeRotOffsetToDriver' has a wrong offset!");
static_assert(offsetof(UInteractionsData, CancelDurationLength) == 0x000070, "Member 'UInteractionsData::CancelDurationLength' has a wrong offset!");
static_assert(offsetof(UInteractionsData, DriverMontage) == 0x000078, "Member 'UInteractionsData::DriverMontage' has a wrong offset!");
static_assert(offsetof(UInteractionsData, DriverMontage_FP) == 0x000080, "Member 'UInteractionsData::DriverMontage_FP' has a wrong offset!");
static_assert(offsetof(UInteractionsData, TriggerTolerance) == 0x000088, "Member 'UInteractionsData::TriggerTolerance' has a wrong offset!");
static_assert(offsetof(UInteractionsData, DriverBlendDuration) == 0x00008C, "Member 'UInteractionsData::DriverBlendDuration' has a wrong offset!");
static_assert(offsetof(UInteractionsData, SlaveMontage) == 0x000098, "Member 'UInteractionsData::SlaveMontage' has a wrong offset!");
static_assert(offsetof(UInteractionsData, SlaveMontage_FP) == 0x0000A0, "Member 'UInteractionsData::SlaveMontage_FP' has a wrong offset!");
static_assert(offsetof(UInteractionsData, MatchedYawOffset) == 0x0000AC, "Member 'UInteractionsData::MatchedYawOffset' has a wrong offset!");
static_assert(offsetof(UInteractionsData, SharedItemMontage) == 0x0000B8, "Member 'UInteractionsData::SharedItemMontage' has a wrong offset!");

// Class ReadyOrNot.AnimNotify_ArrestComplete
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_ArrestComplete final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_ArrestComplete">();
	}
	static class UAnimNotify_ArrestComplete* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_ArrestComplete>();
	}
};
static_assert(alignof(UAnimNotify_ArrestComplete) == 0x000008, "Wrong alignment on UAnimNotify_ArrestComplete");
static_assert(sizeof(UAnimNotify_ArrestComplete) == 0x000038, "Wrong size on UAnimNotify_ArrestComplete");

// Class ReadyOrNot.PlayerHealthStatusWidget
// 0x0020 (0x02E0 - 0x02C0)
class UPlayerHealthStatusWidget final : public UUserWidget
{
public:
	class UHealthStatusWidget*                    Health;                                            // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHealthStatusWidget*                    Armor;                                             // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHealthStatusWidget*                    Helmet;                                            // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APlayerCharacter*                       PlayerCharacter;                                   // 0x02D8(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerHealthStatusWidget">();
	}
	static class UPlayerHealthStatusWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerHealthStatusWidget>();
	}
};
static_assert(alignof(UPlayerHealthStatusWidget) == 0x000008, "Wrong alignment on UPlayerHealthStatusWidget");
static_assert(sizeof(UPlayerHealthStatusWidget) == 0x0002E0, "Wrong size on UPlayerHealthStatusWidget");
static_assert(offsetof(UPlayerHealthStatusWidget, Health) == 0x0002C0, "Member 'UPlayerHealthStatusWidget::Health' has a wrong offset!");
static_assert(offsetof(UPlayerHealthStatusWidget, Armor) == 0x0002C8, "Member 'UPlayerHealthStatusWidget::Armor' has a wrong offset!");
static_assert(offsetof(UPlayerHealthStatusWidget, Helmet) == 0x0002D0, "Member 'UPlayerHealthStatusWidget::Helmet' has a wrong offset!");
static_assert(offsetof(UPlayerHealthStatusWidget, PlayerCharacter) == 0x0002D8, "Member 'UPlayerHealthStatusWidget::PlayerCharacter' has a wrong offset!");

// Class ReadyOrNot.AnimNotify_Breach_C2Detonate
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_Breach_C2Detonate final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_Breach_C2Detonate">();
	}
	static class UAnimNotify_Breach_C2Detonate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_Breach_C2Detonate>();
	}
};
static_assert(alignof(UAnimNotify_Breach_C2Detonate) == 0x000008, "Wrong alignment on UAnimNotify_Breach_C2Detonate");
static_assert(sizeof(UAnimNotify_Breach_C2Detonate) == 0x000038, "Wrong size on UAnimNotify_Breach_C2Detonate");

// Class ReadyOrNot.AnimNotify_Breach_C2Placed
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_Breach_C2Placed final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_Breach_C2Placed">();
	}
	static class UAnimNotify_Breach_C2Placed* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_Breach_C2Placed>();
	}
};
static_assert(alignof(UAnimNotify_Breach_C2Placed) == 0x000008, "Wrong alignment on UAnimNotify_Breach_C2Placed");
static_assert(sizeof(UAnimNotify_Breach_C2Placed) == 0x000038, "Wrong size on UAnimNotify_Breach_C2Placed");

// Class ReadyOrNot.BuildingTrigger
// 0x0098 (0x0338 - 0x02A0)
class ABuildingTrigger : public ATriggerBox
{
public:
	int32                                         NumberOfFloors;                                    // 0x02A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bAuto : 1;                                         // 0x02A4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bUniformFloorSpacing : 1;                          // 0x02A4(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_2A5[0x3];                                      // 0x02A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpacingBetweenFloors;                              // 0x02A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2AC[0x4];                                      // 0x02AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 SpacingPerFloor;                                   // 0x02B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class FText                                   BuildingName;                                      // 0x02C0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TMap<int32, class FString>                    FloorNumberToFloorName;                            // 0x02D8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TArray<struct FBuildingFloor>                 GeneratedFloors;                                   // 0x0328(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, Protected, NativeAccessSpecifierProtected)

public:
	void GenerateFloors();
	void OnBuildingEnter(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnBuildingExit(class AActor* OverlappedActor, class AActor* OtherActor);

	struct FVector GetFloorLocation(int32 FloorNumber) const;
	int32 GetFloorNumberFromActorLocation(class AActor* Actor) const;
	bool IsActorOnFloor(class AActor* Actor, int32 FloorNumber) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingTrigger">();
	}
	static class ABuildingTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingTrigger>();
	}
};
static_assert(alignof(ABuildingTrigger) == 0x000008, "Wrong alignment on ABuildingTrigger");
static_assert(sizeof(ABuildingTrigger) == 0x000338, "Wrong size on ABuildingTrigger");
static_assert(offsetof(ABuildingTrigger, NumberOfFloors) == 0x0002A0, "Member 'ABuildingTrigger::NumberOfFloors' has a wrong offset!");
static_assert(offsetof(ABuildingTrigger, SpacingBetweenFloors) == 0x0002A8, "Member 'ABuildingTrigger::SpacingBetweenFloors' has a wrong offset!");
static_assert(offsetof(ABuildingTrigger, SpacingPerFloor) == 0x0002B0, "Member 'ABuildingTrigger::SpacingPerFloor' has a wrong offset!");
static_assert(offsetof(ABuildingTrigger, BuildingName) == 0x0002C0, "Member 'ABuildingTrigger::BuildingName' has a wrong offset!");
static_assert(offsetof(ABuildingTrigger, FloorNumberToFloorName) == 0x0002D8, "Member 'ABuildingTrigger::FloorNumberToFloorName' has a wrong offset!");
static_assert(offsetof(ABuildingTrigger, GeneratedFloors) == 0x000328, "Member 'ABuildingTrigger::GeneratedFloors' has a wrong offset!");

// Class ReadyOrNot.BuildingTrigger_Incrimination
// 0x0010 (0x0348 - 0x0338)
class ABuildingTrigger_Incrimination final : public ABuildingTrigger
{
public:
	TArray<class AIncriminationClueSpawnPoint*>   ClueSpawnPoints;                                   // 0x0338(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingTrigger_Incrimination">();
	}
	static class ABuildingTrigger_Incrimination* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingTrigger_Incrimination>();
	}
};
static_assert(alignof(ABuildingTrigger_Incrimination) == 0x000008, "Wrong alignment on ABuildingTrigger_Incrimination");
static_assert(sizeof(ABuildingTrigger_Incrimination) == 0x000348, "Wrong size on ABuildingTrigger_Incrimination");
static_assert(offsetof(ABuildingTrigger_Incrimination, ClueSpawnPoints) == 0x000338, "Member 'ABuildingTrigger_Incrimination::ClueSpawnPoints' has a wrong offset!");

// Class ReadyOrNot.ReadyOrNotCharMovementComp
// 0x0000 (0x0F50 - 0x0F50)
class UReadyOrNotCharMovementComp final : public UCharacterMovementComponent
{
public:
	bool                                          bHasReplicatedAcceleration;                        // 0x0F48(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F49[0x7];                                      // 0x0F49(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotCharMovementComp">();
	}
	static class UReadyOrNotCharMovementComp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotCharMovementComp>();
	}
};
static_assert(alignof(UReadyOrNotCharMovementComp) == 0x000010, "Wrong alignment on UReadyOrNotCharMovementComp");
static_assert(sizeof(UReadyOrNotCharMovementComp) == 0x000F50, "Wrong size on UReadyOrNotCharMovementComp");
static_assert(offsetof(UReadyOrNotCharMovementComp, bHasReplicatedAcceleration) == 0x000F48, "Member 'UReadyOrNotCharMovementComp::bHasReplicatedAcceleration' has a wrong offset!");

// Class ReadyOrNot.AnimNotify_ChangeBodySocket
// 0x0010 (0x0048 - 0x0038)
class UAnimNotify_ChangeBodySocket final : public UAnimNotify
{
public:
	EItemCategory                                 ItemCategory;                                      // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Socket;                                            // 0x003C(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_ChangeBodySocket">();
	}
	static class UAnimNotify_ChangeBodySocket* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_ChangeBodySocket>();
	}
};
static_assert(alignof(UAnimNotify_ChangeBodySocket) == 0x000008, "Wrong alignment on UAnimNotify_ChangeBodySocket");
static_assert(sizeof(UAnimNotify_ChangeBodySocket) == 0x000048, "Wrong size on UAnimNotify_ChangeBodySocket");
static_assert(offsetof(UAnimNotify_ChangeBodySocket, ItemCategory) == 0x000038, "Member 'UAnimNotify_ChangeBodySocket::ItemCategory' has a wrong offset!");
static_assert(offsetof(UAnimNotify_ChangeBodySocket, Socket) == 0x00003C, "Member 'UAnimNotify_ChangeBodySocket::Socket' has a wrong offset!");

// Class ReadyOrNot.Ladder
// 0x0010 (0x02A8 - 0x0298)
class ALadder final : public AActor
{
public:
	class UBoxComponent*                          BoxCollision;                                      // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   LadderMesh;                                        // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ladder">();
	}
	static class ALadder* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALadder>();
	}
};
static_assert(alignof(ALadder) == 0x000008, "Wrong alignment on ALadder");
static_assert(sizeof(ALadder) == 0x0002A8, "Wrong size on ALadder");
static_assert(offsetof(ALadder, BoxCollision) == 0x000298, "Member 'ALadder::BoxCollision' has a wrong offset!");
static_assert(offsetof(ALadder, LadderMesh) == 0x0002A0, "Member 'ALadder::LadderMesh' has a wrong offset!");

// Class ReadyOrNot.AnimNotify_CollectEvidence
// 0x0008 (0x0040 - 0x0038)
class UAnimNotify_CollectEvidence final : public UAnimNotify
{
public:
	uint8                                         bCollectFinished : 1;                              // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_CollectEvidence">();
	}
	static class UAnimNotify_CollectEvidence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_CollectEvidence>();
	}
};
static_assert(alignof(UAnimNotify_CollectEvidence) == 0x000008, "Wrong alignment on UAnimNotify_CollectEvidence");
static_assert(sizeof(UAnimNotify_CollectEvidence) == 0x000040, "Wrong size on UAnimNotify_CollectEvidence");

// Class ReadyOrNot.AnimNotify_CompleteHeal
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_CompleteHeal final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_CompleteHeal">();
	}
	static class UAnimNotify_CompleteHeal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_CompleteHeal>();
	}
};
static_assert(alignof(UAnimNotify_CompleteHeal) == 0x000008, "Wrong alignment on UAnimNotify_CompleteHeal");
static_assert(sizeof(UAnimNotify_CompleteHeal) == 0x000038, "Wrong size on UAnimNotify_CompleteHeal");

// Class ReadyOrNot.ItemWheelElement
// 0x0110 (0x03D0 - 0x02C0)
class UItemWheelElement : public UUserWidget
{
public:
	uint8                                         Pad_2C0[0x8];                                      // 0x02C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EItemCategory                                 ElementCategory;                                   // 0x02C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C9[0x7];                                      // 0x02C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 ElementImage;                                      // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D8[0x8];                                      // 0x02D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            ElementBrush;                                      // 0x02E0(0x00D0)(Edit, Protected, NativeAccessSpecifierProtected)
	class UTextBlock*                             CounterText;                                       // 0x03B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B8[0x18];                                     // 0x03B8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsSelectable();
	void Selected(bool Selected_0);
	bool ShowCounter();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemWheelElement">();
	}
	static class UItemWheelElement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemWheelElement>();
	}
};
static_assert(alignof(UItemWheelElement) == 0x000010, "Wrong alignment on UItemWheelElement");
static_assert(sizeof(UItemWheelElement) == 0x0003D0, "Wrong size on UItemWheelElement");
static_assert(offsetof(UItemWheelElement, ElementCategory) == 0x0002C8, "Member 'UItemWheelElement::ElementCategory' has a wrong offset!");
static_assert(offsetof(UItemWheelElement, ElementImage) == 0x0002D0, "Member 'UItemWheelElement::ElementImage' has a wrong offset!");
static_assert(offsetof(UItemWheelElement, ElementBrush) == 0x0002E0, "Member 'UItemWheelElement::ElementBrush' has a wrong offset!");
static_assert(offsetof(UItemWheelElement, CounterText) == 0x0003B0, "Member 'UItemWheelElement::CounterText' has a wrong offset!");

// Class ReadyOrNot.ItemWheelMagazineElement
// 0x0030 (0x0400 - 0x03D0)
class UItemWheelMagazineElement final : public UItemWheelElement
{
public:
	uint8                                         Pad_3D0[0x10];                                     // 0x03D0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextBlock*                             MagazineType;                                      // 0x03E0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E8[0x18];                                     // 0x03E8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemWheelMagazineElement">();
	}
	static class UItemWheelMagazineElement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemWheelMagazineElement>();
	}
};
static_assert(alignof(UItemWheelMagazineElement) == 0x000010, "Wrong alignment on UItemWheelMagazineElement");
static_assert(sizeof(UItemWheelMagazineElement) == 0x000400, "Wrong size on UItemWheelMagazineElement");
static_assert(offsetof(UItemWheelMagazineElement, MagazineType) == 0x0003E0, "Member 'UItemWheelMagazineElement::MagazineType' has a wrong offset!");

// Class ReadyOrNot.AnimNotify_DisableWeaponFOV
// 0x0000 (0x0030 - 0x0030)
class UAnimNotify_DisableWeaponFOV final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_DisableWeaponFOV">();
	}
	static class UAnimNotify_DisableWeaponFOV* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_DisableWeaponFOV>();
	}
};
static_assert(alignof(UAnimNotify_DisableWeaponFOV) == 0x000008, "Wrong alignment on UAnimNotify_DisableWeaponFOV");
static_assert(sizeof(UAnimNotify_DisableWeaponFOV) == 0x000030, "Wrong size on UAnimNotify_DisableWeaponFOV");

// Class ReadyOrNot.ItemData
// 0x0410 (0x0440 - 0x0030)
class UItemData final : public UDataAsset
{
public:
	TSoftObjectPtr<class UStaticMesh>             PreArrestCuffsMesh;                                // 0x0030(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ABaseItem>                  NullFacewearClass;                                 // 0x0058(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FWeaponData>                    BluePVPUniquePrimaryWeapons;                       // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FWeaponData>                    RedPVPUniquePrimaryWeapons;                        // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TSubclassOf<class ABaseItem>                  NullItem;                                          // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWeaponAttachment>          NullPrimaryScopeAttachment;                        // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWeaponAttachment>          NullMuzzleAttachment;                              // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWeaponAttachment>          NullOverbarrelAttachment;                          // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWeaponAttachment>          NullUnderbarrelAttachment;                         // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWeaponAttachment>          NullStockAttachment;                               // 0x00A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWeaponAttachment>          NullGripAttachment;                                // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWeaponAttachment>          NullIlluminatorAttachment;                         // 0x00B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWeaponAttachment>          NullAmmunitionAttachment;                          // 0x00C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class ABaseItem>>          DefaultItemsGivenToPlayer;                         // 0x00C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TSubclassOf<class USkinComponent>             FactorySkin;                                       // 0x00D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSavedLoadout>                  DefaultLoadouts;                                   // 0x00E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FSavedCustomization                    DefaultCustomization;                              // 0x00F0(0x0140)(Edit, NativeAccessSpecifierPublic)
	TMap<EEquippingSwat, struct FDefaultCharacterCustomization> DefaultCharacters;                   // 0x0230(0x0050)(Edit, NativeAccessSpecifierPublic)
	struct FSavedCustomization                    TrailerCustomization;                              // 0x0280(0x0140)(Edit, NativeAccessSpecifierPublic)
	TArray<class UCustomizationCharacter*>        TrailerCharacters;                                 // 0x03C0(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class USkinComponent>>     UniformSelection;                                  // 0x03D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FCharacterData>                 CharacterSelection;                                // 0x03E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              DefaultItemImage;                                  // 0x03F0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FText>                           PersonnelNames;                                    // 0x0418(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FText>                           PersonnelDescriptions;                             // 0x0428(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         AttachmentPointsBase;                              // 0x0438(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_43C[0x4];                                      // 0x043C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemData">();
	}
	static class UItemData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemData>();
	}
};
static_assert(alignof(UItemData) == 0x000008, "Wrong alignment on UItemData");
static_assert(sizeof(UItemData) == 0x000440, "Wrong size on UItemData");
static_assert(offsetof(UItemData, PreArrestCuffsMesh) == 0x000030, "Member 'UItemData::PreArrestCuffsMesh' has a wrong offset!");
static_assert(offsetof(UItemData, NullFacewearClass) == 0x000058, "Member 'UItemData::NullFacewearClass' has a wrong offset!");
static_assert(offsetof(UItemData, BluePVPUniquePrimaryWeapons) == 0x000060, "Member 'UItemData::BluePVPUniquePrimaryWeapons' has a wrong offset!");
static_assert(offsetof(UItemData, RedPVPUniquePrimaryWeapons) == 0x000070, "Member 'UItemData::RedPVPUniquePrimaryWeapons' has a wrong offset!");
static_assert(offsetof(UItemData, NullItem) == 0x000080, "Member 'UItemData::NullItem' has a wrong offset!");
static_assert(offsetof(UItemData, NullPrimaryScopeAttachment) == 0x000088, "Member 'UItemData::NullPrimaryScopeAttachment' has a wrong offset!");
static_assert(offsetof(UItemData, NullMuzzleAttachment) == 0x000090, "Member 'UItemData::NullMuzzleAttachment' has a wrong offset!");
static_assert(offsetof(UItemData, NullOverbarrelAttachment) == 0x000098, "Member 'UItemData::NullOverbarrelAttachment' has a wrong offset!");
static_assert(offsetof(UItemData, NullUnderbarrelAttachment) == 0x0000A0, "Member 'UItemData::NullUnderbarrelAttachment' has a wrong offset!");
static_assert(offsetof(UItemData, NullStockAttachment) == 0x0000A8, "Member 'UItemData::NullStockAttachment' has a wrong offset!");
static_assert(offsetof(UItemData, NullGripAttachment) == 0x0000B0, "Member 'UItemData::NullGripAttachment' has a wrong offset!");
static_assert(offsetof(UItemData, NullIlluminatorAttachment) == 0x0000B8, "Member 'UItemData::NullIlluminatorAttachment' has a wrong offset!");
static_assert(offsetof(UItemData, NullAmmunitionAttachment) == 0x0000C0, "Member 'UItemData::NullAmmunitionAttachment' has a wrong offset!");
static_assert(offsetof(UItemData, DefaultItemsGivenToPlayer) == 0x0000C8, "Member 'UItemData::DefaultItemsGivenToPlayer' has a wrong offset!");
static_assert(offsetof(UItemData, FactorySkin) == 0x0000D8, "Member 'UItemData::FactorySkin' has a wrong offset!");
static_assert(offsetof(UItemData, DefaultLoadouts) == 0x0000E0, "Member 'UItemData::DefaultLoadouts' has a wrong offset!");
static_assert(offsetof(UItemData, DefaultCustomization) == 0x0000F0, "Member 'UItemData::DefaultCustomization' has a wrong offset!");
static_assert(offsetof(UItemData, DefaultCharacters) == 0x000230, "Member 'UItemData::DefaultCharacters' has a wrong offset!");
static_assert(offsetof(UItemData, TrailerCustomization) == 0x000280, "Member 'UItemData::TrailerCustomization' has a wrong offset!");
static_assert(offsetof(UItemData, TrailerCharacters) == 0x0003C0, "Member 'UItemData::TrailerCharacters' has a wrong offset!");
static_assert(offsetof(UItemData, UniformSelection) == 0x0003D0, "Member 'UItemData::UniformSelection' has a wrong offset!");
static_assert(offsetof(UItemData, CharacterSelection) == 0x0003E0, "Member 'UItemData::CharacterSelection' has a wrong offset!");
static_assert(offsetof(UItemData, DefaultItemImage) == 0x0003F0, "Member 'UItemData::DefaultItemImage' has a wrong offset!");
static_assert(offsetof(UItemData, PersonnelNames) == 0x000418, "Member 'UItemData::PersonnelNames' has a wrong offset!");
static_assert(offsetof(UItemData, PersonnelDescriptions) == 0x000428, "Member 'UItemData::PersonnelDescriptions' has a wrong offset!");
static_assert(offsetof(UItemData, AttachmentPointsBase) == 0x000438, "Member 'UItemData::AttachmentPointsBase' has a wrong offset!");

// Class ReadyOrNot.AnimNotify_DisarmTrap
// 0x0008 (0x0040 - 0x0038)
class UAnimNotify_DisarmTrap final : public UAnimNotify
{
public:
	uint8                                         bDisarmFinished : 1;                               // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_DisarmTrap">();
	}
	static class UAnimNotify_DisarmTrap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_DisarmTrap>();
	}
};
static_assert(alignof(UAnimNotify_DisarmTrap) == 0x000008, "Wrong alignment on UAnimNotify_DisarmTrap");
static_assert(sizeof(UAnimNotify_DisarmTrap) == 0x000040, "Wrong size on UAnimNotify_DisarmTrap");

// Class ReadyOrNot.AnimNotify_DoorKickBreak
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_DoorKickBreak final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_DoorKickBreak">();
	}
	static class UAnimNotify_DoorKickBreak* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_DoorKickBreak>();
	}
};
static_assert(alignof(UAnimNotify_DoorKickBreak) == 0x000008, "Wrong alignment on UAnimNotify_DoorKickBreak");
static_assert(sizeof(UAnimNotify_DoorKickBreak) == 0x000038, "Wrong size on UAnimNotify_DoorKickBreak");

// Class ReadyOrNot.KingOfTheHostageGM
// 0x0030 (0x0A00 - 0x09D0)
class AKingOfTheHostageGM final : public AReadyOrNotGameMode_PVP
{
public:
	TArray<class APawn*>                          SpawnedHostages;                                   // 0x09D0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_9E0[0x10];                                     // 0x09E0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Start_RoundTime;                                   // 0x09F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlueTeamOnAttack;                                 // 0x09F4(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9F5[0xB];                                      // 0x09F5(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AreAllHostagesSafe();
	class APawn* SpawnHostage(TSubclassOf<class APawn> HostageClass, const TArray<struct FVector>& SpawnLocations);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KingOfTheHostageGM">();
	}
	static class AKingOfTheHostageGM* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKingOfTheHostageGM>();
	}
};
static_assert(alignof(AKingOfTheHostageGM) == 0x000010, "Wrong alignment on AKingOfTheHostageGM");
static_assert(sizeof(AKingOfTheHostageGM) == 0x000A00, "Wrong size on AKingOfTheHostageGM");
static_assert(offsetof(AKingOfTheHostageGM, SpawnedHostages) == 0x0009D0, "Member 'AKingOfTheHostageGM::SpawnedHostages' has a wrong offset!");
static_assert(offsetof(AKingOfTheHostageGM, Start_RoundTime) == 0x0009F0, "Member 'AKingOfTheHostageGM::Start_RoundTime' has a wrong offset!");
static_assert(offsetof(AKingOfTheHostageGM, bBlueTeamOnAttack) == 0x0009F4, "Member 'AKingOfTheHostageGM::bBlueTeamOnAttack' has a wrong offset!");

// Class ReadyOrNot.AnimNotify_DoorKickFailure
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_DoorKickFailure final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_DoorKickFailure">();
	}
	static class UAnimNotify_DoorKickFailure* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_DoorKickFailure>();
	}
};
static_assert(alignof(UAnimNotify_DoorKickFailure) == 0x000008, "Wrong alignment on UAnimNotify_DoorKickFailure");
static_assert(sizeof(UAnimNotify_DoorKickFailure) == 0x000038, "Wrong size on UAnimNotify_DoorKickFailure");

// Class ReadyOrNot.AnimNotify_EquipItemOfClass
// 0x0010 (0x0048 - 0x0038)
class UAnimNotify_EquipItemOfClass final : public UAnimNotify
{
public:
	TSubclassOf<class ABaseItem>                  ItemClass;                                         // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bInstant : 1;                                      // 0x0040(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bAIOnly : 1;                                       // 0x0040(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_EquipItemOfClass">();
	}
	static class UAnimNotify_EquipItemOfClass* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_EquipItemOfClass>();
	}
};
static_assert(alignof(UAnimNotify_EquipItemOfClass) == 0x000008, "Wrong alignment on UAnimNotify_EquipItemOfClass");
static_assert(sizeof(UAnimNotify_EquipItemOfClass) == 0x000048, "Wrong size on UAnimNotify_EquipItemOfClass");
static_assert(offsetof(UAnimNotify_EquipItemOfClass, ItemClass) == 0x000038, "Member 'UAnimNotify_EquipItemOfClass::ItemClass' has a wrong offset!");

// Class ReadyOrNot.LightAttachmentSpotLight
// 0x0000 (0x0430 - 0x0430)
class ULightAttachmentSpotLight : public USpotLightComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LightAttachmentSpotLight">();
	}
	static class ULightAttachmentSpotLight* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULightAttachmentSpotLight>();
	}
};
static_assert(alignof(ULightAttachmentSpotLight) == 0x000010, "Wrong alignment on ULightAttachmentSpotLight");
static_assert(sizeof(ULightAttachmentSpotLight) == 0x000430, "Wrong size on ULightAttachmentSpotLight");

// Class ReadyOrNot.AnimNotify_EquipLastItem
// 0x0008 (0x0040 - 0x0038)
class UAnimNotify_EquipLastItem final : public UAnimNotify
{
public:
	uint8                                         bInstant : 1;                                      // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_EquipLastItem">();
	}
	static class UAnimNotify_EquipLastItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_EquipLastItem>();
	}
};
static_assert(alignof(UAnimNotify_EquipLastItem) == 0x000008, "Wrong alignment on UAnimNotify_EquipLastItem");
static_assert(sizeof(UAnimNotify_EquipLastItem) == 0x000040, "Wrong size on UAnimNotify_EquipLastItem");

// Class ReadyOrNot.AnimNotify_ForceFireWeapon
// 0x0008 (0x0040 - 0x0038)
class UAnimNotify_ForceFireWeapon final : public UAnimNotify
{
public:
	float                                         Chance;                                            // 0x0038(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNoEnemyRequired;                                  // 0x003C(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_ForceFireWeapon">();
	}
	static class UAnimNotify_ForceFireWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_ForceFireWeapon>();
	}
};
static_assert(alignof(UAnimNotify_ForceFireWeapon) == 0x000008, "Wrong alignment on UAnimNotify_ForceFireWeapon");
static_assert(sizeof(UAnimNotify_ForceFireWeapon) == 0x000040, "Wrong size on UAnimNotify_ForceFireWeapon");
static_assert(offsetof(UAnimNotify_ForceFireWeapon, Chance) == 0x000038, "Member 'UAnimNotify_ForceFireWeapon::Chance' has a wrong offset!");
static_assert(offsetof(UAnimNotify_ForceFireWeapon, bNoEnemyRequired) == 0x00003C, "Member 'UAnimNotify_ForceFireWeapon::bNoEnemyRequired' has a wrong offset!");

// Class ReadyOrNot.WeaponAttachment
// 0x0130 (0x10D0 - 0x0FA0)
class UWeaponAttachment : public USkeletalMeshComponent
{
public:
	TArray<class UMaterialInstanceDynamic*>       SkinMaterials;                                     // 0x0FA0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	EWeaponAttachmentType                         WeaponAttachmentType;                              // 0x0FB0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FB1[0x7];                                      // 0x0FB1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EWeaponAttachmentType>                 RemovesWeaponAttachmentTypes;                      // 0x0FB8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	EWeaponUnderbarrelAnimationType               UnderbarrelAnimationType;                          // 0x0FC8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeedNotAttach;                                    // 0x0FC9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNullAttachmentOnly;                               // 0x0FCA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FCB[0x1];                                      // 0x0FCB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SocketAttachment;                                  // 0x0FCC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FD4[0x4];                                      // 0x0FD4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ItemName;                                          // 0x0FD8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         PointCost;                                         // 0x0FF0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FF4[0x4];                                      // 0x0FF4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttachmentUIElements                  UIElements;                                        // 0x0FF8(0x0078)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<EItemAttachment>                       AdditionalAttachments;                             // 0x1070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         AttachmentWeight;                                  // 0x1080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VerticalRecoilMultiplier;                          // 0x1084(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HorizontalRecoilMultiplier;                        // 0x1088(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpreadMultiplier;                                  // 0x108C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeadzoneMultiplier;                                // 0x1090(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MuzzleVelocityMultiplier;                          // 0x1094(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LowReadyLengthMultiplier;                          // 0x1098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldSupressWeapon;                              // 0x109C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHidesMuzzleFlash;                                 // 0x109D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideMuzzleFlash;                              // 0x109E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_109F[0x1];                                     // 0x109F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        MuzzleFlashParticle;                               // 0x10A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        MuzzleSmokeParticle;                               // 0x10A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10B0[0x4];                                     // 0x10B0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MagazineAmmoIncrease;                              // 0x10B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HideBoneOnMesh;                                    // 0x10B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraBobAdditionFactor;                           // 0x10C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ADS_Speed_Multiplier;                              // 0x10C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             ToggleSound;                                       // 0x10C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ApplyWetness(float Wetness, float RainAmount);
	void PlayToggleSound();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponAttachment">();
	}
	static class UWeaponAttachment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponAttachment>();
	}
};
static_assert(alignof(UWeaponAttachment) == 0x000010, "Wrong alignment on UWeaponAttachment");
static_assert(sizeof(UWeaponAttachment) == 0x0010D0, "Wrong size on UWeaponAttachment");
static_assert(offsetof(UWeaponAttachment, SkinMaterials) == 0x000FA0, "Member 'UWeaponAttachment::SkinMaterials' has a wrong offset!");
static_assert(offsetof(UWeaponAttachment, WeaponAttachmentType) == 0x000FB0, "Member 'UWeaponAttachment::WeaponAttachmentType' has a wrong offset!");
static_assert(offsetof(UWeaponAttachment, RemovesWeaponAttachmentTypes) == 0x000FB8, "Member 'UWeaponAttachment::RemovesWeaponAttachmentTypes' has a wrong offset!");
static_assert(offsetof(UWeaponAttachment, UnderbarrelAnimationType) == 0x000FC8, "Member 'UWeaponAttachment::UnderbarrelAnimationType' has a wrong offset!");
static_assert(offsetof(UWeaponAttachment, bNeedNotAttach) == 0x000FC9, "Member 'UWeaponAttachment::bNeedNotAttach' has a wrong offset!");
static_assert(offsetof(UWeaponAttachment, bNullAttachmentOnly) == 0x000FCA, "Member 'UWeaponAttachment::bNullAttachmentOnly' has a wrong offset!");
static_assert(offsetof(UWeaponAttachment, SocketAttachment) == 0x000FCC, "Member 'UWeaponAttachment::SocketAttachment' has a wrong offset!");
static_assert(offsetof(UWeaponAttachment, ItemName) == 0x000FD8, "Member 'UWeaponAttachment::ItemName' has a wrong offset!");
static_assert(offsetof(UWeaponAttachment, PointCost) == 0x000FF0, "Member 'UWeaponAttachment::PointCost' has a wrong offset!");
static_assert(offsetof(UWeaponAttachment, UIElements) == 0x000FF8, "Member 'UWeaponAttachment::UIElements' has a wrong offset!");
static_assert(offsetof(UWeaponAttachment, AdditionalAttachments) == 0x001070, "Member 'UWeaponAttachment::AdditionalAttachments' has a wrong offset!");
static_assert(offsetof(UWeaponAttachment, AttachmentWeight) == 0x001080, "Member 'UWeaponAttachment::AttachmentWeight' has a wrong offset!");
static_assert(offsetof(UWeaponAttachment, VerticalRecoilMultiplier) == 0x001084, "Member 'UWeaponAttachment::VerticalRecoilMultiplier' has a wrong offset!");
static_assert(offsetof(UWeaponAttachment, HorizontalRecoilMultiplier) == 0x001088, "Member 'UWeaponAttachment::HorizontalRecoilMultiplier' has a wrong offset!");
static_assert(offsetof(UWeaponAttachment, SpreadMultiplier) == 0x00108C, "Member 'UWeaponAttachment::SpreadMultiplier' has a wrong offset!");
static_assert(offsetof(UWeaponAttachment, DeadzoneMultiplier) == 0x001090, "Member 'UWeaponAttachment::DeadzoneMultiplier' has a wrong offset!");
static_assert(offsetof(UWeaponAttachment, MuzzleVelocityMultiplier) == 0x001094, "Member 'UWeaponAttachment::MuzzleVelocityMultiplier' has a wrong offset!");
static_assert(offsetof(UWeaponAttachment, LowReadyLengthMultiplier) == 0x001098, "Member 'UWeaponAttachment::LowReadyLengthMultiplier' has a wrong offset!");
static_assert(offsetof(UWeaponAttachment, bShouldSupressWeapon) == 0x00109C, "Member 'UWeaponAttachment::bShouldSupressWeapon' has a wrong offset!");
static_assert(offsetof(UWeaponAttachment, bHidesMuzzleFlash) == 0x00109D, "Member 'UWeaponAttachment::bHidesMuzzleFlash' has a wrong offset!");
static_assert(offsetof(UWeaponAttachment, bOverrideMuzzleFlash) == 0x00109E, "Member 'UWeaponAttachment::bOverrideMuzzleFlash' has a wrong offset!");
static_assert(offsetof(UWeaponAttachment, MuzzleFlashParticle) == 0x0010A0, "Member 'UWeaponAttachment::MuzzleFlashParticle' has a wrong offset!");
static_assert(offsetof(UWeaponAttachment, MuzzleSmokeParticle) == 0x0010A8, "Member 'UWeaponAttachment::MuzzleSmokeParticle' has a wrong offset!");
static_assert(offsetof(UWeaponAttachment, MagazineAmmoIncrease) == 0x0010B4, "Member 'UWeaponAttachment::MagazineAmmoIncrease' has a wrong offset!");
static_assert(offsetof(UWeaponAttachment, HideBoneOnMesh) == 0x0010B8, "Member 'UWeaponAttachment::HideBoneOnMesh' has a wrong offset!");
static_assert(offsetof(UWeaponAttachment, CameraBobAdditionFactor) == 0x0010C0, "Member 'UWeaponAttachment::CameraBobAdditionFactor' has a wrong offset!");
static_assert(offsetof(UWeaponAttachment, ADS_Speed_Multiplier) == 0x0010C4, "Member 'UWeaponAttachment::ADS_Speed_Multiplier' has a wrong offset!");
static_assert(offsetof(UWeaponAttachment, ToggleSound) == 0x0010C8, "Member 'UWeaponAttachment::ToggleSound' has a wrong offset!");

// Class ReadyOrNot.AnimNotify_ForceRagdoll
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_ForceRagdoll final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_ForceRagdoll">();
	}
	static class UAnimNotify_ForceRagdoll* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_ForceRagdoll>();
	}
};
static_assert(alignof(UAnimNotify_ForceRagdoll) == 0x000008, "Wrong alignment on UAnimNotify_ForceRagdoll");
static_assert(sizeof(UAnimNotify_ForceRagdoll) == 0x000038, "Wrong size on UAnimNotify_ForceRagdoll");

// Class ReadyOrNot.KingOfTheHillGM
// 0x0040 (0x0A10 - 0x09D0)
class AKingOfTheHillGM final : public AReadyOrNotGameMode_PVP
{
public:
	TArray<class APlayerCharacter*>               ArrestedBlueCharacters;                            // 0x09D0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class APlayerCharacter*>               ArrestedRedCharacters;                             // 0x09E0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class UFMODEvent*                             TOWVictorySound;                                   // 0x09F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             MatchLoopMusic;                                    // 0x09F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             MatchStartMusic;                                   // 0x0A00(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             MatchEndMusic;                                     // 0x0A08(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KingOfTheHillGM">();
	}
	static class AKingOfTheHillGM* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKingOfTheHillGM>();
	}
};
static_assert(alignof(AKingOfTheHillGM) == 0x000010, "Wrong alignment on AKingOfTheHillGM");
static_assert(sizeof(AKingOfTheHillGM) == 0x000A10, "Wrong size on AKingOfTheHillGM");
static_assert(offsetof(AKingOfTheHillGM, ArrestedBlueCharacters) == 0x0009D0, "Member 'AKingOfTheHillGM::ArrestedBlueCharacters' has a wrong offset!");
static_assert(offsetof(AKingOfTheHillGM, ArrestedRedCharacters) == 0x0009E0, "Member 'AKingOfTheHillGM::ArrestedRedCharacters' has a wrong offset!");
static_assert(offsetof(AKingOfTheHillGM, TOWVictorySound) == 0x0009F0, "Member 'AKingOfTheHillGM::TOWVictorySound' has a wrong offset!");
static_assert(offsetof(AKingOfTheHillGM, MatchLoopMusic) == 0x0009F8, "Member 'AKingOfTheHillGM::MatchLoopMusic' has a wrong offset!");
static_assert(offsetof(AKingOfTheHillGM, MatchStartMusic) == 0x000A00, "Member 'AKingOfTheHillGM::MatchStartMusic' has a wrong offset!");
static_assert(offsetof(AKingOfTheHillGM, MatchEndMusic) == 0x000A08, "Member 'AKingOfTheHillGM::MatchEndMusic' has a wrong offset!");

// Class ReadyOrNot.AnimNotify_ItemSwitchSocket
// 0x0008 (0x0040 - 0x0038)
class UAnimNotify_ItemSwitchSocket final : public UAnimNotify
{
public:
	EItemSocket                                   DesiredItemSocket;                                 // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_ItemSwitchSocket">();
	}
	static class UAnimNotify_ItemSwitchSocket* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_ItemSwitchSocket>();
	}
};
static_assert(alignof(UAnimNotify_ItemSwitchSocket) == 0x000008, "Wrong alignment on UAnimNotify_ItemSwitchSocket");
static_assert(sizeof(UAnimNotify_ItemSwitchSocket) == 0x000040, "Wrong size on UAnimNotify_ItemSwitchSocket");
static_assert(offsetof(UAnimNotify_ItemSwitchSocket, DesiredItemSocket) == 0x000038, "Member 'UAnimNotify_ItemSwitchSocket::DesiredItemSocket' has a wrong offset!");

// Class ReadyOrNot.AnimNotify_KillMyself
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_KillMyself final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_KillMyself">();
	}
	static class UAnimNotify_KillMyself* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_KillMyself>();
	}
};
static_assert(alignof(UAnimNotify_KillMyself) == 0x000008, "Wrong alignment on UAnimNotify_KillMyself");
static_assert(sizeof(UAnimNotify_KillMyself) == 0x000038, "Wrong size on UAnimNotify_KillMyself");

// Class ReadyOrNot.ModLevelData
// 0x0828 (0x0858 - 0x0030)
class UModLevelData final : public UPrimaryDataAsset
{
public:
	class FName                                   LevelName;                                         // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowInMissionSelect;                              // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLevelDataLookupTable                  Data;                                              // 0x0040(0x0818)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ModLevelData">();
	}
	static class UModLevelData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UModLevelData>();
	}
};
static_assert(alignof(UModLevelData) == 0x000008, "Wrong alignment on UModLevelData");
static_assert(sizeof(UModLevelData) == 0x000858, "Wrong size on UModLevelData");
static_assert(offsetof(UModLevelData, LevelName) == 0x000030, "Member 'UModLevelData::LevelName' has a wrong offset!");
static_assert(offsetof(UModLevelData, bShowInMissionSelect) == 0x000038, "Member 'UModLevelData::bShowInMissionSelect' has a wrong offset!");
static_assert(offsetof(UModLevelData, Data) == 0x000040, "Member 'UModLevelData::Data' has a wrong offset!");

// Class ReadyOrNot.AnimNotify_LockPickDoor
// 0x0008 (0x0040 - 0x0038)
class UAnimNotify_LockPickDoor final : public UAnimNotify
{
public:
	uint8                                         bLockPickFinished : 1;                             // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_LockPickDoor">();
	}
	static class UAnimNotify_LockPickDoor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_LockPickDoor>();
	}
};
static_assert(alignof(UAnimNotify_LockPickDoor) == 0x000008, "Wrong alignment on UAnimNotify_LockPickDoor");
static_assert(sizeof(UAnimNotify_LockPickDoor) == 0x000040, "Wrong size on UAnimNotify_LockPickDoor");

// Class ReadyOrNot.LoadingScreen
// 0x00F0 (0x0500 - 0x0410)
class ULoadingScreen : public UCommonActivatableWidget
{
public:
	uint8                                         Pad_410[0x8];                                      // 0x0410(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ULevelStreaming*                        StreamedLevel;                                     // 0x0418(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_420[0xD0];                                     // 0x0420(0x00D0)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 FriendlyLevelName;                                 // 0x04F0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	float GetLoadingPercentage();
	void GetLoadingScreenDetails(class FString* OutMap, class FString* OutMode, class FString* OutSessionName);
	class FString GetMapName();
	void SetLoadingScreen(const class FString& InMap, const class FString& InMode, const class FString& InSessionName, bool bSeamlessTravel);
	void UpdateTip(class UTextBlock* TipBlock);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadingScreen">();
	}
	static class ULoadingScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadingScreen>();
	}
};
static_assert(alignof(ULoadingScreen) == 0x000008, "Wrong alignment on ULoadingScreen");
static_assert(sizeof(ULoadingScreen) == 0x000500, "Wrong size on ULoadingScreen");
static_assert(offsetof(ULoadingScreen, StreamedLevel) == 0x000418, "Member 'ULoadingScreen::StreamedLevel' has a wrong offset!");
static_assert(offsetof(ULoadingScreen, FriendlyLevelName) == 0x0004F0, "Member 'ULoadingScreen::FriendlyLevelName' has a wrong offset!");

// Class ReadyOrNot.AnimNotify_NextMag
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_NextMag final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_NextMag">();
	}
	static class UAnimNotify_NextMag* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_NextMag>();
	}
};
static_assert(alignof(UAnimNotify_NextMag) == 0x000008, "Wrong alignment on UAnimNotify_NextMag");
static_assert(sizeof(UAnimNotify_NextMag) == 0x000038, "Wrong size on UAnimNotify_NextMag");

// Class ReadyOrNot.AnimNotify_OnCheckedDoor
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_OnCheckedDoor final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_OnCheckedDoor">();
	}
	static class UAnimNotify_OnCheckedDoor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_OnCheckedDoor>();
	}
};
static_assert(alignof(UAnimNotify_OnCheckedDoor) == 0x000008, "Wrong alignment on UAnimNotify_OnCheckedDoor");
static_assert(sizeof(UAnimNotify_OnCheckedDoor) == 0x000038, "Wrong size on UAnimNotify_OnCheckedDoor");

// Class ReadyOrNot.LightAttachment
// 0x0120 (0x11F0 - 0x10D0)
class ULightAttachment : public UWeaponAttachment
{
public:
	TSubclassOf<class ULightAttachmentSpotLight>  SpotLightClass;                                    // 0x10D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ULightAttachmentPointLight> PointLightClass;                                   // 0x10D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USpotLightComponent*                    SpotLightComponent;                                // 0x10E0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPointLightComponent*                   PointLightComponent;                               // 0x10E8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRepOn;                                            // 0x10F0(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10F1[0x7];                                     // 0x10F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Intensity;                                         // 0x10F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BouncedIntensity;                                  // 0x10FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Attenuation;                                       // 0x1100(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InnerConeAngle;                                    // 0x1104(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OuterConeAngle;                                    // 0x1108(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           LightColor;                                        // 0x110C(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_111C[0x4];                                     // 0x111C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     LightFunctionMaterial;                             // 0x1120(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LightFunctionScale;                                // 0x1128(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ALensFlare>                 LensFlareClass;                                    // 0x1140(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALensFlare*                             SpawnedLensFlare;                                  // 0x1148(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumOfFlashLightTrackingPoints;                     // 0x1150(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1154[0x4];                                     // 0x1154(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AFlashLightTrackingPoint*>       FlashLightTrackingPoints;                          // 0x1158(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, UObjectWrapper, NativeAccessSpecifierPublic)
	class AFlashLightTrackingPoint*               PrimaryTrackingPoint;                              // 0x1168(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1170[0x80];                                    // 0x1170(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsLightOn();
	void OnRep_On();
	void ToggleLight(bool bOn);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LightAttachment">();
	}
	static class ULightAttachment* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULightAttachment>();
	}
};
static_assert(alignof(ULightAttachment) == 0x000010, "Wrong alignment on ULightAttachment");
static_assert(sizeof(ULightAttachment) == 0x0011F0, "Wrong size on ULightAttachment");
static_assert(offsetof(ULightAttachment, SpotLightClass) == 0x0010D0, "Member 'ULightAttachment::SpotLightClass' has a wrong offset!");
static_assert(offsetof(ULightAttachment, PointLightClass) == 0x0010D8, "Member 'ULightAttachment::PointLightClass' has a wrong offset!");
static_assert(offsetof(ULightAttachment, SpotLightComponent) == 0x0010E0, "Member 'ULightAttachment::SpotLightComponent' has a wrong offset!");
static_assert(offsetof(ULightAttachment, PointLightComponent) == 0x0010E8, "Member 'ULightAttachment::PointLightComponent' has a wrong offset!");
static_assert(offsetof(ULightAttachment, bRepOn) == 0x0010F0, "Member 'ULightAttachment::bRepOn' has a wrong offset!");
static_assert(offsetof(ULightAttachment, Intensity) == 0x0010F8, "Member 'ULightAttachment::Intensity' has a wrong offset!");
static_assert(offsetof(ULightAttachment, BouncedIntensity) == 0x0010FC, "Member 'ULightAttachment::BouncedIntensity' has a wrong offset!");
static_assert(offsetof(ULightAttachment, Attenuation) == 0x001100, "Member 'ULightAttachment::Attenuation' has a wrong offset!");
static_assert(offsetof(ULightAttachment, InnerConeAngle) == 0x001104, "Member 'ULightAttachment::InnerConeAngle' has a wrong offset!");
static_assert(offsetof(ULightAttachment, OuterConeAngle) == 0x001108, "Member 'ULightAttachment::OuterConeAngle' has a wrong offset!");
static_assert(offsetof(ULightAttachment, LightColor) == 0x00110C, "Member 'ULightAttachment::LightColor' has a wrong offset!");
static_assert(offsetof(ULightAttachment, LightFunctionMaterial) == 0x001120, "Member 'ULightAttachment::LightFunctionMaterial' has a wrong offset!");
static_assert(offsetof(ULightAttachment, LightFunctionScale) == 0x001128, "Member 'ULightAttachment::LightFunctionScale' has a wrong offset!");
static_assert(offsetof(ULightAttachment, LensFlareClass) == 0x001140, "Member 'ULightAttachment::LensFlareClass' has a wrong offset!");
static_assert(offsetof(ULightAttachment, SpawnedLensFlare) == 0x001148, "Member 'ULightAttachment::SpawnedLensFlare' has a wrong offset!");
static_assert(offsetof(ULightAttachment, NumOfFlashLightTrackingPoints) == 0x001150, "Member 'ULightAttachment::NumOfFlashLightTrackingPoints' has a wrong offset!");
static_assert(offsetof(ULightAttachment, FlashLightTrackingPoints) == 0x001158, "Member 'ULightAttachment::FlashLightTrackingPoints' has a wrong offset!");
static_assert(offsetof(ULightAttachment, PrimaryTrackingPoint) == 0x001168, "Member 'ULightAttachment::PrimaryTrackingPoint' has a wrong offset!");

// Class ReadyOrNot.AnimNotify_OnLandmarkProxyUse
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_OnLandmarkProxyUse final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_OnLandmarkProxyUse">();
	}
	static class UAnimNotify_OnLandmarkProxyUse* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_OnLandmarkProxyUse>();
	}
};
static_assert(alignof(UAnimNotify_OnLandmarkProxyUse) == 0x000008, "Wrong alignment on UAnimNotify_OnLandmarkProxyUse");
static_assert(sizeof(UAnimNotify_OnLandmarkProxyUse) == 0x000038, "Wrong size on UAnimNotify_OnLandmarkProxyUse");

// Class ReadyOrNot.AnimNotify_PickupItemComplete
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_PickupItemComplete final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_PickupItemComplete">();
	}
	static class UAnimNotify_PickupItemComplete* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_PickupItemComplete>();
	}
};
static_assert(alignof(UAnimNotify_PickupItemComplete) == 0x000008, "Wrong alignment on UAnimNotify_PickupItemComplete");
static_assert(sizeof(UAnimNotify_PickupItemComplete) == 0x000038, "Wrong size on UAnimNotify_PickupItemComplete");

// Class ReadyOrNot.LensFlare
// 0x02E0 (0x0578 - 0x0298)
class ALensFlare : public AActor
{
public:
	class USceneComponent*                        Scene;                                             // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialBillboardComponent*            LensFlare;                                         // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AReadyOrNotCharacter*                   OwningCharacter;                                   // 0x02A8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     FlareMat;                                          // 0x02B0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              BaseSize;                                          // 0x02B8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinimumRotationDeltaToBeVisible;                   // 0x02C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CC[0x4];                                      // 0x02CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               FlareMatInstance;                                  // 0x02D0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D8[0x4];                                      // 0x02D8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GlobalBrightness;                                  // 0x02DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GhostsBrightness;                                  // 0x02E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FlickerIntensity;                                  // 0x02E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FlickerTime;                                       // 0x02E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           GlobalColor;                                       // 0x02EC(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FadeDistance;                                      // 0x02FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseFadeDistance;                                  // 0x0300(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_301[0x3];                                      // 0x0301(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IncreasingBloomByDistance;                         // 0x0304(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseDistanceBloom;                                 // 0x0308(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_309[0x3];                                      // 0x0309(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HaloOpacity;                                       // 0x030C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HaloInnerRadius;                                   // 0x0310(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HaloBrightness;                                    // 0x0314(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           HaloOuterColor;                                    // 0x0318(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           HaloInnerColor;                                    // 0x0328(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture*                               HaloTexture;                                       // 0x0338(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HaloTextureSize;                                   // 0x0340(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HaloContrast;                                      // 0x0344(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CentreFlareBrightness;                             // 0x0348(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34C[0x4];                                      // 0x034C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture*                               CentreFlareTexture;                                // 0x0350(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           CentreFlareColor;                                  // 0x0358(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CentreFlareSize;                                   // 0x0368(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CentreFlareContrast;                               // 0x036C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MainFlareBrightness;                               // 0x0370(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_374[0x4];                                      // 0x0374(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture*                               MainFlare;                                         // 0x0378(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MainFlareInnerRadius;                              // 0x0380(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           MainOuterColor;                                    // 0x0384(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           MainLensInnerColor;                                // 0x0394(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MainFlareSize;                                     // 0x03A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MainFlareContrast;                                 // 0x03A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReflectionSize;                                    // 0x03AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture*                               ReflectionCentreTexture;                           // 0x03B0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           ReflectionColor;                                   // 0x03B8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReflectionBrightness;                              // 0x03C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReflectionContrast;                                // 0x03CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OppositeFlaresAxisProjection;                      // 0x03D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FlareOppositeSize01;                               // 0x03D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FlareOppositeSize02;                               // 0x03D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           FlareOppositeColor01;                              // 0x03DC(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           FlareOppositeColor02;                              // 0x03EC(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FlareOppositeBrightness01;                         // 0x03FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FlareOppositeBrightness02;                         // 0x0400(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FlareOppositeContrast01;                           // 0x0404(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FlareOppositeContrast02;                           // 0x0408(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_40C[0x4];                                      // 0x040C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture*                               FlareOpposite01;                                   // 0x0410(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture*                               FlareOpposite02;                                   // 0x0418(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FrontFlaresAxisProjection;                         // 0x0420(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FlareFrontSize01;                                  // 0x0424(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FlareFrontSize02;                                  // 0x0428(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           FlareFrontColor01;                                 // 0x042C(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           FlareFrontColor02;                                 // 0x043C(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FlareFrontProximityCentre01;                       // 0x044C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FlareFrontProximityCentre02;                       // 0x0450(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_454[0x4];                                      // 0x0454(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture*                               FlareFront01;                                      // 0x0458(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture*                               FlareFront02;                                      // 0x0460(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FlareFrontContrast01;                              // 0x0468(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FlareFrontContrast02;                              // 0x046C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FlareFrontBrightness01;                            // 0x0470(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FlareFrontBrightness02;                            // 0x0474(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReflectedFlareSize01;                              // 0x0478(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReflectedFlareSize02;                              // 0x047C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReflectedFlareProximityCentre01;                   // 0x0480(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReflectedFlareProximityCentre02;                   // 0x0484(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture*                               ReflectedFlare01;                                  // 0x0488(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture*                               ReflectedFlare02;                                  // 0x0490(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           ReflectedFlareColor01;                             // 0x0498(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           ReflectedFlareColor02;                             // 0x04A8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReflectedFlareContrast01;                          // 0x04B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReflectedFlareContrast02;                          // 0x04BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReflectedFlareBrightness01;                        // 0x04C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReflectedFlareBrightness02;                        // 0x04C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinorFlareProximityCentre01;                       // 0x04C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinorFlareSize01;                                  // 0x04CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinorFlareSizeRandom01;                            // 0x04D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D4[0x4];                                      // 0x04D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture*                               MinorFlare01;                                      // 0x04D8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           MinorFlareColor01;                                 // 0x04E0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinorFlareContrast01;                              // 0x04F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinorFlareBrightness01;                            // 0x04F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           MinorFlareColor02;                                 // 0x04F8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinorFlareContrast02;                              // 0x0508(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinorFlareBrightness02;                            // 0x050C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinorFlareProximityCentre02;                       // 0x0510(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinorFlareSize02;                                  // 0x0514(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinorFlareSizeRandom02;                            // 0x0518(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_51C[0x4];                                      // 0x051C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture*                               MinorFlare02;                                      // 0x0520(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture*                               Iris;                                              // 0x0528(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IrisSize;                                          // 0x0530(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IrisProximityCentre;                               // 0x0534(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IrisBrightness;                                    // 0x0538(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IrisContrast;                                      // 0x053C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           IrisColor;                                         // 0x0540(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture*                               AdditionalFlare;                                   // 0x0550(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AdditionalFlareSize;                               // 0x0558(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AdditionalFlareContrast;                           // 0x055C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AdditionalFlareBrightness;                         // 0x0560(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           AdditionalFlareColor;                              // 0x0564(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_574[0x4];                                      // 0x0574(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LensFlare">();
	}
	static class ALensFlare* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALensFlare>();
	}
};
static_assert(alignof(ALensFlare) == 0x000008, "Wrong alignment on ALensFlare");
static_assert(sizeof(ALensFlare) == 0x000578, "Wrong size on ALensFlare");
static_assert(offsetof(ALensFlare, Scene) == 0x000298, "Member 'ALensFlare::Scene' has a wrong offset!");
static_assert(offsetof(ALensFlare, LensFlare) == 0x0002A0, "Member 'ALensFlare::LensFlare' has a wrong offset!");
static_assert(offsetof(ALensFlare, OwningCharacter) == 0x0002A8, "Member 'ALensFlare::OwningCharacter' has a wrong offset!");
static_assert(offsetof(ALensFlare, FlareMat) == 0x0002B0, "Member 'ALensFlare::FlareMat' has a wrong offset!");
static_assert(offsetof(ALensFlare, BaseSize) == 0x0002B8, "Member 'ALensFlare::BaseSize' has a wrong offset!");
static_assert(offsetof(ALensFlare, MinimumRotationDeltaToBeVisible) == 0x0002C8, "Member 'ALensFlare::MinimumRotationDeltaToBeVisible' has a wrong offset!");
static_assert(offsetof(ALensFlare, FlareMatInstance) == 0x0002D0, "Member 'ALensFlare::FlareMatInstance' has a wrong offset!");
static_assert(offsetof(ALensFlare, GlobalBrightness) == 0x0002DC, "Member 'ALensFlare::GlobalBrightness' has a wrong offset!");
static_assert(offsetof(ALensFlare, GhostsBrightness) == 0x0002E0, "Member 'ALensFlare::GhostsBrightness' has a wrong offset!");
static_assert(offsetof(ALensFlare, FlickerIntensity) == 0x0002E4, "Member 'ALensFlare::FlickerIntensity' has a wrong offset!");
static_assert(offsetof(ALensFlare, FlickerTime) == 0x0002E8, "Member 'ALensFlare::FlickerTime' has a wrong offset!");
static_assert(offsetof(ALensFlare, GlobalColor) == 0x0002EC, "Member 'ALensFlare::GlobalColor' has a wrong offset!");
static_assert(offsetof(ALensFlare, FadeDistance) == 0x0002FC, "Member 'ALensFlare::FadeDistance' has a wrong offset!");
static_assert(offsetof(ALensFlare, bUseFadeDistance) == 0x000300, "Member 'ALensFlare::bUseFadeDistance' has a wrong offset!");
static_assert(offsetof(ALensFlare, IncreasingBloomByDistance) == 0x000304, "Member 'ALensFlare::IncreasingBloomByDistance' has a wrong offset!");
static_assert(offsetof(ALensFlare, bUseDistanceBloom) == 0x000308, "Member 'ALensFlare::bUseDistanceBloom' has a wrong offset!");
static_assert(offsetof(ALensFlare, HaloOpacity) == 0x00030C, "Member 'ALensFlare::HaloOpacity' has a wrong offset!");
static_assert(offsetof(ALensFlare, HaloInnerRadius) == 0x000310, "Member 'ALensFlare::HaloInnerRadius' has a wrong offset!");
static_assert(offsetof(ALensFlare, HaloBrightness) == 0x000314, "Member 'ALensFlare::HaloBrightness' has a wrong offset!");
static_assert(offsetof(ALensFlare, HaloOuterColor) == 0x000318, "Member 'ALensFlare::HaloOuterColor' has a wrong offset!");
static_assert(offsetof(ALensFlare, HaloInnerColor) == 0x000328, "Member 'ALensFlare::HaloInnerColor' has a wrong offset!");
static_assert(offsetof(ALensFlare, HaloTexture) == 0x000338, "Member 'ALensFlare::HaloTexture' has a wrong offset!");
static_assert(offsetof(ALensFlare, HaloTextureSize) == 0x000340, "Member 'ALensFlare::HaloTextureSize' has a wrong offset!");
static_assert(offsetof(ALensFlare, HaloContrast) == 0x000344, "Member 'ALensFlare::HaloContrast' has a wrong offset!");
static_assert(offsetof(ALensFlare, CentreFlareBrightness) == 0x000348, "Member 'ALensFlare::CentreFlareBrightness' has a wrong offset!");
static_assert(offsetof(ALensFlare, CentreFlareTexture) == 0x000350, "Member 'ALensFlare::CentreFlareTexture' has a wrong offset!");
static_assert(offsetof(ALensFlare, CentreFlareColor) == 0x000358, "Member 'ALensFlare::CentreFlareColor' has a wrong offset!");
static_assert(offsetof(ALensFlare, CentreFlareSize) == 0x000368, "Member 'ALensFlare::CentreFlareSize' has a wrong offset!");
static_assert(offsetof(ALensFlare, CentreFlareContrast) == 0x00036C, "Member 'ALensFlare::CentreFlareContrast' has a wrong offset!");
static_assert(offsetof(ALensFlare, MainFlareBrightness) == 0x000370, "Member 'ALensFlare::MainFlareBrightness' has a wrong offset!");
static_assert(offsetof(ALensFlare, MainFlare) == 0x000378, "Member 'ALensFlare::MainFlare' has a wrong offset!");
static_assert(offsetof(ALensFlare, MainFlareInnerRadius) == 0x000380, "Member 'ALensFlare::MainFlareInnerRadius' has a wrong offset!");
static_assert(offsetof(ALensFlare, MainOuterColor) == 0x000384, "Member 'ALensFlare::MainOuterColor' has a wrong offset!");
static_assert(offsetof(ALensFlare, MainLensInnerColor) == 0x000394, "Member 'ALensFlare::MainLensInnerColor' has a wrong offset!");
static_assert(offsetof(ALensFlare, MainFlareSize) == 0x0003A4, "Member 'ALensFlare::MainFlareSize' has a wrong offset!");
static_assert(offsetof(ALensFlare, MainFlareContrast) == 0x0003A8, "Member 'ALensFlare::MainFlareContrast' has a wrong offset!");
static_assert(offsetof(ALensFlare, ReflectionSize) == 0x0003AC, "Member 'ALensFlare::ReflectionSize' has a wrong offset!");
static_assert(offsetof(ALensFlare, ReflectionCentreTexture) == 0x0003B0, "Member 'ALensFlare::ReflectionCentreTexture' has a wrong offset!");
static_assert(offsetof(ALensFlare, ReflectionColor) == 0x0003B8, "Member 'ALensFlare::ReflectionColor' has a wrong offset!");
static_assert(offsetof(ALensFlare, ReflectionBrightness) == 0x0003C8, "Member 'ALensFlare::ReflectionBrightness' has a wrong offset!");
static_assert(offsetof(ALensFlare, ReflectionContrast) == 0x0003CC, "Member 'ALensFlare::ReflectionContrast' has a wrong offset!");
static_assert(offsetof(ALensFlare, OppositeFlaresAxisProjection) == 0x0003D0, "Member 'ALensFlare::OppositeFlaresAxisProjection' has a wrong offset!");
static_assert(offsetof(ALensFlare, FlareOppositeSize01) == 0x0003D4, "Member 'ALensFlare::FlareOppositeSize01' has a wrong offset!");
static_assert(offsetof(ALensFlare, FlareOppositeSize02) == 0x0003D8, "Member 'ALensFlare::FlareOppositeSize02' has a wrong offset!");
static_assert(offsetof(ALensFlare, FlareOppositeColor01) == 0x0003DC, "Member 'ALensFlare::FlareOppositeColor01' has a wrong offset!");
static_assert(offsetof(ALensFlare, FlareOppositeColor02) == 0x0003EC, "Member 'ALensFlare::FlareOppositeColor02' has a wrong offset!");
static_assert(offsetof(ALensFlare, FlareOppositeBrightness01) == 0x0003FC, "Member 'ALensFlare::FlareOppositeBrightness01' has a wrong offset!");
static_assert(offsetof(ALensFlare, FlareOppositeBrightness02) == 0x000400, "Member 'ALensFlare::FlareOppositeBrightness02' has a wrong offset!");
static_assert(offsetof(ALensFlare, FlareOppositeContrast01) == 0x000404, "Member 'ALensFlare::FlareOppositeContrast01' has a wrong offset!");
static_assert(offsetof(ALensFlare, FlareOppositeContrast02) == 0x000408, "Member 'ALensFlare::FlareOppositeContrast02' has a wrong offset!");
static_assert(offsetof(ALensFlare, FlareOpposite01) == 0x000410, "Member 'ALensFlare::FlareOpposite01' has a wrong offset!");
static_assert(offsetof(ALensFlare, FlareOpposite02) == 0x000418, "Member 'ALensFlare::FlareOpposite02' has a wrong offset!");
static_assert(offsetof(ALensFlare, FrontFlaresAxisProjection) == 0x000420, "Member 'ALensFlare::FrontFlaresAxisProjection' has a wrong offset!");
static_assert(offsetof(ALensFlare, FlareFrontSize01) == 0x000424, "Member 'ALensFlare::FlareFrontSize01' has a wrong offset!");
static_assert(offsetof(ALensFlare, FlareFrontSize02) == 0x000428, "Member 'ALensFlare::FlareFrontSize02' has a wrong offset!");
static_assert(offsetof(ALensFlare, FlareFrontColor01) == 0x00042C, "Member 'ALensFlare::FlareFrontColor01' has a wrong offset!");
static_assert(offsetof(ALensFlare, FlareFrontColor02) == 0x00043C, "Member 'ALensFlare::FlareFrontColor02' has a wrong offset!");
static_assert(offsetof(ALensFlare, FlareFrontProximityCentre01) == 0x00044C, "Member 'ALensFlare::FlareFrontProximityCentre01' has a wrong offset!");
static_assert(offsetof(ALensFlare, FlareFrontProximityCentre02) == 0x000450, "Member 'ALensFlare::FlareFrontProximityCentre02' has a wrong offset!");
static_assert(offsetof(ALensFlare, FlareFront01) == 0x000458, "Member 'ALensFlare::FlareFront01' has a wrong offset!");
static_assert(offsetof(ALensFlare, FlareFront02) == 0x000460, "Member 'ALensFlare::FlareFront02' has a wrong offset!");
static_assert(offsetof(ALensFlare, FlareFrontContrast01) == 0x000468, "Member 'ALensFlare::FlareFrontContrast01' has a wrong offset!");
static_assert(offsetof(ALensFlare, FlareFrontContrast02) == 0x00046C, "Member 'ALensFlare::FlareFrontContrast02' has a wrong offset!");
static_assert(offsetof(ALensFlare, FlareFrontBrightness01) == 0x000470, "Member 'ALensFlare::FlareFrontBrightness01' has a wrong offset!");
static_assert(offsetof(ALensFlare, FlareFrontBrightness02) == 0x000474, "Member 'ALensFlare::FlareFrontBrightness02' has a wrong offset!");
static_assert(offsetof(ALensFlare, ReflectedFlareSize01) == 0x000478, "Member 'ALensFlare::ReflectedFlareSize01' has a wrong offset!");
static_assert(offsetof(ALensFlare, ReflectedFlareSize02) == 0x00047C, "Member 'ALensFlare::ReflectedFlareSize02' has a wrong offset!");
static_assert(offsetof(ALensFlare, ReflectedFlareProximityCentre01) == 0x000480, "Member 'ALensFlare::ReflectedFlareProximityCentre01' has a wrong offset!");
static_assert(offsetof(ALensFlare, ReflectedFlareProximityCentre02) == 0x000484, "Member 'ALensFlare::ReflectedFlareProximityCentre02' has a wrong offset!");
static_assert(offsetof(ALensFlare, ReflectedFlare01) == 0x000488, "Member 'ALensFlare::ReflectedFlare01' has a wrong offset!");
static_assert(offsetof(ALensFlare, ReflectedFlare02) == 0x000490, "Member 'ALensFlare::ReflectedFlare02' has a wrong offset!");
static_assert(offsetof(ALensFlare, ReflectedFlareColor01) == 0x000498, "Member 'ALensFlare::ReflectedFlareColor01' has a wrong offset!");
static_assert(offsetof(ALensFlare, ReflectedFlareColor02) == 0x0004A8, "Member 'ALensFlare::ReflectedFlareColor02' has a wrong offset!");
static_assert(offsetof(ALensFlare, ReflectedFlareContrast01) == 0x0004B8, "Member 'ALensFlare::ReflectedFlareContrast01' has a wrong offset!");
static_assert(offsetof(ALensFlare, ReflectedFlareContrast02) == 0x0004BC, "Member 'ALensFlare::ReflectedFlareContrast02' has a wrong offset!");
static_assert(offsetof(ALensFlare, ReflectedFlareBrightness01) == 0x0004C0, "Member 'ALensFlare::ReflectedFlareBrightness01' has a wrong offset!");
static_assert(offsetof(ALensFlare, ReflectedFlareBrightness02) == 0x0004C4, "Member 'ALensFlare::ReflectedFlareBrightness02' has a wrong offset!");
static_assert(offsetof(ALensFlare, MinorFlareProximityCentre01) == 0x0004C8, "Member 'ALensFlare::MinorFlareProximityCentre01' has a wrong offset!");
static_assert(offsetof(ALensFlare, MinorFlareSize01) == 0x0004CC, "Member 'ALensFlare::MinorFlareSize01' has a wrong offset!");
static_assert(offsetof(ALensFlare, MinorFlareSizeRandom01) == 0x0004D0, "Member 'ALensFlare::MinorFlareSizeRandom01' has a wrong offset!");
static_assert(offsetof(ALensFlare, MinorFlare01) == 0x0004D8, "Member 'ALensFlare::MinorFlare01' has a wrong offset!");
static_assert(offsetof(ALensFlare, MinorFlareColor01) == 0x0004E0, "Member 'ALensFlare::MinorFlareColor01' has a wrong offset!");
static_assert(offsetof(ALensFlare, MinorFlareContrast01) == 0x0004F0, "Member 'ALensFlare::MinorFlareContrast01' has a wrong offset!");
static_assert(offsetof(ALensFlare, MinorFlareBrightness01) == 0x0004F4, "Member 'ALensFlare::MinorFlareBrightness01' has a wrong offset!");
static_assert(offsetof(ALensFlare, MinorFlareColor02) == 0x0004F8, "Member 'ALensFlare::MinorFlareColor02' has a wrong offset!");
static_assert(offsetof(ALensFlare, MinorFlareContrast02) == 0x000508, "Member 'ALensFlare::MinorFlareContrast02' has a wrong offset!");
static_assert(offsetof(ALensFlare, MinorFlareBrightness02) == 0x00050C, "Member 'ALensFlare::MinorFlareBrightness02' has a wrong offset!");
static_assert(offsetof(ALensFlare, MinorFlareProximityCentre02) == 0x000510, "Member 'ALensFlare::MinorFlareProximityCentre02' has a wrong offset!");
static_assert(offsetof(ALensFlare, MinorFlareSize02) == 0x000514, "Member 'ALensFlare::MinorFlareSize02' has a wrong offset!");
static_assert(offsetof(ALensFlare, MinorFlareSizeRandom02) == 0x000518, "Member 'ALensFlare::MinorFlareSizeRandom02' has a wrong offset!");
static_assert(offsetof(ALensFlare, MinorFlare02) == 0x000520, "Member 'ALensFlare::MinorFlare02' has a wrong offset!");
static_assert(offsetof(ALensFlare, Iris) == 0x000528, "Member 'ALensFlare::Iris' has a wrong offset!");
static_assert(offsetof(ALensFlare, IrisSize) == 0x000530, "Member 'ALensFlare::IrisSize' has a wrong offset!");
static_assert(offsetof(ALensFlare, IrisProximityCentre) == 0x000534, "Member 'ALensFlare::IrisProximityCentre' has a wrong offset!");
static_assert(offsetof(ALensFlare, IrisBrightness) == 0x000538, "Member 'ALensFlare::IrisBrightness' has a wrong offset!");
static_assert(offsetof(ALensFlare, IrisContrast) == 0x00053C, "Member 'ALensFlare::IrisContrast' has a wrong offset!");
static_assert(offsetof(ALensFlare, IrisColor) == 0x000540, "Member 'ALensFlare::IrisColor' has a wrong offset!");
static_assert(offsetof(ALensFlare, AdditionalFlare) == 0x000550, "Member 'ALensFlare::AdditionalFlare' has a wrong offset!");
static_assert(offsetof(ALensFlare, AdditionalFlareSize) == 0x000558, "Member 'ALensFlare::AdditionalFlareSize' has a wrong offset!");
static_assert(offsetof(ALensFlare, AdditionalFlareContrast) == 0x00055C, "Member 'ALensFlare::AdditionalFlareContrast' has a wrong offset!");
static_assert(offsetof(ALensFlare, AdditionalFlareBrightness) == 0x000560, "Member 'ALensFlare::AdditionalFlareBrightness' has a wrong offset!");
static_assert(offsetof(ALensFlare, AdditionalFlareColor) == 0x000564, "Member 'ALensFlare::AdditionalFlareColor' has a wrong offset!");

// Class ReadyOrNot.AnimNotify_PlayMontage
// 0x0008 (0x0040 - 0x0038)
class UAnimNotify_PlayMontage final : public UAnimNotify
{
public:
	class UAnimMontage*                           Montage;                                           // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_PlayMontage">();
	}
	static class UAnimNotify_PlayMontage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_PlayMontage>();
	}
};
static_assert(alignof(UAnimNotify_PlayMontage) == 0x000008, "Wrong alignment on UAnimNotify_PlayMontage");
static_assert(sizeof(UAnimNotify_PlayMontage) == 0x000040, "Wrong size on UAnimNotify_PlayMontage");
static_assert(offsetof(UAnimNotify_PlayMontage, Montage) == 0x000038, "Member 'UAnimNotify_PlayMontage::Montage' has a wrong offset!");

// Class ReadyOrNot.AnimNotify_PlayPostProcessEffect
// 0x0008 (0x0040 - 0x0038)
class UAnimNotify_PlayPostProcessEffect final : public UAnimNotify
{
public:
	class FName                                   PostProcessEffectName;                             // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_PlayPostProcessEffect">();
	}
	static class UAnimNotify_PlayPostProcessEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_PlayPostProcessEffect>();
	}
};
static_assert(alignof(UAnimNotify_PlayPostProcessEffect) == 0x000008, "Wrong alignment on UAnimNotify_PlayPostProcessEffect");
static_assert(sizeof(UAnimNotify_PlayPostProcessEffect) == 0x000040, "Wrong size on UAnimNotify_PlayPostProcessEffect");
static_assert(offsetof(UAnimNotify_PlayPostProcessEffect, PostProcessEffectName) == 0x000038, "Member 'UAnimNotify_PlayPostProcessEffect::PostProcessEffectName' has a wrong offset!");

// Class ReadyOrNot.ListenForGameEnd
// 0x0000 (0x0000 - 0x0000)
class IListenForGameEnd final
{
public:
	void OnGameEnded();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ListenForGameEnd">();
	}
	static class IListenForGameEnd* GetDefaultObj()
	{
		return GetDefaultObjImpl<IListenForGameEnd>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IListenForGameEnd) == 0x000001, "Wrong alignment on IListenForGameEnd");
static_assert(sizeof(IListenForGameEnd) == 0x000001, "Wrong size on IListenForGameEnd");

// Class ReadyOrNot.AnimNotify_PreMissionWeaponVis
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_PreMissionWeaponVis final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_PreMissionWeaponVis">();
	}
	static class UAnimNotify_PreMissionWeaponVis* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_PreMissionWeaponVis>();
	}
};
static_assert(alignof(UAnimNotify_PreMissionWeaponVis) == 0x000008, "Wrong alignment on UAnimNotify_PreMissionWeaponVis");
static_assert(sizeof(UAnimNotify_PreMissionWeaponVis) == 0x000038, "Wrong size on UAnimNotify_PreMissionWeaponVis");

// Class ReadyOrNot.AnimNotify_RemovePlacedC2
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_RemovePlacedC2 final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_RemovePlacedC2">();
	}
	static class UAnimNotify_RemovePlacedC2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_RemovePlacedC2>();
	}
};
static_assert(alignof(UAnimNotify_RemovePlacedC2) == 0x000008, "Wrong alignment on UAnimNotify_RemovePlacedC2");
static_assert(sizeof(UAnimNotify_RemovePlacedC2) == 0x000038, "Wrong size on UAnimNotify_RemovePlacedC2");

// Class ReadyOrNot.SetControlRotationToCamBoneAnimNotify
// 0x0008 (0x0040 - 0x0038)
class USetControlRotationToCamBoneAnimNotify final : public UAnimNotify
{
public:
	class FName                                   CameraBoneName;                                    // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SetControlRotationToCamBoneAnimNotify">();
	}
	static class USetControlRotationToCamBoneAnimNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<USetControlRotationToCamBoneAnimNotify>();
	}
};
static_assert(alignof(USetControlRotationToCamBoneAnimNotify) == 0x000008, "Wrong alignment on USetControlRotationToCamBoneAnimNotify");
static_assert(sizeof(USetControlRotationToCamBoneAnimNotify) == 0x000040, "Wrong size on USetControlRotationToCamBoneAnimNotify");
static_assert(offsetof(USetControlRotationToCamBoneAnimNotify, CameraBoneName) == 0x000038, "Member 'USetControlRotationToCamBoneAnimNotify::CameraBoneName' has a wrong offset!");

// Class ReadyOrNot.AnimNotify_SetCoverFirePose
// 0x0008 (0x0040 - 0x0038)
class UAnimNotify_SetCoverFirePose final : public UAnimNotify
{
public:
	class UAnimSequence*                          Pose;                                              // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_SetCoverFirePose">();
	}
	static class UAnimNotify_SetCoverFirePose* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_SetCoverFirePose>();
	}
};
static_assert(alignof(UAnimNotify_SetCoverFirePose) == 0x000008, "Wrong alignment on UAnimNotify_SetCoverFirePose");
static_assert(sizeof(UAnimNotify_SetCoverFirePose) == 0x000040, "Wrong size on UAnimNotify_SetCoverFirePose");
static_assert(offsetof(UAnimNotify_SetCoverFirePose, Pose) == 0x000038, "Member 'UAnimNotify_SetCoverFirePose::Pose' has a wrong offset!");

// Class ReadyOrNot.LipSyncSubsystem
// 0x0050 (0x0080 - 0x0030)
class ULipSyncSubsystem final : public UGameInstanceSubsystem
{
public:
	TMap<class FString, struct FCharacterLipSyncData> CharacterLipSyncDataMap;                       // 0x0030(0x0050)(NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LipSyncSubsystem">();
	}
	static class ULipSyncSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULipSyncSubsystem>();
	}
};
static_assert(alignof(ULipSyncSubsystem) == 0x000008, "Wrong alignment on ULipSyncSubsystem");
static_assert(sizeof(ULipSyncSubsystem) == 0x000080, "Wrong size on ULipSyncSubsystem");
static_assert(offsetof(ULipSyncSubsystem, CharacterLipSyncDataMap) == 0x000030, "Member 'ULipSyncSubsystem::CharacterLipSyncDataMap' has a wrong offset!");

// Class ReadyOrNot.AnimNotify_SetCoverHidePose
// 0x0008 (0x0040 - 0x0038)
class UAnimNotify_SetCoverHidePose final : public UAnimNotify
{
public:
	class UAnimSequence*                          Pose;                                              // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_SetCoverHidePose">();
	}
	static class UAnimNotify_SetCoverHidePose* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_SetCoverHidePose>();
	}
};
static_assert(alignof(UAnimNotify_SetCoverHidePose) == 0x000008, "Wrong alignment on UAnimNotify_SetCoverHidePose");
static_assert(sizeof(UAnimNotify_SetCoverHidePose) == 0x000040, "Wrong size on UAnimNotify_SetCoverHidePose");
static_assert(offsetof(UAnimNotify_SetCoverHidePose, Pose) == 0x000038, "Member 'UAnimNotify_SetCoverHidePose::Pose' has a wrong offset!");

// Class ReadyOrNot.AnimNotify_SetHoleTraversalPose
// 0x0008 (0x0040 - 0x0038)
class UAnimNotify_SetHoleTraversalPose final : public UAnimNotify
{
public:
	class UAnimSequence*                          Pose;                                              // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_SetHoleTraversalPose">();
	}
	static class UAnimNotify_SetHoleTraversalPose* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_SetHoleTraversalPose>();
	}
};
static_assert(alignof(UAnimNotify_SetHoleTraversalPose) == 0x000008, "Wrong alignment on UAnimNotify_SetHoleTraversalPose");
static_assert(sizeof(UAnimNotify_SetHoleTraversalPose) == 0x000040, "Wrong size on UAnimNotify_SetHoleTraversalPose");
static_assert(offsetof(UAnimNotify_SetHoleTraversalPose, Pose) == 0x000038, "Member 'UAnimNotify_SetHoleTraversalPose::Pose' has a wrong offset!");

// Class ReadyOrNot.AnimNotify_SpawnThrownItem
// 0x0030 (0x0068 - 0x0038)
class UAnimNotify_SpawnThrownItem final : public UAnimNotify
{
public:
	TSubclassOf<class ABaseItem>                  ItemClass;                                         // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bLocalOnly : 1;                                    // 0x0040(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bNonLocalOnly : 1;                                 // 0x0040(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BoneToSpawnOn;                                     // 0x0044(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bCustomThrowDirection : 1;                         // 0x004C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               ThrowDirection;                                    // 0x0050(0x0018)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_SpawnThrownItem">();
	}
	static class UAnimNotify_SpawnThrownItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_SpawnThrownItem>();
	}
};
static_assert(alignof(UAnimNotify_SpawnThrownItem) == 0x000008, "Wrong alignment on UAnimNotify_SpawnThrownItem");
static_assert(sizeof(UAnimNotify_SpawnThrownItem) == 0x000068, "Wrong size on UAnimNotify_SpawnThrownItem");
static_assert(offsetof(UAnimNotify_SpawnThrownItem, ItemClass) == 0x000038, "Member 'UAnimNotify_SpawnThrownItem::ItemClass' has a wrong offset!");
static_assert(offsetof(UAnimNotify_SpawnThrownItem, BoneToSpawnOn) == 0x000044, "Member 'UAnimNotify_SpawnThrownItem::BoneToSpawnOn' has a wrong offset!");
static_assert(offsetof(UAnimNotify_SpawnThrownItem, ThrowDirection) == 0x000050, "Member 'UAnimNotify_SpawnThrownItem::ThrowDirection' has a wrong offset!");

// Class ReadyOrNot.ShellRackShellComponent
// 0x0000 (0x0630 - 0x0630)
class UShellRackShellComponent final : public UStaticMeshComponent
{
public:
	int32                                         ShellNumber;                                       // 0x0628(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_62C[0x4];                                      // 0x062C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShellRackShellComponent">();
	}
	static class UShellRackShellComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShellRackShellComponent>();
	}
};
static_assert(alignof(UShellRackShellComponent) == 0x000010, "Wrong alignment on UShellRackShellComponent");
static_assert(sizeof(UShellRackShellComponent) == 0x000630, "Wrong size on UShellRackShellComponent");
static_assert(offsetof(UShellRackShellComponent, ShellNumber) == 0x000628, "Member 'UShellRackShellComponent::ShellNumber' has a wrong offset!");

// Class ReadyOrNot.MenuWidget
// 0x0000 (0x0410 - 0x0410)
class UMenuWidget : public UCommonActivatableWidget
{
public:
	void PlayWidgetAnimation_Internal(class UWidgetAnimation* InWidgetAnimation, bool bRestartIfAlreadyPlaying);

	void BP_OnShow() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MenuWidget">();
	}
	static class UMenuWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMenuWidget>();
	}
};
static_assert(alignof(UMenuWidget) == 0x000008, "Wrong alignment on UMenuWidget");
static_assert(sizeof(UMenuWidget) == 0x000410, "Wrong size on UMenuWidget");

// Class ReadyOrNot.PremissionPlanning
// 0x0760 (0x0B70 - 0x0410)
class UPremissionPlanning : public UMenuWidget
{
public:
	bool                                          bIsWeaponCustomization;                            // 0x0410(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOpenInQuartermaster;                              // 0x0411(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCustomizingPrimary;                             // 0x0412(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_413[0x5];                                      // 0x0413(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ABaseItem>                  CustomizeItemClass;                                // 0x0418(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AReadyOrNotGameState*                   gs;                                                // 0x0420(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AReadyOrNotPlayerController*            PC;                                                // 0x0428(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AReadyOrNotPlayerState*                 ps;                                                // 0x0430(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULevelStreaming*                        PreMissionStreamedLevel;                           // 0x0438(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_440[0x8];                                      // 0x0440(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AReadyOrNotPlayerState*                 PreviewPlayerState;                                // 0x0448(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_450[0x2];                                      // 0x0450(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	EEquippingSwat                                EquippingSwatMember;                               // 0x0452(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_453[0x5];                                      // 0x0453(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EEquippingSwat, struct FSavedLoadout>    LastSavedLoadout;                                  // 0x0458(0x0050)(NativeAccessSpecifierPublic)
	uint8                                         Pad_4A8[0x58];                                     // 0x04A8(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bLoadedLoadout;                                    // 0x0500(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_501[0x7];                                      // 0x0501(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSavedLoadout                          ActiveLoadout;                                     // 0x0508(0x02E8)(BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FName, struct FLoadoutPreset>      LoadoutPresetMap;                                  // 0x07F0(0x0050)(BlueprintVisible, NativeAccessSpecifierPublic)
	class AReadyOrNotPlayerState*                 EquippingPlayerState;                              // 0x0840(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<TSubclassOf<class ABaseItem>, struct FSavedWeaponPreset> WeaponToWeaponPresetsMap;          // 0x0848(0x0050)(BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<TSubclassOf<class ABaseItem>, struct FSavedWeaponAttachmentData> WeaponToAttachmentsMap;    // 0x0898(0x0050)(BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<TSubclassOf<class ABaseWeapon>, EFireMode> WeaponClassToDefaultFireModeMap;                 // 0x08E8(0x0050)(BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_938[0x4];                                      // 0x0938(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ActiveCameraTag;                                   // 0x093C(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_944[0x4];                                      // 0x0944(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnRequestRefresh;                                  // 0x0948(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_958[0x8];                                      // 0x0958(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   RedTeamClass;                                      // 0x0960(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   BlueTeamClass;                                     // 0x0988(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   VIPClass;                                          // 0x09B0(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9D8[0x8];                                      // 0x09D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class AReadyOrNotCharacter*, class AReadyOrNotPlayerState*> PlayerStatePreviewMap;          // 0x09E0(0x0050)(UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_A30[0xD8];                                     // 0x0A30(0x00D8)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, class ABaseItem*>           WorkBenchItemPtrMap;                               // 0x0B08(0x0050)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, NativeAccessSpecifierPublic)
	EItemType                                     LastSetItemType;                                   // 0x0B58(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemClass                                    LastSetItemClass;                                  // 0x0B59(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B5A[0x6];                                      // 0x0B5A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ABaseItem>                  LastSetItemObjectClass;                            // 0x0B60(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B68[0x1];                                      // 0x0B68(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bCanUpdateWithUI;                                  // 0x0B69(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B6A[0x6];                                      // 0x0B6A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UPremissionPlanning* GetPremissionPlanning();

	void AttachPrimaryToSocket(class FName Socket);
	void AttachSecondaryToSocket(class FName Socket);
	void CleanPrimaryGun();
	void CleanSecondaryGun();
	void ClearPreviewWeaponSkin(bool IsSecondary);
	void DoPrimaryWeaponPreviewBlend();
	void DoSaveLoadout(EEquippingSwat SwatMember, const struct FSavedLoadout& Loadout);
	void EquipPrimary();
	void EquipSecondary();
	TArray<TSubclassOf<class USkinComponent>> GetAvailablePlayerSkins();
	class AReadyOrNotCharacter* GetDefaultPreviewCharacter();
	void GetEquippingSwatMember(EEquippingSwat* EquippingSwat);
	bool GetInputLocked();
	struct FSavedWeaponAttachmentData GetItemAttachmentData(TSubclassOf<class ABaseItem> Weapon);
	TSubclassOf<class ABaseItem> GetLastItemInSlot(EItemType ItemType);
	EPreMissionSubCategory GetSubcategory();
	struct FWeaponPreset GetWeaponPresetData(TSubclassOf<class ABaseItem> Weapon, int32 Index_0);
	struct FSavedWeaponPreset GetWeaponPresetsData(TSubclassOf<class ABaseItem> Weapon);
	void HidePrimary(bool bIsHidden);
	void HideSecondary(bool bIsHidden);
	void HideWeapons(bool bHidePrimary, bool bHideSecondary, float Delay);
	void Init(bool bReadOnly, const struct FSavedLoadout& PreviewLoadout);
	bool IsAnyWeaponVisible();
	bool IsInLobby();
	void LoadLoadoutPresets();
	void LoadWeaponAttachments();
	void LoadWeaponDefaultFireModes();
	void LoadWeaponPresets();
	void OnLoadoutItemAttachmentsLoaded();
	void OnLoadoutItemAttachmentsSaved();
	void OnLoadoutItemPresetsLoaded();
	void OnLoadoutItemPresetsSaved();
	void OnLoadoutLoaded();
	void OnLoadoutPresetsLoaded();
	void OnLoadoutPresetsSaved();
	void OnLoadoutSaved();
	void OnSwatCharacterChanged();
	void OnWeaponDefaultFireModesLoaded();
	void PlayAnimationOnPreviewCharacter(const class FString& Animation);
	void PlayAnimationOnQuartermaster(const class FString& Animation);
	void SaveActiveLoadout();
	void SaveItemClassAsSlot(EItemType ItemType, TSubclassOf<class ABaseItem> Class_0);
	void SaveLoadoutPresets();
	void SaveWeaponAttachments();
	void SaveWeaponDefaultFireMode();
	void SaveWeaponPresets();
	void SetActiveCameraByTag(class FName Tag, float BlendTime);
	void SetBodyArmour(TSubclassOf<class ABaseItem> BodyArmour);
	void SetEquippingSwatMember(EEquippingSwat NewEquippingSwat, class AReadyOrNotPlayerState* NewEquippingPlayerState);
	void SetHeadwear(TSubclassOf<class ABaseItem> Headwear);
	void SetItem(EItemType ItemType, TSubclassOf<class ABaseItem> ItemClass);
	void SetItem_V2(EItemClass ItemClass, TSubclassOf<class ABaseItem> ItemObjectClass);
	void SetLightColorByTag(class FName Tag, const struct FLinearColor& Color);
	void SetLockInput(bool bShouldLockInput);
	void SetLongTactical(TSubclassOf<class ABaseItem> LongTactical);
	void SetPlayerSkin(TSubclassOf<class USkinComponent> SkinCompClass);
	void SetPrimaryAmmunitionAttachment(TSubclassOf<class UWeaponAttachment> AmmunitionAttachment);
	void SetPrimaryGripAttachment(TSubclassOf<class UWeaponAttachment> GripAttachment);
	void SetPrimaryIlluminatorAttachment(TSubclassOf<class UWeaponAttachment> IlluminatorAttachment);
	void SetPrimaryMuzzleAttachment(TSubclassOf<class UWeaponAttachment> MuzzleAttachment);
	void SetPrimaryOverbarrelAttachment(TSubclassOf<class UWeaponAttachment> OverbarrelAttachment);
	void SetPrimaryScopeAttachment(TSubclassOf<class UWeaponAttachment> ScopeAttachment);
	void SetPrimarySkinAttachment(TSubclassOf<class USkinComponent> SkinAttachment);
	void SetPrimaryStockAttachment(TSubclassOf<class UWeaponAttachment> StockAttachment);
	void SetPrimaryUnderbarrelAttachment(TSubclassOf<class UWeaponAttachment> UnderbarrelAttachment);
	void SetPrimaryWeapon(const struct FWeaponData& WeaponData);
	void SetSecondaryAmmunitionAttachment(TSubclassOf<class UWeaponAttachment> AmmunitionAttachment);
	void SetSecondaryGripAttachment(TSubclassOf<class UWeaponAttachment> GripAttachment);
	void SetSecondaryIlluminatorAttachment(TSubclassOf<class UWeaponAttachment> IlluminatorAttachment);
	void SetSecondaryMuzzleAttachment(TSubclassOf<class UWeaponAttachment> MuzzleAttachment);
	void SetSecondaryOverbarrelAttachment(TSubclassOf<class UWeaponAttachment> OverbarrelAttachment);
	void SetSecondaryScopeAttachment(TSubclassOf<class UWeaponAttachment> ScopeAttachment);
	void SetSecondarySkinAttachment(TSubclassOf<class USkinComponent> SkinAttachment);
	void SetSecondaryStockAttachment(TSubclassOf<class UWeaponAttachment> StockAttachment);
	void SetSecondaryUnderbarrelAttachment(TSubclassOf<class UWeaponAttachment> UnderbarrelAttachment);
	void SetSecondaryWeapon(const struct FWeaponData& WeaponData);
	void SetSubcategory(EPreMissionSubCategory NewSubCategory);
	void SetWorkbenchItemClass(TSubclassOf<class ABaseItem> Item, class FName Tag);
	void UpdatePreviewCharacter(class AReadyOrNotPlayerState* InPreviewPlayerState, class FName Tag);
	void UpdatePreviewCharacterArmour();
	void UpdatePreviewCharacterHeadwear();
	void UpdatePreviewCharacterLongTactical();
	void UpdatePreviewCharacterPrimary();
	void UpdatePreviewCharacterSecondary();
	void UpdatePreviewWeaponAttachments(bool IsSecondary, TSubclassOf<class UWeaponAttachment> Attachment);
	void UpdatePreviewWeaponSkin(bool IsSecondary, TSubclassOf<class USkinComponent> SkinAttachment);
	void UpdateWeaponDefaultFireMode(TSubclassOf<class ABaseWeapon> Weapon, EFireMode NewDefaultFireMode);
	void UpdateWeaponPreset(TSubclassOf<class ABaseItem> Weapon, const struct FWeaponPreset& PresetData, int32 Index_0);
	void UpdateWeaponPresets(TSubclassOf<class ABaseItem> Weapon, const struct FSavedWeaponPreset& Presets);
	void UpdateWorkbenchItemAttachments();

	EItemType ItemClassToItemType(EItemClass InItemClass) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PremissionPlanning">();
	}
	static class UPremissionPlanning* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPremissionPlanning>();
	}
};
static_assert(alignof(UPremissionPlanning) == 0x000008, "Wrong alignment on UPremissionPlanning");
static_assert(sizeof(UPremissionPlanning) == 0x000B70, "Wrong size on UPremissionPlanning");
static_assert(offsetof(UPremissionPlanning, bIsWeaponCustomization) == 0x000410, "Member 'UPremissionPlanning::bIsWeaponCustomization' has a wrong offset!");
static_assert(offsetof(UPremissionPlanning, bOpenInQuartermaster) == 0x000411, "Member 'UPremissionPlanning::bOpenInQuartermaster' has a wrong offset!");
static_assert(offsetof(UPremissionPlanning, bIsCustomizingPrimary) == 0x000412, "Member 'UPremissionPlanning::bIsCustomizingPrimary' has a wrong offset!");
static_assert(offsetof(UPremissionPlanning, CustomizeItemClass) == 0x000418, "Member 'UPremissionPlanning::CustomizeItemClass' has a wrong offset!");
static_assert(offsetof(UPremissionPlanning, gs) == 0x000420, "Member 'UPremissionPlanning::gs' has a wrong offset!");
static_assert(offsetof(UPremissionPlanning, PC) == 0x000428, "Member 'UPremissionPlanning::PC' has a wrong offset!");
static_assert(offsetof(UPremissionPlanning, ps) == 0x000430, "Member 'UPremissionPlanning::ps' has a wrong offset!");
static_assert(offsetof(UPremissionPlanning, PreMissionStreamedLevel) == 0x000438, "Member 'UPremissionPlanning::PreMissionStreamedLevel' has a wrong offset!");
static_assert(offsetof(UPremissionPlanning, PreviewPlayerState) == 0x000448, "Member 'UPremissionPlanning::PreviewPlayerState' has a wrong offset!");
static_assert(offsetof(UPremissionPlanning, EquippingSwatMember) == 0x000452, "Member 'UPremissionPlanning::EquippingSwatMember' has a wrong offset!");
static_assert(offsetof(UPremissionPlanning, LastSavedLoadout) == 0x000458, "Member 'UPremissionPlanning::LastSavedLoadout' has a wrong offset!");
static_assert(offsetof(UPremissionPlanning, bLoadedLoadout) == 0x000500, "Member 'UPremissionPlanning::bLoadedLoadout' has a wrong offset!");
static_assert(offsetof(UPremissionPlanning, ActiveLoadout) == 0x000508, "Member 'UPremissionPlanning::ActiveLoadout' has a wrong offset!");
static_assert(offsetof(UPremissionPlanning, LoadoutPresetMap) == 0x0007F0, "Member 'UPremissionPlanning::LoadoutPresetMap' has a wrong offset!");
static_assert(offsetof(UPremissionPlanning, EquippingPlayerState) == 0x000840, "Member 'UPremissionPlanning::EquippingPlayerState' has a wrong offset!");
static_assert(offsetof(UPremissionPlanning, WeaponToWeaponPresetsMap) == 0x000848, "Member 'UPremissionPlanning::WeaponToWeaponPresetsMap' has a wrong offset!");
static_assert(offsetof(UPremissionPlanning, WeaponToAttachmentsMap) == 0x000898, "Member 'UPremissionPlanning::WeaponToAttachmentsMap' has a wrong offset!");
static_assert(offsetof(UPremissionPlanning, WeaponClassToDefaultFireModeMap) == 0x0008E8, "Member 'UPremissionPlanning::WeaponClassToDefaultFireModeMap' has a wrong offset!");
static_assert(offsetof(UPremissionPlanning, ActiveCameraTag) == 0x00093C, "Member 'UPremissionPlanning::ActiveCameraTag' has a wrong offset!");
static_assert(offsetof(UPremissionPlanning, OnRequestRefresh) == 0x000948, "Member 'UPremissionPlanning::OnRequestRefresh' has a wrong offset!");
static_assert(offsetof(UPremissionPlanning, RedTeamClass) == 0x000960, "Member 'UPremissionPlanning::RedTeamClass' has a wrong offset!");
static_assert(offsetof(UPremissionPlanning, BlueTeamClass) == 0x000988, "Member 'UPremissionPlanning::BlueTeamClass' has a wrong offset!");
static_assert(offsetof(UPremissionPlanning, VIPClass) == 0x0009B0, "Member 'UPremissionPlanning::VIPClass' has a wrong offset!");
static_assert(offsetof(UPremissionPlanning, PlayerStatePreviewMap) == 0x0009E0, "Member 'UPremissionPlanning::PlayerStatePreviewMap' has a wrong offset!");
static_assert(offsetof(UPremissionPlanning, WorkBenchItemPtrMap) == 0x000B08, "Member 'UPremissionPlanning::WorkBenchItemPtrMap' has a wrong offset!");
static_assert(offsetof(UPremissionPlanning, LastSetItemType) == 0x000B58, "Member 'UPremissionPlanning::LastSetItemType' has a wrong offset!");
static_assert(offsetof(UPremissionPlanning, LastSetItemClass) == 0x000B59, "Member 'UPremissionPlanning::LastSetItemClass' has a wrong offset!");
static_assert(offsetof(UPremissionPlanning, LastSetItemObjectClass) == 0x000B60, "Member 'UPremissionPlanning::LastSetItemObjectClass' has a wrong offset!");
static_assert(offsetof(UPremissionPlanning, bCanUpdateWithUI) == 0x000B69, "Member 'UPremissionPlanning::bCanUpdateWithUI' has a wrong offset!");

// Class ReadyOrNot.AnimNotifyState_HideBoneVis
// 0x0008 (0x0038 - 0x0030)
class UAnimNotifyState_HideBoneVis final : public UAnimNotifyState
{
public:
	class FName                                   BoneNameToHide;                                    // 0x0030(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_HideBoneVis">();
	}
	static class UAnimNotifyState_HideBoneVis* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_HideBoneVis>();
	}
};
static_assert(alignof(UAnimNotifyState_HideBoneVis) == 0x000008, "Wrong alignment on UAnimNotifyState_HideBoneVis");
static_assert(sizeof(UAnimNotifyState_HideBoneVis) == 0x000038, "Wrong size on UAnimNotifyState_HideBoneVis");
static_assert(offsetof(UAnimNotifyState_HideBoneVis, BoneNameToHide) == 0x000030, "Member 'UAnimNotifyState_HideBoneVis::BoneNameToHide' has a wrong offset!");

// Class ReadyOrNot.AnimNotify_ToggleEquipmentVis
// 0x0008 (0x0040 - 0x0038)
class UAnimNotify_ToggleEquipmentVis final : public UAnimNotify
{
public:
	EToggleInventoryVis                           InventroyVis;                                      // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_ToggleEquipmentVis">();
	}
	static class UAnimNotify_ToggleEquipmentVis* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_ToggleEquipmentVis>();
	}
};
static_assert(alignof(UAnimNotify_ToggleEquipmentVis) == 0x000008, "Wrong alignment on UAnimNotify_ToggleEquipmentVis");
static_assert(sizeof(UAnimNotify_ToggleEquipmentVis) == 0x000040, "Wrong size on UAnimNotify_ToggleEquipmentVis");
static_assert(offsetof(UAnimNotify_ToggleEquipmentVis, InventroyVis) == 0x000038, "Member 'UAnimNotify_ToggleEquipmentVis::InventroyVis' has a wrong offset!");

// Class ReadyOrNot.LoadoutPortal
// 0x0090 (0x0328 - 0x0298)
class ALoadoutPortal final : public AActor
{
public:
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractableComponent*                 InteractableComponent;                             // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UStaticMeshComponent*>           CompsToOutline;                                    // 0x02A8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class ULightComponent*>                LightsToEnable;                                    // 0x02B8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	class ULevelSequence*                         LevelSequence;                                     // 0x02C8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULevelSequencePlayer*                   LevelSequencePlayer;                               // 0x02D0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ALevelSequenceActor*                    LevelSequenceActor;                                // 0x02D8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bOpenCustomization;                                // 0x02E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E1[0x3];                                      // 0x02E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   LightActorsOfTag;                                  // 0x02E4(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsActive;                                          // 0x02EC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2ED[0x3];                                      // 0x02ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class ULoadout_V2*                            LoadoutWidget;                                     // 0x02F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APlayerController*                      CurrentController;                                 // 0x02F8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_300[0x8];                                      // 0x0300(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ADirectionalLight*>              HiddenDirectionalLights;                           // 0x0308(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class APostProcessVolume*>             HiddenPostProcessVolumes;                          // 0x0318(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	void LoadLoadout();
	void OnLoadoutFadeIn();
	void OnLoadoutFadeOut();
	void OnLoadoutHidden();
	void OnLoadoutLoaded();
	void OnLoadoutShown();
	void OnLoadoutUnloaded();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadoutPortal">();
	}
	static class ALoadoutPortal* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALoadoutPortal>();
	}
};
static_assert(alignof(ALoadoutPortal) == 0x000008, "Wrong alignment on ALoadoutPortal");
static_assert(sizeof(ALoadoutPortal) == 0x000328, "Wrong size on ALoadoutPortal");
static_assert(offsetof(ALoadoutPortal, InteractableComponent) == 0x0002A0, "Member 'ALoadoutPortal::InteractableComponent' has a wrong offset!");
static_assert(offsetof(ALoadoutPortal, CompsToOutline) == 0x0002A8, "Member 'ALoadoutPortal::CompsToOutline' has a wrong offset!");
static_assert(offsetof(ALoadoutPortal, LightsToEnable) == 0x0002B8, "Member 'ALoadoutPortal::LightsToEnable' has a wrong offset!");
static_assert(offsetof(ALoadoutPortal, LevelSequence) == 0x0002C8, "Member 'ALoadoutPortal::LevelSequence' has a wrong offset!");
static_assert(offsetof(ALoadoutPortal, LevelSequencePlayer) == 0x0002D0, "Member 'ALoadoutPortal::LevelSequencePlayer' has a wrong offset!");
static_assert(offsetof(ALoadoutPortal, LevelSequenceActor) == 0x0002D8, "Member 'ALoadoutPortal::LevelSequenceActor' has a wrong offset!");
static_assert(offsetof(ALoadoutPortal, bOpenCustomization) == 0x0002E0, "Member 'ALoadoutPortal::bOpenCustomization' has a wrong offset!");
static_assert(offsetof(ALoadoutPortal, LightActorsOfTag) == 0x0002E4, "Member 'ALoadoutPortal::LightActorsOfTag' has a wrong offset!");
static_assert(offsetof(ALoadoutPortal, IsActive) == 0x0002EC, "Member 'ALoadoutPortal::IsActive' has a wrong offset!");
static_assert(offsetof(ALoadoutPortal, LoadoutWidget) == 0x0002F0, "Member 'ALoadoutPortal::LoadoutWidget' has a wrong offset!");
static_assert(offsetof(ALoadoutPortal, CurrentController) == 0x0002F8, "Member 'ALoadoutPortal::CurrentController' has a wrong offset!");
static_assert(offsetof(ALoadoutPortal, HiddenDirectionalLights) == 0x000308, "Member 'ALoadoutPortal::HiddenDirectionalLights' has a wrong offset!");
static_assert(offsetof(ALoadoutPortal, HiddenPostProcessVolumes) == 0x000318, "Member 'ALoadoutPortal::HiddenPostProcessVolumes' has a wrong offset!");

// Class ReadyOrNot.AnimNotify_WedgeDoor
// 0x0008 (0x0040 - 0x0038)
class UAnimNotify_WedgeDoor final : public UAnimNotify
{
public:
	uint8                                         bWedgeDeployFinished : 1;                          // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_WedgeDoor">();
	}
	static class UAnimNotify_WedgeDoor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_WedgeDoor>();
	}
};
static_assert(alignof(UAnimNotify_WedgeDoor) == 0x000008, "Wrong alignment on UAnimNotify_WedgeDoor");
static_assert(sizeof(UAnimNotify_WedgeDoor) == 0x000040, "Wrong size on UAnimNotify_WedgeDoor");

// Class ReadyOrNot.BaseRadialMenuScript
// 0x0040 (0x0068 - 0x0028)
class UBaseRadialMenuScript : public UObject
{
public:
	TSoftObjectPtr<class UTexture2D>              RadialMenuIcon;                                    // 0x0028(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URadialWidgetBase*                      RadialMenuOwner;                                   // 0x0050(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 Actor;                                             // 0x0058(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWorld*                                 World;                                             // 0x0060(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ExecuteScript();
	void Initialize(class URadialWidgetBase* InRadialMenuOwner);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseRadialMenuScript">();
	}
	static class UBaseRadialMenuScript* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseRadialMenuScript>();
	}
};
static_assert(alignof(UBaseRadialMenuScript) == 0x000008, "Wrong alignment on UBaseRadialMenuScript");
static_assert(sizeof(UBaseRadialMenuScript) == 0x000068, "Wrong size on UBaseRadialMenuScript");
static_assert(offsetof(UBaseRadialMenuScript, RadialMenuIcon) == 0x000028, "Member 'UBaseRadialMenuScript::RadialMenuIcon' has a wrong offset!");
static_assert(offsetof(UBaseRadialMenuScript, RadialMenuOwner) == 0x000050, "Member 'UBaseRadialMenuScript::RadialMenuOwner' has a wrong offset!");
static_assert(offsetof(UBaseRadialMenuScript, Actor) == 0x000058, "Member 'UBaseRadialMenuScript::Actor' has a wrong offset!");
static_assert(offsetof(UBaseRadialMenuScript, World) == 0x000060, "Member 'UBaseRadialMenuScript::World' has a wrong offset!");

// Class ReadyOrNot.WeaponWheelScript
// 0x0040 (0x00A8 - 0x0068)
class UWeaponWheelScript final : public UBaseRadialMenuScript
{
public:
	class FText                                   ItemName;                                          // 0x0068(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   ItemCategory;                                      // 0x0080(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UWeaponWheelWidget*                     WeaponWheelOwner;                                  // 0x0098(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APlayerCharacter*                       PlayerCharacter;                                   // 0x00A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponWheelScript">();
	}
	static class UWeaponWheelScript* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponWheelScript>();
	}
};
static_assert(alignof(UWeaponWheelScript) == 0x000008, "Wrong alignment on UWeaponWheelScript");
static_assert(sizeof(UWeaponWheelScript) == 0x0000A8, "Wrong size on UWeaponWheelScript");
static_assert(offsetof(UWeaponWheelScript, ItemName) == 0x000068, "Member 'UWeaponWheelScript::ItemName' has a wrong offset!");
static_assert(offsetof(UWeaponWheelScript, ItemCategory) == 0x000080, "Member 'UWeaponWheelScript::ItemCategory' has a wrong offset!");
static_assert(offsetof(UWeaponWheelScript, WeaponWheelOwner) == 0x000098, "Member 'UWeaponWheelScript::WeaponWheelOwner' has a wrong offset!");
static_assert(offsetof(UWeaponWheelScript, PlayerCharacter) == 0x0000A0, "Member 'UWeaponWheelScript::PlayerCharacter' has a wrong offset!");

// Class ReadyOrNot.AnimTurnInPlaceLibrary
// 0x0000 (0x0028 - 0x0028)
class UAnimTurnInPlaceLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void PostProcessYawOffset(float DeltaSeconds, float& YawOffset, float& LastYawOffset, float& LastPostProcessedYawOffset, float& TurnAroundTimeToGo, float TurnAroundBlendTime);
	static void UpdateTurnInPlace(float DeltaTime, bool bAllowTurnInPlace, bool bHoldYawOffset, bool bIsTurnTransitionStateRelevant, bool bClampYawOffset, float YawOffsetLimit, const struct FRotator& MeshWorldRotation, const struct FAnimTurnInPlaceAnimSet& AnimSet, struct FAnimTurnInPlaceState& TurnInPlaceState, float TurnInPlaceSpeedMultiplier);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimTurnInPlaceLibrary">();
	}
	static class UAnimTurnInPlaceLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimTurnInPlaceLibrary>();
	}
};
static_assert(alignof(UAnimTurnInPlaceLibrary) == 0x000008, "Wrong alignment on UAnimTurnInPlaceLibrary");
static_assert(sizeof(UAnimTurnInPlaceLibrary) == 0x000028, "Wrong size on UAnimTurnInPlaceLibrary");

// Class ReadyOrNot.ArmourResourceComponent
// 0x0010 (0x0108 - 0x00F8)
class UArmourResourceComponent final : public UResourceComponent
{
public:
	int32                                         MaxTickets;                                        // 0x00F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Resistance;                                        // 0x00FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         RemainingTickets;                                  // 0x0100(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_104[0x4];                                      // 0x0104(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetMaxTickets(int32 NewMax);
	void SetResistance(float NewResistancePercentage);

	int32 GetMaxTickets() const;
	int32 GetRemainingTickets() const;
	float GetResistancePercentage() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArmourResourceComponent">();
	}
	static class UArmourResourceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArmourResourceComponent>();
	}
};
static_assert(alignof(UArmourResourceComponent) == 0x000008, "Wrong alignment on UArmourResourceComponent");
static_assert(sizeof(UArmourResourceComponent) == 0x000108, "Wrong size on UArmourResourceComponent");
static_assert(offsetof(UArmourResourceComponent, MaxTickets) == 0x0000F8, "Member 'UArmourResourceComponent::MaxTickets' has a wrong offset!");
static_assert(offsetof(UArmourResourceComponent, Resistance) == 0x0000FC, "Member 'UArmourResourceComponent::Resistance' has a wrong offset!");
static_assert(offsetof(UArmourResourceComponent, RemainingTickets) == 0x000100, "Member 'UArmourResourceComponent::RemainingTickets' has a wrong offset!");

// Class ReadyOrNot.ArrestAndRescueGS
// 0x0008 (0x0900 - 0x08F8)
class AArrestAndRescueGS final : public AReadyOrNotGameState
{
public:
	int32                                         BlueRespawnWaves;                                  // 0x08F8(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RedRespawnWaves;                                   // 0x08FC(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArrestAndRescueGS">();
	}
	static class AArrestAndRescueGS* GetDefaultObj()
	{
		return GetDefaultObjImpl<AArrestAndRescueGS>();
	}
};
static_assert(alignof(AArrestAndRescueGS) == 0x000008, "Wrong alignment on AArrestAndRescueGS");
static_assert(sizeof(AArrestAndRescueGS) == 0x000900, "Wrong size on AArrestAndRescueGS");
static_assert(offsetof(AArrestAndRescueGS, BlueRespawnWaves) == 0x0008F8, "Member 'AArrestAndRescueGS::BlueRespawnWaves' has a wrong offset!");
static_assert(offsetof(AArrestAndRescueGS, RedRespawnWaves) == 0x0008FC, "Member 'AArrestAndRescueGS::RedRespawnWaves' has a wrong offset!");

// Class ReadyOrNot.ArrestCancelWindowAnimNotify
// 0x0000 (0x0030 - 0x0030)
class UArrestCancelWindowAnimNotify final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArrestCancelWindowAnimNotify">();
	}
	static class UArrestCancelWindowAnimNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArrestCancelWindowAnimNotify>();
	}
};
static_assert(alignof(UArrestCancelWindowAnimNotify) == 0x000008, "Wrong alignment on UArrestCancelWindowAnimNotify");
static_assert(sizeof(UArrestCancelWindowAnimNotify) == 0x000030, "Wrong size on UArrestCancelWindowAnimNotify");

// Class ReadyOrNot.WorldBuildingPlacementActor
// 0x0028 (0x02C0 - 0x0298)
class AWorldBuildingPlacementActor final : public AActor
{
public:
	TSubclassOf<class UWorldBuildingActivity>     Activity;                                          // 0x0298(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACyberneticController*                  InUseByController;                                 // 0x02A0(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWorldBuildingActivity*                 ActivityInstance;                                  // 0x02A8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMoveActivity*                          MoveToActivityInstance;                            // 0x02B0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        DefaultScene;                                      // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnWorldBuildingActivityFinished(class UBaseActivity* InActivity, class ACyberneticController* CyberneticController);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldBuildingPlacementActor">();
	}
	static class AWorldBuildingPlacementActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWorldBuildingPlacementActor>();
	}
};
static_assert(alignof(AWorldBuildingPlacementActor) == 0x000008, "Wrong alignment on AWorldBuildingPlacementActor");
static_assert(sizeof(AWorldBuildingPlacementActor) == 0x0002C0, "Wrong size on AWorldBuildingPlacementActor");
static_assert(offsetof(AWorldBuildingPlacementActor, Activity) == 0x000298, "Member 'AWorldBuildingPlacementActor::Activity' has a wrong offset!");
static_assert(offsetof(AWorldBuildingPlacementActor, InUseByController) == 0x0002A0, "Member 'AWorldBuildingPlacementActor::InUseByController' has a wrong offset!");
static_assert(offsetof(AWorldBuildingPlacementActor, ActivityInstance) == 0x0002A8, "Member 'AWorldBuildingPlacementActor::ActivityInstance' has a wrong offset!");
static_assert(offsetof(AWorldBuildingPlacementActor, MoveToActivityInstance) == 0x0002B0, "Member 'AWorldBuildingPlacementActor::MoveToActivityInstance' has a wrong offset!");
static_assert(offsetof(AWorldBuildingPlacementActor, DefaultScene) == 0x0002B8, "Member 'AWorldBuildingPlacementActor::DefaultScene' has a wrong offset!");

// Class ReadyOrNot.ArrestTargetActivity
// 0x0030 (0x0220 - 0x01F0)
class UArrestTargetActivity final : public UBaseActivity
{
public:
	class ACyberneticCharacter*                   ArrestTarget;                                      // 0x01F0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractionsData*                      ArrestInteraction;                                 // 0x01F8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_200[0x20];                                     // 0x0200(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnterArrestStage();
	void EnterMoveToStage();
	void OnArresterKilled(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter);
	void TickArrestStage(float DeltaTime, float Uptime);

	bool CanArrest() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArrestTargetActivity">();
	}
	static class UArrestTargetActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArrestTargetActivity>();
	}
};
static_assert(alignof(UArrestTargetActivity) == 0x000008, "Wrong alignment on UArrestTargetActivity");
static_assert(sizeof(UArrestTargetActivity) == 0x000220, "Wrong size on UArrestTargetActivity");
static_assert(offsetof(UArrestTargetActivity, ArrestTarget) == 0x0001F0, "Member 'UArrestTargetActivity::ArrestTarget' has a wrong offset!");
static_assert(offsetof(UArrestTargetActivity, ArrestInteraction) == 0x0001F8, "Member 'UArrestTargetActivity::ArrestInteraction' has a wrong offset!");

// Class ReadyOrNot.ArrestXSuspects
// 0x0008 (0x0328 - 0x0320)
class AArrestXSuspects final : public AObjective
{
public:
	int32                                         RequiredArrests;                                   // 0x0320(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_324[0x4];                                      // 0x0324(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArrestXSuspects">();
	}
	static class AArrestXSuspects* GetDefaultObj()
	{
		return GetDefaultObjImpl<AArrestXSuspects>();
	}
};
static_assert(alignof(AArrestXSuspects) == 0x000008, "Wrong alignment on AArrestXSuspects");
static_assert(sizeof(AArrestXSuspects) == 0x000328, "Wrong size on AArrestXSuspects");
static_assert(offsetof(AArrestXSuspects, RequiredArrests) == 0x000320, "Member 'AArrestXSuspects::RequiredArrests' has a wrong offset!");

// Class ReadyOrNot.AspectRatioConstraintBox
// 0x0018 (0x01B0 - 0x0198)
class UAspectRatioConstraintBox final : public UContentWidget
{
public:
	bool                                          bUseFixedConstraint;                               // 0x0198(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_199[0x3];                                      // 0x0199(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FixedAspectRatio;                                  // 0x019C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A0[0x10];                                     // 0x01A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DisableConstraint();
	void EnableConstraint();
	void OnSettingsUpdated();
	void SetFixedAspectRatio(float NewAspectRatio);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AspectRatioConstraintBox">();
	}
	static class UAspectRatioConstraintBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAspectRatioConstraintBox>();
	}
};
static_assert(alignof(UAspectRatioConstraintBox) == 0x000008, "Wrong alignment on UAspectRatioConstraintBox");
static_assert(sizeof(UAspectRatioConstraintBox) == 0x0001B0, "Wrong size on UAspectRatioConstraintBox");
static_assert(offsetof(UAspectRatioConstraintBox, bUseFixedConstraint) == 0x000198, "Member 'UAspectRatioConstraintBox::bUseFixedConstraint' has a wrong offset!");
static_assert(offsetof(UAspectRatioConstraintBox, FixedAspectRatio) == 0x00019C, "Member 'UAspectRatioConstraintBox::FixedAspectRatio' has a wrong offset!");

// Class ReadyOrNot.AsyncLoader
// 0x0000 (0x0028 - 0x0028)
class UAsyncLoader final : public UBlueprintFunctionLibrary
{
public:
	static class UAnimMontage* GetLazyLoadedAnimMontage(TSoftObjectPtr<class UAnimMontage> Montage);
	static class UAnimSequence* GetLazyLoadedAnimSequence(TSoftObjectPtr<class UAnimSequence> Anim);
	static class UClass* GetLazyLoadedClass(TSoftClassPtr<class UClass> Class_0);
	static TArray<TSubclassOf<class UClass>> GetLazyLoadedClassArray(const TArray<TSoftClassPtr<class UClass>>& Array);
	static class UTexture2D* GetLazyLoadedImage(TSoftObjectPtr<class UTexture2D> Texture);
	static TSubclassOf<class ABaseItem> GetLazyLoadedItem(TSoftClassPtr<class UClass> Item);
	static class UMaterialInstance* GetLazyLoadedMaterialInstance(TSoftObjectPtr<class UMaterialInstance> Material);
	static class UStaticMesh* GetLazyLoadedMesh(TSoftObjectPtr<class UStaticMesh> Mesh);
	static class UObject* GetLazyLoadedObject(TSoftObjectPtr<class UObject> Object);
	static class UParticleSystem* GetLazyLoadedParticleSystem(TSoftObjectPtr<class UParticleSystem> Particle);
	static TArray<TSubclassOf<class AReadyOrNotGameMode>> GetLazyLoadedReadyOrNotGameModeArray(const TArray<TSoftClassPtr<class UClass>>& Array);
	static class USkeletalMesh* GetLazyLoadedSkeletalMesh(TSoftObjectPtr<class USkeletalMesh> Mesh);
	static class USoundCue* GetLazyLoadedSoundCue(TSoftObjectPtr<class USoundCue> Cue);
	static TSubclassOf<class ABaseWeapon> GetLazyLoadedWeapon(TSoftClassPtr<class UClass> Item);
	static TSubclassOf<class UUserWidget> GetLazyLoadedWidget(TSoftClassPtr<class UClass> Widget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncLoader">();
	}
	static class UAsyncLoader* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncLoader>();
	}
};
static_assert(alignof(UAsyncLoader) == 0x000008, "Wrong alignment on UAsyncLoader");
static_assert(sizeof(UAsyncLoader) == 0x000028, "Wrong size on UAsyncLoader");

// Class ReadyOrNot.AttachmentSlot_V2
// 0x0048 (0x0330 - 0x02E8)
class UAttachmentSlot_V2 final : public UCommonUserWidget
{
public:
	EWeaponAttachmentType                         AttachmentType;                                    // 0x02E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E9[0x7];                                      // 0x02E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             ItemImage;                                         // 0x02F0(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             EmptyImage;                                        // 0x02F8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   ItemName;                                          // 0x0300(0x0018)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class UTextBlock*                             ItemType;                                          // 0x0318(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWeaponAttachment*                      Attachment;                                        // 0x0320(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          Equipped;                                          // 0x0328(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_329[0x7];                                      // 0x0329(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TSubclassOf<class UWeaponAttachment> GetAttachment();
	EWeaponAttachmentType GetAttachmentType();
	bool GetEquipped();
	void OnEquipped();
	void RefreshAttachmentInfo();
	void SetAttachment(class UWeaponAttachment* WeaponAttachment);
	void SetAttachmentType(EWeaponAttachmentType Type);
	void SetEquipped(bool IsEquipped);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AttachmentSlot_V2">();
	}
	static class UAttachmentSlot_V2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAttachmentSlot_V2>();
	}
};
static_assert(alignof(UAttachmentSlot_V2) == 0x000008, "Wrong alignment on UAttachmentSlot_V2");
static_assert(sizeof(UAttachmentSlot_V2) == 0x000330, "Wrong size on UAttachmentSlot_V2");
static_assert(offsetof(UAttachmentSlot_V2, AttachmentType) == 0x0002E8, "Member 'UAttachmentSlot_V2::AttachmentType' has a wrong offset!");
static_assert(offsetof(UAttachmentSlot_V2, ItemImage) == 0x0002F0, "Member 'UAttachmentSlot_V2::ItemImage' has a wrong offset!");
static_assert(offsetof(UAttachmentSlot_V2, EmptyImage) == 0x0002F8, "Member 'UAttachmentSlot_V2::EmptyImage' has a wrong offset!");
static_assert(offsetof(UAttachmentSlot_V2, ItemName) == 0x000300, "Member 'UAttachmentSlot_V2::ItemName' has a wrong offset!");
static_assert(offsetof(UAttachmentSlot_V2, ItemType) == 0x000318, "Member 'UAttachmentSlot_V2::ItemType' has a wrong offset!");
static_assert(offsetof(UAttachmentSlot_V2, Attachment) == 0x000320, "Member 'UAttachmentSlot_V2::Attachment' has a wrong offset!");
static_assert(offsetof(UAttachmentSlot_V2, Equipped) == 0x000328, "Member 'UAttachmentSlot_V2::Equipped' has a wrong offset!");

// Class ReadyOrNot.BadAIAction
// 0x0068 (0x0300 - 0x0298)
class ABadAIAction final : public AActor
{
public:
	class FText                                   Summary;                                           // 0x0298(0x0018)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x02B0(0x0018)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C8[0x8];                                      // 0x02C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBillboardComponent*                    BillboardComponent;                                // 0x02D0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D8[0x28];                                     // 0x02D8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddNote(const class FText& InSummary, const class FText& InDescription);
	void RemoveBadAIAction();
	void RemoveReport(bool bReportToLog, bool bDrawString);
	void Report(bool bReportToLog, bool bDrawString);
	void ReportBadAIAction();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BadAIAction">();
	}
	static class ABadAIAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABadAIAction>();
	}
};
static_assert(alignof(ABadAIAction) == 0x000008, "Wrong alignment on ABadAIAction");
static_assert(sizeof(ABadAIAction) == 0x000300, "Wrong size on ABadAIAction");
static_assert(offsetof(ABadAIAction, Summary) == 0x000298, "Member 'ABadAIAction::Summary' has a wrong offset!");
static_assert(offsetof(ABadAIAction, Description) == 0x0002B0, "Member 'ABadAIAction::Description' has a wrong offset!");
static_assert(offsetof(ABadAIAction, BillboardComponent) == 0x0002D0, "Member 'ABadAIAction::BillboardComponent' has a wrong offset!");

// Class ReadyOrNot.BaseDeployableGear
// 0x0000 (0x0BB0 - 0x0BB0)
class ABaseDeployableGear : public ABaseItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseDeployableGear">();
	}
	static class ABaseDeployableGear* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseDeployableGear>();
	}
};
static_assert(alignof(ABaseDeployableGear) == 0x000010, "Wrong alignment on ABaseDeployableGear");
static_assert(sizeof(ABaseDeployableGear) == 0x000BB0, "Wrong size on ABaseDeployableGear");

// Class ReadyOrNot.ItemWheel
// 0x0210 (0x04D0 - 0x02C0)
class alignas(0x10) UItemWheel : public UUserWidget
{
public:
	class UDataTable*                             ItemWheelDataTable;                                // 0x02C0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentIndex;                                      // 0x02C8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PreviousNavSelectionIndex;                         // 0x02CC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidget*                            MainWheel;                                         // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidget*                            SubWheel;                                          // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FItemWheelOption>               CurrentItemWheelOptions;                           // 0x02E0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UTextBlock*                             HeaderText;                                        // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               HeaderOverlay;                                     // 0x02F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGamepadButtonImage*                    NavigateBackImage;                                 // 0x0300(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidget*                            InnerWheel;                                        // 0x0308(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUserWidget*                            OuterWheel;                                        // 0x0310(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_318[0x1B8];                                    // 0x0318(0x01B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ForceSetInDeadzone(bool bInDeadzone);
	void ItemAdded(class ABaseItem* Item);
	void ItemEquipped(class ABaseItem* Item);
	void ItemRemoved(class ABaseItem* Item);
	void ItemWheelCollapsed();
	void ItemWheelDisabled();
	void ItemWheelEnabled();
	void ItemWheelExpanded();
	void SetWheelOptions(const class UUserWidget* ItemWheel, const TArray<struct FItemWheelOption>& ItemWheelOptions, const int32& SelectedIndex);
	void SetWheelSegments(const class UUserWidget* ItemWheel, const uint8& Amount);
	void SetWheelSelection(const class UUserWidget* ItemWheel, const struct FVector& Direction);

	bool IsSegmentEnabled(const int32& SegmentIndex) const;
	void SetHeaderText(const class FText& Text) const;
	bool ValidWithoutSubOptions(const int32& SegmentIndex) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemWheel">();
	}
	static class UItemWheel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemWheel>();
	}
};
static_assert(alignof(UItemWheel) == 0x000010, "Wrong alignment on UItemWheel");
static_assert(sizeof(UItemWheel) == 0x0004D0, "Wrong size on UItemWheel");
static_assert(offsetof(UItemWheel, ItemWheelDataTable) == 0x0002C0, "Member 'UItemWheel::ItemWheelDataTable' has a wrong offset!");
static_assert(offsetof(UItemWheel, CurrentIndex) == 0x0002C8, "Member 'UItemWheel::CurrentIndex' has a wrong offset!");
static_assert(offsetof(UItemWheel, PreviousNavSelectionIndex) == 0x0002CC, "Member 'UItemWheel::PreviousNavSelectionIndex' has a wrong offset!");
static_assert(offsetof(UItemWheel, MainWheel) == 0x0002D0, "Member 'UItemWheel::MainWheel' has a wrong offset!");
static_assert(offsetof(UItemWheel, SubWheel) == 0x0002D8, "Member 'UItemWheel::SubWheel' has a wrong offset!");
static_assert(offsetof(UItemWheel, CurrentItemWheelOptions) == 0x0002E0, "Member 'UItemWheel::CurrentItemWheelOptions' has a wrong offset!");
static_assert(offsetof(UItemWheel, HeaderText) == 0x0002F0, "Member 'UItemWheel::HeaderText' has a wrong offset!");
static_assert(offsetof(UItemWheel, HeaderOverlay) == 0x0002F8, "Member 'UItemWheel::HeaderOverlay' has a wrong offset!");
static_assert(offsetof(UItemWheel, NavigateBackImage) == 0x000300, "Member 'UItemWheel::NavigateBackImage' has a wrong offset!");
static_assert(offsetof(UItemWheel, InnerWheel) == 0x000308, "Member 'UItemWheel::InnerWheel' has a wrong offset!");
static_assert(offsetof(UItemWheel, OuterWheel) == 0x000310, "Member 'UItemWheel::OuterWheel' has a wrong offset!");

// Class ReadyOrNot.BallisticsShield
// 0x0040 (0x0BF0 - 0x0BB0)
class ABallisticsShield : public ABaseDeployableGear
{
public:
	class UMaterialInstanceDynamic*               GlassMaterialInstance;                             // 0x0BB0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABaseMagazineWeapon*                    PistolEquippedWithShield;                          // 0x0BB8(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC0[0x8];                                      // 0x0BC0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             ShieldHitEvent;                                    // 0x0BC8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Damage;                                            // 0x0BD0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlassPhaseParam;                                   // 0x0BD4(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BD8[0x2];                                      // 0x0BD8(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bLowered;                                          // 0x0BDA(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BDB[0x5];                                      // 0x0BDB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ULegacyCameraShake>         ShieldHitCameraShake;                              // 0x0BE0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BE8[0x8];                                      // 0x0BE8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Client_SetPistol(class ABaseItem* newPistol);
	void Server_SetLowered(bool bShouldLower);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BallisticsShield">();
	}
	static class ABallisticsShield* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABallisticsShield>();
	}
};
static_assert(alignof(ABallisticsShield) == 0x000010, "Wrong alignment on ABallisticsShield");
static_assert(sizeof(ABallisticsShield) == 0x000BF0, "Wrong size on ABallisticsShield");
static_assert(offsetof(ABallisticsShield, GlassMaterialInstance) == 0x000BB0, "Member 'ABallisticsShield::GlassMaterialInstance' has a wrong offset!");
static_assert(offsetof(ABallisticsShield, PistolEquippedWithShield) == 0x000BB8, "Member 'ABallisticsShield::PistolEquippedWithShield' has a wrong offset!");
static_assert(offsetof(ABallisticsShield, ShieldHitEvent) == 0x000BC8, "Member 'ABallisticsShield::ShieldHitEvent' has a wrong offset!");
static_assert(offsetof(ABallisticsShield, Damage) == 0x000BD0, "Member 'ABallisticsShield::Damage' has a wrong offset!");
static_assert(offsetof(ABallisticsShield, GlassPhaseParam) == 0x000BD4, "Member 'ABallisticsShield::GlassPhaseParam' has a wrong offset!");
static_assert(offsetof(ABallisticsShield, bLowered) == 0x000BDA, "Member 'ABallisticsShield::bLowered' has a wrong offset!");
static_assert(offsetof(ABallisticsShield, ShieldHitCameraShake) == 0x000BE0, "Member 'ABallisticsShield::ShieldHitCameraShake' has a wrong offset!");

// Class ReadyOrNot.BanManagerLibrary
// 0x0000 (0x0028 - 0x0028)
class UBanManagerLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void BanPlayer(class UObject* WorldContextObject, const class FString& UniquePlayerId, const class FString& DisplayName, const EBanType BanType);
	static TMap<class FString, struct FPlayerBanInfo> GetBannedPlayers(class UObject* WorldContextObject);
	static bool IsPlayerBanned(class UObject* WorldContextObject, const class FString& UniquePlayerId);
	static void UnbanPlayer(class UObject* WorldContextObject, const class FString& UniquePlayerId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BanManagerLibrary">();
	}
	static class UBanManagerLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBanManagerLibrary>();
	}
};
static_assert(alignof(UBanManagerLibrary) == 0x000008, "Wrong alignment on UBanManagerLibrary");
static_assert(sizeof(UBanManagerLibrary) == 0x000028, "Wrong size on UBanManagerLibrary");

// Class ReadyOrNot.CacheRetrievalPoint
// 0x0010 (0x02B0 - 0x02A0)
class UCacheRetrievalPoint final : public USceneComponent
{
public:
	bool                                          bEnabled;                                          // 0x02A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInUse;                                            // 0x02A1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A2[0x6];                                      // 0x02A2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class ACyberneticCharacter*                   UsingCharacter;                                    // 0x02A8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CacheRetrievalPoint">();
	}
	static class UCacheRetrievalPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCacheRetrievalPoint>();
	}
};
static_assert(alignof(UCacheRetrievalPoint) == 0x000010, "Wrong alignment on UCacheRetrievalPoint");
static_assert(sizeof(UCacheRetrievalPoint) == 0x0002B0, "Wrong size on UCacheRetrievalPoint");
static_assert(offsetof(UCacheRetrievalPoint, bEnabled) == 0x0002A0, "Member 'UCacheRetrievalPoint::bEnabled' has a wrong offset!");
static_assert(offsetof(UCacheRetrievalPoint, bInUse) == 0x0002A1, "Member 'UCacheRetrievalPoint::bInUse' has a wrong offset!");
static_assert(offsetof(UCacheRetrievalPoint, UsingCharacter) == 0x0002A8, "Member 'UCacheRetrievalPoint::UsingCharacter' has a wrong offset!");

// Class ReadyOrNot.BanManagerProfile
// 0x0050 (0x0078 - 0x0028)
class UBanManagerProfile final : public USaveGame
{
public:
	TMap<class FString, struct FPlayerBanInfo>    BannedPlayers;                                     // 0x0028(0x0050)(Edit, EditConst, Protected, NativeAccessSpecifierProtected)

public:
	void AddBannedPlayer(const class FString& UniquePlayerId, const class FString& DisplayName, const EBanType BanType);
	TMap<class FString, struct FPlayerBanInfo> GetBannedPlayers();
	void RemoveBannedPlayer(const class FString& UniquePlayerId);

	bool IsPlayerBanned(const class FString& UniquePlayerId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BanManagerProfile">();
	}
	static class UBanManagerProfile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBanManagerProfile>();
	}
};
static_assert(alignof(UBanManagerProfile) == 0x000008, "Wrong alignment on UBanManagerProfile");
static_assert(sizeof(UBanManagerProfile) == 0x000078, "Wrong size on UBanManagerProfile");
static_assert(offsetof(UBanManagerProfile, BannedPlayers) == 0x000028, "Member 'UBanManagerProfile::BannedPlayers' has a wrong offset!");

// Class ReadyOrNot.BanManagerSubsystem
// 0x0008 (0x0038 - 0x0030)
class UBanManagerSubsystem final : public UGameInstanceSubsystem
{
public:
	class UBanManagerProfile*                     Profile;                                           // 0x0030(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BanManagerSubsystem">();
	}
	static class UBanManagerSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBanManagerSubsystem>();
	}
};
static_assert(alignof(UBanManagerSubsystem) == 0x000008, "Wrong alignment on UBanManagerSubsystem");
static_assert(sizeof(UBanManagerSubsystem) == 0x000038, "Wrong size on UBanManagerSubsystem");
static_assert(offsetof(UBanManagerSubsystem, Profile) == 0x000030, "Member 'UBanManagerSubsystem::Profile' has a wrong offset!");

// Class ReadyOrNot.BaseArmour
// 0x0070 (0x0C20 - 0x0BB0)
class ABaseArmour : public ABaseItem
{
public:
	bool                                          bIsHeavy;                                          // 0x0BB0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BB1[0x3];                                      // 0x0BB1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ScaleLensFlare;                                    // 0x0BB4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USkeletalMesh*>                  Variations;                                        // 0x0BB8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	class UParticleSystem*                        ArmourHitParticle;                                 // 0x0BC8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             ArmourHitSound;                                    // 0x0BD0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             ArmourHitSoundFirstPerson;                         // 0x0BD8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             PaperdollTexture;                                  // 0x0BE0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             PaperdollTexture_Crouch;                           // 0x0BE8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             PaperdollTexture_Carry;                            // 0x0BF0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             PaperdollTexture_Carry_Crouch;                     // 0x0BF8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ULegacyCameraShake>         InterceptShakeFront;                               // 0x0C00(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ULegacyCameraShake>         InterceptShakeBack;                                // 0x0C08(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ULegacyCameraShake>         InterceptShakeLeft;                                // 0x0C10(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ULegacyCameraShake>         InterceptShakeRight;                               // 0x0C18(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	float GetDurabilityPercentage() const;
	bool HasRemainingProtection() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseArmour">();
	}
	static class ABaseArmour* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseArmour>();
	}
};
static_assert(alignof(ABaseArmour) == 0x000010, "Wrong alignment on ABaseArmour");
static_assert(sizeof(ABaseArmour) == 0x000C20, "Wrong size on ABaseArmour");
static_assert(offsetof(ABaseArmour, bIsHeavy) == 0x000BB0, "Member 'ABaseArmour::bIsHeavy' has a wrong offset!");
static_assert(offsetof(ABaseArmour, ScaleLensFlare) == 0x000BB4, "Member 'ABaseArmour::ScaleLensFlare' has a wrong offset!");
static_assert(offsetof(ABaseArmour, Variations) == 0x000BB8, "Member 'ABaseArmour::Variations' has a wrong offset!");
static_assert(offsetof(ABaseArmour, ArmourHitParticle) == 0x000BC8, "Member 'ABaseArmour::ArmourHitParticle' has a wrong offset!");
static_assert(offsetof(ABaseArmour, ArmourHitSound) == 0x000BD0, "Member 'ABaseArmour::ArmourHitSound' has a wrong offset!");
static_assert(offsetof(ABaseArmour, ArmourHitSoundFirstPerson) == 0x000BD8, "Member 'ABaseArmour::ArmourHitSoundFirstPerson' has a wrong offset!");
static_assert(offsetof(ABaseArmour, PaperdollTexture) == 0x000BE0, "Member 'ABaseArmour::PaperdollTexture' has a wrong offset!");
static_assert(offsetof(ABaseArmour, PaperdollTexture_Crouch) == 0x000BE8, "Member 'ABaseArmour::PaperdollTexture_Crouch' has a wrong offset!");
static_assert(offsetof(ABaseArmour, PaperdollTexture_Carry) == 0x000BF0, "Member 'ABaseArmour::PaperdollTexture_Carry' has a wrong offset!");
static_assert(offsetof(ABaseArmour, PaperdollTexture_Carry_Crouch) == 0x000BF8, "Member 'ABaseArmour::PaperdollTexture_Carry_Crouch' has a wrong offset!");
static_assert(offsetof(ABaseArmour, InterceptShakeFront) == 0x000C00, "Member 'ABaseArmour::InterceptShakeFront' has a wrong offset!");
static_assert(offsetof(ABaseArmour, InterceptShakeBack) == 0x000C08, "Member 'ABaseArmour::InterceptShakeBack' has a wrong offset!");
static_assert(offsetof(ABaseArmour, InterceptShakeLeft) == 0x000C10, "Member 'ABaseArmour::InterceptShakeLeft' has a wrong offset!");
static_assert(offsetof(ABaseArmour, InterceptShakeRight) == 0x000C18, "Member 'ABaseArmour::InterceptShakeRight' has a wrong offset!");

// Class ReadyOrNot.BaseCombatActivity
// 0x02C0 (0x04B0 - 0x01F0)
class UBaseCombatActivity : public UBaseActivity
{
public:
	TMulticastInlineDelegate<void(class AReadyOrNotCharacter* NewTrackedEnemy)> OnTrackNewEnemy;     // 0x01F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FScriptedFireAt                        CurrentScriptedFireAt;                             // 0x0200(0x0038)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FScriptedLookAt                        CurrentScriptedLookAt;                             // 0x0238(0x0028)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_260[0xC];                                      // 0x0260(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FleeDesire;                                        // 0x026C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeSincePerformingAnyCombatMove;                  // 0x0270(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimePerformingAnyCombatMove;                       // 0x0274(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTraverseHoleActivity*                  TraverseHoleActivity;                              // 0x0278(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBaseCombatMoveActivity*                CombatMoveActivity;                                // 0x0280(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBaseCombatMoveActivity*                PreviousCombatMoveActivity;                        // 0x0288(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHardCoverCombatMove*                   HardCoverCombatMove;                               // 0x0290(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDuelingCombatMove*                     DuelingCombatMove;                                 // 0x0298(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFlankingCombatMove*                    FlankingCombatMove;                                // 0x02A0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USuppressionCombatMove*                 SuppressionCombatMove;                             // 0x02A8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPushCombatMove*                        PushCombatMove;                                    // 0x02B0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UChargeCombatMove*                      ChargeCombatMove;                                  // 0x02B8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFleeingCombatMove*                     FleeingCombatMove;                                 // 0x02C0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URepositionCombatMove*                  RepositionCombatMove;                              // 0x02C8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D0[0x18];                                     // 0x02D0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CoverLandmarkEvaluationCooldown;                   // 0x02E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2EC[0x4];                                      // 0x02EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AReadyOrNotCharacter*                   LastTrackedEnemy;                                  // 0x02F0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F8[0x18];                                     // 0x02F8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UPickupItemActivity*                    PickupItemActivity;                                // 0x0310(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UReloadSafelyActivity*                  ReloadSafelyActivity;                              // 0x0318(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlayDeadActivity*                      PlayDeadActivity;                                  // 0x0320(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCommitSuicideActivity*                 CommitSuicideActivity;                             // 0x0328(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UIntimidateNearbyCivilianActivity*      IntimidateNearbyCivilianActivity;                  // 0x0330(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCompliantActivity*                     CompliantActivity;                                 // 0x0338(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBaseActivity*                          RallyToActivity;                                   // 0x0340(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBaseActivity*                          RegroupActivity;                                   // 0x0348(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_350[0x160];                                    // 0x0350(0x0160)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnterNoStrafeState();
	void EnterStrafeState();
	void FinishCombatMove(bool bSuccess);
	void OnCoverExit();
	void OnCoverFound();
	void OnCoverLandmarkExit();
	void OnNoCoverFound();
	void OnRequestCover();
	void OnRequestCoverLandmark();
	void OnStunned(class AReadyOrNotCharacter* StunnedCharacter, float Duration, EStunType StunType, class AActor* DamageCauser);
	void OnSuicideFakeOutSuccess();
	void OnTakeDamage(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* DamagedCharacter, class AActor* DamageCauser, float Damage, float HealthRemaining);
	void PerformNoStrafeLogic(float DeltaTime, float Uptime);
	void PerformStrafeLogic(float DeltaTime, float Uptime);
	void PlayDeadFinished(class UBaseActivity* Activity, class ACyberneticController* Controller);
	void PlayDeadStarted(class UBaseActivity* Activity, class ACyberneticController* Controller);
	void ResetTimeSpentEngagingOnTarget();
	void ScriptedFireAtActor(class AActor* InActor, float InTime, bool bOverrideTarget, float AccuracyPenaltyMultiplier, bool bInfiniteAmmo);
	void ScriptedFireAtLocation(const struct FVector& InLocation, float InTime, bool bOverrideTarget, float AccuracyPenaltyMultiplier, bool bInfiniteAmmo);
	void ScriptedLookAtActor(class AActor* InActor, float InTime);
	void ScriptedLookAtLocation(const struct FVector& InLocation, float InTime);
	void StartRunningCombatMove(class UBaseCombatMoveActivity* CombatMove);
	void StopScriptedFire();
	void StopScriptedLook();
	void TrackEnemyFire(class AReadyOrNotCharacter* FromCharacter, class ABaseMagazineWeapon* Weapon, const struct FVector& fireDirection);
	void TrackEnemyKilled(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter);

	class UBaseCombatMoveActivity* GetCombatMoveActivity() const;
	int32 GetFailureCountForCombatMove(TSubclassOf<class UBaseCombatMoveActivity> CombatMoveClass) const;
	bool IsFocusingOnActor(const class AActor* InActor) const;
	bool IsRunningCombatMoveActivity(class UClass* Class_0) const;
	bool IsTryingToFireAtScriptedActor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseCombatActivity">();
	}
	static class UBaseCombatActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseCombatActivity>();
	}
};
static_assert(alignof(UBaseCombatActivity) == 0x000008, "Wrong alignment on UBaseCombatActivity");
static_assert(sizeof(UBaseCombatActivity) == 0x0004B0, "Wrong size on UBaseCombatActivity");
static_assert(offsetof(UBaseCombatActivity, OnTrackNewEnemy) == 0x0001F0, "Member 'UBaseCombatActivity::OnTrackNewEnemy' has a wrong offset!");
static_assert(offsetof(UBaseCombatActivity, CurrentScriptedFireAt) == 0x000200, "Member 'UBaseCombatActivity::CurrentScriptedFireAt' has a wrong offset!");
static_assert(offsetof(UBaseCombatActivity, CurrentScriptedLookAt) == 0x000238, "Member 'UBaseCombatActivity::CurrentScriptedLookAt' has a wrong offset!");
static_assert(offsetof(UBaseCombatActivity, FleeDesire) == 0x00026C, "Member 'UBaseCombatActivity::FleeDesire' has a wrong offset!");
static_assert(offsetof(UBaseCombatActivity, TimeSincePerformingAnyCombatMove) == 0x000270, "Member 'UBaseCombatActivity::TimeSincePerformingAnyCombatMove' has a wrong offset!");
static_assert(offsetof(UBaseCombatActivity, TimePerformingAnyCombatMove) == 0x000274, "Member 'UBaseCombatActivity::TimePerformingAnyCombatMove' has a wrong offset!");
static_assert(offsetof(UBaseCombatActivity, TraverseHoleActivity) == 0x000278, "Member 'UBaseCombatActivity::TraverseHoleActivity' has a wrong offset!");
static_assert(offsetof(UBaseCombatActivity, CombatMoveActivity) == 0x000280, "Member 'UBaseCombatActivity::CombatMoveActivity' has a wrong offset!");
static_assert(offsetof(UBaseCombatActivity, PreviousCombatMoveActivity) == 0x000288, "Member 'UBaseCombatActivity::PreviousCombatMoveActivity' has a wrong offset!");
static_assert(offsetof(UBaseCombatActivity, HardCoverCombatMove) == 0x000290, "Member 'UBaseCombatActivity::HardCoverCombatMove' has a wrong offset!");
static_assert(offsetof(UBaseCombatActivity, DuelingCombatMove) == 0x000298, "Member 'UBaseCombatActivity::DuelingCombatMove' has a wrong offset!");
static_assert(offsetof(UBaseCombatActivity, FlankingCombatMove) == 0x0002A0, "Member 'UBaseCombatActivity::FlankingCombatMove' has a wrong offset!");
static_assert(offsetof(UBaseCombatActivity, SuppressionCombatMove) == 0x0002A8, "Member 'UBaseCombatActivity::SuppressionCombatMove' has a wrong offset!");
static_assert(offsetof(UBaseCombatActivity, PushCombatMove) == 0x0002B0, "Member 'UBaseCombatActivity::PushCombatMove' has a wrong offset!");
static_assert(offsetof(UBaseCombatActivity, ChargeCombatMove) == 0x0002B8, "Member 'UBaseCombatActivity::ChargeCombatMove' has a wrong offset!");
static_assert(offsetof(UBaseCombatActivity, FleeingCombatMove) == 0x0002C0, "Member 'UBaseCombatActivity::FleeingCombatMove' has a wrong offset!");
static_assert(offsetof(UBaseCombatActivity, RepositionCombatMove) == 0x0002C8, "Member 'UBaseCombatActivity::RepositionCombatMove' has a wrong offset!");
static_assert(offsetof(UBaseCombatActivity, CoverLandmarkEvaluationCooldown) == 0x0002E8, "Member 'UBaseCombatActivity::CoverLandmarkEvaluationCooldown' has a wrong offset!");
static_assert(offsetof(UBaseCombatActivity, LastTrackedEnemy) == 0x0002F0, "Member 'UBaseCombatActivity::LastTrackedEnemy' has a wrong offset!");
static_assert(offsetof(UBaseCombatActivity, PickupItemActivity) == 0x000310, "Member 'UBaseCombatActivity::PickupItemActivity' has a wrong offset!");
static_assert(offsetof(UBaseCombatActivity, ReloadSafelyActivity) == 0x000318, "Member 'UBaseCombatActivity::ReloadSafelyActivity' has a wrong offset!");
static_assert(offsetof(UBaseCombatActivity, PlayDeadActivity) == 0x000320, "Member 'UBaseCombatActivity::PlayDeadActivity' has a wrong offset!");
static_assert(offsetof(UBaseCombatActivity, CommitSuicideActivity) == 0x000328, "Member 'UBaseCombatActivity::CommitSuicideActivity' has a wrong offset!");
static_assert(offsetof(UBaseCombatActivity, IntimidateNearbyCivilianActivity) == 0x000330, "Member 'UBaseCombatActivity::IntimidateNearbyCivilianActivity' has a wrong offset!");
static_assert(offsetof(UBaseCombatActivity, CompliantActivity) == 0x000338, "Member 'UBaseCombatActivity::CompliantActivity' has a wrong offset!");
static_assert(offsetof(UBaseCombatActivity, RallyToActivity) == 0x000340, "Member 'UBaseCombatActivity::RallyToActivity' has a wrong offset!");
static_assert(offsetof(UBaseCombatActivity, RegroupActivity) == 0x000348, "Member 'UBaseCombatActivity::RegroupActivity' has a wrong offset!");

// Class ReadyOrNot.ItemSlot_V2
// 0x0038 (0x0320 - 0x02E8)
class UItemSlot_V2 : public UCommonUserWidget
{
public:
	class ABaseItem*                              BaseItem;                                          // 0x02E8(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UArmourMaterial*                        ArmorMaterial;                                     // 0x02F0(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ItemName;                                          // 0x02F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ItemType;                                          // 0x0300(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         PrefixText;                                        // 0x0308(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 PresetName;                                        // 0x0310(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetArmorMaterial(class UArmourMaterial* Armor);
	void SetItem(class ABaseItem* Item);
	void SetTexts(const class FText& Name_0, const class FText& Type);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemSlot_V2">();
	}
	static class UItemSlot_V2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemSlot_V2>();
	}
};
static_assert(alignof(UItemSlot_V2) == 0x000008, "Wrong alignment on UItemSlot_V2");
static_assert(sizeof(UItemSlot_V2) == 0x000320, "Wrong size on UItemSlot_V2");
static_assert(offsetof(UItemSlot_V2, BaseItem) == 0x0002E8, "Member 'UItemSlot_V2::BaseItem' has a wrong offset!");
static_assert(offsetof(UItemSlot_V2, ArmorMaterial) == 0x0002F0, "Member 'UItemSlot_V2::ArmorMaterial' has a wrong offset!");
static_assert(offsetof(UItemSlot_V2, ItemName) == 0x0002F8, "Member 'UItemSlot_V2::ItemName' has a wrong offset!");
static_assert(offsetof(UItemSlot_V2, ItemType) == 0x000300, "Member 'UItemSlot_V2::ItemType' has a wrong offset!");
static_assert(offsetof(UItemSlot_V2, PrefixText) == 0x000308, "Member 'UItemSlot_V2::PrefixText' has a wrong offset!");
static_assert(offsetof(UItemSlot_V2, PresetName) == 0x000310, "Member 'UItemSlot_V2::PresetName' has a wrong offset!");

// Class ReadyOrNot.BaseCredit
// 0x0008 (0x02C8 - 0x02C0)
class UBaseCredit : public UUserWidget
{
public:
	bool                                          bRevealed;                                         // 0x02C0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C1[0x3];                                      // 0x02C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         fAnimationSpeed;                                   // 0x02C4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseCredit">();
	}
	static class UBaseCredit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseCredit>();
	}
};
static_assert(alignof(UBaseCredit) == 0x000008, "Wrong alignment on UBaseCredit");
static_assert(sizeof(UBaseCredit) == 0x0002C8, "Wrong size on UBaseCredit");
static_assert(offsetof(UBaseCredit, bRevealed) == 0x0002C0, "Member 'UBaseCredit::bRevealed' has a wrong offset!");
static_assert(offsetof(UBaseCredit, fAnimationSpeed) == 0x0002C4, "Member 'UBaseCredit::fAnimationSpeed' has a wrong offset!");

// Class ReadyOrNot.BaseGasEmitter
// 0x0028 (0x02C0 - 0x0298)
class ABaseGasEmitter final : public AActor
{
public:
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   Mesh;                                              // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Lifetime;                                          // 0x02A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x02AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAffectsNavigation;                                // 0x02B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAppliesStunDamage;                                // 0x02B1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B2[0xE];                                      // 0x02B2(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void StartGas();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseGasEmitter">();
	}
	static class ABaseGasEmitter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseGasEmitter>();
	}
};
static_assert(alignof(ABaseGasEmitter) == 0x000008, "Wrong alignment on ABaseGasEmitter");
static_assert(sizeof(ABaseGasEmitter) == 0x0002C0, "Wrong size on ABaseGasEmitter");
static_assert(offsetof(ABaseGasEmitter, Mesh) == 0x0002A0, "Member 'ABaseGasEmitter::Mesh' has a wrong offset!");
static_assert(offsetof(ABaseGasEmitter, Lifetime) == 0x0002A8, "Member 'ABaseGasEmitter::Lifetime' has a wrong offset!");
static_assert(offsetof(ABaseGasEmitter, Radius) == 0x0002AC, "Member 'ABaseGasEmitter::Radius' has a wrong offset!");
static_assert(offsetof(ABaseGasEmitter, bAffectsNavigation) == 0x0002B0, "Member 'ABaseGasEmitter::bAffectsNavigation' has a wrong offset!");
static_assert(offsetof(ABaseGasEmitter, bAppliesStunDamage) == 0x0002B1, "Member 'ABaseGasEmitter::bAppliesStunDamage' has a wrong offset!");

// Class ReadyOrNot.BaseGasGrenade
// 0x0040 (0x11E0 - 0x11A0)
class ABaseGasGrenade : public ABaseGrenade
{
public:
	uint8                                         Pad_11A0[0x8];                                     // 0x11A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxGasPoints;                                      // 0x11A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11AC[0x14];                                    // 0x11AC(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LocationRecordingRate;                             // 0x11C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecordDistanceThreshold;                           // 0x11C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11C8[0x18];                                    // 0x11C8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RecordLocation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseGasGrenade">();
	}
	static class ABaseGasGrenade* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseGasGrenade>();
	}
};
static_assert(alignof(ABaseGasGrenade) == 0x000010, "Wrong alignment on ABaseGasGrenade");
static_assert(sizeof(ABaseGasGrenade) == 0x0011E0, "Wrong size on ABaseGasGrenade");
static_assert(offsetof(ABaseGasGrenade, MaxGasPoints) == 0x0011A8, "Member 'ABaseGasGrenade::MaxGasPoints' has a wrong offset!");
static_assert(offsetof(ABaseGasGrenade, LocationRecordingRate) == 0x0011C0, "Member 'ABaseGasGrenade::LocationRecordingRate' has a wrong offset!");
static_assert(offsetof(ABaseGasGrenade, RecordDistanceThreshold) == 0x0011C4, "Member 'ABaseGasGrenade::RecordDistanceThreshold' has a wrong offset!");

// Class ReadyOrNot.BaseMagazineWeaponOTR
// 0x0060 (0x17A0 - 0x1740)
class ABaseMagazineWeaponOTR : public ABaseMagazineWeapon
{
public:
	bool                                          bHasReloadedOnce;                                  // 0x1738(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1739[0x7];                                     // 0x1739(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   Mag_OTR_Comp;                                      // 0x1740(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            Mag_OTR_Static;                                    // 0x1748(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Mag_OTR_Socket;                                    // 0x1750(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1758[0x48];                                    // 0x1758(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseMagazineWeaponOTR">();
	}
	static class ABaseMagazineWeaponOTR* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseMagazineWeaponOTR>();
	}
};
static_assert(alignof(ABaseMagazineWeaponOTR) == 0x000010, "Wrong alignment on ABaseMagazineWeaponOTR");
static_assert(sizeof(ABaseMagazineWeaponOTR) == 0x0017A0, "Wrong size on ABaseMagazineWeaponOTR");
static_assert(offsetof(ABaseMagazineWeaponOTR, bHasReloadedOnce) == 0x001738, "Member 'ABaseMagazineWeaponOTR::bHasReloadedOnce' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeaponOTR, Mag_OTR_Comp) == 0x001740, "Member 'ABaseMagazineWeaponOTR::Mag_OTR_Comp' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeaponOTR, Mag_OTR_Static) == 0x001748, "Member 'ABaseMagazineWeaponOTR::Mag_OTR_Static' has a wrong offset!");
static_assert(offsetof(ABaseMagazineWeaponOTR, Mag_OTR_Socket) == 0x001750, "Member 'ABaseMagazineWeaponOTR::Mag_OTR_Socket' has a wrong offset!");

// Class ReadyOrNot.BaseMagPouch
// 0x0020 (0x0BD0 - 0x0BB0)
class ABaseMagPouch final : public ABaseItem
{
public:
	class USkeletalMeshComponent*                 MagazineMesh;                                      // 0x0BB0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimationAsset*                        OpenPouchAnim;                                     // 0x0BB8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimationAsset*                        ClosedPouchAnim;                                   // 0x0BC0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   MagSocket;                                         // 0x0BC8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void ClosePouch();
	void HideMagazine();
	void OpenPouch();
	void ShowMagazine();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseMagPouch">();
	}
	static class ABaseMagPouch* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseMagPouch>();
	}
};
static_assert(alignof(ABaseMagPouch) == 0x000010, "Wrong alignment on ABaseMagPouch");
static_assert(sizeof(ABaseMagPouch) == 0x000BD0, "Wrong size on ABaseMagPouch");
static_assert(offsetof(ABaseMagPouch, MagazineMesh) == 0x000BB0, "Member 'ABaseMagPouch::MagazineMesh' has a wrong offset!");
static_assert(offsetof(ABaseMagPouch, OpenPouchAnim) == 0x000BB8, "Member 'ABaseMagPouch::OpenPouchAnim' has a wrong offset!");
static_assert(offsetof(ABaseMagPouch, ClosedPouchAnim) == 0x000BC0, "Member 'ABaseMagPouch::ClosedPouchAnim' has a wrong offset!");
static_assert(offsetof(ABaseMagPouch, MagSocket) == 0x000BC8, "Member 'ABaseMagPouch::MagSocket' has a wrong offset!");

// Class ReadyOrNot.BasePlayerEffect
// 0x0008 (0x0060 - 0x0058)
class UBasePlayerEffect : public UReadyOrNotGameplayEffect
{
public:
	class APlayerCharacter*                       PlayerCharacter;                                   // 0x0058(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BasePlayerEffect">();
	}
	static class UBasePlayerEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBasePlayerEffect>();
	}
};
static_assert(alignof(UBasePlayerEffect) == 0x000008, "Wrong alignment on UBasePlayerEffect");
static_assert(sizeof(UBasePlayerEffect) == 0x000060, "Wrong size on UBasePlayerEffect");
static_assert(offsetof(UBasePlayerEffect, PlayerCharacter) == 0x000058, "Member 'UBasePlayerEffect::PlayerCharacter' has a wrong offset!");

// Class ReadyOrNot.BaseSquadsActivity
// 0x0080 (0x00A8 - 0x0028)
class UBaseSquadsActivity final : public UObject
{
public:
	struct FGameplayTag                           ActivityTag;                                       // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Cooldown;                                          // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRunTime;                                        // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSquadActionGateData>           Gates;                                             // 0x0038(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FSquadRolesData>                ActivityRoles;                                     // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, struct FCyberneticCharacterArrayContainer> RoleAssignmentMap;          // 0x0058(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseSquadsActivity">();
	}
	static class UBaseSquadsActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseSquadsActivity>();
	}
};
static_assert(alignof(UBaseSquadsActivity) == 0x000008, "Wrong alignment on UBaseSquadsActivity");
static_assert(sizeof(UBaseSquadsActivity) == 0x0000A8, "Wrong size on UBaseSquadsActivity");
static_assert(offsetof(UBaseSquadsActivity, ActivityTag) == 0x000028, "Member 'UBaseSquadsActivity::ActivityTag' has a wrong offset!");
static_assert(offsetof(UBaseSquadsActivity, Cooldown) == 0x000030, "Member 'UBaseSquadsActivity::Cooldown' has a wrong offset!");
static_assert(offsetof(UBaseSquadsActivity, MaxRunTime) == 0x000034, "Member 'UBaseSquadsActivity::MaxRunTime' has a wrong offset!");
static_assert(offsetof(UBaseSquadsActivity, Gates) == 0x000038, "Member 'UBaseSquadsActivity::Gates' has a wrong offset!");
static_assert(offsetof(UBaseSquadsActivity, ActivityRoles) == 0x000048, "Member 'UBaseSquadsActivity::ActivityRoles' has a wrong offset!");
static_assert(offsetof(UBaseSquadsActivity, RoleAssignmentMap) == 0x000058, "Member 'UBaseSquadsActivity::RoleAssignmentMap' has a wrong offset!");

// Class ReadyOrNot.TeamDeathmatchGM
// 0x0020 (0x09F0 - 0x09D0)
class ATeamDeathmatchGM final : public AReadyOrNotGameMode_PVP
{
public:
	bool                                          bSuddenDeath;                                      // 0x09D0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9D1[0x7];                                      // 0x09D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             MatchLoopMusic;                                    // 0x09D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             MatchStartMusic;                                   // 0x09E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             MatchEndMusic;                                     // 0x09E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeamDeathmatchGM">();
	}
	static class ATeamDeathmatchGM* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATeamDeathmatchGM>();
	}
};
static_assert(alignof(ATeamDeathmatchGM) == 0x000010, "Wrong alignment on ATeamDeathmatchGM");
static_assert(sizeof(ATeamDeathmatchGM) == 0x0009F0, "Wrong size on ATeamDeathmatchGM");
static_assert(offsetof(ATeamDeathmatchGM, bSuddenDeath) == 0x0009D0, "Member 'ATeamDeathmatchGM::bSuddenDeath' has a wrong offset!");
static_assert(offsetof(ATeamDeathmatchGM, MatchLoopMusic) == 0x0009D8, "Member 'ATeamDeathmatchGM::MatchLoopMusic' has a wrong offset!");
static_assert(offsetof(ATeamDeathmatchGM, MatchStartMusic) == 0x0009E0, "Member 'ATeamDeathmatchGM::MatchStartMusic' has a wrong offset!");
static_assert(offsetof(ATeamDeathmatchGM, MatchEndMusic) == 0x0009E8, "Member 'ATeamDeathmatchGM::MatchEndMusic' has a wrong offset!");

// Class ReadyOrNot.BeanbagDamageType
// 0x0000 (0x07B0 - 0x07B0)
class UBeanbagDamageType : public UStunDamage
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BeanbagDamageType">();
	}
	static class UBeanbagDamageType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBeanbagDamageType>();
	}
};
static_assert(alignof(UBeanbagDamageType) == 0x000010, "Wrong alignment on UBeanbagDamageType");
static_assert(sizeof(UBeanbagDamageType) == 0x0007B0, "Wrong size on UBeanbagDamageType");

// Class ReadyOrNot.BleedDamageType
// 0x0000 (0x0040 - 0x0040)
class UBleedDamageType final : public UDamageType
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BleedDamageType">();
	}
	static class UBleedDamageType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBleedDamageType>();
	}
};
static_assert(alignof(UBleedDamageType) == 0x000008, "Wrong alignment on UBleedDamageType");
static_assert(sizeof(UBleedDamageType) == 0x000040, "Wrong size on UBleedDamageType");

// Class ReadyOrNot.TeamProgressScoreWidget
// 0x0028 (0x0310 - 0x02E8)
class UTeamProgressScoreWidget final : public UBaseWidget
{
public:
	ETeamType                                     Team;                                              // 0x02E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E9[0x7];                                      // 0x02E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UProgressBar*                           ProgressBar_LeftAligned;                           // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Score_Text_LeftAligned;                            // 0x02F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           ProgressBar_RightAligned;                          // 0x0300(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Score_Text_RightAligned;                           // 0x0308(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeamProgressScoreWidget">();
	}
	static class UTeamProgressScoreWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTeamProgressScoreWidget>();
	}
};
static_assert(alignof(UTeamProgressScoreWidget) == 0x000008, "Wrong alignment on UTeamProgressScoreWidget");
static_assert(sizeof(UTeamProgressScoreWidget) == 0x000310, "Wrong size on UTeamProgressScoreWidget");
static_assert(offsetof(UTeamProgressScoreWidget, Team) == 0x0002E8, "Member 'UTeamProgressScoreWidget::Team' has a wrong offset!");
static_assert(offsetof(UTeamProgressScoreWidget, ProgressBar_LeftAligned) == 0x0002F0, "Member 'UTeamProgressScoreWidget::ProgressBar_LeftAligned' has a wrong offset!");
static_assert(offsetof(UTeamProgressScoreWidget, Score_Text_LeftAligned) == 0x0002F8, "Member 'UTeamProgressScoreWidget::Score_Text_LeftAligned' has a wrong offset!");
static_assert(offsetof(UTeamProgressScoreWidget, ProgressBar_RightAligned) == 0x000300, "Member 'UTeamProgressScoreWidget::ProgressBar_RightAligned' has a wrong offset!");
static_assert(offsetof(UTeamProgressScoreWidget, Score_Text_RightAligned) == 0x000308, "Member 'UTeamProgressScoreWidget::Score_Text_RightAligned' has a wrong offset!");

// Class ReadyOrNot.BlockListData
// 0x0028 (0x02E8 - 0x02C0)
class UBlockListData final : public UUserWidget
{
public:
	class FString                                 DisplayName;                                       // 0x02C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlayerId;                                          // 0x02D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUserWidget*                            BlockList;                                         // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlockListData">();
	}
	static class UBlockListData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlockListData>();
	}
};
static_assert(alignof(UBlockListData) == 0x000008, "Wrong alignment on UBlockListData");
static_assert(sizeof(UBlockListData) == 0x0002E8, "Wrong size on UBlockListData");
static_assert(offsetof(UBlockListData, DisplayName) == 0x0002C0, "Member 'UBlockListData::DisplayName' has a wrong offset!");
static_assert(offsetof(UBlockListData, PlayerId) == 0x0002D0, "Member 'UBlockListData::PlayerId' has a wrong offset!");
static_assert(offsetof(UBlockListData, BlockList) == 0x0002E0, "Member 'UBlockListData::BlockList' has a wrong offset!");

// Class ReadyOrNot.BlockList_Entry
// 0x0028 (0x0438 - 0x0410)
class UBlockList_Entry : public UCommonActivatableWidget
{
public:
	uint8                                         Pad_410[0x8];                                      // 0x0410(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlockListData*                         ListData;                                          // 0x0418(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             PlayerName;                                        // 0x0420(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Avatar;                                            // 0x0428(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_430[0x8];                                      // 0x0430(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAvatarDownloaded(class UTexture2DDynamic* Texture);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlockList_Entry">();
	}
	static class UBlockList_Entry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlockList_Entry>();
	}
};
static_assert(alignof(UBlockList_Entry) == 0x000008, "Wrong alignment on UBlockList_Entry");
static_assert(sizeof(UBlockList_Entry) == 0x000438, "Wrong size on UBlockList_Entry");
static_assert(offsetof(UBlockList_Entry, ListData) == 0x000418, "Member 'UBlockList_Entry::ListData' has a wrong offset!");
static_assert(offsetof(UBlockList_Entry, PlayerName) == 0x000420, "Member 'UBlockList_Entry::PlayerName' has a wrong offset!");
static_assert(offsetof(UBlockList_Entry, Avatar) == 0x000428, "Member 'UBlockList_Entry::Avatar' has a wrong offset!");

// Class ReadyOrNot.BloodData
// 0x02D0 (0x0300 - 0x0030)
class UBloodData final : public UDataAsset
{
public:
	float                                         DecalFadeScreenSize;                               // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMaterialInterface*>             Splatters;                                         // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         SplatterMaxTraceDistance;                          // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              SplatterSizeRange;                                 // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMaterialInterface*>             AnimatedSplatters;                                 // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TSubclassOf<class AAnimatedDecal>             AnimatedDecalClass;                                // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           AnimatedSplatterBones;                             // 0x0078(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         AnimatedSplatterMaxDistance;                       // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              AnimatedSplatterSizeRange;                         // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimatedBloodTimescale;                            // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     AnimatedBloodCurve;                                // 0x00A8(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<class UMaterialInterface*>             HeadshotSplatters;                                 // 0x0130(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class UStaticMesh*                            HeadshotDecalMesh;                                 // 0x0140(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           HeadshotSplatterBones;                             // 0x0148(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         HeadshotMaxSplatterDistance;                       // 0x0158(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15C[0x4];                                      // 0x015C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              HeadshotSplatterSizeRange;                         // 0x0160(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UParticleSystem*>                HitEntryParticles;                                 // 0x0170(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint32                                        SkinnedDecalImageCount;                            // 0x0180(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_184[0x4];                                      // 0x0184(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              SkinnedDecalSizeRange;                             // 0x0188(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FArteryData>                    Arteries;                                          // 0x0198(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UParticleSystem*>                ArteryParticles;                                   // 0x01A8(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UMaterialInterface*>             ArteryParticleCollisionDecals;                     // 0x01B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         ArteryParticleCollisionChance;                     // 0x01C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1CC[0x4];                                      // 0x01CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              ArteryParticleCollisionSizeRange;                  // 0x01D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UParticleSystem*>                DismembermentParticles;                            // 0x01E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UMaterialInterface*>             DismembermentParticleCollisionDecals;              // 0x01F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         DismembermentParticleCollisionChance;              // 0x0200(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_204[0x4];                                      // 0x0204(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              DismembermentParticleCollisionSizeRange;           // 0x0208(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGibData                               GibData;                                           // 0x0218(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	TSubclassOf<class ABloodPool>                 BloodPoolClass;                                    // 0x0248(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BloodPoolSpawnDelay;                               // 0x0250(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BloodPoolSpawnBone;                                // 0x0254(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25C[0x4];                                      // 0x025C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstance*                      BloodPoolFootstepDecal;                            // 0x0260(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BloodPoolFootstepSize;                             // 0x0268(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BloodPoolFootstepOffset;                           // 0x0280(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BloodPoolFootstepTime;                             // 0x0298(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29C[0x4];                                      // 0x029C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             BloodPoolFootstepEvent;                            // 0x02A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMaterialInstance*>              BigSplatterDecals;                                 // 0x02A8(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TSubclassOf<class AExplosionGibs>             Gibs;                                              // 0x02B8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BigSplatterTraceDistance;                          // 0x02C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C4[0x4];                                      // 0x02C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                BigSplatterDecalSize;                              // 0x02C8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             HitEvent;                                          // 0x02E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             DeadHitEvent;                                      // 0x02E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             GoreEvent;                                         // 0x02F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             HeadshotEvent;                                     // 0x02F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodData">();
	}
	static class UBloodData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBloodData>();
	}
};
static_assert(alignof(UBloodData) == 0x000008, "Wrong alignment on UBloodData");
static_assert(sizeof(UBloodData) == 0x000300, "Wrong size on UBloodData");
static_assert(offsetof(UBloodData, DecalFadeScreenSize) == 0x000030, "Member 'UBloodData::DecalFadeScreenSize' has a wrong offset!");
static_assert(offsetof(UBloodData, Splatters) == 0x000038, "Member 'UBloodData::Splatters' has a wrong offset!");
static_assert(offsetof(UBloodData, SplatterMaxTraceDistance) == 0x000048, "Member 'UBloodData::SplatterMaxTraceDistance' has a wrong offset!");
static_assert(offsetof(UBloodData, SplatterSizeRange) == 0x000050, "Member 'UBloodData::SplatterSizeRange' has a wrong offset!");
static_assert(offsetof(UBloodData, AnimatedSplatters) == 0x000060, "Member 'UBloodData::AnimatedSplatters' has a wrong offset!");
static_assert(offsetof(UBloodData, AnimatedDecalClass) == 0x000070, "Member 'UBloodData::AnimatedDecalClass' has a wrong offset!");
static_assert(offsetof(UBloodData, AnimatedSplatterBones) == 0x000078, "Member 'UBloodData::AnimatedSplatterBones' has a wrong offset!");
static_assert(offsetof(UBloodData, AnimatedSplatterMaxDistance) == 0x000088, "Member 'UBloodData::AnimatedSplatterMaxDistance' has a wrong offset!");
static_assert(offsetof(UBloodData, AnimatedSplatterSizeRange) == 0x000090, "Member 'UBloodData::AnimatedSplatterSizeRange' has a wrong offset!");
static_assert(offsetof(UBloodData, AnimatedBloodTimescale) == 0x0000A0, "Member 'UBloodData::AnimatedBloodTimescale' has a wrong offset!");
static_assert(offsetof(UBloodData, AnimatedBloodCurve) == 0x0000A8, "Member 'UBloodData::AnimatedBloodCurve' has a wrong offset!");
static_assert(offsetof(UBloodData, HeadshotSplatters) == 0x000130, "Member 'UBloodData::HeadshotSplatters' has a wrong offset!");
static_assert(offsetof(UBloodData, HeadshotDecalMesh) == 0x000140, "Member 'UBloodData::HeadshotDecalMesh' has a wrong offset!");
static_assert(offsetof(UBloodData, HeadshotSplatterBones) == 0x000148, "Member 'UBloodData::HeadshotSplatterBones' has a wrong offset!");
static_assert(offsetof(UBloodData, HeadshotMaxSplatterDistance) == 0x000158, "Member 'UBloodData::HeadshotMaxSplatterDistance' has a wrong offset!");
static_assert(offsetof(UBloodData, HeadshotSplatterSizeRange) == 0x000160, "Member 'UBloodData::HeadshotSplatterSizeRange' has a wrong offset!");
static_assert(offsetof(UBloodData, HitEntryParticles) == 0x000170, "Member 'UBloodData::HitEntryParticles' has a wrong offset!");
static_assert(offsetof(UBloodData, SkinnedDecalImageCount) == 0x000180, "Member 'UBloodData::SkinnedDecalImageCount' has a wrong offset!");
static_assert(offsetof(UBloodData, SkinnedDecalSizeRange) == 0x000188, "Member 'UBloodData::SkinnedDecalSizeRange' has a wrong offset!");
static_assert(offsetof(UBloodData, Arteries) == 0x000198, "Member 'UBloodData::Arteries' has a wrong offset!");
static_assert(offsetof(UBloodData, ArteryParticles) == 0x0001A8, "Member 'UBloodData::ArteryParticles' has a wrong offset!");
static_assert(offsetof(UBloodData, ArteryParticleCollisionDecals) == 0x0001B8, "Member 'UBloodData::ArteryParticleCollisionDecals' has a wrong offset!");
static_assert(offsetof(UBloodData, ArteryParticleCollisionChance) == 0x0001C8, "Member 'UBloodData::ArteryParticleCollisionChance' has a wrong offset!");
static_assert(offsetof(UBloodData, ArteryParticleCollisionSizeRange) == 0x0001D0, "Member 'UBloodData::ArteryParticleCollisionSizeRange' has a wrong offset!");
static_assert(offsetof(UBloodData, DismembermentParticles) == 0x0001E0, "Member 'UBloodData::DismembermentParticles' has a wrong offset!");
static_assert(offsetof(UBloodData, DismembermentParticleCollisionDecals) == 0x0001F0, "Member 'UBloodData::DismembermentParticleCollisionDecals' has a wrong offset!");
static_assert(offsetof(UBloodData, DismembermentParticleCollisionChance) == 0x000200, "Member 'UBloodData::DismembermentParticleCollisionChance' has a wrong offset!");
static_assert(offsetof(UBloodData, DismembermentParticleCollisionSizeRange) == 0x000208, "Member 'UBloodData::DismembermentParticleCollisionSizeRange' has a wrong offset!");
static_assert(offsetof(UBloodData, GibData) == 0x000218, "Member 'UBloodData::GibData' has a wrong offset!");
static_assert(offsetof(UBloodData, BloodPoolClass) == 0x000248, "Member 'UBloodData::BloodPoolClass' has a wrong offset!");
static_assert(offsetof(UBloodData, BloodPoolSpawnDelay) == 0x000250, "Member 'UBloodData::BloodPoolSpawnDelay' has a wrong offset!");
static_assert(offsetof(UBloodData, BloodPoolSpawnBone) == 0x000254, "Member 'UBloodData::BloodPoolSpawnBone' has a wrong offset!");
static_assert(offsetof(UBloodData, BloodPoolFootstepDecal) == 0x000260, "Member 'UBloodData::BloodPoolFootstepDecal' has a wrong offset!");
static_assert(offsetof(UBloodData, BloodPoolFootstepSize) == 0x000268, "Member 'UBloodData::BloodPoolFootstepSize' has a wrong offset!");
static_assert(offsetof(UBloodData, BloodPoolFootstepOffset) == 0x000280, "Member 'UBloodData::BloodPoolFootstepOffset' has a wrong offset!");
static_assert(offsetof(UBloodData, BloodPoolFootstepTime) == 0x000298, "Member 'UBloodData::BloodPoolFootstepTime' has a wrong offset!");
static_assert(offsetof(UBloodData, BloodPoolFootstepEvent) == 0x0002A0, "Member 'UBloodData::BloodPoolFootstepEvent' has a wrong offset!");
static_assert(offsetof(UBloodData, BigSplatterDecals) == 0x0002A8, "Member 'UBloodData::BigSplatterDecals' has a wrong offset!");
static_assert(offsetof(UBloodData, Gibs) == 0x0002B8, "Member 'UBloodData::Gibs' has a wrong offset!");
static_assert(offsetof(UBloodData, BigSplatterTraceDistance) == 0x0002C0, "Member 'UBloodData::BigSplatterTraceDistance' has a wrong offset!");
static_assert(offsetof(UBloodData, BigSplatterDecalSize) == 0x0002C8, "Member 'UBloodData::BigSplatterDecalSize' has a wrong offset!");
static_assert(offsetof(UBloodData, HitEvent) == 0x0002E0, "Member 'UBloodData::HitEvent' has a wrong offset!");
static_assert(offsetof(UBloodData, DeadHitEvent) == 0x0002E8, "Member 'UBloodData::DeadHitEvent' has a wrong offset!");
static_assert(offsetof(UBloodData, GoreEvent) == 0x0002F0, "Member 'UBloodData::GoreEvent' has a wrong offset!");
static_assert(offsetof(UBloodData, HeadshotEvent) == 0x0002F8, "Member 'UBloodData::HeadshotEvent' has a wrong offset!");

// Class ReadyOrNot.TextWidget
// 0x0078 (0x0338 - 0x02C0)
class UTextWidget : public UUserWidget
{
public:
	class UCommonTextBlock*                       txt_Text;                                          // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   CurrentText;                                       // 0x02C8(0x0018)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FSlateFontInfo                         CurrentFont;                                       // 0x02E0(0x0058)(BlueprintVisible, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TextWidget">();
	}
	static class UTextWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTextWidget>();
	}
};
static_assert(alignof(UTextWidget) == 0x000008, "Wrong alignment on UTextWidget");
static_assert(sizeof(UTextWidget) == 0x000338, "Wrong size on UTextWidget");
static_assert(offsetof(UTextWidget, txt_Text) == 0x0002C0, "Member 'UTextWidget::txt_Text' has a wrong offset!");
static_assert(offsetof(UTextWidget, CurrentText) == 0x0002C8, "Member 'UTextWidget::CurrentText' has a wrong offset!");
static_assert(offsetof(UTextWidget, CurrentFont) == 0x0002E0, "Member 'UTextWidget::CurrentFont' has a wrong offset!");

// Class ReadyOrNot.BloodPool
// 0x0010 (0x02F0 - 0x02E0)
class ABloodPool : public APooledActor
{
public:
	class UDecalComponent*                        Decal;                                             // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          BoxComponent;                                      // 0x02E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnOverlapEnd(class AActor* OverlappedActor, class AActor* OtherActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodPool">();
	}
	static class ABloodPool* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABloodPool>();
	}
};
static_assert(alignof(ABloodPool) == 0x000008, "Wrong alignment on ABloodPool");
static_assert(sizeof(ABloodPool) == 0x0002F0, "Wrong size on ABloodPool");
static_assert(offsetof(ABloodPool, Decal) == 0x0002E0, "Member 'ABloodPool::Decal' has a wrong offset!");
static_assert(offsetof(ABloodPool, BoxComponent) == 0x0002E8, "Member 'ABloodPool::BoxComponent' has a wrong offset!");

// Class ReadyOrNot.BombActor
// 0x0090 (0x0328 - 0x0298)
class ABombActor final : public AActor
{
public:
	uint8                                         Pad_298[0x10];                                     // 0x0298(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class ABombActor* DefusedBomb)> OnBombDefused;                     // 0x02A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractableComponent*                 InteractableComponent;                             // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystemComponent*               ExplosionParticleComponent;                        // 0x02C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MultitoolUseTime;                                  // 0x02D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplosionRadius;                                   // 0x02D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBombState                                    BombState;                                         // 0x02D8(0x0001)(Edit, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D9[0x3];                                      // 0x02D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeUntilExplodes;                                 // 0x02DC(0x0004)(Edit, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPVPBombOnly;                                      // 0x02E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E1[0x7];                                      // 0x02E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             BombTickEvent;                                     // 0x02E8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             BombExplodeEvent;                                  // 0x02F0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F8[0x8];                                      // 0x02F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundSource*                           BombSoundSource;                                   // 0x0300(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UForceFeedbackEffect*                   ForceFeedbackEffect;                               // 0x0308(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UForceFeedbackAttenuation*              ForceFeedbackAttenuation;                          // 0x0310(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_318[0x10];                                     // 0x0318(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Explode();
	EBombState GetBombState();
	float GetTimeUntilExplodes();
	void Multicast_PlayBombExplodeSFX(int32 Start, int32 End);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BombActor">();
	}
	static class ABombActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABombActor>();
	}
};
static_assert(alignof(ABombActor) == 0x000008, "Wrong alignment on ABombActor");
static_assert(sizeof(ABombActor) == 0x000328, "Wrong size on ABombActor");
static_assert(offsetof(ABombActor, OnBombDefused) == 0x0002A8, "Member 'ABombActor::OnBombDefused' has a wrong offset!");
static_assert(offsetof(ABombActor, StaticMeshComponent) == 0x0002B8, "Member 'ABombActor::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(ABombActor, InteractableComponent) == 0x0002C0, "Member 'ABombActor::InteractableComponent' has a wrong offset!");
static_assert(offsetof(ABombActor, ExplosionParticleComponent) == 0x0002C8, "Member 'ABombActor::ExplosionParticleComponent' has a wrong offset!");
static_assert(offsetof(ABombActor, MultitoolUseTime) == 0x0002D0, "Member 'ABombActor::MultitoolUseTime' has a wrong offset!");
static_assert(offsetof(ABombActor, ExplosionRadius) == 0x0002D4, "Member 'ABombActor::ExplosionRadius' has a wrong offset!");
static_assert(offsetof(ABombActor, BombState) == 0x0002D8, "Member 'ABombActor::BombState' has a wrong offset!");
static_assert(offsetof(ABombActor, TimeUntilExplodes) == 0x0002DC, "Member 'ABombActor::TimeUntilExplodes' has a wrong offset!");
static_assert(offsetof(ABombActor, bPVPBombOnly) == 0x0002E0, "Member 'ABombActor::bPVPBombOnly' has a wrong offset!");
static_assert(offsetof(ABombActor, BombTickEvent) == 0x0002E8, "Member 'ABombActor::BombTickEvent' has a wrong offset!");
static_assert(offsetof(ABombActor, BombExplodeEvent) == 0x0002F0, "Member 'ABombActor::BombExplodeEvent' has a wrong offset!");
static_assert(offsetof(ABombActor, BombSoundSource) == 0x000300, "Member 'ABombActor::BombSoundSource' has a wrong offset!");
static_assert(offsetof(ABombActor, ForceFeedbackEffect) == 0x000308, "Member 'ABombActor::ForceFeedbackEffect' has a wrong offset!");
static_assert(offsetof(ABombActor, ForceFeedbackAttenuation) == 0x000310, "Member 'ABombActor::ForceFeedbackAttenuation' has a wrong offset!");

// Class ReadyOrNot.TestInputBlueprintFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UTestInputBlueprintFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void RonApplyInputAction(class UObject* Context, const class FName& ActionName, EInputEvent InputEventType);
	static void RonApplyInputAxis(class UObject* Context, const class FName& AxisName, float AxisValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TestInputBlueprintFunctionLibrary">();
	}
	static class UTestInputBlueprintFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTestInputBlueprintFunctionLibrary>();
	}
};
static_assert(alignof(UTestInputBlueprintFunctionLibrary) == 0x000008, "Wrong alignment on UTestInputBlueprintFunctionLibrary");
static_assert(sizeof(UTestInputBlueprintFunctionLibrary) == 0x000028, "Wrong size on UTestInputBlueprintFunctionLibrary");

// Class ReadyOrNot.ThrownItem
// 0x0360 (0x05F8 - 0x0298)
class AThrownItem : public AActor
{
public:
	class AReadyOrNotCharacter*                   ThrowInstigator;                                   // 0x0298(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ThrownInRoom;                                      // 0x02A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        SceneComponent;                                    // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   StaticMesh;                                        // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAIPerceptionStimuliSourceComponent*    PerceptionStimuliComp;                             // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TurnPhysicsOffDelay;                               // 0x02C0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ThrowDistance;                                     // 0x02C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FVector>                        FirstBouncePath;                                   // 0x02C8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FHitResult                             FirstBounceHit;                                    // 0x02D8(0x00E8)(IsPlainOldData, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C0[0x8];                                      // 0x03C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        SecondBouncePath;                                  // 0x03C8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FHitResult                             SecondBounceHit;                                   // 0x03D8(0x00E8)(IsPlainOldData, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C0[0x8];                                      // 0x04C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        ThirdBouncePath;                                   // 0x04C8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FHitResult                             ThirdBounceHit;                                    // 0x04D8(0x00E8)(IsPlainOldData, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C0[0x8];                                      // 0x05C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector_NetQuantize>            CompletePath;                                      // 0x05C8(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	int32                                         BouncePt1;                                         // 0x05D8(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         BouncePt2;                                         // 0x05DC(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         BouncePt3;                                         // 0x05E0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5E4[0x4];                                      // 0x05E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ThrowSpeed;                                        // 0x05E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5EC[0x8];                                      // 0x05EC(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ThrowBounciness;                                   // 0x05F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComponent, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void OnRep_ThrowPath();
	void UpdateServerPath(const TArray<struct FVector_NetQuantize>& Path, int32 Bounce1, int32 Bounce2, int32 Bounce3);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ThrownItem">();
	}
	static class AThrownItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<AThrownItem>();
	}
};
static_assert(alignof(AThrownItem) == 0x000008, "Wrong alignment on AThrownItem");
static_assert(sizeof(AThrownItem) == 0x0005F8, "Wrong size on AThrownItem");
static_assert(offsetof(AThrownItem, ThrowInstigator) == 0x000298, "Member 'AThrownItem::ThrowInstigator' has a wrong offset!");
static_assert(offsetof(AThrownItem, ThrownInRoom) == 0x0002A0, "Member 'AThrownItem::ThrownInRoom' has a wrong offset!");
static_assert(offsetof(AThrownItem, SceneComponent) == 0x0002A8, "Member 'AThrownItem::SceneComponent' has a wrong offset!");
static_assert(offsetof(AThrownItem, StaticMesh) == 0x0002B0, "Member 'AThrownItem::StaticMesh' has a wrong offset!");
static_assert(offsetof(AThrownItem, PerceptionStimuliComp) == 0x0002B8, "Member 'AThrownItem::PerceptionStimuliComp' has a wrong offset!");
static_assert(offsetof(AThrownItem, TurnPhysicsOffDelay) == 0x0002C0, "Member 'AThrownItem::TurnPhysicsOffDelay' has a wrong offset!");
static_assert(offsetof(AThrownItem, ThrowDistance) == 0x0002C4, "Member 'AThrownItem::ThrowDistance' has a wrong offset!");
static_assert(offsetof(AThrownItem, FirstBouncePath) == 0x0002C8, "Member 'AThrownItem::FirstBouncePath' has a wrong offset!");
static_assert(offsetof(AThrownItem, FirstBounceHit) == 0x0002D8, "Member 'AThrownItem::FirstBounceHit' has a wrong offset!");
static_assert(offsetof(AThrownItem, SecondBouncePath) == 0x0003C8, "Member 'AThrownItem::SecondBouncePath' has a wrong offset!");
static_assert(offsetof(AThrownItem, SecondBounceHit) == 0x0003D8, "Member 'AThrownItem::SecondBounceHit' has a wrong offset!");
static_assert(offsetof(AThrownItem, ThirdBouncePath) == 0x0004C8, "Member 'AThrownItem::ThirdBouncePath' has a wrong offset!");
static_assert(offsetof(AThrownItem, ThirdBounceHit) == 0x0004D8, "Member 'AThrownItem::ThirdBounceHit' has a wrong offset!");
static_assert(offsetof(AThrownItem, CompletePath) == 0x0005C8, "Member 'AThrownItem::CompletePath' has a wrong offset!");
static_assert(offsetof(AThrownItem, BouncePt1) == 0x0005D8, "Member 'AThrownItem::BouncePt1' has a wrong offset!");
static_assert(offsetof(AThrownItem, BouncePt2) == 0x0005DC, "Member 'AThrownItem::BouncePt2' has a wrong offset!");
static_assert(offsetof(AThrownItem, BouncePt3) == 0x0005E0, "Member 'AThrownItem::BouncePt3' has a wrong offset!");
static_assert(offsetof(AThrownItem, ThrowSpeed) == 0x0005E8, "Member 'AThrownItem::ThrowSpeed' has a wrong offset!");
static_assert(offsetof(AThrownItem, ThrowBounciness) == 0x0005F4, "Member 'AThrownItem::ThrowBounciness' has a wrong offset!");

// Class ReadyOrNot.ReadyOrNotSaveGame
// 0x0068 (0x0090 - 0x0028)
class UReadyOrNotSaveGame final : public USaveGame
{
public:
	class FString                                 SaveSlotName;                                      // 0x0028(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        UserIndex;                                         // 0x0038(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ETeamType, TSubclassOf<class USkinComponent>> SkinSaveMap;                                  // 0x0040(0x0050)(BlueprintVisible, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UReadyOrNotSaveGame* CreateDefaultSavegame(const class FString& LoadSlotName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotSaveGame">();
	}
	static class UReadyOrNotSaveGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotSaveGame>();
	}
};
static_assert(alignof(UReadyOrNotSaveGame) == 0x000008, "Wrong alignment on UReadyOrNotSaveGame");
static_assert(sizeof(UReadyOrNotSaveGame) == 0x000090, "Wrong size on UReadyOrNotSaveGame");
static_assert(offsetof(UReadyOrNotSaveGame, SaveSlotName) == 0x000028, "Member 'UReadyOrNotSaveGame::SaveSlotName' has a wrong offset!");
static_assert(offsetof(UReadyOrNotSaveGame, UserIndex) == 0x000038, "Member 'UReadyOrNotSaveGame::UserIndex' has a wrong offset!");
static_assert(offsetof(UReadyOrNotSaveGame, SkinSaveMap) == 0x000040, "Member 'UReadyOrNotSaveGame::SkinSaveMap' has a wrong offset!");

// Class ReadyOrNot.ReadyOrNotModData
// 0x0038 (0x0060 - 0x0028)
class UReadyOrNotModData final : public USaveGame
{
public:
	class FString                                 SaveSlotName;                                      // 0x0028(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        UserIndex;                                         // 0x0038(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int64>                                 DisabledMods;                                      // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int64>                                 ErroredMods;                                       // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotModData">();
	}
	static class UReadyOrNotModData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotModData>();
	}
};
static_assert(alignof(UReadyOrNotModData) == 0x000008, "Wrong alignment on UReadyOrNotModData");
static_assert(sizeof(UReadyOrNotModData) == 0x000060, "Wrong size on UReadyOrNotModData");
static_assert(offsetof(UReadyOrNotModData, SaveSlotName) == 0x000028, "Member 'UReadyOrNotModData::SaveSlotName' has a wrong offset!");
static_assert(offsetof(UReadyOrNotModData, UserIndex) == 0x000038, "Member 'UReadyOrNotModData::UserIndex' has a wrong offset!");
static_assert(offsetof(UReadyOrNotModData, DisabledMods) == 0x000040, "Member 'UReadyOrNotModData::DisabledMods' has a wrong offset!");
static_assert(offsetof(UReadyOrNotModData, ErroredMods) == 0x000050, "Member 'UReadyOrNotModData::ErroredMods' has a wrong offset!");

// Class ReadyOrNot.BpVideoSettingsLib
// 0x0000 (0x0028 - 0x0028)
class UBpVideoSettingsLib final : public UBlueprintFunctionLibrary
{
public:
	static bool ChangeScreenResolution(const int32 Width, const int32 Height, EWindowMode NewWindowMode);
	static void ForceReloadSettings();
	static class FText GenerateDlssQualityString(int32 Quality);
	static class FText GenerateFSRQualityString(int32 Quality);
	static class FText GenerateQualityString(int32 Quality);
	static bool GetAntiAliasingQuality(int32* AntiAliasing);
	static EWindowMode GetCurrentScreenMode();
	static class FString GetCurrentScreenResolution();
	static bool GetDepthOfFieldSetting(bool* bDoFEnabled);
	static bool GetDlssFrameGenerationSetting(int32* Setting);
	static class FText GetDLSSFrameGenerationUnsupportedReason();
	static bool GetDlssQuality(int32* Quality);
	static bool GetEffectsQuality(int32* Effects);
	static bool GetFrameRateLimit(int32* FrameRateLimit, bool* bEnabled);
	static bool GetFSRQuality(int32* Quality);
	static bool GetGlobalIlluminationQuality(int32* GlobalIllumination);
	static int32 GetGraphicsPresetIndex();
	static bool GetInterfaceAspectRatio(float* OutAspectRatio);
	static bool GetMotionBlurEnabled(bool* bEnabled);
	static bool GetMotionBlurStrength(float* Strength);
	static int32 GetNumDlssQualityOptions();
	static bool GetOverallVideoQuality(int32* Quality);
	static bool GetPerObjectShadowsEnabled(bool* bPerObjectShadowsEnabled);
	static bool GetPostProcessQuality(int32* PostProcess);
	static bool GetRaytracingSettings(bool* bRTXEnabled, bool* bRTXReflectionsEnabled, bool* bRTXShadowsEnabled, bool* bRTXAmbientOcclusionEnabled, bool* bRTXGlobalIllumination, bool* bRTXTranslucency);
	static bool GetReflectionQuality(int32* Reflections);
	static bool GetReflexEnabled(uint8* ReflexMode, bool* bFlashIndicatorEnabled);
	static void GetReflexLatency(bool* bGameToRenderLatencyEnabled, float* GametoRenderLatency, bool* bGameLatencyEnabled, float* GameLatencyInMS, bool* bRenderLatencyEnabled, float* RenderLatencyInMS);
	static bool GetReflexLatencyOptions(bool* bGameToRenderLatencyEnabled, bool* bGameLatencyEnabled, bool* bRenderLatencyEnabled);
	static bool GetResolutionScaling(float* ResolutionScaling);
	static bool GetShadowQuality(int32* Shadow);
	static bool GetSupportedScreenResolutions(TArray<class FString>* Resolutions);
	static bool GetTextureQuality(int32* Texture);
	static bool GetVideoQualitySettings(int32* AntiAliasing, int32* Effects, int32* PostProcess, float* ResolutionScaling, int32* Shadow, int32* Texture, int32* ViewDistance, int32* GlobalIllumination, int32* Reflections);
	static bool GetVideoQualitySettingsAsString(class FText* OverallSetting, class FText* AntiAliasing, class FText* Effects, class FText* PostProcess, class FText* Shadow, class FText* Texture, class FText* ViewDistance, class FText* GlobalIllumination, class FText* Reflections);
	static bool GetViewDistanceQuality(int32* ViewDistance);
	static bool GetVSyncEnabled(bool* bEnabled);
	static bool GetWorldDecalsEnabled(bool* bEnabled, float* FadeDistance, float* Density);
	static bool IsDLSSFrameGenerationSupported();
	static bool IsNvidiaReflexEnabled();
	static bool SaveVideoModeAndQuality();
	static bool SetDepthofFieldSetting(bool bDoFEnabled);
	static bool SetDlssFrameGenerationSetting(int32 Setting);
	static bool SetDlssQuality(int32 Quality);
	static bool SetFrameRateLimit(int32 FrameRateLimit, bool bEnabled);
	static bool SetFSRQuality(int32 Quality);
	static bool SetGraphicsPresetIndex(const int32 GraphicsPresetIndex);
	static bool SetInterfaceAspectRatio(float InAspectRatio);
	static bool SetMotionBlurEnabled(bool bEnabled);
	static bool SetMotionBlurStrength(float Strength);
	static bool SetOverallVideoQuality(int32 Quality);
	static bool SetPerObjectShadowsEnabled(bool bPerObjectShadowsEnabled);
	static bool SetRaytracingSettings(bool bRTXEnabled, bool bRTXReflectionsEnabled, bool bRTXShadowsEnabled, bool bRTXAmbientOcclusionEnabled, bool bRTXGlobalIllumination, bool bRTXTranslucency);
	static bool SetReflexEnabled(uint8 ReflexMode, bool bFlashIndicatorEnabled);
	static bool SetReflexLatencyOptions(bool bGameToRenderLatencyEnabled, bool bGameLatencyEnabled, bool bRenderLatencyEnabled);
	static bool SetScreenResolution(const int32 Width, const int32 Height, EWindowMode NewWindowMode);
	static bool SetVideoQualitySettings(const int32 AntiAliasing, const int32 Effects, const int32 PostProcess, const float ResolutionScaling, const int32 Shadow, const int32 Texture, const int32 ViewDistance, const int32 GlobalIllumination, const int32 Reflections);
	static bool SetVSyncEnabled(bool bEnabled);
	static bool SetWorldDecalEnabled(bool bEnabled, float FadeDistance, float Density);
	static bool SupportsRayTracing();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BpVideoSettingsLib">();
	}
	static class UBpVideoSettingsLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBpVideoSettingsLib>();
	}
};
static_assert(alignof(UBpVideoSettingsLib) == 0x000008, "Wrong alignment on UBpVideoSettingsLib");
static_assert(sizeof(UBpVideoSettingsLib) == 0x000028, "Wrong size on UBpVideoSettingsLib");

// Class ReadyOrNot.BpWidgetLib
// 0x0000 (0x0028 - 0x0028)
class UBpWidgetLib final : public UBlueprintFunctionLibrary
{
public:
	static class FText ChangeStringTableTextKey(const class FText& Target, const class FString& NewKey);
	static void DrawLinesWithCenteredOffset(struct FPaintContext& Context, const TArray<struct FVector2D>& Points, const struct FLinearColor& Tint, bool bAntiAlias, float Thickness, const struct FVector2D& Offset, const struct FVector2D& Center, float Scale);
	static void DrawLinesWithThickness(struct FPaintContext& Context, const TArray<struct FVector2D>& Points, const struct FLinearColor& Tint, bool bAntiAlias, float Thickness, const struct FVector2D& Offset);
	static void DrawLineWithCenteredOffset(struct FPaintContext& Context, const struct FVector2D& PositionA, const struct FVector2D& PositionB, const struct FLinearColor& Tint, bool bAntiAlias, float Thickness, const struct FVector2D& Offset, const struct FVector2D& Center, float Scale);
	static void DrawLineWithThickness(struct FPaintContext& Context, const struct FVector2D& PositionA, const struct FVector2D& PositionB, const struct FLinearColor& Tint, bool bAntiAlias, float Thickness, const struct FVector2D& Offset);
	static struct FVector2D GetNormalizedClick(const struct FGeometry& InGeometry, const struct FPointerEvent& InMouseEvent);
	static class ATablet* GetPlayerTablet(const class UObject* WorldContextObject);
	static bool IsWorldTearingDown(const class UObject* WorldContextObject);
	static void PlayEventFromTablet(const class UObject* WorldContextObject, class UFMODEvent* Event);
	static bool PostBugReport(const class FString& Summary, const class FString& Description, const class FString& Category);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BpWidgetLib">();
	}
	static class UBpWidgetLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBpWidgetLib>();
	}
};
static_assert(alignof(UBpWidgetLib) == 0x000008, "Wrong alignment on UBpWidgetLib");
static_assert(sizeof(UBpWidgetLib) == 0x000028, "Wrong size on UBpWidgetLib");

// Class ReadyOrNot.BreachingShotgun
// 0x0000 (0x17B0 - 0x17B0)
class ABreachingShotgun : public AShotgun
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BreachingShotgun">();
	}
	static class ABreachingShotgun* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABreachingShotgun>();
	}
};
static_assert(alignof(ABreachingShotgun) == 0x000010, "Wrong alignment on ABreachingShotgun");
static_assert(sizeof(ABreachingShotgun) == 0x0017B0, "Wrong size on ABreachingShotgun");

// Class ReadyOrNot.BreakableGlass
// 0x0020 (0x02B8 - 0x0298)
class ABreakableGlass final : public AActor
{
public:
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bCanSoundPass;                                     // 0x02A0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A1[0x7];                                      // 0x02A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             TPMeleeImpactFMODEvent;                            // 0x02A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        MeleeImpactParticle;                               // 0x02B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ConvertHitAndExecute(const struct FHitResult& Hit, float Damage);
	void DestructibleHit(const struct FVector& Location);
	void FirstHitPositionObject(int32 FirstPositionBox, int32 TextureY, int32 TextureX, const struct FVector& HitPosition, const struct FVector& ObjectiveDirection, float DamageRadius, bool bFirstHitCanBreakIt, float CharacterVelocityToBreak);
	void Multicast_ConvertHitAndExecute(int32 FirstPositionBox, int32 TextureX, int32 TextureY, const struct FVector_NetQuantize& HitPosition, const struct FVector_NetQuantize& Direction, float Damage);
	void Multicast_DestructibleHit(const struct FVector_NetQuantize& Location);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BreakableGlass">();
	}
	static class ABreakableGlass* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABreakableGlass>();
	}
};
static_assert(alignof(ABreakableGlass) == 0x000008, "Wrong alignment on ABreakableGlass");
static_assert(sizeof(ABreakableGlass) == 0x0002B8, "Wrong size on ABreakableGlass");
static_assert(offsetof(ABreakableGlass, bCanSoundPass) == 0x0002A0, "Member 'ABreakableGlass::bCanSoundPass' has a wrong offset!");
static_assert(offsetof(ABreakableGlass, TPMeleeImpactFMODEvent) == 0x0002A8, "Member 'ABreakableGlass::TPMeleeImpactFMODEvent' has a wrong offset!");
static_assert(offsetof(ABreakableGlass, MeleeImpactParticle) == 0x0002B0, "Member 'ABreakableGlass::MeleeImpactParticle' has a wrong offset!");

// Class ReadyOrNot.BriefingWidget
// 0x0088 (0x0370 - 0x02E8)
class UBriefingWidget : public UBaseWidget
{
public:
	uint8                                         Pad_2E8[0x88];                                     // 0x02E8(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DoesLevelHaveMissionAudio(const class FString& AudioName, bool* bHasMissionAudio);
	void GetBioDetails(const struct FCharacterBio& Bio, TArray<struct FCriminalRecord>* RapSheet, class UTexture2D** ProfileImage, class FString* OutDescription, class FString* OutBioText);
	void GetBios(EBioType BioType, TArray<struct FCharacterBio>* OutBios);
	void GetBriefing(struct FMissionAudio* OutBriefing);
	void GetLevelNickname(class FString* OutNickname);
	void GetWhiteboardObjectiveText(class FString* OutString);
	void GetWhiteboardTimelineAsString(class FString* OutString);
	void MoveCameraToMouseCursor(const struct FPointerEvent& PointerEvent);
	void PlayMissionAudio(const class FString& AudioName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BriefingWidget">();
	}
	static class UBriefingWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBriefingWidget>();
	}
};
static_assert(alignof(UBriefingWidget) == 0x000008, "Wrong alignment on UBriefingWidget");
static_assert(sizeof(UBriefingWidget) == 0x000370, "Wrong size on UBriefingWidget");

// Class ReadyOrNot.BulletDamageType
// 0x0030 (0x0070 - 0x0040)
class UBulletDamageType : public UDamageType
{
public:
	TSubclassOf<class UUserWidget>                HitVisuals;                                        // 0x0040(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ULegacyCameraShake>         HitShake;                                          // 0x0048(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bArmorPiercing;                                    // 0x0050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNonLethal;                                        // 0x0051(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52[0x2];                                       // 0x0052(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AggressionChangeInAI;                              // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeadDamageMultiplier;                              // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpperBodyDamageMultiplier;                         // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LowerBodyDamageMultiplier;                         // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArmDamageMultiplier;                               // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LegDamageMultiplier;                               // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootDamageMultiplier;                              // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BulletDamageType">();
	}
	static class UBulletDamageType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBulletDamageType>();
	}
};
static_assert(alignof(UBulletDamageType) == 0x000008, "Wrong alignment on UBulletDamageType");
static_assert(sizeof(UBulletDamageType) == 0x000070, "Wrong size on UBulletDamageType");
static_assert(offsetof(UBulletDamageType, HitVisuals) == 0x000040, "Member 'UBulletDamageType::HitVisuals' has a wrong offset!");
static_assert(offsetof(UBulletDamageType, HitShake) == 0x000048, "Member 'UBulletDamageType::HitShake' has a wrong offset!");
static_assert(offsetof(UBulletDamageType, bArmorPiercing) == 0x000050, "Member 'UBulletDamageType::bArmorPiercing' has a wrong offset!");
static_assert(offsetof(UBulletDamageType, bNonLethal) == 0x000051, "Member 'UBulletDamageType::bNonLethal' has a wrong offset!");
static_assert(offsetof(UBulletDamageType, AggressionChangeInAI) == 0x000054, "Member 'UBulletDamageType::AggressionChangeInAI' has a wrong offset!");
static_assert(offsetof(UBulletDamageType, HeadDamageMultiplier) == 0x000058, "Member 'UBulletDamageType::HeadDamageMultiplier' has a wrong offset!");
static_assert(offsetof(UBulletDamageType, UpperBodyDamageMultiplier) == 0x00005C, "Member 'UBulletDamageType::UpperBodyDamageMultiplier' has a wrong offset!");
static_assert(offsetof(UBulletDamageType, LowerBodyDamageMultiplier) == 0x000060, "Member 'UBulletDamageType::LowerBodyDamageMultiplier' has a wrong offset!");
static_assert(offsetof(UBulletDamageType, ArmDamageMultiplier) == 0x000064, "Member 'UBulletDamageType::ArmDamageMultiplier' has a wrong offset!");
static_assert(offsetof(UBulletDamageType, LegDamageMultiplier) == 0x000068, "Member 'UBulletDamageType::LegDamageMultiplier' has a wrong offset!");
static_assert(offsetof(UBulletDamageType, FootDamageMultiplier) == 0x00006C, "Member 'UBulletDamageType::FootDamageMultiplier' has a wrong offset!");

// Class ReadyOrNot.DamageProjectile
// 0x0030 (0x0310 - 0x02E0)
class ADamageProjectile : public AProjectile
{
public:
	uint8                                         Pad_2E0[0x18];                                     // 0x02E0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Damage;                                            // 0x02F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FC[0x4];                                      // 0x02FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UDamageType>                DamageType;                                        // 0x0300(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             HitMarker;                                         // 0x0308(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DamageProjectile">();
	}
	static class ADamageProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADamageProjectile>();
	}
};
static_assert(alignof(ADamageProjectile) == 0x000008, "Wrong alignment on ADamageProjectile");
static_assert(sizeof(ADamageProjectile) == 0x000310, "Wrong size on ADamageProjectile");
static_assert(offsetof(ADamageProjectile, Damage) == 0x0002F8, "Member 'ADamageProjectile::Damage' has a wrong offset!");
static_assert(offsetof(ADamageProjectile, DamageType) == 0x000300, "Member 'ADamageProjectile::DamageType' has a wrong offset!");
static_assert(offsetof(ADamageProjectile, HitMarker) == 0x000308, "Member 'ADamageProjectile::HitMarker' has a wrong offset!");

// Class ReadyOrNot.BulletProjectile
// 0x0118 (0x0428 - 0x0310)
class ABulletProjectile : public ADamageProjectile
{
public:
	class UStaticMeshComponent*                   BulletMesh;                                        // 0x0310(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_318[0x18];                                     // 0x0318(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class ABaseItem*                              FiredFromWeapon;                                   // 0x0330(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerCharacter*                       FiredFromPlayer;                                   // 0x0338(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitAngleMultiplier;                                // 0x0340(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RequiredAngleToDeflect;                            // 0x0344(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PercentageToDeflect;                               // 0x0348(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeflectionAmount;                                  // 0x034C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_350[0x8];                                      // 0x0350(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpeedLossMultiplierPerSurface;                     // 0x0358(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageLossMultiplierPerSurface;                    // 0x035C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VelocityRequiredToRespawn;                         // 0x0360(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawBlood;                                        // 0x0364(0x0001)(Edit, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_365[0x1B];                                     // 0x0365(0x001B)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                BulletProjectileScale;                             // 0x0380(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecalScale;                                        // 0x0398(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAffectedByGravity;                                // 0x039C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39D[0x3];                                      // 0x039D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundCue*                              BulletWizzSound;                                   // 0x03A0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimumDistanceForWizz;                            // 0x03A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         requiredSpeedForWizz;                              // 0x03AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DebugLineSize;                                     // 0x03B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B4[0x4];                                      // 0x03B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AImpactEffect>              ExitEffects;                                       // 0x03B8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AImpactEffect>              RicochetEffects;                                   // 0x03C0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        RichochetParticle;                                 // 0x03C8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArmorPiercing;                                     // 0x03D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDestroyOnHit;                                     // 0x03D4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttachOnHit;                                      // 0x03D5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D6[0x2];                                      // 0x03D6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InitialSpeed;                                      // 0x03D8(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3DC[0x4];                                      // 0x03DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                InitialLocation;                                   // 0x03E0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OwningActor;                                       // 0x03F8(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LockIntegrityDamage;                               // 0x0400(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_404[0x4];                                      // 0x0404(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UDamageType>                InitialDamageType;                                 // 0x0408(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifeSpan;                                          // 0x0410(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Drag;                                              // 0x0414(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Wobble;                                            // 0x0418(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialWobbleDelay;                                // 0x041C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhysicsImpulseMultiplier;                          // 0x0420(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_424[0x1];                                      // 0x0424(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bCanPenetrate;                                     // 0x0425(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bServerValidated;                                  // 0x0426(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_427[0x1];                                      // 0x0427(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Multicast_ApplyForceToHitObjects(const struct FHitResult& Hit, const struct FVector& Velocity);
	void Multicast_AttachToComponent(const struct FVector& NewLocation, class USceneComponent* Component, class FName BoneName);
	void Multicast_OnRespawnProjectile(const struct FVector_NetQuantize100& RespawnLocation, const struct FVector_NetQuantize100& RespawnRotation, float NewSpeed, float NewDamage, EProjectileReaction ProjectileReaction);
	void Multicast_SimulatePhysics(bool bSimulate);
	void OnDeflect(const struct FHitResult& DeflectionHit);
	void OnMeshHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void OnProjectileValidated();
	void OnRep_UpdateMesh();
	void OnRespawnProjectile(const struct FVector& RespawnLocation, const struct FRotator& RespawnRotation, float NewSpeed, float NewDamage, EProjectileReaction ProjectileReaction);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BulletProjectile">();
	}
	static class ABulletProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABulletProjectile>();
	}
};
static_assert(alignof(ABulletProjectile) == 0x000008, "Wrong alignment on ABulletProjectile");
static_assert(sizeof(ABulletProjectile) == 0x000428, "Wrong size on ABulletProjectile");
static_assert(offsetof(ABulletProjectile, BulletMesh) == 0x000310, "Member 'ABulletProjectile::BulletMesh' has a wrong offset!");
static_assert(offsetof(ABulletProjectile, FiredFromWeapon) == 0x000330, "Member 'ABulletProjectile::FiredFromWeapon' has a wrong offset!");
static_assert(offsetof(ABulletProjectile, FiredFromPlayer) == 0x000338, "Member 'ABulletProjectile::FiredFromPlayer' has a wrong offset!");
static_assert(offsetof(ABulletProjectile, HitAngleMultiplier) == 0x000340, "Member 'ABulletProjectile::HitAngleMultiplier' has a wrong offset!");
static_assert(offsetof(ABulletProjectile, RequiredAngleToDeflect) == 0x000344, "Member 'ABulletProjectile::RequiredAngleToDeflect' has a wrong offset!");
static_assert(offsetof(ABulletProjectile, PercentageToDeflect) == 0x000348, "Member 'ABulletProjectile::PercentageToDeflect' has a wrong offset!");
static_assert(offsetof(ABulletProjectile, DeflectionAmount) == 0x00034C, "Member 'ABulletProjectile::DeflectionAmount' has a wrong offset!");
static_assert(offsetof(ABulletProjectile, SpeedLossMultiplierPerSurface) == 0x000358, "Member 'ABulletProjectile::SpeedLossMultiplierPerSurface' has a wrong offset!");
static_assert(offsetof(ABulletProjectile, DamageLossMultiplierPerSurface) == 0x00035C, "Member 'ABulletProjectile::DamageLossMultiplierPerSurface' has a wrong offset!");
static_assert(offsetof(ABulletProjectile, VelocityRequiredToRespawn) == 0x000360, "Member 'ABulletProjectile::VelocityRequiredToRespawn' has a wrong offset!");
static_assert(offsetof(ABulletProjectile, bDrawBlood) == 0x000364, "Member 'ABulletProjectile::bDrawBlood' has a wrong offset!");
static_assert(offsetof(ABulletProjectile, BulletProjectileScale) == 0x000380, "Member 'ABulletProjectile::BulletProjectileScale' has a wrong offset!");
static_assert(offsetof(ABulletProjectile, DecalScale) == 0x000398, "Member 'ABulletProjectile::DecalScale' has a wrong offset!");
static_assert(offsetof(ABulletProjectile, bAffectedByGravity) == 0x00039C, "Member 'ABulletProjectile::bAffectedByGravity' has a wrong offset!");
static_assert(offsetof(ABulletProjectile, BulletWizzSound) == 0x0003A0, "Member 'ABulletProjectile::BulletWizzSound' has a wrong offset!");
static_assert(offsetof(ABulletProjectile, MinimumDistanceForWizz) == 0x0003A8, "Member 'ABulletProjectile::MinimumDistanceForWizz' has a wrong offset!");
static_assert(offsetof(ABulletProjectile, requiredSpeedForWizz) == 0x0003AC, "Member 'ABulletProjectile::requiredSpeedForWizz' has a wrong offset!");
static_assert(offsetof(ABulletProjectile, DebugLineSize) == 0x0003B0, "Member 'ABulletProjectile::DebugLineSize' has a wrong offset!");
static_assert(offsetof(ABulletProjectile, ExitEffects) == 0x0003B8, "Member 'ABulletProjectile::ExitEffects' has a wrong offset!");
static_assert(offsetof(ABulletProjectile, RicochetEffects) == 0x0003C0, "Member 'ABulletProjectile::RicochetEffects' has a wrong offset!");
static_assert(offsetof(ABulletProjectile, RichochetParticle) == 0x0003C8, "Member 'ABulletProjectile::RichochetParticle' has a wrong offset!");
static_assert(offsetof(ABulletProjectile, ArmorPiercing) == 0x0003D0, "Member 'ABulletProjectile::ArmorPiercing' has a wrong offset!");
static_assert(offsetof(ABulletProjectile, bDestroyOnHit) == 0x0003D4, "Member 'ABulletProjectile::bDestroyOnHit' has a wrong offset!");
static_assert(offsetof(ABulletProjectile, bAttachOnHit) == 0x0003D5, "Member 'ABulletProjectile::bAttachOnHit' has a wrong offset!");
static_assert(offsetof(ABulletProjectile, InitialSpeed) == 0x0003D8, "Member 'ABulletProjectile::InitialSpeed' has a wrong offset!");
static_assert(offsetof(ABulletProjectile, InitialLocation) == 0x0003E0, "Member 'ABulletProjectile::InitialLocation' has a wrong offset!");
static_assert(offsetof(ABulletProjectile, OwningActor) == 0x0003F8, "Member 'ABulletProjectile::OwningActor' has a wrong offset!");
static_assert(offsetof(ABulletProjectile, LockIntegrityDamage) == 0x000400, "Member 'ABulletProjectile::LockIntegrityDamage' has a wrong offset!");
static_assert(offsetof(ABulletProjectile, InitialDamageType) == 0x000408, "Member 'ABulletProjectile::InitialDamageType' has a wrong offset!");
static_assert(offsetof(ABulletProjectile, LifeSpan) == 0x000410, "Member 'ABulletProjectile::LifeSpan' has a wrong offset!");
static_assert(offsetof(ABulletProjectile, Drag) == 0x000414, "Member 'ABulletProjectile::Drag' has a wrong offset!");
static_assert(offsetof(ABulletProjectile, Wobble) == 0x000418, "Member 'ABulletProjectile::Wobble' has a wrong offset!");
static_assert(offsetof(ABulletProjectile, InitialWobbleDelay) == 0x00041C, "Member 'ABulletProjectile::InitialWobbleDelay' has a wrong offset!");
static_assert(offsetof(ABulletProjectile, PhysicsImpulseMultiplier) == 0x000420, "Member 'ABulletProjectile::PhysicsImpulseMultiplier' has a wrong offset!");
static_assert(offsetof(ABulletProjectile, bCanPenetrate) == 0x000425, "Member 'ABulletProjectile::bCanPenetrate' has a wrong offset!");
static_assert(offsetof(ABulletProjectile, bServerValidated) == 0x000426, "Member 'ABulletProjectile::bServerValidated' has a wrong offset!");

// Class ReadyOrNot.BulletProjectileMovementComponent
// 0x0000 (0x0260 - 0x0260)
class UBulletProjectileMovementComponent final : public UProjectileMovementComponent
{
public:
	bool                                          bReduceFrictionAfterFirstBounce;                   // 0x0258(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_259[0x3];                                      // 0x0259(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FrictionAfterFirstBounce;                          // 0x025C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BulletProjectileMovementComponent">();
	}
	static class UBulletProjectileMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBulletProjectileMovementComponent>();
	}
};
static_assert(alignof(UBulletProjectileMovementComponent) == 0x000010, "Wrong alignment on UBulletProjectileMovementComponent");
static_assert(sizeof(UBulletProjectileMovementComponent) == 0x000260, "Wrong size on UBulletProjectileMovementComponent");
static_assert(offsetof(UBulletProjectileMovementComponent, bReduceFrictionAfterFirstBounce) == 0x000258, "Member 'UBulletProjectileMovementComponent::bReduceFrictionAfterFirstBounce' has a wrong offset!");
static_assert(offsetof(UBulletProjectileMovementComponent, FrictionAfterFirstBounce) == 0x00025C, "Member 'UBulletProjectileMovementComponent::FrictionAfterFirstBounce' has a wrong offset!");

// Class ReadyOrNot.BulletTracer
// 0x0058 (0x02F0 - 0x0298)
class ABulletTracer final : public AActor
{
public:
	class USceneComponent*                        RootComp;                                          // 0x0298(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A0[0x38];                                     // 0x02A0(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystemComponent*               ParticleComponent;                                 // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        TracerParticle;                                    // 0x02E0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        SmokeParticle;                                     // 0x02E8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BulletTracer">();
	}
	static class ABulletTracer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABulletTracer>();
	}
};
static_assert(alignof(ABulletTracer) == 0x000008, "Wrong alignment on ABulletTracer");
static_assert(sizeof(ABulletTracer) == 0x0002F0, "Wrong size on ABulletTracer");
static_assert(offsetof(ABulletTracer, RootComp) == 0x000298, "Member 'ABulletTracer::RootComp' has a wrong offset!");
static_assert(offsetof(ABulletTracer, ParticleComponent) == 0x0002D8, "Member 'ABulletTracer::ParticleComponent' has a wrong offset!");
static_assert(offsetof(ABulletTracer, TracerParticle) == 0x0002E0, "Member 'ABulletTracer::TracerParticle' has a wrong offset!");
static_assert(offsetof(ABulletTracer, SmokeParticle) == 0x0002E8, "Member 'ABulletTracer::SmokeParticle' has a wrong offset!");

// Class ReadyOrNot.C2Explosive
// 0x0110 (0x0CC0 - 0x0BB0)
class AC2Explosive : public ABaseItem
{
public:
	bool                                          bIsValidPlacement;                                 // 0x0BB0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BB1[0x7];                                      // 0x0BB1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             LastGoodPlacement;                                 // 0x0BB8(0x00E8)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class APlacedC2Explosive*                     LastPlacedC2Explosive;                             // 0x0CA0(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPlacementDistance;                              // 0x0CA8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CAC[0x4];                                      // 0x0CAC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 CurrentActorPlacement;                             // 0x0CB0(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class APlacedC2Explosive>         PlacedC2Class;                                     // 0x0CB8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Client_C2PlacementFinished();
	void Multicast_StartPlaceC2Explosive();
	void OnRep_LastPlacedC2Explosive();
	void Server_FinishC2Placement();
	void Server_StartC2Placement(class AActor* Actor);

	void EquipDetonator(bool bFromExplosives) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"C2Explosive">();
	}
	static class AC2Explosive* GetDefaultObj()
	{
		return GetDefaultObjImpl<AC2Explosive>();
	}
};
static_assert(alignof(AC2Explosive) == 0x000010, "Wrong alignment on AC2Explosive");
static_assert(sizeof(AC2Explosive) == 0x000CC0, "Wrong size on AC2Explosive");
static_assert(offsetof(AC2Explosive, bIsValidPlacement) == 0x000BB0, "Member 'AC2Explosive::bIsValidPlacement' has a wrong offset!");
static_assert(offsetof(AC2Explosive, LastGoodPlacement) == 0x000BB8, "Member 'AC2Explosive::LastGoodPlacement' has a wrong offset!");
static_assert(offsetof(AC2Explosive, LastPlacedC2Explosive) == 0x000CA0, "Member 'AC2Explosive::LastPlacedC2Explosive' has a wrong offset!");
static_assert(offsetof(AC2Explosive, MaxPlacementDistance) == 0x000CA8, "Member 'AC2Explosive::MaxPlacementDistance' has a wrong offset!");
static_assert(offsetof(AC2Explosive, CurrentActorPlacement) == 0x000CB0, "Member 'AC2Explosive::CurrentActorPlacement' has a wrong offset!");
static_assert(offsetof(AC2Explosive, PlacedC2Class) == 0x000CB8, "Member 'AC2Explosive::PlacedC2Class' has a wrong offset!");

// Class ReadyOrNot.CampaignData
// 0x0108 (0x0138 - 0x0030)
class UCampaignData final : public UPrimaryDataAsset
{
public:
	class FText                                   CampaignTitle;                                     // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   CampaignAuthor;                                    // 0x0048(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   CampaignDescription;                               // 0x0060(0x0018)(Edit, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCampaignData>           RequiredCampaign;                                  // 0x0078(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameVersionRestriction                       VersionRestriction;                                // 0x00A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UWorld>                  StationLevelOverride;                              // 0x00A8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAvailableInCommanderMode;                         // 0x00D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableLevelProgressionInQuickPlay;                // 0x00D1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableLevelProgressionInCommanderMode;            // 0x00D2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D3[0x5];                                       // 0x00D3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         Levels;                                            // 0x00D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   CampaignCompletedWidget;                           // 0x00E8(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   CampaignUnlockedWidget;                            // 0x0110(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CampaignData">();
	}
	static class UCampaignData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCampaignData>();
	}
};
static_assert(alignof(UCampaignData) == 0x000008, "Wrong alignment on UCampaignData");
static_assert(sizeof(UCampaignData) == 0x000138, "Wrong size on UCampaignData");
static_assert(offsetof(UCampaignData, CampaignTitle) == 0x000030, "Member 'UCampaignData::CampaignTitle' has a wrong offset!");
static_assert(offsetof(UCampaignData, CampaignAuthor) == 0x000048, "Member 'UCampaignData::CampaignAuthor' has a wrong offset!");
static_assert(offsetof(UCampaignData, CampaignDescription) == 0x000060, "Member 'UCampaignData::CampaignDescription' has a wrong offset!");
static_assert(offsetof(UCampaignData, RequiredCampaign) == 0x000078, "Member 'UCampaignData::RequiredCampaign' has a wrong offset!");
static_assert(offsetof(UCampaignData, VersionRestriction) == 0x0000A0, "Member 'UCampaignData::VersionRestriction' has a wrong offset!");
static_assert(offsetof(UCampaignData, StationLevelOverride) == 0x0000A8, "Member 'UCampaignData::StationLevelOverride' has a wrong offset!");
static_assert(offsetof(UCampaignData, bAvailableInCommanderMode) == 0x0000D0, "Member 'UCampaignData::bAvailableInCommanderMode' has a wrong offset!");
static_assert(offsetof(UCampaignData, bEnableLevelProgressionInQuickPlay) == 0x0000D1, "Member 'UCampaignData::bEnableLevelProgressionInQuickPlay' has a wrong offset!");
static_assert(offsetof(UCampaignData, bEnableLevelProgressionInCommanderMode) == 0x0000D2, "Member 'UCampaignData::bEnableLevelProgressionInCommanderMode' has a wrong offset!");
static_assert(offsetof(UCampaignData, Levels) == 0x0000D8, "Member 'UCampaignData::Levels' has a wrong offset!");
static_assert(offsetof(UCampaignData, CampaignCompletedWidget) == 0x0000E8, "Member 'UCampaignData::CampaignCompletedWidget' has a wrong offset!");
static_assert(offsetof(UCampaignData, CampaignUnlockedWidget) == 0x000110, "Member 'UCampaignData::CampaignUnlockedWidget' has a wrong offset!");

// Class ReadyOrNot.CancellableInteractionsData
// 0x0010 (0x00D0 - 0x00C0)
class UCancellableInteractionsData final : public UInteractionsData
{
public:
	class UAnimMontage*                           DriverMontageCancel;                               // 0x00C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           DriverMontageCancel_FP;                            // 0x00C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CancellableInteractionsData">();
	}
	static class UCancellableInteractionsData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCancellableInteractionsData>();
	}
};
static_assert(alignof(UCancellableInteractionsData) == 0x000008, "Wrong alignment on UCancellableInteractionsData");
static_assert(sizeof(UCancellableInteractionsData) == 0x0000D0, "Wrong size on UCancellableInteractionsData");
static_assert(offsetof(UCancellableInteractionsData, DriverMontageCancel) == 0x0000C0, "Member 'UCancellableInteractionsData::DriverMontageCancel' has a wrong offset!");
static_assert(offsetof(UCancellableInteractionsData, DriverMontageCancel_FP) == 0x0000C8, "Member 'UCancellableInteractionsData::DriverMontageCancel_FP' has a wrong offset!");

// Class ReadyOrNot.CanPlaceC2On
// 0x0000 (0x0000 - 0x0000)
class ICanPlaceC2On final
{
public:
	void C2StartPlacement(class AC2Explosive* C2);
	void C2StopPlacement(class AC2Explosive* C2);
	bool CanPlaceC2OnNow(class APlayerCharacter* C2Owner, class AC2Explosive* C2, const struct FHitResult& Hit);
	struct FVector GetPlacementLocation(const struct FHitResult& TraceHit);
	struct FRotator GetPlacementRotation(const struct FHitResult& TraceHit);
	void OnC2Detonated(class APlacedC2Explosive* C2);
	void OnC2Removed(class APlacedC2Explosive* C2);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CanPlaceC2On">();
	}
	static class ICanPlaceC2On* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICanPlaceC2On>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ICanPlaceC2On) == 0x000001, "Wrong alignment on ICanPlaceC2On");
static_assert(sizeof(ICanPlaceC2On) == 0x000001, "Wrong size on ICanPlaceC2On");

// Class ReadyOrNot.CanUse
// 0x0000 (0x0000 - 0x0000)
class ICanUse final
{
public:
	bool CanUse(class APlayerCharacter* User);
	void EndUse(class APlayerCharacter* User);
	class FText GetUseButtonPromptText();
	class USceneComponent* GetUseIconBoltComponent();
	TArray<class USceneComponent*> GetUseViewComponents();
	bool IsAvailableForUse();
	bool OverridesUseButtonPromptText();
	bool PlaysUseIconComplete();
	bool StartUse(class APlayerCharacter* User);
	bool UsesHoldButtonPrompt();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CanUse">();
	}
	static class ICanUse* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICanUse>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ICanUse) == 0x000001, "Wrong alignment on ICanUse");
static_assert(sizeof(ICanUse) == 0x000001, "Wrong size on ICanUse");

// Class ReadyOrNot.CanUseMultitoolOn
// 0x0000 (0x0000 - 0x0000)
class ICanUseMultitoolOn final
{
public:
	bool CanCancelMultitoolAction();
	bool CanUseMultitoolNow(class AReadyOrNotCharacter* ToolOwner, class AMultitool* Tool, const struct FHitResult& TraceHit);
	void Client_FinishedUsingMultitool(class AReadyOrNotCharacter* ToolOwner);
	float GetMultitoolUseTime();
	EMultitoolFunctions GetMultitoolUseType();
	void Server_FinishedUsingMultitool(class AReadyOrNotCharacter* ToolOwner);

	bool ShouldInterrupt() const;
	bool ShouldOperate() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CanUseMultitoolOn">();
	}
	static class ICanUseMultitoolOn* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICanUseMultitoolOn>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ICanUseMultitoolOn) == 0x000001, "Wrong alignment on ICanUseMultitoolOn");
static_assert(sizeof(ICanUseMultitoolOn) == 0x000001, "Wrong size on ICanUseMultitoolOn");

// Class ReadyOrNot.CaptureTheFlagGS
// 0x0018 (0x0910 - 0x08F8)
class ACaptureTheFlagGS final : public AReadyOrNotGameState
{
public:
	class ACTF_Flag*                              Flag;                                              // 0x08F8(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerCharacter*                       FlagBearer;                                        // 0x0900(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETeamType                                     FlagBearerTeam;                                    // 0x0908(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bFlagCaptured : 1;                                 // 0x0909(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bGameWon : 1;                                      // 0x0909(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_90A[0x6];                                      // 0x090A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_FlagStatus();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CaptureTheFlagGS">();
	}
	static class ACaptureTheFlagGS* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACaptureTheFlagGS>();
	}
};
static_assert(alignof(ACaptureTheFlagGS) == 0x000008, "Wrong alignment on ACaptureTheFlagGS");
static_assert(sizeof(ACaptureTheFlagGS) == 0x000910, "Wrong size on ACaptureTheFlagGS");
static_assert(offsetof(ACaptureTheFlagGS, Flag) == 0x0008F8, "Member 'ACaptureTheFlagGS::Flag' has a wrong offset!");
static_assert(offsetof(ACaptureTheFlagGS, FlagBearer) == 0x000900, "Member 'ACaptureTheFlagGS::FlagBearer' has a wrong offset!");
static_assert(offsetof(ACaptureTheFlagGS, FlagBearerTeam) == 0x000908, "Member 'ACaptureTheFlagGS::FlagBearerTeam' has a wrong offset!");

// Class ReadyOrNot.ChallengeManager
// 0x0018 (0x0048 - 0x0030)
class UChallengeManager final : public UWorldSubsystem
{
public:
	TArray<class UChallenge*>                     Challenges;                                        // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class UReadyOrNotProfile*                     Profile;                                           // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void InitChallenges(class AReadyOrNotGameState* GameState, const struct FLevelDataLookupTable& LevelData);
	void SaveChallenges();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChallengeManager">();
	}
	static class UChallengeManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChallengeManager>();
	}
};
static_assert(alignof(UChallengeManager) == 0x000008, "Wrong alignment on UChallengeManager");
static_assert(sizeof(UChallengeManager) == 0x000048, "Wrong size on UChallengeManager");
static_assert(offsetof(UChallengeManager, Challenges) == 0x000030, "Member 'UChallengeManager::Challenges' has a wrong offset!");
static_assert(offsetof(UChallengeManager, Profile) == 0x000040, "Member 'UChallengeManager::Profile' has a wrong offset!");

// Class ReadyOrNot.CharacterCountEventCondition
// 0x0010 (0x0050 - 0x0040)
class UCharacterCountEventCondition final : public UMissionEventCondition
{
public:
	int32                                         RequiredCount;                                     // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterCountEventConditionRule             CountRule;                                         // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncludeKilled;                                    // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncludeIncapacitated;                             // 0x0049(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncludeSurrendered;                               // 0x004A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncludeArrested;                                  // 0x004B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCountSuspects;                                    // 0x004C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCountCivilians;                                   // 0x004D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCountSwat;                                        // 0x004E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4F[0x1];                                       // 0x004F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleAllCharactersSpawned();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterCountEventCondition">();
	}
	static class UCharacterCountEventCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterCountEventCondition>();
	}
};
static_assert(alignof(UCharacterCountEventCondition) == 0x000008, "Wrong alignment on UCharacterCountEventCondition");
static_assert(sizeof(UCharacterCountEventCondition) == 0x000050, "Wrong size on UCharacterCountEventCondition");
static_assert(offsetof(UCharacterCountEventCondition, RequiredCount) == 0x000040, "Member 'UCharacterCountEventCondition::RequiredCount' has a wrong offset!");
static_assert(offsetof(UCharacterCountEventCondition, CountRule) == 0x000044, "Member 'UCharacterCountEventCondition::CountRule' has a wrong offset!");
static_assert(offsetof(UCharacterCountEventCondition, bIncludeKilled) == 0x000048, "Member 'UCharacterCountEventCondition::bIncludeKilled' has a wrong offset!");
static_assert(offsetof(UCharacterCountEventCondition, bIncludeIncapacitated) == 0x000049, "Member 'UCharacterCountEventCondition::bIncludeIncapacitated' has a wrong offset!");
static_assert(offsetof(UCharacterCountEventCondition, bIncludeSurrendered) == 0x00004A, "Member 'UCharacterCountEventCondition::bIncludeSurrendered' has a wrong offset!");
static_assert(offsetof(UCharacterCountEventCondition, bIncludeArrested) == 0x00004B, "Member 'UCharacterCountEventCondition::bIncludeArrested' has a wrong offset!");
static_assert(offsetof(UCharacterCountEventCondition, bCountSuspects) == 0x00004C, "Member 'UCharacterCountEventCondition::bCountSuspects' has a wrong offset!");
static_assert(offsetof(UCharacterCountEventCondition, bCountCivilians) == 0x00004D, "Member 'UCharacterCountEventCondition::bCountCivilians' has a wrong offset!");
static_assert(offsetof(UCharacterCountEventCondition, bCountSwat) == 0x00004E, "Member 'UCharacterCountEventCondition::bCountSwat' has a wrong offset!");

// Class ReadyOrNot.CharacterCustomizationPortal
// 0x0068 (0x0300 - 0x0298)
class ACharacterCustomizationPortal final : public AActor
{
public:
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AReadyOrNotCharacter*                   CustomizationCharacter;                            // 0x02A0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInteractableComponent*                 InteractableComponent;                             // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBillboardComponent*                    BillboardComponent;                                // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UArrowComponent*                        CharacterSpawnPoint;                               // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C0[0x10];                                     // 0x02C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UStaticMeshComponent*>           CompsToOutline;                                    // 0x02D0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class ULightComponent*>                LightsToEnable;                                    // 0x02E0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	class FName                                   LightActorsOfTag;                                  // 0x02F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHasLocked;                                        // 0x02F8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F9[0x7];                                      // 0x02F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void GetAllCompatibleBodies(class FName InHead, TArray<class FName>* OutBodies);
	static void GetAllCompatibleHeads(class FName InBody, TArray<class FName>* OutHeads);
	static bool GetCharacterLookOverride(class FName Head, class FName Body, struct FCharacterLookOverride* OutCharacterLookOverride);
	static bool GetCurrentCharacterLookOverride(class FName* OutHead, class FName* OutBody);
	static void GetCustomizationEntries(TArray<struct FCharacterPersonalizationData>* OutHeads, TArray<struct FCharacterPersonalizationData>* OutBodys);
	static bool IsDLCLocked(const struct FCharacterPersonalizationData& Data);
	static bool SaveCharacterLookOverride(class FName InHead, class FName InBody);

	void UpdateCharacterLookOverride(class FName Head, class FName Body);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterCustomizationPortal">();
	}
	static class ACharacterCustomizationPortal* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACharacterCustomizationPortal>();
	}
};
static_assert(alignof(ACharacterCustomizationPortal) == 0x000008, "Wrong alignment on ACharacterCustomizationPortal");
static_assert(sizeof(ACharacterCustomizationPortal) == 0x000300, "Wrong size on ACharacterCustomizationPortal");
static_assert(offsetof(ACharacterCustomizationPortal, CustomizationCharacter) == 0x0002A0, "Member 'ACharacterCustomizationPortal::CustomizationCharacter' has a wrong offset!");
static_assert(offsetof(ACharacterCustomizationPortal, InteractableComponent) == 0x0002A8, "Member 'ACharacterCustomizationPortal::InteractableComponent' has a wrong offset!");
static_assert(offsetof(ACharacterCustomizationPortal, BillboardComponent) == 0x0002B0, "Member 'ACharacterCustomizationPortal::BillboardComponent' has a wrong offset!");
static_assert(offsetof(ACharacterCustomizationPortal, CharacterSpawnPoint) == 0x0002B8, "Member 'ACharacterCustomizationPortal::CharacterSpawnPoint' has a wrong offset!");
static_assert(offsetof(ACharacterCustomizationPortal, CompsToOutline) == 0x0002D0, "Member 'ACharacterCustomizationPortal::CompsToOutline' has a wrong offset!");
static_assert(offsetof(ACharacterCustomizationPortal, LightsToEnable) == 0x0002E0, "Member 'ACharacterCustomizationPortal::LightsToEnable' has a wrong offset!");
static_assert(offsetof(ACharacterCustomizationPortal, LightActorsOfTag) == 0x0002F0, "Member 'ACharacterCustomizationPortal::LightActorsOfTag' has a wrong offset!");
static_assert(offsetof(ACharacterCustomizationPortal, bHasLocked) == 0x0002F8, "Member 'ACharacterCustomizationPortal::bHasLocked' has a wrong offset!");

// Class ReadyOrNot.TableTennisPlayer
// 0x0010 (0x02A8 - 0x0298)
class ATableTennisPlayer final : public AActor
{
public:
	class ATableTennisMachine*                    TargetGame;                                        // 0x0298(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A0[0x8];                                      // 0x02A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Server_SetPosition(float NewPosition);
	void Server_StopPlaying();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TableTennisPlayer">();
	}
	static class ATableTennisPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATableTennisPlayer>();
	}
};
static_assert(alignof(ATableTennisPlayer) == 0x000008, "Wrong alignment on ATableTennisPlayer");
static_assert(sizeof(ATableTennisPlayer) == 0x0002A8, "Wrong size on ATableTennisPlayer");
static_assert(offsetof(ATableTennisPlayer, TargetGame) == 0x000298, "Member 'ATableTennisPlayer::TargetGame' has a wrong offset!");

// Class ReadyOrNot.ReactionInterestPoint
// 0x0008 (0x02A0 - 0x0298)
class AReactionInterestPoint final : public AActor
{
public:
	class UBillboardComponent*                    BillboardComponent;                                // 0x0298(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReactionInterestPoint">();
	}
	static class AReactionInterestPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AReactionInterestPoint>();
	}
};
static_assert(alignof(AReactionInterestPoint) == 0x000008, "Wrong alignment on AReactionInterestPoint");
static_assert(sizeof(AReactionInterestPoint) == 0x0002A0, "Wrong size on AReactionInterestPoint");
static_assert(offsetof(AReactionInterestPoint, BillboardComponent) == 0x000298, "Member 'AReactionInterestPoint::BillboardComponent' has a wrong offset!");

// Class ReadyOrNot.FreeMode
// 0x0010 (0x0980 - 0x0970)
class AFreeMode final : public AReadyOrNotGameMode
{
public:
	float                                         RespawnTime;                                       // 0x0970(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_974[0xC];                                      // 0x0974(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FreeMode">();
	}
	static class AFreeMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFreeMode>();
	}
};
static_assert(alignof(AFreeMode) == 0x000010, "Wrong alignment on AFreeMode");
static_assert(sizeof(AFreeMode) == 0x000980, "Wrong size on AFreeMode");
static_assert(offsetof(AFreeMode, RespawnTime) == 0x000970, "Member 'AFreeMode::RespawnTime' has a wrong offset!");

// Class ReadyOrNot.CharacterReactionVolume
// 0x00A8 (0x0378 - 0x02D0)
class ACharacterReactionVolume final : public AVolume
{
public:
	TArray<class FString>                         PossibleVoiceLines;                                // 0x02D0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bUseStealthVoiceLines;                             // 0x02E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E1[0x7];                                      // 0x02E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         PossibleStealthVoiceLines;                         // 0x02E8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bUseEligibleSpeakersOnly;                          // 0x02F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F9[0x7];                                      // 0x02F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         EligibleSpeakers;                                  // 0x0300(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bUseSpecificVoiceLines;                            // 0x0310(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_311[0x3];                                      // 0x0311(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InspectTimeBeforeReaction;                         // 0x0314(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeBetweenReactionAttempts;                       // 0x0318(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeWithoutCombat;                                 // 0x031C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxReactions;                                      // 0x0320(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   VolumeTag;                                         // 0x0324(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSwatOnly;                                         // 0x032C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32D[0x3];                                      // 0x032D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AReactionInterestPoint*>         InterestPoints;                                    // 0x0330(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, AdvancedDisplay, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class AReadyOrNotCharacter*>           OverlappingCharacters;                             // 0x0340(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_350[0x28];                                     // 0x0350(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AttemptReaction();
	void OnOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnOverlapEnd(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnTaggedVolumeTriggered(class ACharacterReactionVolume* Volume, class FName Tag);
	void PlayReaction(class AReadyOrNotCharacter* Character);
	void ReactionLengthReady(float Length);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterReactionVolume">();
	}
	static class ACharacterReactionVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACharacterReactionVolume>();
	}
};
static_assert(alignof(ACharacterReactionVolume) == 0x000008, "Wrong alignment on ACharacterReactionVolume");
static_assert(sizeof(ACharacterReactionVolume) == 0x000378, "Wrong size on ACharacterReactionVolume");
static_assert(offsetof(ACharacterReactionVolume, PossibleVoiceLines) == 0x0002D0, "Member 'ACharacterReactionVolume::PossibleVoiceLines' has a wrong offset!");
static_assert(offsetof(ACharacterReactionVolume, bUseStealthVoiceLines) == 0x0002E0, "Member 'ACharacterReactionVolume::bUseStealthVoiceLines' has a wrong offset!");
static_assert(offsetof(ACharacterReactionVolume, PossibleStealthVoiceLines) == 0x0002E8, "Member 'ACharacterReactionVolume::PossibleStealthVoiceLines' has a wrong offset!");
static_assert(offsetof(ACharacterReactionVolume, bUseEligibleSpeakersOnly) == 0x0002F8, "Member 'ACharacterReactionVolume::bUseEligibleSpeakersOnly' has a wrong offset!");
static_assert(offsetof(ACharacterReactionVolume, EligibleSpeakers) == 0x000300, "Member 'ACharacterReactionVolume::EligibleSpeakers' has a wrong offset!");
static_assert(offsetof(ACharacterReactionVolume, bUseSpecificVoiceLines) == 0x000310, "Member 'ACharacterReactionVolume::bUseSpecificVoiceLines' has a wrong offset!");
static_assert(offsetof(ACharacterReactionVolume, InspectTimeBeforeReaction) == 0x000314, "Member 'ACharacterReactionVolume::InspectTimeBeforeReaction' has a wrong offset!");
static_assert(offsetof(ACharacterReactionVolume, TimeBetweenReactionAttempts) == 0x000318, "Member 'ACharacterReactionVolume::TimeBetweenReactionAttempts' has a wrong offset!");
static_assert(offsetof(ACharacterReactionVolume, TimeWithoutCombat) == 0x00031C, "Member 'ACharacterReactionVolume::TimeWithoutCombat' has a wrong offset!");
static_assert(offsetof(ACharacterReactionVolume, MaxReactions) == 0x000320, "Member 'ACharacterReactionVolume::MaxReactions' has a wrong offset!");
static_assert(offsetof(ACharacterReactionVolume, VolumeTag) == 0x000324, "Member 'ACharacterReactionVolume::VolumeTag' has a wrong offset!");
static_assert(offsetof(ACharacterReactionVolume, bSwatOnly) == 0x00032C, "Member 'ACharacterReactionVolume::bSwatOnly' has a wrong offset!");
static_assert(offsetof(ACharacterReactionVolume, InterestPoints) == 0x000330, "Member 'ACharacterReactionVolume::InterestPoints' has a wrong offset!");
static_assert(offsetof(ACharacterReactionVolume, OverlappingCharacters) == 0x000340, "Member 'ACharacterReactionVolume::OverlappingCharacters' has a wrong offset!");

// Class ReadyOrNot.DoorInteractionActivity
// 0x0068 (0x0258 - 0x01F0)
class UDoorInteractionActivity : public UBaseActivity
{
public:
	class ADoor*                                  Door;                                              // 0x01F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CommandLocation;                                   // 0x01F8(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OriginalLocation;                                  // 0x0210(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bReturnToPositionAfterInteraction : 1;             // 0x0228(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDisablePlayerDoorInteraction : 1;                 // 0x0228(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bHadShieldEquipped : 1;                            // 0x0228(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_229[0x7];                                      // 0x0229(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 InteractionAnimation;                              // 0x0230(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           InteractionAnimMontage;                            // 0x0240(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_248[0x10];                                     // 0x0248(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnterGetInPositionStage();
	void EnterInteractStage();
	void EnterReturnStage();
	void ExitGetInPositionStage();
	void ExitInteractStage();
	void ExitReturnStage();
	void OnDoorBroken();
	void OnDoorClosed();
	void OnDoorMovementBlocked();
	void OnDoorOpened();
	void OnInteractionBegin();
	void OnInteractionEnd();
	void PerformGetInPositionStage(float DeltaTime, float Uptime);
	void PerformInteractStage(float DeltaTime, float Uptime);
	void TickReturnStage(float DeltaTime, float Uptime);

	bool CanInteract() const;
	bool CanReturn() const;
	bool ShouldGetInPosition() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DoorInteractionActivity">();
	}
	static class UDoorInteractionActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDoorInteractionActivity>();
	}
};
static_assert(alignof(UDoorInteractionActivity) == 0x000008, "Wrong alignment on UDoorInteractionActivity");
static_assert(sizeof(UDoorInteractionActivity) == 0x000258, "Wrong size on UDoorInteractionActivity");
static_assert(offsetof(UDoorInteractionActivity, Door) == 0x0001F0, "Member 'UDoorInteractionActivity::Door' has a wrong offset!");
static_assert(offsetof(UDoorInteractionActivity, CommandLocation) == 0x0001F8, "Member 'UDoorInteractionActivity::CommandLocation' has a wrong offset!");
static_assert(offsetof(UDoorInteractionActivity, OriginalLocation) == 0x000210, "Member 'UDoorInteractionActivity::OriginalLocation' has a wrong offset!");
static_assert(offsetof(UDoorInteractionActivity, InteractionAnimation) == 0x000230, "Member 'UDoorInteractionActivity::InteractionAnimation' has a wrong offset!");
static_assert(offsetof(UDoorInteractionActivity, InteractionAnimMontage) == 0x000240, "Member 'UDoorInteractionActivity::InteractionAnimMontage' has a wrong offset!");

// Class ReadyOrNot.DoorBreachActivity
// 0x0020 (0x0278 - 0x0258)
class UDoorBreachActivity : public UDoorInteractionActivity
{
public:
	class ABaseItem*                              BreachItem;                                        // 0x0258(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UBaseActivity* Activity, class ACyberneticController* Controller)> OnBreachFinished; // 0x0260(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_270[0x8];                                      // 0x0270(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnterBreachedStage();
	void ExitBreachedStage();
	void FinishDoorBreach();
	void OnBreacherKilled(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter);
	void TickBreachedStage(float DeltaTime, float Uptime);

	bool IsBreachFinished() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DoorBreachActivity">();
	}
	static class UDoorBreachActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDoorBreachActivity>();
	}
};
static_assert(alignof(UDoorBreachActivity) == 0x000008, "Wrong alignment on UDoorBreachActivity");
static_assert(sizeof(UDoorBreachActivity) == 0x000278, "Wrong size on UDoorBreachActivity");
static_assert(offsetof(UDoorBreachActivity, BreachItem) == 0x000258, "Member 'UDoorBreachActivity::BreachItem' has a wrong offset!");
static_assert(offsetof(UDoorBreachActivity, OnBreachFinished) == 0x000260, "Member 'UDoorBreachActivity::OnBreachFinished' has a wrong offset!");

// Class ReadyOrNot.CustomDoorBreachActivity
// 0x0000 (0x0278 - 0x0278)
class UCustomDoorBreachActivity final : public UDoorBreachActivity
{
public:
	void TickBreachDoor(float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomDoorBreachActivity">();
	}
	static class UCustomDoorBreachActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomDoorBreachActivity>();
	}
};
static_assert(alignof(UCustomDoorBreachActivity) == 0x000008, "Wrong alignment on UCustomDoorBreachActivity");
static_assert(sizeof(UCustomDoorBreachActivity) == 0x000278, "Wrong size on UCustomDoorBreachActivity");

// Class ReadyOrNot.TaggedCharacterEventCondition
// 0x0020 (0x0060 - 0x0040)
class UTaggedCharacterEventCondition final : public UMissionEventCondition
{
public:
	class FName                                   CharacterTag;                                      // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTriggerOnKilled;                                  // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTriggerOnIncapacitated;                           // 0x0049(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTriggerOnArrested;                                // 0x004A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTriggerOnSurrendered;                             // 0x004B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTriggerOnOverStressed;                            // 0x004C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OverStressedTriggerThreshold;                      // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ACyberneticCharacter*                   TaggedCharacter;                                   // 0x0058(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void HandleAllCharactersSpawned();
	void HandleCharacterArrestedOrSurrendered(class AReadyOrNotCharacter* Character);
	void HandleCharacterIncapacitated(class AReadyOrNotCharacter* IncapacitatedCharacter, class AReadyOrNotCharacter* InstigatorCharacter);
	void HandleCharacterKilled(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TaggedCharacterEventCondition">();
	}
	static class UTaggedCharacterEventCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTaggedCharacterEventCondition>();
	}
};
static_assert(alignof(UTaggedCharacterEventCondition) == 0x000008, "Wrong alignment on UTaggedCharacterEventCondition");
static_assert(sizeof(UTaggedCharacterEventCondition) == 0x000060, "Wrong size on UTaggedCharacterEventCondition");
static_assert(offsetof(UTaggedCharacterEventCondition, CharacterTag) == 0x000040, "Member 'UTaggedCharacterEventCondition::CharacterTag' has a wrong offset!");
static_assert(offsetof(UTaggedCharacterEventCondition, bTriggerOnKilled) == 0x000048, "Member 'UTaggedCharacterEventCondition::bTriggerOnKilled' has a wrong offset!");
static_assert(offsetof(UTaggedCharacterEventCondition, bTriggerOnIncapacitated) == 0x000049, "Member 'UTaggedCharacterEventCondition::bTriggerOnIncapacitated' has a wrong offset!");
static_assert(offsetof(UTaggedCharacterEventCondition, bTriggerOnArrested) == 0x00004A, "Member 'UTaggedCharacterEventCondition::bTriggerOnArrested' has a wrong offset!");
static_assert(offsetof(UTaggedCharacterEventCondition, bTriggerOnSurrendered) == 0x00004B, "Member 'UTaggedCharacterEventCondition::bTriggerOnSurrendered' has a wrong offset!");
static_assert(offsetof(UTaggedCharacterEventCondition, bTriggerOnOverStressed) == 0x00004C, "Member 'UTaggedCharacterEventCondition::bTriggerOnOverStressed' has a wrong offset!");
static_assert(offsetof(UTaggedCharacterEventCondition, OverStressedTriggerThreshold) == 0x000050, "Member 'UTaggedCharacterEventCondition::OverStressedTriggerThreshold' has a wrong offset!");
static_assert(offsetof(UTaggedCharacterEventCondition, TaggedCharacter) == 0x000058, "Member 'UTaggedCharacterEventCondition::TaggedCharacter' has a wrong offset!");

// Class ReadyOrNot.CharacterStatusCardWidget
// 0x0000 (0x15E0 - 0x15E0)
class UCharacterStatusCardWidget : public UCommonButtonImplementation
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterStatusCardWidget">();
	}
	static class UCharacterStatusCardWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterStatusCardWidget>();
	}
};
static_assert(alignof(UCharacterStatusCardWidget) == 0x000010, "Wrong alignment on UCharacterStatusCardWidget");
static_assert(sizeof(UCharacterStatusCardWidget) == 0x0015E0, "Wrong size on UCharacterStatusCardWidget");

// Class ReadyOrNot.CharacterProxy
// 0x0030 (0x0058 - 0x0028)
class UCharacterProxy : public UObject
{
public:
	TMulticastInlineDelegate<void()>              OnStatusUpdated;                                   // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(EPlanningLineTeam Team)> OnTeamUpdated;                            // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnLoadoutUpdated;                                  // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	class FText GetFirstName();
	float GetHealth();
	TSoftObjectPtr<class UTexture2D> GetImage();
	bool GetIsReady();
	struct FRosterLoadout GetLoadout();
	class FText GetName();
	int32 GetNumber();
	class FText GetStatus();
	ETeamType GetTeam();
	class URosterTrait* GetTrait(bool* bIsUnlocked);
	struct FBPUniqueNetId GetUniqueNetID();
	bool IsLocalPlayer();
	bool IsPlayer();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterProxy">();
	}
	static class UCharacterProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterProxy>();
	}
};
static_assert(alignof(UCharacterProxy) == 0x000008, "Wrong alignment on UCharacterProxy");
static_assert(sizeof(UCharacterProxy) == 0x000058, "Wrong size on UCharacterProxy");
static_assert(offsetof(UCharacterProxy, OnStatusUpdated) == 0x000028, "Member 'UCharacterProxy::OnStatusUpdated' has a wrong offset!");
static_assert(offsetof(UCharacterProxy, OnTeamUpdated) == 0x000038, "Member 'UCharacterProxy::OnTeamUpdated' has a wrong offset!");
static_assert(offsetof(UCharacterProxy, OnLoadoutUpdated) == 0x000048, "Member 'UCharacterProxy::OnLoadoutUpdated' has a wrong offset!");

// Class ReadyOrNot.FootstepNativeAnimNotify
// 0x0000 (0x0038 - 0x0038)
class UFootstepNativeAnimNotify final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FootstepNativeAnimNotify">();
	}
	static class UFootstepNativeAnimNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFootstepNativeAnimNotify>();
	}
};
static_assert(alignof(UFootstepNativeAnimNotify) == 0x000008, "Wrong alignment on UFootstepNativeAnimNotify");
static_assert(sizeof(UFootstepNativeAnimNotify) == 0x000038, "Wrong size on UFootstepNativeAnimNotify");

// Class ReadyOrNot.PlayerCharacterProxy
// 0x0008 (0x0060 - 0x0058)
class UPlayerCharacterProxy final : public UCharacterProxy
{
public:
	class AReadyOrNotPlayerState*                 PlayerState;                                       // 0x0058(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void HandleTeamChanged(EPlanningLineTeam Team);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerCharacterProxy">();
	}
	static class UPlayerCharacterProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerCharacterProxy>();
	}
};
static_assert(alignof(UPlayerCharacterProxy) == 0x000008, "Wrong alignment on UPlayerCharacterProxy");
static_assert(sizeof(UPlayerCharacterProxy) == 0x000060, "Wrong size on UPlayerCharacterProxy");
static_assert(offsetof(UPlayerCharacterProxy, PlayerState) == 0x000058, "Member 'UPlayerCharacterProxy::PlayerState' has a wrong offset!");

// Class ReadyOrNot.TargetingComponent
// 0x0580 (0x0620 - 0x00A0)
class UTargetingComponent final : public UActorComponent
{
public:
	struct FVector                                ThreatTrackingIgnoredDirection;                    // 0x00A0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ADoor*>                          AllowedTrackingDoors;                              // 0x00B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, UObjectWrapper, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageFocalAnim;                                  // 0x00C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MontageFocalPoint;                                 // 0x00D0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CustomFocusLocation;                               // 0x00E8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 CustomFocusActor;                                  // 0x0100(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AInterestOverrideZone*                  CurrentInterestZone;                               // 0x0108(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HeadTrackingLocation;                              // 0x0110(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Threat;                                            // 0x0128(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Tension;                                           // 0x012C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AThreatAwarenessActor*                  ThreatLookPoint;                                   // 0x0130(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_138[0x8];                                      // 0x0138(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FExposedToNoise                        LastHeardAggressiveNoise;                          // 0x0140(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	TMap<class FName, struct FExposedToNoise>     HeardNoises;                                       // 0x0180(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPublic)
	struct FExposedToNoise                        LastHeardNoiseStimulus;                            // 0x01D0(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_210[0x18];                                     // 0x0210(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class AReadyOrNotCharacter*, float>      CharactersSeen;                                    // 0x0228(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, Protected, NativeAccessSpecifierProtected)
	ETargetingCompTracking                        TrackingType;                                      // 0x0278(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_279[0x7];                                      // 0x0279(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AReadyOrNotCharacter*>           KnownFriendlies;                                   // 0x0280(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class AReadyOrNotCharacter*>           KnownNeutrals;                                     // 0x0290(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class AReadyOrNotCharacter*>           KnownEnemies;                                      // 0x02A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FVector                                LastKnownTargetPosition;                           // 0x02B0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LastKnownTargetPositionInLOS;                      // 0x02C8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LastSeenKnownTargetFrom;                           // 0x02E0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F8[0x8];                                      // 0x02F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeSinceLastSeenTarget;                           // 0x0300(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeSinceLastSeenEnemy;                            // 0x0304(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeSinceLastSeenNeutral;                          // 0x0308(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeSinceLastSeenFriendly;                         // 0x030C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PreviousTimeNotSeenTarget;                         // 0x0310(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PreviousTimeNotSeenEnemy;                          // 0x0314(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PreviousTimeNotSeenFriendly;                       // 0x0318(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PreviousTimeNotSeenNeutral;                        // 0x031C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeTrackingTarget;                                // 0x0320(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeTrackingEnemy;                                 // 0x0324(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeTrackingNeutral;                               // 0x0328(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeTrackingFriendly;                              // 0x032C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeSinceLastFriendlyDeath;                        // 0x0330(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeSinceLastFriendlyTookDamage;                   // 0x0334(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeSinceLastFriendlyStunned;                      // 0x0338(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeSinceLastEnemyDeath;                           // 0x033C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeSinceLastEnemyTookDamage;                      // 0x0340(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeSinceLastEnemyStunned;                         // 0x0344(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EngagementTimeUntilReachedLastBoneZone;            // 0x0348(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BoneRetargetingRate;                               // 0x034C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeSinceLastBoneRetarget;                         // 0x0350(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LastKnownTrackingTime;                             // 0x0354(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AReadyOrNotCharacter*>           AITrackingMe;                                      // 0x0358(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         bHasLOSToTarget : 1;                               // 0x0368(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCanSeeTarget : 1;                                 // 0x0368(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bHasLOSToLastTarget : 1;                           // 0x0368(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCanSeeLastTarget : 1;                             // 0x0368(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bHasLOSToLastKnownTargetPosition : 1;              // 0x0368(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         CurrentBoneTargetZoneIndex;                        // 0x0369(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         PreviousBoneTargetZoneIndex;                       // 0x036A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_36B[0x1];                                      // 0x036B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TargetedBone;                                      // 0x036C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_374[0x4];                                      // 0x0374(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           BonesToTarget;                                     // 0x0378(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_388[0x10];                                     // 0x0388(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ABaseGrenade*                           SmokeGrenadeBetweenTarget;                         // 0x0398(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ExposureFromEnemy;                                 // 0x03A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EnemyExposureFromUs;                               // 0x03A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RequiredTimeTrackingTarget;                        // 0x03A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeTrackingHead;                                  // 0x03AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AReadyOrNotCharacter*                   TrackedTarget;                                     // 0x03B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AReadyOrNotCharacter*                   LastTrackedTarget;                                 // 0x03B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AReadyOrNotCharacter*                   LastKnownEnemy;                                    // 0x03C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                LastMoveVectorFocalPoint;                          // 0x03C8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ADoor*                                  LastTrackedDoor;                                   // 0x03E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeSinceLastHeardNoiseStimulus;                   // 0x03E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3EC[0x4];                                      // 0x03EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LatestNoiseLocation;                               // 0x03F0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AThreatAwarenessActor*                  LastThreatAwarenessActor;                          // 0x0408(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSearchingPathAwareness;                           // 0x0410(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_411[0x3];                                      // 0x0411(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeSinceGotLastThreatAwarenessActor;              // 0x0414(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeUntilFinishedCheckingThreat;                   // 0x0418(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FIntVector                             LastLookAtPoint;                                   // 0x041C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EPathedAwareness, struct FPathAwarenessInfo> LatestPathedAwareness;                         // 0x0428(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, Protected, NativeAccessSpecifierProtected)
	TMap<EPathedAwareness, struct FVector>        LastSearchedPathedAwareness;                       // 0x0478(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, Protected, NativeAccessSpecifierProtected)
	TMap<EPathedAwareness, float>                 PathAwarenessSearchTimeout;                        // 0x04C8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, Protected, NativeAccessSpecifierProtected)
	TMap<uint32, EPathedAwareness>                PathedAwarenessQueryType;                          // 0x0518(0x0050)(Edit, DisableEditOnTemplate, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<class AReadyOrNotCharacter*>           AllKnownCharacters;                                // 0x0568(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_578[0x8];                                      // 0x0578(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AThreatAwarenessActor*                  NearestThreat;                                     // 0x0580(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AThreatAwarenessActor*                  NearestExtremeThreat;                              // 0x0588(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_590[0x90];                                     // 0x0590(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddCharacterToSeenMap(class AReadyOrNotCharacter* InCharacter);
	void AddKnownEnemy(class AReadyOrNotCharacter* Enemy, bool bForce);
	void AddKnownFriendly(class AReadyOrNotCharacter* Friendly);
	void AddKnownNeutral(class AReadyOrNotCharacter* Neutral);
	struct FExposedToNoise GetLastNoiseByTag(class FName Tag);
	TArray<class FName> GetLastNoisesTags();
	int32 GetVisibleKnownFriendlies();
	bool IsLookingAtFocalPoint(float Tolerance);
	bool IsTrackedByKnownFriendly(class AReadyOrNotCharacter* Target);
	void OnTrackedTargetExitedSurrender(class ACyberneticCharacter* Character, ESurrenderExitType ExitType);
	void OnTrackedTargetIncapacitated(class AReadyOrNotCharacter* IncapacitatedCharacter, class AReadyOrNotCharacter* InstigatorCharacter);
	void OnTrackedTargetKilled(class AReadyOrNotCharacter* Instigator, class AReadyOrNotCharacter* KilledCharacter);
	void OnTrackedTargetStartedReloading(class APlayerCharacter* Character);
	void SetLastTrackedTarget(class AReadyOrNotCharacter* Target);

	bool AnyAITrackingMe() const;
	bool CanActorBeSeen(class AActor* InActor) const;
	bool CanCharacterBeSeen(class AReadyOrNotCharacter* InCharacter) const;
	bool CanSeeLastTrackedTarget() const;
	bool CanSeeTrackedTarget() const;
	int32 GetKnownFriendlyCount() const;
	struct FVector GetLastHeardAggressiveNoiseLocation() const;
	struct FVector GetLastHeardNoiseLocation() const;
	class AReadyOrNotCharacter* GetLastKnownEnemy() const;
	struct FVector GetLastKnownEnemyPosition() const;
	float GetLastKnownTrackingTimeConfig() const;
	struct FVector GetLastSeenKnownEnemyFrom() const;
	class AReadyOrNotCharacter* GetLastTrackedTarget() const;
	class AThreatAwarenessActor* GetNearestExtremeThreat() const;
	class AThreatAwarenessActor* GetNearestThreat() const;
	float GetRequiredTrackingTime() const;
	class FName GetTargetedBone() const;
	float GetTimeSinceLastSeenEnemy() const;
	float GetTimeSinceLastSeenFriendly() const;
	float GetTimeSinceLastSeenNeutral() const;
	float GetTimeSinceLastSeenTarget() const;
	float GetTimeTrackingHead() const;
	float GetTimeTrackingTarget() const;
	class AReadyOrNotCharacter* GetTrackedTarget() const;
	ETargetingCompTracking GetTrackingType() const;
	bool HasLineOfSightToLastKnownTargetPosition() const;
	bool HasLineOfSightToLastTrackedTarget() const;
	bool HasLineOfSightToTrackedTarget() const;
	bool HasSeenCharacterFor(class AReadyOrNotCharacter* InCharacter, float Seconds) const;
	bool HasTargetOfType(const TArray<ETargetType>& TargetType, bool bAllowLastTrackedTarget) const;
	bool IsTrackedInKnownEnemies(class AReadyOrNotCharacter* PlayerCharacter) const;
	bool IsTrackedInKnownFriendlies(class AReadyOrNotCharacter* PlayerCharacter) const;
	bool IsTrackedInKnownNeutrals(class AReadyOrNotCharacter* PlayerCharacter) const;
	bool IsTrackingMontagePosition() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TargetingComponent">();
	}
	static class UTargetingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTargetingComponent>();
	}
};
static_assert(alignof(UTargetingComponent) == 0x000008, "Wrong alignment on UTargetingComponent");
static_assert(sizeof(UTargetingComponent) == 0x000620, "Wrong size on UTargetingComponent");
static_assert(offsetof(UTargetingComponent, ThreatTrackingIgnoredDirection) == 0x0000A0, "Member 'UTargetingComponent::ThreatTrackingIgnoredDirection' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, AllowedTrackingDoors) == 0x0000B8, "Member 'UTargetingComponent::AllowedTrackingDoors' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, MontageFocalAnim) == 0x0000C8, "Member 'UTargetingComponent::MontageFocalAnim' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, MontageFocalPoint) == 0x0000D0, "Member 'UTargetingComponent::MontageFocalPoint' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, CustomFocusLocation) == 0x0000E8, "Member 'UTargetingComponent::CustomFocusLocation' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, CustomFocusActor) == 0x000100, "Member 'UTargetingComponent::CustomFocusActor' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, CurrentInterestZone) == 0x000108, "Member 'UTargetingComponent::CurrentInterestZone' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, HeadTrackingLocation) == 0x000110, "Member 'UTargetingComponent::HeadTrackingLocation' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, Threat) == 0x000128, "Member 'UTargetingComponent::Threat' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, Tension) == 0x00012C, "Member 'UTargetingComponent::Tension' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, ThreatLookPoint) == 0x000130, "Member 'UTargetingComponent::ThreatLookPoint' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, LastHeardAggressiveNoise) == 0x000140, "Member 'UTargetingComponent::LastHeardAggressiveNoise' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, HeardNoises) == 0x000180, "Member 'UTargetingComponent::HeardNoises' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, LastHeardNoiseStimulus) == 0x0001D0, "Member 'UTargetingComponent::LastHeardNoiseStimulus' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, CharactersSeen) == 0x000228, "Member 'UTargetingComponent::CharactersSeen' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, TrackingType) == 0x000278, "Member 'UTargetingComponent::TrackingType' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, KnownFriendlies) == 0x000280, "Member 'UTargetingComponent::KnownFriendlies' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, KnownNeutrals) == 0x000290, "Member 'UTargetingComponent::KnownNeutrals' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, KnownEnemies) == 0x0002A0, "Member 'UTargetingComponent::KnownEnemies' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, LastKnownTargetPosition) == 0x0002B0, "Member 'UTargetingComponent::LastKnownTargetPosition' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, LastKnownTargetPositionInLOS) == 0x0002C8, "Member 'UTargetingComponent::LastKnownTargetPositionInLOS' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, LastSeenKnownTargetFrom) == 0x0002E0, "Member 'UTargetingComponent::LastSeenKnownTargetFrom' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, TimeSinceLastSeenTarget) == 0x000300, "Member 'UTargetingComponent::TimeSinceLastSeenTarget' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, TimeSinceLastSeenEnemy) == 0x000304, "Member 'UTargetingComponent::TimeSinceLastSeenEnemy' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, TimeSinceLastSeenNeutral) == 0x000308, "Member 'UTargetingComponent::TimeSinceLastSeenNeutral' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, TimeSinceLastSeenFriendly) == 0x00030C, "Member 'UTargetingComponent::TimeSinceLastSeenFriendly' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, PreviousTimeNotSeenTarget) == 0x000310, "Member 'UTargetingComponent::PreviousTimeNotSeenTarget' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, PreviousTimeNotSeenEnemy) == 0x000314, "Member 'UTargetingComponent::PreviousTimeNotSeenEnemy' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, PreviousTimeNotSeenFriendly) == 0x000318, "Member 'UTargetingComponent::PreviousTimeNotSeenFriendly' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, PreviousTimeNotSeenNeutral) == 0x00031C, "Member 'UTargetingComponent::PreviousTimeNotSeenNeutral' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, TimeTrackingTarget) == 0x000320, "Member 'UTargetingComponent::TimeTrackingTarget' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, TimeTrackingEnemy) == 0x000324, "Member 'UTargetingComponent::TimeTrackingEnemy' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, TimeTrackingNeutral) == 0x000328, "Member 'UTargetingComponent::TimeTrackingNeutral' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, TimeTrackingFriendly) == 0x00032C, "Member 'UTargetingComponent::TimeTrackingFriendly' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, TimeSinceLastFriendlyDeath) == 0x000330, "Member 'UTargetingComponent::TimeSinceLastFriendlyDeath' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, TimeSinceLastFriendlyTookDamage) == 0x000334, "Member 'UTargetingComponent::TimeSinceLastFriendlyTookDamage' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, TimeSinceLastFriendlyStunned) == 0x000338, "Member 'UTargetingComponent::TimeSinceLastFriendlyStunned' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, TimeSinceLastEnemyDeath) == 0x00033C, "Member 'UTargetingComponent::TimeSinceLastEnemyDeath' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, TimeSinceLastEnemyTookDamage) == 0x000340, "Member 'UTargetingComponent::TimeSinceLastEnemyTookDamage' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, TimeSinceLastEnemyStunned) == 0x000344, "Member 'UTargetingComponent::TimeSinceLastEnemyStunned' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, EngagementTimeUntilReachedLastBoneZone) == 0x000348, "Member 'UTargetingComponent::EngagementTimeUntilReachedLastBoneZone' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, BoneRetargetingRate) == 0x00034C, "Member 'UTargetingComponent::BoneRetargetingRate' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, TimeSinceLastBoneRetarget) == 0x000350, "Member 'UTargetingComponent::TimeSinceLastBoneRetarget' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, LastKnownTrackingTime) == 0x000354, "Member 'UTargetingComponent::LastKnownTrackingTime' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, AITrackingMe) == 0x000358, "Member 'UTargetingComponent::AITrackingMe' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, CurrentBoneTargetZoneIndex) == 0x000369, "Member 'UTargetingComponent::CurrentBoneTargetZoneIndex' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, PreviousBoneTargetZoneIndex) == 0x00036A, "Member 'UTargetingComponent::PreviousBoneTargetZoneIndex' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, TargetedBone) == 0x00036C, "Member 'UTargetingComponent::TargetedBone' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, BonesToTarget) == 0x000378, "Member 'UTargetingComponent::BonesToTarget' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, SmokeGrenadeBetweenTarget) == 0x000398, "Member 'UTargetingComponent::SmokeGrenadeBetweenTarget' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, ExposureFromEnemy) == 0x0003A0, "Member 'UTargetingComponent::ExposureFromEnemy' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, EnemyExposureFromUs) == 0x0003A4, "Member 'UTargetingComponent::EnemyExposureFromUs' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, RequiredTimeTrackingTarget) == 0x0003A8, "Member 'UTargetingComponent::RequiredTimeTrackingTarget' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, TimeTrackingHead) == 0x0003AC, "Member 'UTargetingComponent::TimeTrackingHead' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, TrackedTarget) == 0x0003B0, "Member 'UTargetingComponent::TrackedTarget' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, LastTrackedTarget) == 0x0003B8, "Member 'UTargetingComponent::LastTrackedTarget' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, LastKnownEnemy) == 0x0003C0, "Member 'UTargetingComponent::LastKnownEnemy' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, LastMoveVectorFocalPoint) == 0x0003C8, "Member 'UTargetingComponent::LastMoveVectorFocalPoint' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, LastTrackedDoor) == 0x0003E0, "Member 'UTargetingComponent::LastTrackedDoor' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, TimeSinceLastHeardNoiseStimulus) == 0x0003E8, "Member 'UTargetingComponent::TimeSinceLastHeardNoiseStimulus' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, LatestNoiseLocation) == 0x0003F0, "Member 'UTargetingComponent::LatestNoiseLocation' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, LastThreatAwarenessActor) == 0x000408, "Member 'UTargetingComponent::LastThreatAwarenessActor' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, bSearchingPathAwareness) == 0x000410, "Member 'UTargetingComponent::bSearchingPathAwareness' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, TimeSinceGotLastThreatAwarenessActor) == 0x000414, "Member 'UTargetingComponent::TimeSinceGotLastThreatAwarenessActor' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, TimeUntilFinishedCheckingThreat) == 0x000418, "Member 'UTargetingComponent::TimeUntilFinishedCheckingThreat' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, LastLookAtPoint) == 0x00041C, "Member 'UTargetingComponent::LastLookAtPoint' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, LatestPathedAwareness) == 0x000428, "Member 'UTargetingComponent::LatestPathedAwareness' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, LastSearchedPathedAwareness) == 0x000478, "Member 'UTargetingComponent::LastSearchedPathedAwareness' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, PathAwarenessSearchTimeout) == 0x0004C8, "Member 'UTargetingComponent::PathAwarenessSearchTimeout' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, PathedAwarenessQueryType) == 0x000518, "Member 'UTargetingComponent::PathedAwarenessQueryType' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, AllKnownCharacters) == 0x000568, "Member 'UTargetingComponent::AllKnownCharacters' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, NearestThreat) == 0x000580, "Member 'UTargetingComponent::NearestThreat' has a wrong offset!");
static_assert(offsetof(UTargetingComponent, NearestExtremeThreat) == 0x000588, "Member 'UTargetingComponent::NearestExtremeThreat' has a wrong offset!");

// Class ReadyOrNot.CoopCharacterProxy
// 0x0010 (0x0068 - 0x0058)
class UCoopCharacterProxy final : public UCharacterProxy
{
public:
	class ASWATCharacter*                         SWATCharacter;                                     // 0x0058(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_60[0x8];                                       // 0x0060(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoopCharacterProxy">();
	}
	static class UCoopCharacterProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoopCharacterProxy>();
	}
};
static_assert(alignof(UCoopCharacterProxy) == 0x000008, "Wrong alignment on UCoopCharacterProxy");
static_assert(sizeof(UCoopCharacterProxy) == 0x000068, "Wrong size on UCoopCharacterProxy");
static_assert(offsetof(UCoopCharacterProxy, SWATCharacter) == 0x000058, "Member 'UCoopCharacterProxy::SWATCharacter' has a wrong offset!");

// Class ReadyOrNot.ThrowItemThroughDoorActivity
// 0x0040 (0x02B8 - 0x0278)
class UThrowItemThroughDoorActivity : public UDoorBreachActivity
{
public:
	TSubclassOf<class ABaseItem>                  ThrowItemClass;                                    // 0x0278(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnThrowReady;                                      // 0x0280(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnThrowingItem;                                    // 0x0290(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A0[0x8];                                      // 0x02A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ABaseItem*                              ThrownItem;                                        // 0x02A8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B0[0x8];                                      // 0x02B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ThrowItemThroughDoorActivity">();
	}
	static class UThrowItemThroughDoorActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UThrowItemThroughDoorActivity>();
	}
};
static_assert(alignof(UThrowItemThroughDoorActivity) == 0x000008, "Wrong alignment on UThrowItemThroughDoorActivity");
static_assert(sizeof(UThrowItemThroughDoorActivity) == 0x0002B8, "Wrong size on UThrowItemThroughDoorActivity");
static_assert(offsetof(UThrowItemThroughDoorActivity, ThrowItemClass) == 0x000278, "Member 'UThrowItemThroughDoorActivity::ThrowItemClass' has a wrong offset!");
static_assert(offsetof(UThrowItemThroughDoorActivity, OnThrowReady) == 0x000280, "Member 'UThrowItemThroughDoorActivity::OnThrowReady' has a wrong offset!");
static_assert(offsetof(UThrowItemThroughDoorActivity, OnThrowingItem) == 0x000290, "Member 'UThrowItemThroughDoorActivity::OnThrowingItem' has a wrong offset!");
static_assert(offsetof(UThrowItemThroughDoorActivity, ThrownItem) == 0x0002A8, "Member 'UThrowItemThroughDoorActivity::ThrownItem' has a wrong offset!");

// Class ReadyOrNot.ChargeCombatMove
// 0x0000 (0x0230 - 0x0230)
class UChargeCombatMove final : public UBaseCombatMoveActivity
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChargeCombatMove">();
	}
	static class UChargeCombatMove* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChargeCombatMove>();
	}
};
static_assert(alignof(UChargeCombatMove) == 0x000008, "Wrong alignment on UChargeCombatMove");
static_assert(sizeof(UChargeCombatMove) == 0x000230, "Wrong size on UChargeCombatMove");

// Class ReadyOrNot.CheckpointActivityTriggerVolume
// 0x0000 (0x0350 - 0x0350)
class ACheckpointActivityTriggerVolume final : public AActivityTriggerVolume
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CheckpointActivityTriggerVolume">();
	}
	static class ACheckpointActivityTriggerVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACheckpointActivityTriggerVolume>();
	}
};
static_assert(alignof(ACheckpointActivityTriggerVolume) == 0x000008, "Wrong alignment on ACheckpointActivityTriggerVolume");
static_assert(sizeof(ACheckpointActivityTriggerVolume) == 0x000350, "Wrong size on ACheckpointActivityTriggerVolume");

// Class ReadyOrNot.DuelingCombatMove
// 0x0038 (0x0268 - 0x0230)
class UDuelingCombatMove final : public UBaseCombatMoveActivity
{
public:
	uint8                                         Pad_230[0x38];                                     // 0x0230(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DuelingCombatMove">();
	}
	static class UDuelingCombatMove* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDuelingCombatMove>();
	}
};
static_assert(alignof(UDuelingCombatMove) == 0x000008, "Wrong alignment on UDuelingCombatMove");
static_assert(sizeof(UDuelingCombatMove) == 0x000268, "Wrong size on UDuelingCombatMove");

// Class ReadyOrNot.Chemlight
// 0x0040 (0x0BF0 - 0x0BB0)
class AChemlight : public ABaseItem
{
public:
	uint8                                         Pad_BB0[0x10];                                     // 0x0BB0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UAmmoComponent*                         Ammo;                                              // 0x0BC0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SocketSpawnName;                                   // 0x0BC8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BD0[0x20];                                     // 0x0BD0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CancelThrow();
	void Multicast_SpawnThrownChemlight();
	void NormalThrow();
	void OnChemlightThrown();
	void QuickThrow();
	void Server_SpawnThrownChemlight();
	void SetFPMeshHidden(bool bFPMeshHidden);

	bool CanThrow() const;
	int32 GetRemainingAmmo() const;
	bool IsPlayingChemlightThrowAnimations() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Chemlight">();
	}
	static class AChemlight* GetDefaultObj()
	{
		return GetDefaultObjImpl<AChemlight>();
	}
};
static_assert(alignof(AChemlight) == 0x000010, "Wrong alignment on AChemlight");
static_assert(sizeof(AChemlight) == 0x000BF0, "Wrong size on AChemlight");
static_assert(offsetof(AChemlight, Ammo) == 0x000BC0, "Member 'AChemlight::Ammo' has a wrong offset!");
static_assert(offsetof(AChemlight, SocketSpawnName) == 0x000BC8, "Member 'AChemlight::SocketSpawnName' has a wrong offset!");

// Class ReadyOrNot.TeamBaseActivity
// 0x0010 (0x0200 - 0x01F0)
class UTeamBaseActivity : public UBaseActivity
{
public:
	ESquadPosition                                OverrideSquadPosition;                             // 0x01F0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESquadPosition                                PreviousSquadPosition;                             // 0x01F1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSwapping;                                       // 0x01F2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F3[0xD];                                      // 0x01F3(0x000D)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class ACyberneticCharacter* GetCharacterAtSquadPosition(ESquadPosition SquadPosition) const;
	class ACyberneticCharacter* GetCharacterClosestToCharacter(class ACyberneticCharacter* InCharacter) const;
	class ACyberneticCharacter* GetCharacterClosestToLocation(const struct FVector& TestLocation) const;
	class ACyberneticCharacter* GetCharacterWithItem(TSubclassOf<class ABaseItem> ItemClass) const;
	class AReadyOrNotCharacter* GetSquadLeader() const;
	bool HasTeamReachedPosition(float Tolerance) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeamBaseActivity">();
	}
	static class UTeamBaseActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTeamBaseActivity>();
	}
};
static_assert(alignof(UTeamBaseActivity) == 0x000008, "Wrong alignment on UTeamBaseActivity");
static_assert(sizeof(UTeamBaseActivity) == 0x000200, "Wrong size on UTeamBaseActivity");
static_assert(offsetof(UTeamBaseActivity, OverrideSquadPosition) == 0x0001F0, "Member 'UTeamBaseActivity::OverrideSquadPosition' has a wrong offset!");
static_assert(offsetof(UTeamBaseActivity, PreviousSquadPosition) == 0x0001F1, "Member 'UTeamBaseActivity::PreviousSquadPosition' has a wrong offset!");
static_assert(offsetof(UTeamBaseActivity, bIsSwapping) == 0x0001F2, "Member 'UTeamBaseActivity::bIsSwapping' has a wrong offset!");

// Class ReadyOrNot.TeamStackUpActivity
// 0x0048 (0x0248 - 0x0200)
class UTeamStackUpActivity : public UTeamBaseActivity
{
public:
	class AStackUpActor*                          OccupiedStackUpActor;                              // 0x0200(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_208[0x40];                                     // 0x0208(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnterCheckStage();
	void EnterStackedStage();
	void EnterStackupStage();
	void ExitCheckStage();
	void ExitStackupStage();
	void OnDoorChecked();
	void OnDoorOpened();
	void PerformCheckStage(float DeltaTime, float Uptime);
	void PerformStackedStage(float DeltaTime, float Uptime);
	void PerformStackUpStage(float DeltaTime, float Uptime);

	bool CanPerformCheck() const;
	class ACyberneticCharacter* GetCharacterAtHighestSquadPositionInStackUpArea(EStackupGenArea StackUpArea) const;
	class ACyberneticCharacter* GetCharacterAtSquadPositionInStackUpArea(ESquadPosition SquadPosition, EStackupGenArea StackUpArea) const;
	bool IsCheckFinished() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeamStackUpActivity">();
	}
	static class UTeamStackUpActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTeamStackUpActivity>();
	}
};
static_assert(alignof(UTeamStackUpActivity) == 0x000008, "Wrong alignment on UTeamStackUpActivity");
static_assert(sizeof(UTeamStackUpActivity) == 0x000248, "Wrong size on UTeamStackUpActivity");
static_assert(offsetof(UTeamStackUpActivity, OccupiedStackUpActor) == 0x000200, "Member 'UTeamStackUpActivity::OccupiedStackUpActor' has a wrong offset!");

// Class ReadyOrNot.DoorRam
// 0x0120 (0x0CD0 - 0x0BB0)
class ADoorRam : public ABaseDeployableGear
{
public:
	TArray<TSubclassOf<class AActor>>             AcceptableHitWhitelist;                            // 0x0BB0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         MaxHitDistance;                                    // 0x0BC0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC4[0x4];                                      // 0x0BC4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UDamageType>                RamDamageTypeDefault;                              // 0x0BC8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageType>                RamDamageTypeCrumble;                              // 0x0BD0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageType>                RamDamageTypePlayer;                               // 0x0BD8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StrikePlayerDamage;                                // 0x0BE0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BE4[0x4];                                      // 0x0BE4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             LastGoodHit;                                       // 0x0BE8(0x00E8)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void OnBatteringRamHit();
	void Server_StrikeDoor(class ADoor* TargetDoor);
	void Server_StrikeGlass(class ABreakableGlass* TargetGlass);
	void Server_StrikePlayer(class APlayerCharacter* TargetPlayer);

	bool CanHitActor(const struct FHitResult& TestHit) const;
	struct FHitResult TryGetHitPosition() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DoorRam">();
	}
	static class ADoorRam* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADoorRam>();
	}
};
static_assert(alignof(ADoorRam) == 0x000010, "Wrong alignment on ADoorRam");
static_assert(sizeof(ADoorRam) == 0x000CD0, "Wrong size on ADoorRam");
static_assert(offsetof(ADoorRam, AcceptableHitWhitelist) == 0x000BB0, "Member 'ADoorRam::AcceptableHitWhitelist' has a wrong offset!");
static_assert(offsetof(ADoorRam, MaxHitDistance) == 0x000BC0, "Member 'ADoorRam::MaxHitDistance' has a wrong offset!");
static_assert(offsetof(ADoorRam, RamDamageTypeDefault) == 0x000BC8, "Member 'ADoorRam::RamDamageTypeDefault' has a wrong offset!");
static_assert(offsetof(ADoorRam, RamDamageTypeCrumble) == 0x000BD0, "Member 'ADoorRam::RamDamageTypeCrumble' has a wrong offset!");
static_assert(offsetof(ADoorRam, RamDamageTypePlayer) == 0x000BD8, "Member 'ADoorRam::RamDamageTypePlayer' has a wrong offset!");
static_assert(offsetof(ADoorRam, StrikePlayerDamage) == 0x000BE0, "Member 'ADoorRam::StrikePlayerDamage' has a wrong offset!");
static_assert(offsetof(ADoorRam, LastGoodHit) == 0x000BE8, "Member 'ADoorRam::LastGoodHit' has a wrong offset!");

// Class ReadyOrNot.CyberneticCharacter
// 0x0BB0 (0x2550 - 0x19A0)
class ACyberneticCharacter : public AReadyOrNotCharacter
{
public:
	uint8                                         Pad_19A0[0x18];                                    // 0x19A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class APawn*                                  ClosestPawn;                                       // 0x19B8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19C0[0x38];                                    // 0x19C0(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VisibleSwatPercentage;                             // 0x19F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VisibleSwatCount;                                  // 0x19FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VisibleSquadMembersCount;                          // 0x1A00(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A04[0x4];                                     // 0x1A04(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class URoNMoveStyleComponent*                 MoveStyle;                                         // 0x1A08(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EStunType, float>                        TimeOfStunTypeEnded;                               // 0x1A10(0x0050)(NativeAccessSpecifierPublic)
	uint8                                         Pad_1A60[0x18];                                    // 0x1A60(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class AReadyOrNotCharacter*, float>      AppliedGasVisibilityPenaltyMap;                    // 0x1A78(0x0050)(NativeAccessSpecifierPublic)
	uint8                                         Pad_1AC8[0x24];                                    // 0x1AC8(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ForceComplianceStrength;                           // 0x1AEC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECoverDirection                               ActiveCoverDirection;                              // 0x1AF0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECoverAimType                                 ActiveCoverAimType;                                // 0x1AF1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECoverFireType                                ActiveCoverFireType;                               // 0x1AF2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AF3[0x5];                                     // 0x1AF3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          ActiveCoverFirePose;                               // 0x1AF8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ActiveCoverIdlePose;                               // 0x1B00(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACoverLandmark*                         CurrentCoverLandmarkInUse;                         // 0x1B08(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACoverLandmark*                         LastCoverLandmarkUsed;                             // 0x1B10(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AWallHoleTraversal*                     CurrentWallHoleTraversalInUse;                     // 0x1B18(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AWallHoleTraversal*                     LastWallHoleTraversalUsed;                         // 0x1B20(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B28[0x8];                                     // 0x1B28(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             VoiceLineEventMask;                                // 0x1B30(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B38[0x8];                                     // 0x1B38(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UStaticMeshComponent*>           SimulatingAttachedStaticMeshes;                    // 0x1B40(0x0010)(ExportObject, Net, ZeroConstructor, RepNotify, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FAttachedMeshData>              AttachedMeshData;                                  // 0x1B50(0x0010)(Net, ZeroConstructor, RepNotify, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FAttachedSkeletalMeshData>      AttachedSkeletalMeshData;                          // 0x1B60(0x0010)(Net, ZeroConstructor, RepNotify, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bIsMoving;                                         // 0x1B70(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B71[0x47];                                    // 0x1B71(0x0047)(Fixing Size After Last Property [ Dumper-7 ])
	class ABaseItem*                              LastEquippedBreachItem;                            // 0x1BB8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AReadyOrNotCharacter* Character)> OnSurrendered;             // 0x1BC0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AReadyOrNotCharacter* Character)> OnFakeSurrendered;         // 0x1BD0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ACyberneticCharacter* Spotter, class AReadyOrNotCharacter* Character)> OnSpottedEnemy; // 0x1BE0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ACyberneticCharacter* Spotter, class AReadyOrNotCharacter* Character)> OnSpottedFriendly; // 0x1BF0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ACyberneticCharacter* Spotter, class AReadyOrNotCharacter* Character)> OnSpottedNeutral; // 0x1C00(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ACyberneticCharacter* Spotter, class AReadyOrNotCharacter* Character)> OnSpottedCharacter; // 0x1C10(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AActor* Actor)> OnSensedActor;                               // 0x1C20(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AReadyOrNotCharacter* Character)> OnSensedCharacter;         // 0x1C30(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnAIFinishSpawning;                                // 0x1C40(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C50[0x10];                                    // 0x1C50(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextRenderComponent*                   NoBuenoTextRender;                                 // 0x1C60(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AbuseCount;                                        // 0x1C68(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C6C[0x4];                                     // 0x1C6C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         ReasonsToSprint;                                   // 0x1C70(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         ReasonsToStandStill;                               // 0x1C80(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         ReasonsToWalk;                                     // 0x1C90(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FCoverAnimStateMachineData             Rep_CoverAnimState;                                // 0x1CA0(0x0018)(BlueprintVisible, Net, NoDestructor, NativeAccessSpecifierPublic)
	struct FHidingAnimStateMachineData            Rep_HidingAnimState;                               // 0x1CB8(0x0010)(BlueprintVisible, Net, NoDestructor, NativeAccessSpecifierPublic)
	struct FHoleTraversalAnimStateMachineData     Rep_HoleTraversalAnimState;                        // 0x1CC8(0x0010)(BlueprintVisible, Net, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              AimOffset;                                         // 0x1CD8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1CE8[0x20];                                    // 0x1CE8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class AReadyOrNotCharacter*, int32>      MeleeCountMap;                                     // 0x1D08(0x0050)(NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UWorldBuildingActivity>> CivilianCowerActivities;                       // 0x1D58(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         CivilianCowerActivityDuration;                     // 0x1D68(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D6C[0x14];                                    // 0x1D6C(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	class AAIFactionManager*                      FactionManager;                                    // 0x1D80(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D88[0x20];                                    // 0x1D88(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class ASquadManager*                          SquadManager;                                      // 0x1DA8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DB0[0xA0];                                    // 0x1DB0(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	class AAISpawn*                               SpawnedFromSpawner;                                // 0x1E50(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECombatState                                  CombatState;                                       // 0x1E58(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E59[0x7];                                     // 0x1E59(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AReadyOrNotCharacter*                   RecentMeleeVictim;                                 // 0x1E60(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AReadyOrNotCharacter*                   PendingMeleeTarget;                                // 0x1E68(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasEverShot;                                      // 0x1E70(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E71[0x7];                                     // 0x1E71(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnWeaponForceFire_FromAnimNotify;                  // 0x1E78(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnDoorShotgunBreach_FromAnimNotify;                // 0x1E88(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnDoorKickBreach_FromAnimNotify;                   // 0x1E98(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnDoorRamBreach_FromAnimNotify;                    // 0x1EA8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ABaseItem* InThrownItem)> OnPendingItemThrown_FromAnimNotify; // 0x1EB8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class ABaseItem*                              PendingThrownItem;                                 // 0x1EC8(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ACyberneticCharacter* AICharacter, class ABaseMagazineWeapon* MagazineWeapon, const struct FVector& fireDirection)> OnAIFire; // 0x1ED0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnCollectPendingEvidenceBegin_FromAnimNotify;      // 0x1EE0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnCollectPendingEvidenceEnd_FromAnimNotify;        // 0x1EF0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F00[0x8];                                     // 0x1F00(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AReadyOrNotCharacter* Shouter, bool bLOS)> OnHeardOfficerYell; // 0x1F08(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ACyberneticCharacter* Character, ESurrenderExitType ExitType)> OnExitedSurrender; // 0x1F18(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F28[0x4];                                     // 0x1F28(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SuppressionAmount;                                 // 0x1F2C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACyberneticCharacter*                   BeingRestrainedBy;                                 // 0x1F30(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UScoringComponent*                      ScoringComponent;                                  // 0x1F38(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F40[0x8];                                     // 0x1F40(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAIArchetypeData*                       Archetype;                                         // 0x1F48(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SpawnLocation;                                     // 0x1F50(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAIArchetypeData*                       DefaultSuspectArchetype;                           // 0x1F68(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAIArchetypeData*                       DefaultCivilianArchetype;                          // 0x1F70(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FActivityRouteCollection               ActivityRouteCollection;                           // 0x1F78(0x0020)(Edit, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPublic)
	struct FVector                                Rep_AimOffsetFocalPoint;                           // 0x1F98(0x0018)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Rep_FocalPoint;                                    // 0x1FB0(0x0018)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Rep_HeadFocalPoint;                                // 0x1FC8(0x0018)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Rep_FocalActor;                                    // 0x1FE0(0x0008)(Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasLOSToFocalPoint;                               // 0x1FE8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bHeardYellFromOfficer : 1;                         // 0x1FE9(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1FEA[0x2];                                     // 0x1FEA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeSinceHeardOfficerYell;                         // 0x1FEC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeSinceLastAggressiveForce;                      // 0x1FF0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArrestedTime;                                      // 0x1FF4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFemale;                                           // 0x1FF8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChild;                                            // 0x1FF9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FFA[0x6];                                     // 0x1FFA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           LastGetUpMontage;                                  // 0x2000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bRecoveringFromRagdoll : 1;                        // 0x2008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsKnockedOut : 1;                                 // 0x2008(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsPlayingDead : 1;                                // 0x2008(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2009[0x3];                                     // 0x2009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeHiding;                                        // 0x200C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimePlayingDead;                                   // 0x2010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeSinceLastPlayDead;                             // 0x2014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeSinceAtLastCoverLandmark;                      // 0x2018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeSinceLastSeenCharacterWhilstHiding;            // 0x201C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeSinceSeenCharacterNotLookingWhilstHiding;      // 0x2020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasEverSeenCharacterWhilstHiding;                 // 0x2024(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2025[0x3];                                     // 0x2025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class AReadyOrNotCharacter*                   CharacterSeenWhilstHiding;                         // 0x2028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReadyOrNotCharacterAnimData*           Unarmed_Calm_AD;                                   // 0x2030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReadyOrNotCharacterAnimData*           Unarmed_Sr_AD;                                     // 0x2038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReadyOrNotCharacterAnimData*           Unarmed_Ar_AD;                                     // 0x2040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReadyOrNotCharacterAnimData*           Unarmed_Ar_Crouch_AD;                              // 0x2048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReadyOrNotCharacterAnimData*           Unarmed_Alert_AD;                                  // 0x2050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReadyOrNotCharacterAnimData*           Rifle_AD;                                          // 0x2058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReadyOrNotCharacterAnimData*           Pistol_AD;                                         // 0x2060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReadyOrNotCharacterAnimData*           Pistol_OneHanded_AD;                               // 0x2068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACyberneticCharacter*                   AvoidingCharacter;                                 // 0x2070(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAIMoveDataBlock                       MoveDataOverride;                                  // 0x2078(0x0098)(NativeAccessSpecifierPublic)
	struct FAIMoveDataBlock                       CurMoveDataBlock;                                  // 0x2110(0x0098)(Edit, NativeAccessSpecifierPublic)
	struct FAIMovementStyleData                   MovementStyleData;                                 // 0x21A8(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_21F0[0x4];                                     // 0x21F0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Stress;                                            // 0x21F4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartingStress;                                    // 0x21F8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeSinceLastShot;                                 // 0x21FC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeSinceArrest;                                   // 0x2200(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasPlayedSurrenderAnim;                           // 0x2204(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFakeSurrender;                                  // 0x2205(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasEverFakeSurrendered;                           // 0x2206(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFinishedEquippingLoadout;                         // 0x2207(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFinishedEquippingArmour;                          // 0x2208(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceFiringEnabled;                               // 0x2209(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_220A[0x6];                                     // 0x220A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCharacterMesh                         CharacterMeshData;                                 // 0x2210(0x0088)(Net, RepNotify, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_2298[0x8];                                     // 0x2298(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class ACyberneticCharacter* Character, class AReadyOrNotCharacter* Target)> OnAimedAt; // 0x22A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_22B0[0x8];                                     // 0x22B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bAimingAtTarget : 1;                               // 0x22B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bHasEverAimedAtTarget : 1;                         // 0x22B8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsFleeing : 1;                                    // 0x22B8(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsExitingLandmark : 1;                            // 0x22B8(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawingWeapon : 1;                                // 0x22B8(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPickingUpWeapon : 1;                              // 0x22B8(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bHasDamagedSWATTeam : 1;                           // 0x22B8(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bHitScannedFriendly : 1;                           // 0x22B8(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDiedWhilstTraversingHole : 1;                     // 0x22B9(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDiedWhilstHiding : 1;                             // 0x22B9(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsRaisingWeapon : 1;                              // 0x22B9(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsLoweringWeapon : 1;                             // 0x22B9(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_22BA[0x2];                                     // 0x22BA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DrawingWeaponTime;                                 // 0x22BC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PickingUpWeaponTime;                               // 0x22C0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RaisingWeaponTime;                                 // 0x22C4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoweringWeaponTime;                                // 0x22C8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22CC[0x4];                                     // 0x22CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             CachedHitScanResult;                               // 0x22D0(0x00E8)(BlueprintVisible, BlueprintReadOnly, Net, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FWorldBuildingAnimState                Rep_WorldBuildingAnimState;                        // 0x23B8(0x0010)(BlueprintVisible, Net, NoDestructor, NativeAccessSpecifierPublic)
	struct FTakeHostageAnimState                  Rep_TakeHostageAnimState;                          // 0x23C8(0x0018)(BlueprintVisible, Net, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_23E0[0x8];                                     // 0x23E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          HostageMasterIdleLoop;                             // 0x23E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          HostageSlaveIdleLoop;                              // 0x23F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACyberneticCharacter*                   TakenHostageBy;                                    // 0x23F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACyberneticCharacter*                   BeingDisarmedBy;                                   // 0x2400(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2408[0x2C];                                    // 0x2408(0x002C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeSurrendered;                                   // 0x2434(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIsComplying : 1;                                  // 0x2438(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsWaiting : 1;                                    // 0x2438(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_2439[0x3];                                     // 0x2439(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PepperSprayAbuseLevel;                             // 0x243C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeSinceLastTasered;                              // 0x2440(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TimesTasered;                                      // 0x2444(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                RagdollMeshLocation;                               // 0x2448(0x0018)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               RagdollMeshRotation;                               // 0x2460(0x0018)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2478[0x4];                                     // 0x2478(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HesitationTime;                                    // 0x247C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2480[0x28];                                    // 0x2480(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FocalPointInterpSpeed;                             // 0x24A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAlphaBlendOption                             FocalPointInterpCurve;                             // 0x24AC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAlphaBlendOption                             AimOffsetInterpCurve;                              // 0x24AD(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24AE[0x2];                                     // 0x24AE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FocusTurnSpeed;                                    // 0x24B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnDegreesPerSecond;                              // 0x24B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActorRotationInterpStandingSpeed;                  // 0x24B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActorRotationInterpMovingSpeed;                    // 0x24BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimOffsetInterpSpeed;                              // 0x24C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24C4[0x4];                                     // 0x24C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UEnvQuery*                              EscapeGasQuery;                                    // 0x24C8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACombatMoveZone*                        LastUsedCombatMoveZone;                            // 0x24D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSet<class ACombatMoveZone*>                  VisitedCombatMoveZones;                            // 0x24D8(0x0050)(Edit, BlueprintVisible, UObjectWrapper, NativeAccessSpecifierPublic)
	ECurrentZoneTransitionState                   ZoneTransitionState;                               // 0x2528(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2529[0x7];                                     // 0x2529(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetComponent*                       DebugAISelectionWidget;                            // 0x2530(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2538[0x4];                                     // 0x2538(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsBlockingRaiseLowerWpAnimsActive;                // 0x253C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPlayingSurrenderAnim;                           // 0x253D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_253E[0x2];                                     // 0x253E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           CurrentSurrenderAnim;                              // 0x2540(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2548[0x8];                                     // 0x2548(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DecreaseStress(float Amount);
	void DrawWeapon();
	void FakeSurrender(bool bIsMelee);
	void ForceFireGun(float Chance);
	float GetCurrentSurrenderAnimPosition();
	bool GetIsSurrenderAnimPlaying();
	float GetStressUntilWeaponRaise();
	void IncreaseStress(float Amount);
	void Knockout(float Duration, bool bPlayVO);
	void Multicast_PlayArmourHitEffects(class ABaseArmour* Armour, const struct FHitResult& Hit, class AController* HitInstigator);
	void Multicast_SendCharacterMeshData(const struct FCharacterMesh& RPC_CharacterMeshData);
	void OnGetupAfterRagdollComplete();
	void OnOfficerShouted(class AReadyOrNotCharacter* Shouter, bool bLOS);
	void OnRep_AttachedMeshData();
	void OnRep_AttachedSkeletalMeshData();
	void OnRep_CharacterMeshData();
	void OnRep_SimulatingAttachedStaticMeshes();
	void OnSquadRoleAssigned(const struct FGameplayTag& RoleTag);
	void OnSurrenderMontageBlendedOut(class UAnimMontage* Montage, bool bInterrupted);
	void OnSurrenderMontageEnded(class UAnimMontage* Montage, bool bInterrupted);
	void PlayActionVoiceline(struct FAIActionData* ActionData, bool bVoicelineCooldown);
	void PlayBarkOrStartConversation(const class FString& SpeechRow, bool bHasSharedCooldown, float Cooldown);
	void PlayDead(float Duration, const bool bPlayVO);
	class UAnimMontage* PlayMontageFromTableWithFocalPoint(const class FString& Animation, const struct FVector& FocalPoint);
	class UAnimMontage* PlayMontageFromTableWithIndexWithFocalPoint(const class FString& Animation, int32 Index_0, const struct FVector& FocalPoint);
	bool PlayMontageWithFocalPoint(class UAnimMontage* Montage, const struct FVector& FocalPoint);
	void PlayShootingWeaponConversation();
	void StartBlockingRaiseLowerWpAnims(float TimeBlockingSwitch);
	void StopBlockingRaiseLowerWpAnims();
	void StopPlayingDead();
	void Surrender();
	bool SurrenderExit(ESurrenderExitType ExitType, const struct FVector& FocalPoint);

	bool CanEverSuicide() const;
	bool CanExitSurrender() const;
	ESurrenderExitType DetermineSurrenderExitType() const;
	class UAIArchetypeData* GetAIArchetype() const;
	class ABaseArmour* GetArmour() const;
	class ACyberneticController* GetCyberneticsController() const;
	TArray<struct FDebugData> GetDebugInfoOnROE() const;
	struct FVector GetFocalPoint() const;
	float GetHesitationTime() const;
	struct FRotator GetLookAtRotation(float YawLimit, float PitchLimit) const;
	float GetVisibleSWATPercentage() const;
	bool HasDamagedSWAT() const;
	bool HasLineOfSightToCharacter(class AReadyOrNotCharacter* InCharacter) const;
	bool IsActiveForCombat() const;
	bool IsArrestCapable(class APlayerCharacter* PlayerCharacter) const;
	bool IsBeginningHostageTake() const;
	bool IsBeingTakenHostage() const;
	bool IsComplying() const;
	bool IsDamagedByLessLethal() const;
	bool IsDamagedByLethal() const;
	bool IsEndingHostageTake() const;
	bool IsExitingSurrender() const;
	bool IsFiringFromCover() const;
	bool IsHesitating() const;
	bool IsHesitatingFor(const float Seconds) const;
	bool IsHiding() const;
	bool IsLoweringWeapon() const;
	bool IsMovingToCover() const;
	bool IsMovingToLandmarkCover() const;
	bool IsPlayingDead() const;
	bool IsPlayingStunAnimation() const;
	bool IsRaisingWeapon() const;
	bool IsSameFaction(class ACyberneticCharacter* OtherAI) const;
	bool IsSameSquad(class ACyberneticCharacter* OtherAI) const;
	bool IsTakingCover() const;
	bool IsTakingCoverAtLandmark() const;
	bool IsTakingHostage() const;
	bool IsUnjustifiedUseOfForce(class AReadyOrNotCharacter* Aggressor, class ABaseItem* ForceWeapon, const class UDamageType* ForceUsed) const;
	bool IsWearingExplosiveVest() const;
	bool IsWearingHeadArmor() const;
	bool WasRecentlyYelledAt(const float Seconds) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CyberneticCharacter">();
	}
	static class ACyberneticCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACyberneticCharacter>();
	}
};
static_assert(alignof(ACyberneticCharacter) == 0x000010, "Wrong alignment on ACyberneticCharacter");
static_assert(sizeof(ACyberneticCharacter) == 0x002550, "Wrong size on ACyberneticCharacter");
static_assert(offsetof(ACyberneticCharacter, ClosestPawn) == 0x0019B8, "Member 'ACyberneticCharacter::ClosestPawn' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, VisibleSwatPercentage) == 0x0019F8, "Member 'ACyberneticCharacter::VisibleSwatPercentage' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, VisibleSwatCount) == 0x0019FC, "Member 'ACyberneticCharacter::VisibleSwatCount' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, VisibleSquadMembersCount) == 0x001A00, "Member 'ACyberneticCharacter::VisibleSquadMembersCount' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, MoveStyle) == 0x001A08, "Member 'ACyberneticCharacter::MoveStyle' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, TimeOfStunTypeEnded) == 0x001A10, "Member 'ACyberneticCharacter::TimeOfStunTypeEnded' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, AppliedGasVisibilityPenaltyMap) == 0x001A78, "Member 'ACyberneticCharacter::AppliedGasVisibilityPenaltyMap' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, ForceComplianceStrength) == 0x001AEC, "Member 'ACyberneticCharacter::ForceComplianceStrength' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, ActiveCoverDirection) == 0x001AF0, "Member 'ACyberneticCharacter::ActiveCoverDirection' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, ActiveCoverAimType) == 0x001AF1, "Member 'ACyberneticCharacter::ActiveCoverAimType' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, ActiveCoverFireType) == 0x001AF2, "Member 'ACyberneticCharacter::ActiveCoverFireType' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, ActiveCoverFirePose) == 0x001AF8, "Member 'ACyberneticCharacter::ActiveCoverFirePose' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, ActiveCoverIdlePose) == 0x001B00, "Member 'ACyberneticCharacter::ActiveCoverIdlePose' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, CurrentCoverLandmarkInUse) == 0x001B08, "Member 'ACyberneticCharacter::CurrentCoverLandmarkInUse' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, LastCoverLandmarkUsed) == 0x001B10, "Member 'ACyberneticCharacter::LastCoverLandmarkUsed' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, CurrentWallHoleTraversalInUse) == 0x001B18, "Member 'ACyberneticCharacter::CurrentWallHoleTraversalInUse' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, LastWallHoleTraversalUsed) == 0x001B20, "Member 'ACyberneticCharacter::LastWallHoleTraversalUsed' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, VoiceLineEventMask) == 0x001B30, "Member 'ACyberneticCharacter::VoiceLineEventMask' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, SimulatingAttachedStaticMeshes) == 0x001B40, "Member 'ACyberneticCharacter::SimulatingAttachedStaticMeshes' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, AttachedMeshData) == 0x001B50, "Member 'ACyberneticCharacter::AttachedMeshData' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, AttachedSkeletalMeshData) == 0x001B60, "Member 'ACyberneticCharacter::AttachedSkeletalMeshData' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, bIsMoving) == 0x001B70, "Member 'ACyberneticCharacter::bIsMoving' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, LastEquippedBreachItem) == 0x001BB8, "Member 'ACyberneticCharacter::LastEquippedBreachItem' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, OnSurrendered) == 0x001BC0, "Member 'ACyberneticCharacter::OnSurrendered' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, OnFakeSurrendered) == 0x001BD0, "Member 'ACyberneticCharacter::OnFakeSurrendered' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, OnSpottedEnemy) == 0x001BE0, "Member 'ACyberneticCharacter::OnSpottedEnemy' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, OnSpottedFriendly) == 0x001BF0, "Member 'ACyberneticCharacter::OnSpottedFriendly' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, OnSpottedNeutral) == 0x001C00, "Member 'ACyberneticCharacter::OnSpottedNeutral' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, OnSpottedCharacter) == 0x001C10, "Member 'ACyberneticCharacter::OnSpottedCharacter' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, OnSensedActor) == 0x001C20, "Member 'ACyberneticCharacter::OnSensedActor' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, OnSensedCharacter) == 0x001C30, "Member 'ACyberneticCharacter::OnSensedCharacter' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, OnAIFinishSpawning) == 0x001C40, "Member 'ACyberneticCharacter::OnAIFinishSpawning' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, NoBuenoTextRender) == 0x001C60, "Member 'ACyberneticCharacter::NoBuenoTextRender' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, AbuseCount) == 0x001C68, "Member 'ACyberneticCharacter::AbuseCount' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, ReasonsToSprint) == 0x001C70, "Member 'ACyberneticCharacter::ReasonsToSprint' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, ReasonsToStandStill) == 0x001C80, "Member 'ACyberneticCharacter::ReasonsToStandStill' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, ReasonsToWalk) == 0x001C90, "Member 'ACyberneticCharacter::ReasonsToWalk' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, Rep_CoverAnimState) == 0x001CA0, "Member 'ACyberneticCharacter::Rep_CoverAnimState' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, Rep_HidingAnimState) == 0x001CB8, "Member 'ACyberneticCharacter::Rep_HidingAnimState' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, Rep_HoleTraversalAnimState) == 0x001CC8, "Member 'ACyberneticCharacter::Rep_HoleTraversalAnimState' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, AimOffset) == 0x001CD8, "Member 'ACyberneticCharacter::AimOffset' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, MeleeCountMap) == 0x001D08, "Member 'ACyberneticCharacter::MeleeCountMap' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, CivilianCowerActivities) == 0x001D58, "Member 'ACyberneticCharacter::CivilianCowerActivities' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, CivilianCowerActivityDuration) == 0x001D68, "Member 'ACyberneticCharacter::CivilianCowerActivityDuration' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, FactionManager) == 0x001D80, "Member 'ACyberneticCharacter::FactionManager' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, SquadManager) == 0x001DA8, "Member 'ACyberneticCharacter::SquadManager' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, SpawnedFromSpawner) == 0x001E50, "Member 'ACyberneticCharacter::SpawnedFromSpawner' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, CombatState) == 0x001E58, "Member 'ACyberneticCharacter::CombatState' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, RecentMeleeVictim) == 0x001E60, "Member 'ACyberneticCharacter::RecentMeleeVictim' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, PendingMeleeTarget) == 0x001E68, "Member 'ACyberneticCharacter::PendingMeleeTarget' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, bHasEverShot) == 0x001E70, "Member 'ACyberneticCharacter::bHasEverShot' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, OnWeaponForceFire_FromAnimNotify) == 0x001E78, "Member 'ACyberneticCharacter::OnWeaponForceFire_FromAnimNotify' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, OnDoorShotgunBreach_FromAnimNotify) == 0x001E88, "Member 'ACyberneticCharacter::OnDoorShotgunBreach_FromAnimNotify' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, OnDoorKickBreach_FromAnimNotify) == 0x001E98, "Member 'ACyberneticCharacter::OnDoorKickBreach_FromAnimNotify' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, OnDoorRamBreach_FromAnimNotify) == 0x001EA8, "Member 'ACyberneticCharacter::OnDoorRamBreach_FromAnimNotify' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, OnPendingItemThrown_FromAnimNotify) == 0x001EB8, "Member 'ACyberneticCharacter::OnPendingItemThrown_FromAnimNotify' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, PendingThrownItem) == 0x001EC8, "Member 'ACyberneticCharacter::PendingThrownItem' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, OnAIFire) == 0x001ED0, "Member 'ACyberneticCharacter::OnAIFire' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, OnCollectPendingEvidenceBegin_FromAnimNotify) == 0x001EE0, "Member 'ACyberneticCharacter::OnCollectPendingEvidenceBegin_FromAnimNotify' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, OnCollectPendingEvidenceEnd_FromAnimNotify) == 0x001EF0, "Member 'ACyberneticCharacter::OnCollectPendingEvidenceEnd_FromAnimNotify' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, OnHeardOfficerYell) == 0x001F08, "Member 'ACyberneticCharacter::OnHeardOfficerYell' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, OnExitedSurrender) == 0x001F18, "Member 'ACyberneticCharacter::OnExitedSurrender' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, SuppressionAmount) == 0x001F2C, "Member 'ACyberneticCharacter::SuppressionAmount' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, BeingRestrainedBy) == 0x001F30, "Member 'ACyberneticCharacter::BeingRestrainedBy' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, ScoringComponent) == 0x001F38, "Member 'ACyberneticCharacter::ScoringComponent' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, Archetype) == 0x001F48, "Member 'ACyberneticCharacter::Archetype' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, SpawnLocation) == 0x001F50, "Member 'ACyberneticCharacter::SpawnLocation' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, DefaultSuspectArchetype) == 0x001F68, "Member 'ACyberneticCharacter::DefaultSuspectArchetype' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, DefaultCivilianArchetype) == 0x001F70, "Member 'ACyberneticCharacter::DefaultCivilianArchetype' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, ActivityRouteCollection) == 0x001F78, "Member 'ACyberneticCharacter::ActivityRouteCollection' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, Rep_AimOffsetFocalPoint) == 0x001F98, "Member 'ACyberneticCharacter::Rep_AimOffsetFocalPoint' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, Rep_FocalPoint) == 0x001FB0, "Member 'ACyberneticCharacter::Rep_FocalPoint' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, Rep_HeadFocalPoint) == 0x001FC8, "Member 'ACyberneticCharacter::Rep_HeadFocalPoint' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, Rep_FocalActor) == 0x001FE0, "Member 'ACyberneticCharacter::Rep_FocalActor' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, bHasLOSToFocalPoint) == 0x001FE8, "Member 'ACyberneticCharacter::bHasLOSToFocalPoint' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, TimeSinceHeardOfficerYell) == 0x001FEC, "Member 'ACyberneticCharacter::TimeSinceHeardOfficerYell' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, TimeSinceLastAggressiveForce) == 0x001FF0, "Member 'ACyberneticCharacter::TimeSinceLastAggressiveForce' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, ArrestedTime) == 0x001FF4, "Member 'ACyberneticCharacter::ArrestedTime' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, bFemale) == 0x001FF8, "Member 'ACyberneticCharacter::bFemale' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, bChild) == 0x001FF9, "Member 'ACyberneticCharacter::bChild' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, LastGetUpMontage) == 0x002000, "Member 'ACyberneticCharacter::LastGetUpMontage' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, TimeHiding) == 0x00200C, "Member 'ACyberneticCharacter::TimeHiding' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, TimePlayingDead) == 0x002010, "Member 'ACyberneticCharacter::TimePlayingDead' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, TimeSinceLastPlayDead) == 0x002014, "Member 'ACyberneticCharacter::TimeSinceLastPlayDead' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, TimeSinceAtLastCoverLandmark) == 0x002018, "Member 'ACyberneticCharacter::TimeSinceAtLastCoverLandmark' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, TimeSinceLastSeenCharacterWhilstHiding) == 0x00201C, "Member 'ACyberneticCharacter::TimeSinceLastSeenCharacterWhilstHiding' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, TimeSinceSeenCharacterNotLookingWhilstHiding) == 0x002020, "Member 'ACyberneticCharacter::TimeSinceSeenCharacterNotLookingWhilstHiding' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, bHasEverSeenCharacterWhilstHiding) == 0x002024, "Member 'ACyberneticCharacter::bHasEverSeenCharacterWhilstHiding' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, CharacterSeenWhilstHiding) == 0x002028, "Member 'ACyberneticCharacter::CharacterSeenWhilstHiding' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, Unarmed_Calm_AD) == 0x002030, "Member 'ACyberneticCharacter::Unarmed_Calm_AD' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, Unarmed_Sr_AD) == 0x002038, "Member 'ACyberneticCharacter::Unarmed_Sr_AD' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, Unarmed_Ar_AD) == 0x002040, "Member 'ACyberneticCharacter::Unarmed_Ar_AD' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, Unarmed_Ar_Crouch_AD) == 0x002048, "Member 'ACyberneticCharacter::Unarmed_Ar_Crouch_AD' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, Unarmed_Alert_AD) == 0x002050, "Member 'ACyberneticCharacter::Unarmed_Alert_AD' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, Rifle_AD) == 0x002058, "Member 'ACyberneticCharacter::Rifle_AD' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, Pistol_AD) == 0x002060, "Member 'ACyberneticCharacter::Pistol_AD' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, Pistol_OneHanded_AD) == 0x002068, "Member 'ACyberneticCharacter::Pistol_OneHanded_AD' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, AvoidingCharacter) == 0x002070, "Member 'ACyberneticCharacter::AvoidingCharacter' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, MoveDataOverride) == 0x002078, "Member 'ACyberneticCharacter::MoveDataOverride' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, CurMoveDataBlock) == 0x002110, "Member 'ACyberneticCharacter::CurMoveDataBlock' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, MovementStyleData) == 0x0021A8, "Member 'ACyberneticCharacter::MovementStyleData' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, Stress) == 0x0021F4, "Member 'ACyberneticCharacter::Stress' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, StartingStress) == 0x0021F8, "Member 'ACyberneticCharacter::StartingStress' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, TimeSinceLastShot) == 0x0021FC, "Member 'ACyberneticCharacter::TimeSinceLastShot' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, TimeSinceArrest) == 0x002200, "Member 'ACyberneticCharacter::TimeSinceArrest' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, bHasPlayedSurrenderAnim) == 0x002204, "Member 'ACyberneticCharacter::bHasPlayedSurrenderAnim' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, bIsFakeSurrender) == 0x002205, "Member 'ACyberneticCharacter::bIsFakeSurrender' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, bHasEverFakeSurrendered) == 0x002206, "Member 'ACyberneticCharacter::bHasEverFakeSurrendered' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, bFinishedEquippingLoadout) == 0x002207, "Member 'ACyberneticCharacter::bFinishedEquippingLoadout' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, bFinishedEquippingArmour) == 0x002208, "Member 'ACyberneticCharacter::bFinishedEquippingArmour' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, bForceFiringEnabled) == 0x002209, "Member 'ACyberneticCharacter::bForceFiringEnabled' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, CharacterMeshData) == 0x002210, "Member 'ACyberneticCharacter::CharacterMeshData' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, OnAimedAt) == 0x0022A0, "Member 'ACyberneticCharacter::OnAimedAt' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, DrawingWeaponTime) == 0x0022BC, "Member 'ACyberneticCharacter::DrawingWeaponTime' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, PickingUpWeaponTime) == 0x0022C0, "Member 'ACyberneticCharacter::PickingUpWeaponTime' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, RaisingWeaponTime) == 0x0022C4, "Member 'ACyberneticCharacter::RaisingWeaponTime' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, LoweringWeaponTime) == 0x0022C8, "Member 'ACyberneticCharacter::LoweringWeaponTime' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, CachedHitScanResult) == 0x0022D0, "Member 'ACyberneticCharacter::CachedHitScanResult' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, Rep_WorldBuildingAnimState) == 0x0023B8, "Member 'ACyberneticCharacter::Rep_WorldBuildingAnimState' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, Rep_TakeHostageAnimState) == 0x0023C8, "Member 'ACyberneticCharacter::Rep_TakeHostageAnimState' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, HostageMasterIdleLoop) == 0x0023E8, "Member 'ACyberneticCharacter::HostageMasterIdleLoop' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, HostageSlaveIdleLoop) == 0x0023F0, "Member 'ACyberneticCharacter::HostageSlaveIdleLoop' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, TakenHostageBy) == 0x0023F8, "Member 'ACyberneticCharacter::TakenHostageBy' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, BeingDisarmedBy) == 0x002400, "Member 'ACyberneticCharacter::BeingDisarmedBy' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, TimeSurrendered) == 0x002434, "Member 'ACyberneticCharacter::TimeSurrendered' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, PepperSprayAbuseLevel) == 0x00243C, "Member 'ACyberneticCharacter::PepperSprayAbuseLevel' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, TimeSinceLastTasered) == 0x002440, "Member 'ACyberneticCharacter::TimeSinceLastTasered' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, TimesTasered) == 0x002444, "Member 'ACyberneticCharacter::TimesTasered' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, RagdollMeshLocation) == 0x002448, "Member 'ACyberneticCharacter::RagdollMeshLocation' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, RagdollMeshRotation) == 0x002460, "Member 'ACyberneticCharacter::RagdollMeshRotation' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, HesitationTime) == 0x00247C, "Member 'ACyberneticCharacter::HesitationTime' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, FocalPointInterpSpeed) == 0x0024A8, "Member 'ACyberneticCharacter::FocalPointInterpSpeed' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, FocalPointInterpCurve) == 0x0024AC, "Member 'ACyberneticCharacter::FocalPointInterpCurve' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, AimOffsetInterpCurve) == 0x0024AD, "Member 'ACyberneticCharacter::AimOffsetInterpCurve' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, FocusTurnSpeed) == 0x0024B0, "Member 'ACyberneticCharacter::FocusTurnSpeed' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, TurnDegreesPerSecond) == 0x0024B4, "Member 'ACyberneticCharacter::TurnDegreesPerSecond' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, ActorRotationInterpStandingSpeed) == 0x0024B8, "Member 'ACyberneticCharacter::ActorRotationInterpStandingSpeed' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, ActorRotationInterpMovingSpeed) == 0x0024BC, "Member 'ACyberneticCharacter::ActorRotationInterpMovingSpeed' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, AimOffsetInterpSpeed) == 0x0024C0, "Member 'ACyberneticCharacter::AimOffsetInterpSpeed' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, EscapeGasQuery) == 0x0024C8, "Member 'ACyberneticCharacter::EscapeGasQuery' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, LastUsedCombatMoveZone) == 0x0024D0, "Member 'ACyberneticCharacter::LastUsedCombatMoveZone' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, VisitedCombatMoveZones) == 0x0024D8, "Member 'ACyberneticCharacter::VisitedCombatMoveZones' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, ZoneTransitionState) == 0x002528, "Member 'ACyberneticCharacter::ZoneTransitionState' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, DebugAISelectionWidget) == 0x002530, "Member 'ACyberneticCharacter::DebugAISelectionWidget' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, bIsBlockingRaiseLowerWpAnimsActive) == 0x00253C, "Member 'ACyberneticCharacter::bIsBlockingRaiseLowerWpAnimsActive' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, bIsPlayingSurrenderAnim) == 0x00253D, "Member 'ACyberneticCharacter::bIsPlayingSurrenderAnim' has a wrong offset!");
static_assert(offsetof(ACyberneticCharacter, CurrentSurrenderAnim) == 0x002540, "Member 'ACyberneticCharacter::CurrentSurrenderAnim' has a wrong offset!");

// Class ReadyOrNot.CivilianCharacter
// 0x0000 (0x2550 - 0x2550)
class ACivilianCharacter : public ACyberneticCharacter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CivilianCharacter">();
	}
	static class ACivilianCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACivilianCharacter>();
	}
};
static_assert(alignof(ACivilianCharacter) == 0x000010, "Wrong alignment on ACivilianCharacter");
static_assert(sizeof(ACivilianCharacter) == 0x002550, "Wrong size on ACivilianCharacter");

// Class ReadyOrNot.RamDoorActivity
// 0x0008 (0x0280 - 0x0278)
class URamDoorActivity final : public UDoorBreachActivity
{
public:
	uint8                                         Pad_278[0x8];                                      // 0x0278(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDoorRammed();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RamDoorActivity">();
	}
	static class URamDoorActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<URamDoorActivity>();
	}
};
static_assert(alignof(URamDoorActivity) == 0x000008, "Wrong alignment on URamDoorActivity");
static_assert(sizeof(URamDoorActivity) == 0x000280, "Wrong size on URamDoorActivity");

// Class ReadyOrNot.CivilianCombatActivity
// 0x0008 (0x04B8 - 0x04B0)
class UCivilianCombatActivity final : public UBaseCombatActivity
{
public:
	class UCivilianFleeCombatMove*                CivilianFleeCombatMove;                            // 0x04B0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CivilianCombatActivity">();
	}
	static class UCivilianCombatActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCivilianCombatActivity>();
	}
};
static_assert(alignof(UCivilianCombatActivity) == 0x000008, "Wrong alignment on UCivilianCombatActivity");
static_assert(sizeof(UCivilianCombatActivity) == 0x0004B8, "Wrong size on UCivilianCombatActivity");
static_assert(offsetof(UCivilianCombatActivity, CivilianFleeCombatMove) == 0x0004B0, "Member 'UCivilianCombatActivity::CivilianFleeCombatMove' has a wrong offset!");

// Class ReadyOrNot.ZoneManager
// 0x0060 (0x02F8 - 0x0298)
class AZoneManager final : public AInfo
{
public:
	TArray<class ACombatMoveZone*>                AllZones;                                          // 0x0298(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A8[0x50];                                     // 0x02A8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class ACombatMoveZone* FindNextZone(class ACyberneticCharacter* Character);
	bool HasValidZone(class ACyberneticCharacter* Character, ECurrentZoneTransitionState ZoneDirection);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ZoneManager">();
	}
	static class AZoneManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AZoneManager>();
	}
};
static_assert(alignof(AZoneManager) == 0x000008, "Wrong alignment on AZoneManager");
static_assert(sizeof(AZoneManager) == 0x0002F8, "Wrong size on AZoneManager");
static_assert(offsetof(AZoneManager, AllZones) == 0x000298, "Member 'AZoneManager::AllZones' has a wrong offset!");

// Class ReadyOrNot.CyberneticController
// 0x0688 (0x0A48 - 0x03C0)
class ACyberneticController : public AAIController
{
public:
	uint8                                         Pad_3C0[0x20];                                     // 0x03C0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAIAction*>                      CustomActions;                                     // 0x03E0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class UAIPerceptionComponent*                 AIPerceptionComponent;                             // 0x03F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UReadyOrNotAISenseConfig_Sight*         SightConfig;                                       // 0x03F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAISenseConfig_Touch*                   TouchConfig;                                       // 0x0400(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAISenseConfig_Damage*                  DamageConfig;                                      // 0x0408(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAISenseConfig_Hearing*                 HearingConfig;                                     // 0x0410(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMoraleComponent*                       MoraleComponent;                                   // 0x0418(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTargetingComponent*                    TargetingComponent;                                // 0x0420(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class AActor*, float>                    LastHeardActorTime;                                // 0x0428(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class APlayerCharacter*                       SensingCharacter;                                  // 0x0478(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 LastSensedActor;                                   // 0x0480(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AReadyOrNotCharacter*                   HeardActorInstigator;                              // 0x0488(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AReadyOrNotCharacter*                   LastSensedCharacter;                               // 0x0490(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LastSensedLocation;                                // 0x0498(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bCanOpenDoorThroughNavLink : 1;                    // 0x04B0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_4B1[0x3];                                      // 0x04B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeSinceLastMove;                                 // 0x04B4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeUntilRecentlySeenCharactersClear;              // 0x04B8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4BC[0x4];                                      // 0x04BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AReadyOrNotCharacter*>           RecentlySeenSwat;                                  // 0x04C0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class AReadyOrNotCharacter*>           RecentlySeenSuspects;                              // 0x04D0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class AReadyOrNotCharacter*>           RecentlySeenCivilians;                             // 0x04E0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 PathId, ERonNavigationQueryResult Result)> OnAsyncPathFound; // 0x04F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_500[0x60];                                     // 0x0500(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LastAcceptanceRadius;                              // 0x0560(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_564[0x4];                                      // 0x0564(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class AReadyOrNotCharacter*, float>      DamagedBy;                                         // 0x0568(0x0050)(NativeAccessSpecifierPublic)
	TMap<class AReadyOrNotCharacter*, struct FVector> DamagedByLocation;                             // 0x05B8(0x0050)(NativeAccessSpecifierPublic)
	uint8                                         Pad_608[0x8];                                      // 0x0608(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UInvestigateStimulusActivity*           InvestigateStimulusActivity;                       // 0x0610(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_618[0x2];                                      // 0x0618(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	EAIAwarenessState                             PreviousAwarenessState;                            // 0x061A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAIAwarenessState                             AwarenessState;                                    // 0x061B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_61C[0x4];                                      // 0x061C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class ACyberneticController* Controller, EAIAwarenessState Previous, EAIAwarenessState Current)> OnAwarenessStateChangedDelegate; // 0x0620(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_630[0x60];                                     // 0x0630(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIStimulus                            LatestStimulus;                                    // 0x0690(0x0058)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FAIStimulus                            LatestSightStimulus;                               // 0x06E8(0x0058)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FAIStimulus                            LatestHearingStimulus;                             // 0x0740(0x0058)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FAIStimulus                            LatestDamageStimulus;                              // 0x0798(0x0058)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_7F0[0x10];                                     // 0x07F0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         TrackedDistractions;                               // 0x0800(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_810[0x28];                                     // 0x0810(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AAIController* Controller, int32 RequestID)> OnMoveComplete; // 0x0838(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FActorSense>                    ActorSightSenseMap;                                // 0x0848(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FActorSense>                    ActorSoundSenseMap;                                // 0x0858(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FActorSense>                    ActorDamageSenseMap;                               // 0x0868(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bStopDecisionMaking : 1;                           // 0x0878(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_879[0x7];                                      // 0x0879(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBaseActivity*                          CurrentActivity;                                   // 0x0880(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UBaseActivity*>                  ActivityQueue;                                     // 0x0888(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_898[0x10];                                     // 0x0898(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CallForHelpCoolDownDuration;                       // 0x08A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxHearingForHelpDistance;                         // 0x08AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FlashLightSeenCoolDownDuration;                    // 0x08B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bDisableSensePerception : 1;                       // 0x08B4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, DisableEditOnTemplate, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_8B5[0x3];                                      // 0x08B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FExposedToNoise>     ExposedToStimulusTags;                             // 0x08B8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_908[0x58];                                     // 0x0908(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeSinceLastExposedToAggressiveStimulus;          // 0x0960(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeSinceLastExposedToAnyStimulus;                 // 0x0964(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeSinceLastExposedToSightStimulus;               // 0x0968(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeSinceLastExposedToSoundStimulus;               // 0x096C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bEverHeardAggressiveStimulus : 1;                  // 0x0970(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_971[0x3];                                      // 0x0971(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UnalertTime;                                       // 0x0974(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AlertTime;                                         // 0x0978(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SuspiciousTime;                                    // 0x097C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasEverHeardSwat;                                 // 0x0980(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_981[0x17];                                     // 0x0981(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	class UBaseCombatActivity*                    CombatActivity;                                    // 0x0998(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9A0[0x60];                                     // 0x09A0(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	class UMoveToActivity*                        MoveToActivity;                                    // 0x0A00(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMoveActivity*                          TeamMoveActivity;                                  // 0x0A08(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMoveToActivity*                        PushMoveToActivity;                                // 0x0A10(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMoveToActivity*                        AvoidanceMoveToActivity;                           // 0x0A18(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMoveToExitActivity*                    MoveToExitActivity;                                // 0x0A20(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTargetNextCivilianActivity*            TargetNextCivilianActivity;                        // 0x0A28(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDisarmBombActivity*                    DisarmBombActivity;                                // 0x0A30(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADoor*                                  LastHeardDoorKick;                                 // 0x0A38(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A40[0x8];                                      // 0x0A40(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AbortCover();
	void AbortCoverLandmark();
	void AbortMove(bool bKeepVelocity);
	bool AddActivity(class UBaseActivity* Activity, bool bOverrideCurrentActivity);
	void AddExposedToStimulusTag(const class FName& Tag, const struct FVector& StimulusLocation, bool bFriendly, class AReadyOrNotCharacter* StimulusInstigator, float ExpiryTime);
	void FinishActivity(class UBaseActivity* Activity, bool bSuccess, bool bForce);
	class FString GetActivityQueueAsString();
	class AReadyOrNotCharacter* GetTrackedTarget();
	bool HasActivityType(TSubclassOf<class UBaseActivity> ActivityType);
	void OnAIFinishSpawning();
	void OnDoorExploded(class ADoor* Door, class AReadyOrNotCharacter* InstigatorCharacter);
	void OnKilledOrIncapacitated(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter);
	void OnKnownEnemyIncapacitated(class AReadyOrNotCharacter* IncapacitatedCharacter, class AReadyOrNotCharacter* InstigatorCharacter);
	void OnKnownEnemyIncapacitated_Blueprint(class AReadyOrNotCharacter* IncapacitatedCharacter);
	void OnKnownEnemyKilled(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter);
	void OnKnownEnemyKilled_Blueprint(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter);
	void OnKnownEnemyStunned(class AReadyOrNotCharacter* StunnedCharacter, float Duration, EStunType StunType, class AActor* DamageCauser);
	void OnKnownEnemyStunned_Blueprint(class AReadyOrNotCharacter* StunnedCharacter, float Duration, EStunType StunType, class AActor* DamageCauser);
	void OnKnownEnemyTakeDamage(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* DamagedCharacter, class AActor* DamageCauser, float Damage, float HealthRemaining);
	void OnKnownEnemyTakeDamage_Blueprint(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* DamagedCharacter, class AActor* DamageCauser, float Damage, float HealthRemaining);
	void OnKnownFriendlyIncapacitated(class AReadyOrNotCharacter* IncapacitatedCharacter, class AReadyOrNotCharacter* InstigatorCharacter);
	void OnKnownFriendlyIncapacitated_Blueprint(class AReadyOrNotCharacter* IncapacitatedCharacter);
	void OnKnownFriendlyKilled(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter);
	void OnKnownFriendlyKilled_Blueprint(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter);
	void OnKnownFriendlyStunned(class AReadyOrNotCharacter* StunnedCharacter, float Duration, EStunType StunType, class AActor* DamageCauser);
	void OnKnownFriendlyStunned_Blueprint(class AReadyOrNotCharacter* StunnedCharacter, float Duration, EStunType StunType, class AActor* DamageCauser);
	void OnKnownFriendlyTakeDamage(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* DamagedCharacter, class AActor* DamageCauser, float Damage, float HealthRemaining);
	void OnKnownFriendlyTakeDamage_Blueprint(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* DamagedCharacter, class AActor* DamageCauser, float Damage, float HealthRemaining);
	void OnKnownNeutralIncapacitated(class AReadyOrNotCharacter* IncapacitatedCharacter, class AReadyOrNotCharacter* InstigatorCharacter);
	void OnKnownNeutralIncapacitated_Blueprint(class AReadyOrNotCharacter* IncapacitatedCharacter);
	void OnKnownNeutralKilled(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter);
	void OnKnownNeutralKilled_Blueprint(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter);
	void OnKnownNeutralStunned(class AReadyOrNotCharacter* StunnedCharacter, float Duration, EStunType StunType, class AActor* DamageCauser);
	void OnKnownNeutralStunned_Blueprint(class AReadyOrNotCharacter* StunnedCharacter, float Duration, EStunType StunType, class AActor* DamageCauser);
	void OnKnownNeutralTakeDamage(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* DamagedCharacter, class AActor* DamageCauser, float Damage, float HealthRemaining);
	void OnKnownNeutralTakeDamage_Blueprint(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* DamagedCharacter, class AActor* DamageCauser, float Damage, float HealthRemaining);
	void OnPerceptionUpdated(const TArray<class AActor*>& TestActors);
	void OnStunDamageTaken(EStunType StunType);
	void RemoveActivitiesOfType(TSubclassOf<class UBaseActivity> ActivityType, bool bClearCurrent);
	void RemoveAllActivitiesExcept(TSubclassOf<class UBaseActivity> ActivityType);
	int32 RequestMoveAsync(const struct FVector& Location, bool bProjectToNavigation, float AcceptanceRadius);
	void SetAwarenessState(EAIAwarenessState NewState);

	bool DoesCharacterMatchTargetType(class AReadyOrNotCharacter* InCharacter, int32 TargetTypeMask) const;
	bool DoesPathGoThroughDoor(class ADoor* Door) const;
	class UBaseActivity* GetActivity(TSubclassOf<class UBaseActivity> ActivityType) const;
	int32 GetActivityQueueCount() const;
	class UMoveToActivity* GetAvoidanceMoveToActivity() const;
	EAIAwarenessState GetAwarenessState() const;
	class ACyberneticCharacter* GetCharacter() const;
	class UBaseCombatActivity* GetCombatActivity() const;
	class UDisarmBombActivity* GetDisarmBombActivity() const;
	int32 GetFailedConsiderCountForAction(class FName Action) const;
	class AReadyOrNotCharacter* GetHeardActorInstigator() const;
	struct FAIStimulus GetLatestStimulus() const;
	class UMoveActivity* GetMoveActivity() const;
	class UMoveToActivity* GetMoveToActivity() const;
	class UMoveToExitActivity* GetMoveToExitActivity() const;
	TSubclassOf<class UNavigationQueryFilter> GetNavQueryFilter() const;
	class UMoveToActivity* GetPushMoveToActivity() const;
	int32 GetSuccessConsiderCountForAction(class FName Action) const;
	class UTargetNextCivilianActivity* GetTargetNextCivilianActivity() const;
	ETeamType GetTeam() const;
	float GetTimeSinceLastMove() const;
	bool HasBeenExposedToAggressiveNoise(float SinceSeconds, float MaxDistance, int32 TargetTypeMask) const;
	bool HasBeenExposedToAggressiveNoise_Tag(class FName* OutTag, float SinceSeconds, float MaxDistance, int32 TargetTypeMask) const;
	bool HasBeenExposedToAnyNoise(float SinceSeconds, float MaxDistance, int32 TargetTypeMask) const;
	bool HasBeenExposedToAnyNoise_Tag(class FName* OutTag, float SinceSeconds, float MaxDistance, int32 TargetTypeMask) const;
	bool HasRecentlySeenCivilian() const;
	bool HasRecentlySeenSuspect() const;
	bool HasRecentlySeenSwat(struct FVector* OutLocation) const;
	bool IsActivelyMovingOnPath() const;
	bool IsCharacterEnemy(class AReadyOrNotCharacter* InCharacter) const;
	bool IsCharacterFriendly(class AReadyOrNotCharacter* InCharacter) const;
	bool IsCharacterKnownEnemy(class AReadyOrNotCharacter* InCharacter) const;
	bool IsCharacterNeutral(class AReadyOrNotCharacter* InCharacter) const;
	bool IsCivilian() const;
	bool IsFindingAnyPath() const;
	bool IsFindingPath(int32 PathId) const;
	bool IsLastAlive() const;
	bool IsMoving() const;
	bool IsMovingForRequest(int32 RequestID) const;
	bool IsMovingForRequests(const TArray<struct FAIRequestID>& Requests) const;
	bool IsSuspect() const;
	bool IsSWAT() const;
	bool IsTagAggressiveNoise(const class FName& Tag) const;
	bool IsTagInvestigativeNoise(const class FName& Tag) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CyberneticController">();
	}
	static class ACyberneticController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACyberneticController>();
	}
};
static_assert(alignof(ACyberneticController) == 0x000008, "Wrong alignment on ACyberneticController");
static_assert(sizeof(ACyberneticController) == 0x000A48, "Wrong size on ACyberneticController");
static_assert(offsetof(ACyberneticController, CustomActions) == 0x0003E0, "Member 'ACyberneticController::CustomActions' has a wrong offset!");
static_assert(offsetof(ACyberneticController, AIPerceptionComponent) == 0x0003F0, "Member 'ACyberneticController::AIPerceptionComponent' has a wrong offset!");
static_assert(offsetof(ACyberneticController, SightConfig) == 0x0003F8, "Member 'ACyberneticController::SightConfig' has a wrong offset!");
static_assert(offsetof(ACyberneticController, TouchConfig) == 0x000400, "Member 'ACyberneticController::TouchConfig' has a wrong offset!");
static_assert(offsetof(ACyberneticController, DamageConfig) == 0x000408, "Member 'ACyberneticController::DamageConfig' has a wrong offset!");
static_assert(offsetof(ACyberneticController, HearingConfig) == 0x000410, "Member 'ACyberneticController::HearingConfig' has a wrong offset!");
static_assert(offsetof(ACyberneticController, MoraleComponent) == 0x000418, "Member 'ACyberneticController::MoraleComponent' has a wrong offset!");
static_assert(offsetof(ACyberneticController, TargetingComponent) == 0x000420, "Member 'ACyberneticController::TargetingComponent' has a wrong offset!");
static_assert(offsetof(ACyberneticController, LastHeardActorTime) == 0x000428, "Member 'ACyberneticController::LastHeardActorTime' has a wrong offset!");
static_assert(offsetof(ACyberneticController, SensingCharacter) == 0x000478, "Member 'ACyberneticController::SensingCharacter' has a wrong offset!");
static_assert(offsetof(ACyberneticController, LastSensedActor) == 0x000480, "Member 'ACyberneticController::LastSensedActor' has a wrong offset!");
static_assert(offsetof(ACyberneticController, HeardActorInstigator) == 0x000488, "Member 'ACyberneticController::HeardActorInstigator' has a wrong offset!");
static_assert(offsetof(ACyberneticController, LastSensedCharacter) == 0x000490, "Member 'ACyberneticController::LastSensedCharacter' has a wrong offset!");
static_assert(offsetof(ACyberneticController, LastSensedLocation) == 0x000498, "Member 'ACyberneticController::LastSensedLocation' has a wrong offset!");
static_assert(offsetof(ACyberneticController, TimeSinceLastMove) == 0x0004B4, "Member 'ACyberneticController::TimeSinceLastMove' has a wrong offset!");
static_assert(offsetof(ACyberneticController, TimeUntilRecentlySeenCharactersClear) == 0x0004B8, "Member 'ACyberneticController::TimeUntilRecentlySeenCharactersClear' has a wrong offset!");
static_assert(offsetof(ACyberneticController, RecentlySeenSwat) == 0x0004C0, "Member 'ACyberneticController::RecentlySeenSwat' has a wrong offset!");
static_assert(offsetof(ACyberneticController, RecentlySeenSuspects) == 0x0004D0, "Member 'ACyberneticController::RecentlySeenSuspects' has a wrong offset!");
static_assert(offsetof(ACyberneticController, RecentlySeenCivilians) == 0x0004E0, "Member 'ACyberneticController::RecentlySeenCivilians' has a wrong offset!");
static_assert(offsetof(ACyberneticController, OnAsyncPathFound) == 0x0004F0, "Member 'ACyberneticController::OnAsyncPathFound' has a wrong offset!");
static_assert(offsetof(ACyberneticController, LastAcceptanceRadius) == 0x000560, "Member 'ACyberneticController::LastAcceptanceRadius' has a wrong offset!");
static_assert(offsetof(ACyberneticController, DamagedBy) == 0x000568, "Member 'ACyberneticController::DamagedBy' has a wrong offset!");
static_assert(offsetof(ACyberneticController, DamagedByLocation) == 0x0005B8, "Member 'ACyberneticController::DamagedByLocation' has a wrong offset!");
static_assert(offsetof(ACyberneticController, InvestigateStimulusActivity) == 0x000610, "Member 'ACyberneticController::InvestigateStimulusActivity' has a wrong offset!");
static_assert(offsetof(ACyberneticController, PreviousAwarenessState) == 0x00061A, "Member 'ACyberneticController::PreviousAwarenessState' has a wrong offset!");
static_assert(offsetof(ACyberneticController, AwarenessState) == 0x00061B, "Member 'ACyberneticController::AwarenessState' has a wrong offset!");
static_assert(offsetof(ACyberneticController, OnAwarenessStateChangedDelegate) == 0x000620, "Member 'ACyberneticController::OnAwarenessStateChangedDelegate' has a wrong offset!");
static_assert(offsetof(ACyberneticController, LatestStimulus) == 0x000690, "Member 'ACyberneticController::LatestStimulus' has a wrong offset!");
static_assert(offsetof(ACyberneticController, LatestSightStimulus) == 0x0006E8, "Member 'ACyberneticController::LatestSightStimulus' has a wrong offset!");
static_assert(offsetof(ACyberneticController, LatestHearingStimulus) == 0x000740, "Member 'ACyberneticController::LatestHearingStimulus' has a wrong offset!");
static_assert(offsetof(ACyberneticController, LatestDamageStimulus) == 0x000798, "Member 'ACyberneticController::LatestDamageStimulus' has a wrong offset!");
static_assert(offsetof(ACyberneticController, TrackedDistractions) == 0x000800, "Member 'ACyberneticController::TrackedDistractions' has a wrong offset!");
static_assert(offsetof(ACyberneticController, OnMoveComplete) == 0x000838, "Member 'ACyberneticController::OnMoveComplete' has a wrong offset!");
static_assert(offsetof(ACyberneticController, ActorSightSenseMap) == 0x000848, "Member 'ACyberneticController::ActorSightSenseMap' has a wrong offset!");
static_assert(offsetof(ACyberneticController, ActorSoundSenseMap) == 0x000858, "Member 'ACyberneticController::ActorSoundSenseMap' has a wrong offset!");
static_assert(offsetof(ACyberneticController, ActorDamageSenseMap) == 0x000868, "Member 'ACyberneticController::ActorDamageSenseMap' has a wrong offset!");
static_assert(offsetof(ACyberneticController, CurrentActivity) == 0x000880, "Member 'ACyberneticController::CurrentActivity' has a wrong offset!");
static_assert(offsetof(ACyberneticController, ActivityQueue) == 0x000888, "Member 'ACyberneticController::ActivityQueue' has a wrong offset!");
static_assert(offsetof(ACyberneticController, CallForHelpCoolDownDuration) == 0x0008A8, "Member 'ACyberneticController::CallForHelpCoolDownDuration' has a wrong offset!");
static_assert(offsetof(ACyberneticController, MaxHearingForHelpDistance) == 0x0008AC, "Member 'ACyberneticController::MaxHearingForHelpDistance' has a wrong offset!");
static_assert(offsetof(ACyberneticController, FlashLightSeenCoolDownDuration) == 0x0008B0, "Member 'ACyberneticController::FlashLightSeenCoolDownDuration' has a wrong offset!");
static_assert(offsetof(ACyberneticController, ExposedToStimulusTags) == 0x0008B8, "Member 'ACyberneticController::ExposedToStimulusTags' has a wrong offset!");
static_assert(offsetof(ACyberneticController, TimeSinceLastExposedToAggressiveStimulus) == 0x000960, "Member 'ACyberneticController::TimeSinceLastExposedToAggressiveStimulus' has a wrong offset!");
static_assert(offsetof(ACyberneticController, TimeSinceLastExposedToAnyStimulus) == 0x000964, "Member 'ACyberneticController::TimeSinceLastExposedToAnyStimulus' has a wrong offset!");
static_assert(offsetof(ACyberneticController, TimeSinceLastExposedToSightStimulus) == 0x000968, "Member 'ACyberneticController::TimeSinceLastExposedToSightStimulus' has a wrong offset!");
static_assert(offsetof(ACyberneticController, TimeSinceLastExposedToSoundStimulus) == 0x00096C, "Member 'ACyberneticController::TimeSinceLastExposedToSoundStimulus' has a wrong offset!");
static_assert(offsetof(ACyberneticController, UnalertTime) == 0x000974, "Member 'ACyberneticController::UnalertTime' has a wrong offset!");
static_assert(offsetof(ACyberneticController, AlertTime) == 0x000978, "Member 'ACyberneticController::AlertTime' has a wrong offset!");
static_assert(offsetof(ACyberneticController, SuspiciousTime) == 0x00097C, "Member 'ACyberneticController::SuspiciousTime' has a wrong offset!");
static_assert(offsetof(ACyberneticController, bHasEverHeardSwat) == 0x000980, "Member 'ACyberneticController::bHasEverHeardSwat' has a wrong offset!");
static_assert(offsetof(ACyberneticController, CombatActivity) == 0x000998, "Member 'ACyberneticController::CombatActivity' has a wrong offset!");
static_assert(offsetof(ACyberneticController, MoveToActivity) == 0x000A00, "Member 'ACyberneticController::MoveToActivity' has a wrong offset!");
static_assert(offsetof(ACyberneticController, TeamMoveActivity) == 0x000A08, "Member 'ACyberneticController::TeamMoveActivity' has a wrong offset!");
static_assert(offsetof(ACyberneticController, PushMoveToActivity) == 0x000A10, "Member 'ACyberneticController::PushMoveToActivity' has a wrong offset!");
static_assert(offsetof(ACyberneticController, AvoidanceMoveToActivity) == 0x000A18, "Member 'ACyberneticController::AvoidanceMoveToActivity' has a wrong offset!");
static_assert(offsetof(ACyberneticController, MoveToExitActivity) == 0x000A20, "Member 'ACyberneticController::MoveToExitActivity' has a wrong offset!");
static_assert(offsetof(ACyberneticController, TargetNextCivilianActivity) == 0x000A28, "Member 'ACyberneticController::TargetNextCivilianActivity' has a wrong offset!");
static_assert(offsetof(ACyberneticController, DisarmBombActivity) == 0x000A30, "Member 'ACyberneticController::DisarmBombActivity' has a wrong offset!");
static_assert(offsetof(ACyberneticController, LastHeardDoorKick) == 0x000A38, "Member 'ACyberneticController::LastHeardDoorKick' has a wrong offset!");

// Class ReadyOrNot.UnmannedVehicle
// 0x0048 (0x0368 - 0x0320)
class AUnmannedVehicle : public APawn
{
public:
	uint8                                         Pad_320[0x8];                                      // 0x0320(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerCharacter*                       Pilot;                                             // 0x0328(0x0008)(BlueprintVisible, Net, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Health;                                            // 0x0330(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDead;                                             // 0x0334(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_335[0x3];                                      // 0x0335(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxHealth;                                         // 0x0338(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33C[0x4];                                      // 0x033C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   VehicleTabletName;                                 // 0x0340(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSubclassOf<class AHUD>                       PreviousHUD;                                       // 0x0358(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AHUD>                       VehicleHUD;                                        // 0x0360(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void AssumeTabletControl(class APlayerCharacter* TabletOwner);
	bool CanControlWithTablet(class APlayerCharacter* TabletOwner);
	bool CanTabletViewMe(class APlayerCharacter* TabletOwner, class AReadyOrNotGameState* GameState);
	void Die(class AController* EventInstigator, class AActor* DamageCauser);
	float GetHealth();
	class APlayerCharacter* GetPilot();
	class FText GetTabletNameText();
	class USceneComponent* GetTabletViewComponent();
	ETeamType GetTabletViewTeamColor();
	void HideActorsForTabletView(class USceneCaptureComponent2D* Component);
	bool IsAlive();
	void OnDeath(class AController* EventInstigator, class AActor* DamageCauser);
	void Server_StartPiloting(class AReadyOrNotPlayerController* NewController);
	void Server_StopPiloting(class AReadyOrNotPlayerController* CallingController);
	float TakeDamage(float Damage, const struct FDamageEvent& DamageEvent, class AController* EventInstigator, class AActor* DamageCauser);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnmannedVehicle">();
	}
	static class AUnmannedVehicle* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUnmannedVehicle>();
	}
};
static_assert(alignof(AUnmannedVehicle) == 0x000008, "Wrong alignment on AUnmannedVehicle");
static_assert(sizeof(AUnmannedVehicle) == 0x000368, "Wrong size on AUnmannedVehicle");
static_assert(offsetof(AUnmannedVehicle, Pilot) == 0x000328, "Member 'AUnmannedVehicle::Pilot' has a wrong offset!");
static_assert(offsetof(AUnmannedVehicle, Health) == 0x000330, "Member 'AUnmannedVehicle::Health' has a wrong offset!");
static_assert(offsetof(AUnmannedVehicle, bDead) == 0x000334, "Member 'AUnmannedVehicle::bDead' has a wrong offset!");
static_assert(offsetof(AUnmannedVehicle, MaxHealth) == 0x000338, "Member 'AUnmannedVehicle::MaxHealth' has a wrong offset!");
static_assert(offsetof(AUnmannedVehicle, VehicleTabletName) == 0x000340, "Member 'AUnmannedVehicle::VehicleTabletName' has a wrong offset!");
static_assert(offsetof(AUnmannedVehicle, PreviousHUD) == 0x000358, "Member 'AUnmannedVehicle::PreviousHUD' has a wrong offset!");
static_assert(offsetof(AUnmannedVehicle, VehicleHUD) == 0x000360, "Member 'AUnmannedVehicle::VehicleHUD' has a wrong offset!");

// Class ReadyOrNot.DroneVehicle
// 0x01D8 (0x0540 - 0x0368)
class ADroneVehicle final : public AUnmannedVehicle
{
public:
	class UBoxComponent*                          FlightBox;                                         // 0x0368(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 Mesh;                                              // 0x0370(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAudioComponent*                        Audio;                                             // 0x0378(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCameraComponent*                       FirstPersonCamera;                                 // 0x0380(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USpringArmComponent*                    ThirdPersonSpringArm;                              // 0x0388(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCameraComponent*                       ThirdPersonCamera;                                 // 0x0390(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFloatingPawnMovement*                  FloatingMovementComponent;                         // 0x0398(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTilt;                                           // 0x03A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRPM;                                            // 0x03A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleRPM;                                           // 0x03A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RPMForceScale;                                     // 0x03AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RPMThrottleMultiplier;                             // 0x03B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThrottleInterpSpeed;                               // 0x03B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationInterpSpeed;                               // 0x03B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnSpeed;                                         // 0x03BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationInterpSpeedWhenSteady;                     // 0x03C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnSpeedWhenSteady;                               // 0x03C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinSpeed;                                          // 0x03C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed;                                          // 0x03CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedIncrementRate;                                // 0x03D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InvincibilityTimeAfterDamageApplied;               // 0x03D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RPM;                                               // 0x03D8(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3DC[0x4];                                      // 0x03DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               RotorRotation;                                     // 0x03E0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         CurrentAltitude;                                   // 0x03F8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentPilotDistance;                              // 0x03FC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             DroneTransform;                                    // 0x0400(0x0060)(BlueprintVisible, BlueprintReadOnly, Net, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               TargetRotation;                                    // 0x0460(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_478[0x68];                                     // 0x0478(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bApplyingInput;                                    // 0x04E0(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSteadyDrone;                                      // 0x04E1(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E2[0x3E];                                     // 0x04E2(0x003E)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerCharacter*                       DroneOwner;                                        // 0x0520(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWorld*                                 World;                                             // 0x0528(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_530[0x10];                                     // 0x0530(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Drone_Exit();
	void Drone_MoveForward(float Val);
	void Drone_QuickTurn();
	void Drone_Right(float Val);
	void Drone_Steady();
	void Drone_Throttle(float Val);
	void Drone_ToggleThirdPerson();
	void Drone_Yaw(float Val);
	void OnDroneHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void OnRep_DroneMovement();
	void Server_UpdateDroneTransform(const struct FTransform& NewTransform);
	void UpdatePilotingInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DroneVehicle">();
	}
	static class ADroneVehicle* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADroneVehicle>();
	}
};
static_assert(alignof(ADroneVehicle) == 0x000010, "Wrong alignment on ADroneVehicle");
static_assert(sizeof(ADroneVehicle) == 0x000540, "Wrong size on ADroneVehicle");
static_assert(offsetof(ADroneVehicle, FlightBox) == 0x000368, "Member 'ADroneVehicle::FlightBox' has a wrong offset!");
static_assert(offsetof(ADroneVehicle, Mesh) == 0x000370, "Member 'ADroneVehicle::Mesh' has a wrong offset!");
static_assert(offsetof(ADroneVehicle, Audio) == 0x000378, "Member 'ADroneVehicle::Audio' has a wrong offset!");
static_assert(offsetof(ADroneVehicle, FirstPersonCamera) == 0x000380, "Member 'ADroneVehicle::FirstPersonCamera' has a wrong offset!");
static_assert(offsetof(ADroneVehicle, ThirdPersonSpringArm) == 0x000388, "Member 'ADroneVehicle::ThirdPersonSpringArm' has a wrong offset!");
static_assert(offsetof(ADroneVehicle, ThirdPersonCamera) == 0x000390, "Member 'ADroneVehicle::ThirdPersonCamera' has a wrong offset!");
static_assert(offsetof(ADroneVehicle, FloatingMovementComponent) == 0x000398, "Member 'ADroneVehicle::FloatingMovementComponent' has a wrong offset!");
static_assert(offsetof(ADroneVehicle, MaxTilt) == 0x0003A0, "Member 'ADroneVehicle::MaxTilt' has a wrong offset!");
static_assert(offsetof(ADroneVehicle, MaxRPM) == 0x0003A4, "Member 'ADroneVehicle::MaxRPM' has a wrong offset!");
static_assert(offsetof(ADroneVehicle, IdleRPM) == 0x0003A8, "Member 'ADroneVehicle::IdleRPM' has a wrong offset!");
static_assert(offsetof(ADroneVehicle, RPMForceScale) == 0x0003AC, "Member 'ADroneVehicle::RPMForceScale' has a wrong offset!");
static_assert(offsetof(ADroneVehicle, RPMThrottleMultiplier) == 0x0003B0, "Member 'ADroneVehicle::RPMThrottleMultiplier' has a wrong offset!");
static_assert(offsetof(ADroneVehicle, ThrottleInterpSpeed) == 0x0003B4, "Member 'ADroneVehicle::ThrottleInterpSpeed' has a wrong offset!");
static_assert(offsetof(ADroneVehicle, RotationInterpSpeed) == 0x0003B8, "Member 'ADroneVehicle::RotationInterpSpeed' has a wrong offset!");
static_assert(offsetof(ADroneVehicle, TurnSpeed) == 0x0003BC, "Member 'ADroneVehicle::TurnSpeed' has a wrong offset!");
static_assert(offsetof(ADroneVehicle, RotationInterpSpeedWhenSteady) == 0x0003C0, "Member 'ADroneVehicle::RotationInterpSpeedWhenSteady' has a wrong offset!");
static_assert(offsetof(ADroneVehicle, TurnSpeedWhenSteady) == 0x0003C4, "Member 'ADroneVehicle::TurnSpeedWhenSteady' has a wrong offset!");
static_assert(offsetof(ADroneVehicle, MinSpeed) == 0x0003C8, "Member 'ADroneVehicle::MinSpeed' has a wrong offset!");
static_assert(offsetof(ADroneVehicle, MaxSpeed) == 0x0003CC, "Member 'ADroneVehicle::MaxSpeed' has a wrong offset!");
static_assert(offsetof(ADroneVehicle, SpeedIncrementRate) == 0x0003D0, "Member 'ADroneVehicle::SpeedIncrementRate' has a wrong offset!");
static_assert(offsetof(ADroneVehicle, InvincibilityTimeAfterDamageApplied) == 0x0003D4, "Member 'ADroneVehicle::InvincibilityTimeAfterDamageApplied' has a wrong offset!");
static_assert(offsetof(ADroneVehicle, RPM) == 0x0003D8, "Member 'ADroneVehicle::RPM' has a wrong offset!");
static_assert(offsetof(ADroneVehicle, RotorRotation) == 0x0003E0, "Member 'ADroneVehicle::RotorRotation' has a wrong offset!");
static_assert(offsetof(ADroneVehicle, CurrentAltitude) == 0x0003F8, "Member 'ADroneVehicle::CurrentAltitude' has a wrong offset!");
static_assert(offsetof(ADroneVehicle, CurrentPilotDistance) == 0x0003FC, "Member 'ADroneVehicle::CurrentPilotDistance' has a wrong offset!");
static_assert(offsetof(ADroneVehicle, DroneTransform) == 0x000400, "Member 'ADroneVehicle::DroneTransform' has a wrong offset!");
static_assert(offsetof(ADroneVehicle, TargetRotation) == 0x000460, "Member 'ADroneVehicle::TargetRotation' has a wrong offset!");
static_assert(offsetof(ADroneVehicle, bApplyingInput) == 0x0004E0, "Member 'ADroneVehicle::bApplyingInput' has a wrong offset!");
static_assert(offsetof(ADroneVehicle, bSteadyDrone) == 0x0004E1, "Member 'ADroneVehicle::bSteadyDrone' has a wrong offset!");
static_assert(offsetof(ADroneVehicle, DroneOwner) == 0x000520, "Member 'ADroneVehicle::DroneOwner' has a wrong offset!");
static_assert(offsetof(ADroneVehicle, World) == 0x000528, "Member 'ADroneVehicle::World' has a wrong offset!");

// Class ReadyOrNot.CivilianController
// 0x0000 (0x0A48 - 0x0A48)
class ACivilianController : public ACyberneticController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CivilianController">();
	}
	static class ACivilianController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACivilianController>();
	}
};
static_assert(alignof(ACivilianController) == 0x000008, "Wrong alignment on ACivilianController");
static_assert(sizeof(ACivilianController) == 0x000A48, "Wrong size on ACivilianController");

// Class ReadyOrNot.CivilianFleeCombatMove
// 0x0008 (0x0238 - 0x0230)
class UCivilianFleeCombatMove final : public UBaseCombatMoveActivity
{
public:
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CivilianFleeCombatMove">();
	}
	static class UCivilianFleeCombatMove* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCivilianFleeCombatMove>();
	}
};
static_assert(alignof(UCivilianFleeCombatMove) == 0x000008, "Wrong alignment on UCivilianFleeCombatMove");
static_assert(sizeof(UCivilianFleeCombatMove) == 0x000238, "Wrong size on UCivilianFleeCombatMove");

// Class ReadyOrNot.EnvQueryContext_GasSources
// 0x0000 (0x0028 - 0x0028)
class UEnvQueryContext_GasSources final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryContext_GasSources">();
	}
	static class UEnvQueryContext_GasSources* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryContext_GasSources>();
	}
};
static_assert(alignof(UEnvQueryContext_GasSources) == 0x000008, "Wrong alignment on UEnvQueryContext_GasSources");
static_assert(sizeof(UEnvQueryContext_GasSources) == 0x000028, "Wrong size on UEnvQueryContext_GasSources");

// Class ReadyOrNot.ClearWeaponAnimNotify
// 0x0000 (0x0038 - 0x0038)
class UClearWeaponAnimNotify final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClearWeaponAnimNotify">();
	}
	static class UClearWeaponAnimNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClearWeaponAnimNotify>();
	}
};
static_assert(alignof(UClearWeaponAnimNotify) == 0x000008, "Wrong alignment on UClearWeaponAnimNotify");
static_assert(sizeof(UClearWeaponAnimNotify) == 0x000038, "Wrong size on UClearWeaponAnimNotify");

// Class ReadyOrNot.Collectable
// 0x0058 (0x02F0 - 0x0298)
class ACollectable final : public AActor
{
public:
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ItemName;                                          // 0x02A0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   ItemDescription;                                   // 0x02B8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<class FName>                           RequiredTags;                                      // 0x02D0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UProgressionRequirement*>        RequiredProgression;                               // 0x02E0(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Collectable">();
	}
	static class ACollectable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACollectable>();
	}
};
static_assert(alignof(ACollectable) == 0x000008, "Wrong alignment on ACollectable");
static_assert(sizeof(ACollectable) == 0x0002F0, "Wrong size on ACollectable");
static_assert(offsetof(ACollectable, ItemName) == 0x0002A0, "Member 'ACollectable::ItemName' has a wrong offset!");
static_assert(offsetof(ACollectable, ItemDescription) == 0x0002B8, "Member 'ACollectable::ItemDescription' has a wrong offset!");
static_assert(offsetof(ACollectable, RequiredTags) == 0x0002D0, "Member 'ACollectable::RequiredTags' has a wrong offset!");
static_assert(offsetof(ACollectable, RequiredProgression) == 0x0002E0, "Member 'ACollectable::RequiredProgression' has a wrong offset!");

// Class ReadyOrNot.DynamicWorldActor
// 0x0010 (0x02A8 - 0x0298)
class ADynamicWorldActor final : public AActor
{
public:
	class FName                                   DynamicLabel;                                      // 0x0298(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReplicateSpawn;                                   // 0x02A0(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A1[0x7];                                      // 0x02A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CheckDynamicSpawn();
	void OnDynamicallySpawned();
	void OnRep_ReplicateSpawn();
	void SetDynamicSpawn(bool bShouldSpawn);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicWorldActor">();
	}
	static class ADynamicWorldActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADynamicWorldActor>();
	}
};
static_assert(alignof(ADynamicWorldActor) == 0x000008, "Wrong alignment on ADynamicWorldActor");
static_assert(sizeof(ADynamicWorldActor) == 0x0002A8, "Wrong size on ADynamicWorldActor");
static_assert(offsetof(ADynamicWorldActor, DynamicLabel) == 0x000298, "Member 'ADynamicWorldActor::DynamicLabel' has a wrong offset!");
static_assert(offsetof(ADynamicWorldActor, bReplicateSpawn) == 0x0002A0, "Member 'ADynamicWorldActor::bReplicateSpawn' has a wrong offset!");

// Class ReadyOrNot.CollectableViewController
// 0x0098 (0x0330 - 0x0298)
class ACollectableViewController final : public AActor
{
public:
	float                                         RotationSpeed;                                     // 0x0298(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ScaleLevels;                                       // 0x029C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleSpeed;                                        // 0x02A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimumScale;                                      // 0x02A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaximumScale;                                      // 0x02A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VerticalFov;                                       // 0x02AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACameraActor*                           CameraActor;                                       // 0x02B0(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 SpawnPointActor;                                   // 0x02B8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACollectable*                           CollectableActor;                                  // 0x02C0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AReadyOrNotPlayerController*            CurrentController;                                 // 0x02C8(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCollectableWidget*                     CollectableWidget;                                 // 0x02D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D8[0x18];                                     // 0x02D8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ADirectionalLight*>              HiddenDirectionalLights;                           // 0x02F0(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class ASkyLight*>                      HiddenSkyLights;                                   // 0x0300(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class APostProcessVolume*>             HiddenPostProcessVolumes;                          // 0x0310(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class AExponentialHeightFog*>          HiddenExponentialHeightFogs;                       // 0x0320(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CollectableViewController">();
	}
	static class ACollectableViewController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACollectableViewController>();
	}
};
static_assert(alignof(ACollectableViewController) == 0x000008, "Wrong alignment on ACollectableViewController");
static_assert(sizeof(ACollectableViewController) == 0x000330, "Wrong size on ACollectableViewController");
static_assert(offsetof(ACollectableViewController, RotationSpeed) == 0x000298, "Member 'ACollectableViewController::RotationSpeed' has a wrong offset!");
static_assert(offsetof(ACollectableViewController, ScaleLevels) == 0x00029C, "Member 'ACollectableViewController::ScaleLevels' has a wrong offset!");
static_assert(offsetof(ACollectableViewController, ScaleSpeed) == 0x0002A0, "Member 'ACollectableViewController::ScaleSpeed' has a wrong offset!");
static_assert(offsetof(ACollectableViewController, MinimumScale) == 0x0002A4, "Member 'ACollectableViewController::MinimumScale' has a wrong offset!");
static_assert(offsetof(ACollectableViewController, MaximumScale) == 0x0002A8, "Member 'ACollectableViewController::MaximumScale' has a wrong offset!");
static_assert(offsetof(ACollectableViewController, VerticalFov) == 0x0002AC, "Member 'ACollectableViewController::VerticalFov' has a wrong offset!");
static_assert(offsetof(ACollectableViewController, CameraActor) == 0x0002B0, "Member 'ACollectableViewController::CameraActor' has a wrong offset!");
static_assert(offsetof(ACollectableViewController, SpawnPointActor) == 0x0002B8, "Member 'ACollectableViewController::SpawnPointActor' has a wrong offset!");
static_assert(offsetof(ACollectableViewController, CollectableActor) == 0x0002C0, "Member 'ACollectableViewController::CollectableActor' has a wrong offset!");
static_assert(offsetof(ACollectableViewController, CurrentController) == 0x0002C8, "Member 'ACollectableViewController::CurrentController' has a wrong offset!");
static_assert(offsetof(ACollectableViewController, CollectableWidget) == 0x0002D0, "Member 'ACollectableViewController::CollectableWidget' has a wrong offset!");
static_assert(offsetof(ACollectableViewController, HiddenDirectionalLights) == 0x0002F0, "Member 'ACollectableViewController::HiddenDirectionalLights' has a wrong offset!");
static_assert(offsetof(ACollectableViewController, HiddenSkyLights) == 0x000300, "Member 'ACollectableViewController::HiddenSkyLights' has a wrong offset!");
static_assert(offsetof(ACollectableViewController, HiddenPostProcessVolumes) == 0x000310, "Member 'ACollectableViewController::HiddenPostProcessVolumes' has a wrong offset!");
static_assert(offsetof(ACollectableViewController, HiddenExponentialHeightFogs) == 0x000320, "Member 'ACollectableViewController::HiddenExponentialHeightFogs' has a wrong offset!");

// Class ReadyOrNot.CollectableViewer
// 0x0020 (0x02B8 - 0x0298)
class ACollectableViewer final : public AActor
{
public:
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ACollectable>               CollectableClass;                                  // 0x02A0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractableComponent*                 InteractableComponent;                             // 0x02A8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACollectableViewController*             ViewController;                                    // 0x02B0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CollectableViewer">();
	}
	static class ACollectableViewer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACollectableViewer>();
	}
};
static_assert(alignof(ACollectableViewer) == 0x000008, "Wrong alignment on ACollectableViewer");
static_assert(sizeof(ACollectableViewer) == 0x0002B8, "Wrong size on ACollectableViewer");
static_assert(offsetof(ACollectableViewer, CollectableClass) == 0x0002A0, "Member 'ACollectableViewer::CollectableClass' has a wrong offset!");
static_assert(offsetof(ACollectableViewer, InteractableComponent) == 0x0002A8, "Member 'ACollectableViewer::InteractableComponent' has a wrong offset!");
static_assert(offsetof(ACollectableViewer, ViewController) == 0x0002B0, "Member 'ACollectableViewer::ViewController' has a wrong offset!");

// Class ReadyOrNot.CollectableWidget
// 0x0008 (0x0418 - 0x0410)
class UCollectableWidget : public UCommonActivatableWidget
{
public:
	class ACollectableViewController*             ParentController;                                  // 0x0410(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void CloseCollectableWidget();
	void SetItem(class ACollectable* Collectable);
	void ToggleInterface();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CollectableWidget">();
	}
	static class UCollectableWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCollectableWidget>();
	}
};
static_assert(alignof(UCollectableWidget) == 0x000008, "Wrong alignment on UCollectableWidget");
static_assert(sizeof(UCollectableWidget) == 0x000418, "Wrong size on UCollectableWidget");
static_assert(offsetof(UCollectableWidget, ParentController) == 0x000410, "Member 'UCollectableWidget::ParentController' has a wrong offset!");

// Class ReadyOrNot.CollectedEvidenceActor
// 0x0020 (0x02B8 - 0x0298)
class ACollectedEvidenceActor final : public AActor
{
public:
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   CollectionBagMesh;                                 // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEvidenceComponent*                     EvidenceComponent;                                 // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             Bag_Spawn_Sound;                                   // 0x02B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void Multicast_PlaySpawnSound();
	void PlaySpawnSound();
	void Server_PlaySpawnSound();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CollectedEvidenceActor">();
	}
	static class ACollectedEvidenceActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACollectedEvidenceActor>();
	}
};
static_assert(alignof(ACollectedEvidenceActor) == 0x000008, "Wrong alignment on ACollectedEvidenceActor");
static_assert(sizeof(ACollectedEvidenceActor) == 0x0002B8, "Wrong size on ACollectedEvidenceActor");
static_assert(offsetof(ACollectedEvidenceActor, CollectionBagMesh) == 0x0002A0, "Member 'ACollectedEvidenceActor::CollectionBagMesh' has a wrong offset!");
static_assert(offsetof(ACollectedEvidenceActor, EvidenceComponent) == 0x0002A8, "Member 'ACollectedEvidenceActor::EvidenceComponent' has a wrong offset!");
static_assert(offsetof(ACollectedEvidenceActor, Bag_Spawn_Sound) == 0x0002B0, "Member 'ACollectedEvidenceActor::Bag_Spawn_Sound' has a wrong offset!");

// Class ReadyOrNot.EngageTargetLessLethalActivity
// 0x0018 (0x0208 - 0x01F0)
class UEngageTargetLessLethalActivity final : public UBaseActivity
{
public:
	class AReadyOrNotCharacter*                   TargetCharacter;                                   // 0x01F0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F8[0x10];                                     // 0x01F8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EngageTargetLessLethalActivity">();
	}
	static class UEngageTargetLessLethalActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEngageTargetLessLethalActivity>();
	}
};
static_assert(alignof(UEngageTargetLessLethalActivity) == 0x000008, "Wrong alignment on UEngageTargetLessLethalActivity");
static_assert(sizeof(UEngageTargetLessLethalActivity) == 0x000208, "Wrong size on UEngageTargetLessLethalActivity");
static_assert(offsetof(UEngageTargetLessLethalActivity, TargetCharacter) == 0x0001F0, "Member 'UEngageTargetLessLethalActivity::TargetCharacter' has a wrong offset!");

// Class ReadyOrNot.CollectEvidenceActivity
// 0x0018 (0x0208 - 0x01F0)
class UCollectEvidenceActivity final : public UBaseActivity
{
public:
	class AActor*                                 EvidenceItem;                                      // 0x01F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F8[0x10];                                     // 0x01F8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnterCollectStage();
	void EnterMoveToStage();
	void OnCollectEvidenceBegin();
	void OnCollectEvidenceEnd();
	void OnEvidenceCollected(class AReadyOrNotCharacter* CollectingCharacter);
	void TickCollectStage(float DeltaTime, float Uptime);

	bool CanCollectEvidence() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CollectEvidenceActivity">();
	}
	static class UCollectEvidenceActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCollectEvidenceActivity>();
	}
};
static_assert(alignof(UCollectEvidenceActivity) == 0x000008, "Wrong alignment on UCollectEvidenceActivity");
static_assert(sizeof(UCollectEvidenceActivity) == 0x000208, "Wrong size on UCollectEvidenceActivity");
static_assert(offsetof(UCollectEvidenceActivity, EvidenceItem) == 0x0001F0, "Member 'UCollectEvidenceActivity::EvidenceItem' has a wrong offset!");

// Class ReadyOrNot.CombatMoveZone
// 0x0078 (0x0348 - 0x02D0)
class ACombatMoveZone final : public AVolume
{
public:
	TArray<class ACombatMoveZone*>                LinkedZones;                                       // 0x02D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E0[0x8];                                      // 0x02E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class AAISpawn>>        AISpawnBlacklist;                                  // 0x02E8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class AAISpawn>>        AISpawnWhitelist;                                  // 0x02F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	EZonePriority                                 ZonePriority;                                      // 0x0308(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_309[0x7];                                      // 0x0309(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EAIAwarenessState>                     AllowableStates;                                   // 0x0310(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AReadyOrNotCharacter*>           OverlappingSWAT;                                   // 0x0320(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bDisableOnSWATOverlap;                             // 0x0330(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisablePermanently;                               // 0x0331(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableLinkedZonesPermanently;                    // 0x0332(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_333[0x1];                                      // 0x0333(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxSuspectCount;                                   // 0x0334(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Probability;                                       // 0x0338(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33C[0xC];                                      // 0x033C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CombatMoveZone">();
	}
	static class ACombatMoveZone* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACombatMoveZone>();
	}
};
static_assert(alignof(ACombatMoveZone) == 0x000008, "Wrong alignment on ACombatMoveZone");
static_assert(sizeof(ACombatMoveZone) == 0x000348, "Wrong size on ACombatMoveZone");
static_assert(offsetof(ACombatMoveZone, LinkedZones) == 0x0002D0, "Member 'ACombatMoveZone::LinkedZones' has a wrong offset!");
static_assert(offsetof(ACombatMoveZone, AISpawnBlacklist) == 0x0002E8, "Member 'ACombatMoveZone::AISpawnBlacklist' has a wrong offset!");
static_assert(offsetof(ACombatMoveZone, AISpawnWhitelist) == 0x0002F8, "Member 'ACombatMoveZone::AISpawnWhitelist' has a wrong offset!");
static_assert(offsetof(ACombatMoveZone, ZonePriority) == 0x000308, "Member 'ACombatMoveZone::ZonePriority' has a wrong offset!");
static_assert(offsetof(ACombatMoveZone, AllowableStates) == 0x000310, "Member 'ACombatMoveZone::AllowableStates' has a wrong offset!");
static_assert(offsetof(ACombatMoveZone, OverlappingSWAT) == 0x000320, "Member 'ACombatMoveZone::OverlappingSWAT' has a wrong offset!");
static_assert(offsetof(ACombatMoveZone, bDisableOnSWATOverlap) == 0x000330, "Member 'ACombatMoveZone::bDisableOnSWATOverlap' has a wrong offset!");
static_assert(offsetof(ACombatMoveZone, bDisablePermanently) == 0x000331, "Member 'ACombatMoveZone::bDisablePermanently' has a wrong offset!");
static_assert(offsetof(ACombatMoveZone, bDisableLinkedZonesPermanently) == 0x000332, "Member 'ACombatMoveZone::bDisableLinkedZonesPermanently' has a wrong offset!");
static_assert(offsetof(ACombatMoveZone, MaxSuspectCount) == 0x000334, "Member 'ACombatMoveZone::MaxSuspectCount' has a wrong offset!");
static_assert(offsetof(ACombatMoveZone, Probability) == 0x000338, "Member 'ACombatMoveZone::Probability' has a wrong offset!");

// Class ReadyOrNot.EvidenceActor
// 0x0060 (0x0360 - 0x0300)
class AEvidenceActor final : public APickupActor
{
public:
	uint8                                         Pad_300[0x18];                                     // 0x0300(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UScoringComponent*                      ScoringComponent;                                  // 0x0318(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UEvidenceComponent*                     EvidenceComponent;                                 // 0x0320(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          InteractionBox;                                    // 0x0328(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   EvidenceName;                                      // 0x0330(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	uint8                                         bInteractHeld : 1;                                 // 0x0348(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_349[0x7];                                      // 0x0349(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AEvidenceActor* CollectedEvidence, class AReadyOrNotCharacter* Collector)> OnEvidenceCollected; // 0x0350(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)

public:
	void OnEvidenceStateChanged(EEvidenceActorState NewState);

	class FText GetEvidenceName() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EvidenceActor">();
	}
	static class AEvidenceActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEvidenceActor>();
	}
};
static_assert(alignof(AEvidenceActor) == 0x000008, "Wrong alignment on AEvidenceActor");
static_assert(sizeof(AEvidenceActor) == 0x000360, "Wrong size on AEvidenceActor");
static_assert(offsetof(AEvidenceActor, ScoringComponent) == 0x000318, "Member 'AEvidenceActor::ScoringComponent' has a wrong offset!");
static_assert(offsetof(AEvidenceActor, EvidenceComponent) == 0x000320, "Member 'AEvidenceActor::EvidenceComponent' has a wrong offset!");
static_assert(offsetof(AEvidenceActor, InteractionBox) == 0x000328, "Member 'AEvidenceActor::InteractionBox' has a wrong offset!");
static_assert(offsetof(AEvidenceActor, EvidenceName) == 0x000330, "Member 'AEvidenceActor::EvidenceName' has a wrong offset!");
static_assert(offsetof(AEvidenceActor, OnEvidenceCollected) == 0x000350, "Member 'AEvidenceActor::OnEvidenceCollected' has a wrong offset!");

// Class ReadyOrNot.CoopGM
// 0x04A0 (0x0E10 - 0x0970)
#pragma pack(push, 0x1)
class alignas(0x10) ACoopGM : public AReadyOrNotGameMode
{
public:
	uint8                                         Pad_970[0x8];                                      // 0x0970(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnAllAISpawned;                                    // 0x0978(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AWorldDataGenerator*                    WorldDataGenerator;                                // 0x0988(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECOOPMode                                     Mode;                                              // 0x0990(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_991[0x27];                                     // 0x0991(0x0027)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     KilledSuspectAvoidanceShape;                       // 0x09B8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNegotiatorActive;                                 // 0x09C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAIEquipSameLoadoutAsPlayer;                       // 0x09C1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C2[0x2];                                      // 0x09C2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxHostagesKilledBeforeMissionFailed;              // 0x09C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxTeamKillsBeforeAIRetaliates;                    // 0x09C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9CC[0x4];                                      // 0x09CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ACyberneticCharacter>       SwatAlphaClass;                                    // 0x09D0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACyberneticCharacter>       SwatBetaClass;                                     // 0x09D8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACyberneticCharacter>       SwatCharlieClass;                                  // 0x09E0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACyberneticCharacter>       SwatDeltaClass;                                    // 0x09E8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACyberneticCharacter>       SwatTrailerClass;                                  // 0x09F0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AAIController>              FriendlyAIController;                              // 0x09F8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSavedLoadout                          FriendlyAILoadout;                                 // 0x0A00(0x02E8)(Edit, NativeAccessSpecifierPublic)
	TSubclassOf<class AEvidenceActor>             EvidenceClass;                                     // 0x0CE8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool bMissionSucceded)> OnMissionEnded;                            // 0x0CF0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TSubclassOf<class UUserWidget>                GameStartedWidget;                                 // 0x0D00(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     KeycardClass;                                      // 0x0D08(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AI_SpawnTag;                                       // 0x0D10(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D18[0x60];                                     // 0x0D18(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AEvidenceActor*>                 EvidenceInWorld;                                   // 0x0D78(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	int32                                         NextHighgroundDesignation;                         // 0x0D88(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D8C[0x4];                                      // 0x0D8C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AHighgroundVolume*>              Highground;                                        // 0x0D90(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bUniqueOfficerSoundsets;                           // 0x0DA0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DA1[0x3];                                      // 0x0DA1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumPickedOfficerSoundsets;                         // 0x0DA4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PickedOfficerSoundsets;                            // 0x0DA8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DAC[0x4];                                      // 0x0DAC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ASWATCharacter*>                 SpawnedSWATAI;                                     // 0x0DB0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class ATrailerSWATCharacter*>          SpawnedTrailerSWATAI;                              // 0x0DC0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class AAISpawn*>                       SpawnLaterSpawns;                                  // 0x0DD0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         AISpawnDistance;                                   // 0x0DE0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DE4[0x4];                                      // 0x0DE4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundCue*                              NegFeedback;                                       // 0x0DE8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              PosFeedBack;                                       // 0x0DF0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ADoor*>                          KickedDoorsTriggeredMoraleChange;                  // 0x0DF8(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	void AIArrested(class AReadyOrNotCharacter* ArrestedCharacter, class AReadyOrNotCharacter* InstigatorCharacter);
	void AIIncapacitated(class AReadyOrNotCharacter* Incapacitated, class AReadyOrNotCharacter* InstigatorCharacter);
	void AIKilled(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter);
	void AISurrendered(class AReadyOrNotCharacter* Character);
	class APlayerStart* FindPlayerStartForTeam(ETeamType Team);
	void FriendlyAIKilled(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter);
	void IncapHumanKilled(class AReadyOrNotCharacter* InstigatorCharacter, class AIncapacitatedHuman* KilledHuman);
	void MissionEnd(bool bSuccess);
	void Personnel_SpawnHighground(int32 PersonnelNum, int32 MapPointNum, bool bSpotter, bool bMarksman, bool bSniper);
	void Personnel_SpawnNegotiator();
	void Personnel_SpawnOperator(int32 PersonnelNum, int32 MapPointNum, bool bNoisemaker);
	void Personnel_SpawnPowerCrew();
	void Personnel_SpawnTruckDriver(int32 PersonnelNum, int32 MapPointNum);
	void Personnel_SpawnVentilation(int32 PersonnelNum, int32 MapPointNum);
	void RemoveAllSpawnedAI();
	void ReturnToStation();
	void Server_SoftClearVoteCheck();
	void SpawnPolice();
	void SpawnSuspectsAndHostages();
	void StartMissionEndTimer(bool bWon);

	ECOOPMode GetCOOPMode() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoopGM">();
	}
	static class ACoopGM* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACoopGM>();
	}
};
#pragma pack(pop)
static_assert(alignof(ACoopGM) == 0x000010, "Wrong alignment on ACoopGM");
static_assert(sizeof(ACoopGM) == 0x000E10, "Wrong size on ACoopGM");
static_assert(offsetof(ACoopGM, OnAllAISpawned) == 0x000978, "Member 'ACoopGM::OnAllAISpawned' has a wrong offset!");
static_assert(offsetof(ACoopGM, WorldDataGenerator) == 0x000988, "Member 'ACoopGM::WorldDataGenerator' has a wrong offset!");
static_assert(offsetof(ACoopGM, Mode) == 0x000990, "Member 'ACoopGM::Mode' has a wrong offset!");
static_assert(offsetof(ACoopGM, KilledSuspectAvoidanceShape) == 0x0009B8, "Member 'ACoopGM::KilledSuspectAvoidanceShape' has a wrong offset!");
static_assert(offsetof(ACoopGM, bNegotiatorActive) == 0x0009C0, "Member 'ACoopGM::bNegotiatorActive' has a wrong offset!");
static_assert(offsetof(ACoopGM, bAIEquipSameLoadoutAsPlayer) == 0x0009C1, "Member 'ACoopGM::bAIEquipSameLoadoutAsPlayer' has a wrong offset!");
static_assert(offsetof(ACoopGM, MaxHostagesKilledBeforeMissionFailed) == 0x0009C4, "Member 'ACoopGM::MaxHostagesKilledBeforeMissionFailed' has a wrong offset!");
static_assert(offsetof(ACoopGM, MaxTeamKillsBeforeAIRetaliates) == 0x0009C8, "Member 'ACoopGM::MaxTeamKillsBeforeAIRetaliates' has a wrong offset!");
static_assert(offsetof(ACoopGM, SwatAlphaClass) == 0x0009D0, "Member 'ACoopGM::SwatAlphaClass' has a wrong offset!");
static_assert(offsetof(ACoopGM, SwatBetaClass) == 0x0009D8, "Member 'ACoopGM::SwatBetaClass' has a wrong offset!");
static_assert(offsetof(ACoopGM, SwatCharlieClass) == 0x0009E0, "Member 'ACoopGM::SwatCharlieClass' has a wrong offset!");
static_assert(offsetof(ACoopGM, SwatDeltaClass) == 0x0009E8, "Member 'ACoopGM::SwatDeltaClass' has a wrong offset!");
static_assert(offsetof(ACoopGM, SwatTrailerClass) == 0x0009F0, "Member 'ACoopGM::SwatTrailerClass' has a wrong offset!");
static_assert(offsetof(ACoopGM, FriendlyAIController) == 0x0009F8, "Member 'ACoopGM::FriendlyAIController' has a wrong offset!");
static_assert(offsetof(ACoopGM, FriendlyAILoadout) == 0x000A00, "Member 'ACoopGM::FriendlyAILoadout' has a wrong offset!");
static_assert(offsetof(ACoopGM, EvidenceClass) == 0x000CE8, "Member 'ACoopGM::EvidenceClass' has a wrong offset!");
static_assert(offsetof(ACoopGM, OnMissionEnded) == 0x000CF0, "Member 'ACoopGM::OnMissionEnded' has a wrong offset!");
static_assert(offsetof(ACoopGM, GameStartedWidget) == 0x000D00, "Member 'ACoopGM::GameStartedWidget' has a wrong offset!");
static_assert(offsetof(ACoopGM, KeycardClass) == 0x000D08, "Member 'ACoopGM::KeycardClass' has a wrong offset!");
static_assert(offsetof(ACoopGM, AI_SpawnTag) == 0x000D10, "Member 'ACoopGM::AI_SpawnTag' has a wrong offset!");
static_assert(offsetof(ACoopGM, EvidenceInWorld) == 0x000D78, "Member 'ACoopGM::EvidenceInWorld' has a wrong offset!");
static_assert(offsetof(ACoopGM, NextHighgroundDesignation) == 0x000D88, "Member 'ACoopGM::NextHighgroundDesignation' has a wrong offset!");
static_assert(offsetof(ACoopGM, Highground) == 0x000D90, "Member 'ACoopGM::Highground' has a wrong offset!");
static_assert(offsetof(ACoopGM, bUniqueOfficerSoundsets) == 0x000DA0, "Member 'ACoopGM::bUniqueOfficerSoundsets' has a wrong offset!");
static_assert(offsetof(ACoopGM, NumPickedOfficerSoundsets) == 0x000DA4, "Member 'ACoopGM::NumPickedOfficerSoundsets' has a wrong offset!");
static_assert(offsetof(ACoopGM, PickedOfficerSoundsets) == 0x000DA8, "Member 'ACoopGM::PickedOfficerSoundsets' has a wrong offset!");
static_assert(offsetof(ACoopGM, SpawnedSWATAI) == 0x000DB0, "Member 'ACoopGM::SpawnedSWATAI' has a wrong offset!");
static_assert(offsetof(ACoopGM, SpawnedTrailerSWATAI) == 0x000DC0, "Member 'ACoopGM::SpawnedTrailerSWATAI' has a wrong offset!");
static_assert(offsetof(ACoopGM, SpawnLaterSpawns) == 0x000DD0, "Member 'ACoopGM::SpawnLaterSpawns' has a wrong offset!");
static_assert(offsetof(ACoopGM, AISpawnDistance) == 0x000DE0, "Member 'ACoopGM::AISpawnDistance' has a wrong offset!");
static_assert(offsetof(ACoopGM, NegFeedback) == 0x000DE8, "Member 'ACoopGM::NegFeedback' has a wrong offset!");
static_assert(offsetof(ACoopGM, PosFeedBack) == 0x000DF0, "Member 'ACoopGM::PosFeedBack' has a wrong offset!");
static_assert(offsetof(ACoopGM, KickedDoorsTriggeredMoraleChange) == 0x000DF8, "Member 'ACoopGM::KickedDoorsTriggeredMoraleChange' has a wrong offset!");

// Class ReadyOrNot.CommanderGM
// 0x0020 (0x0E30 - 0x0E10)
class ACommanderGM final : public ACoopGM
{
public:
	class UCommanderProfile*                      CommanderProfile;                                  // 0x0E08(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URosterManager*                         RosterManager;                                     // 0x0E10(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AExfilPortal>               ExfilPortalClass;                                  // 0x0E18(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E20[0x10];                                     // 0x0E20(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommanderGM">();
	}
	static class ACommanderGM* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACommanderGM>();
	}
};
static_assert(alignof(ACommanderGM) == 0x000010, "Wrong alignment on ACommanderGM");
static_assert(sizeof(ACommanderGM) == 0x000E30, "Wrong size on ACommanderGM");
static_assert(offsetof(ACommanderGM, CommanderProfile) == 0x000E08, "Member 'ACommanderGM::CommanderProfile' has a wrong offset!");
static_assert(offsetof(ACommanderGM, RosterManager) == 0x000E10, "Member 'ACommanderGM::RosterManager' has a wrong offset!");
static_assert(offsetof(ACommanderGM, ExfilPortalClass) == 0x000E18, "Member 'ACommanderGM::ExfilPortalClass' has a wrong offset!");

// Class ReadyOrNot.EnvQueryGenerator_GasPoints
// 0x00B8 (0x0148 - 0x0090)
class UEnvQueryGenerator_GasPoints final : public UEnvQueryGenerator_ProjectedPoints
{
public:
	struct FAIDataProviderFloatValue              GridRadius;                                        // 0x0090(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderFloatValue              SpaceBetween;                                      // 0x00C8(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TSubclassOf<class UEnvQueryContext>           GenerateAround;                                    // 0x0100(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UNavigationQueryFilter>     NavigationFilter;                                  // 0x0108(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FAIDataProviderFloatValue              SafePointsBufferDistance;                          // 0x0110(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryGenerator_GasPoints">();
	}
	static class UEnvQueryGenerator_GasPoints* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryGenerator_GasPoints>();
	}
};
static_assert(alignof(UEnvQueryGenerator_GasPoints) == 0x000008, "Wrong alignment on UEnvQueryGenerator_GasPoints");
static_assert(sizeof(UEnvQueryGenerator_GasPoints) == 0x000148, "Wrong size on UEnvQueryGenerator_GasPoints");
static_assert(offsetof(UEnvQueryGenerator_GasPoints, GridRadius) == 0x000090, "Member 'UEnvQueryGenerator_GasPoints::GridRadius' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_GasPoints, SpaceBetween) == 0x0000C8, "Member 'UEnvQueryGenerator_GasPoints::SpaceBetween' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_GasPoints, GenerateAround) == 0x000100, "Member 'UEnvQueryGenerator_GasPoints::GenerateAround' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_GasPoints, NavigationFilter) == 0x000108, "Member 'UEnvQueryGenerator_GasPoints::NavigationFilter' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_GasPoints, SafePointsBufferDistance) == 0x000110, "Member 'UEnvQueryGenerator_GasPoints::SafePointsBufferDistance' has a wrong offset!");

// Class ReadyOrNot.CoopGS
// 0x0110 (0x0A08 - 0x08F8)
class ACoopGS : public AReadyOrNotGameState
{
public:
	uint8                                         Pad_8F8[0x10];                                     // 0x08F8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bMissionSucceded;                                  // 0x0908(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMissionSoftCompleted;                             // 0x0909(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECOOPMode                                     Mode;                                              // 0x090A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_90B[0x1];                                      // 0x090B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   EntryPointTag;                                     // 0x090C(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCrouchingTigerHiddenDragon;                       // 0x0914(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_915[0x3];                                      // 0x0915(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentDeployables;                                // 0x0918(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91C[0x4];                                      // 0x091C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 DeployableDepot;                                   // 0x0920(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DepotLabel;                                        // 0x0928(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DepotNumber;                                       // 0x0930(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DepotCost;                                         // 0x0934(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentPersonnel;                                  // 0x0938(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentUsedPersonnelPoints;                        // 0x093C(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int32, int32>                            PersonnelMapping;                                  // 0x0940(0x0050)(BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         TotalAIOfficers;                                   // 0x0990(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalOfficers;                                     // 0x0994(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumCompleteExtraObjectives;                        // 0x0998(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumTotalExtraObjectives;                           // 0x099C(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamKills;                                         // 0x09A0(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllPlayerCharactesDead;                           // 0x09A4(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9A5[0x3];                                      // 0x09A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SquadPointsRemaining;                              // 0x09A8(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESelectedSpawn                                SelectedRedSpawnPoint;                             // 0x09AC(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9AD[0x3];                                      // 0x09AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RedSpawnSquadPoints;                               // 0x09B0(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESelectedSpawn                                SelectedBlueSpawnPoint;                            // 0x09B4(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9B5[0x3];                                      // 0x09B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BlueSpawnSquadPoints;                              // 0x09B8(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9BC[0x4];                                      // 0x09BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             missionMusic;                                      // 0x09C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFMODEventInstance                     musicInstance;                                     // 0x09C8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FText                                   PromotedLeaderFormat;                              // 0x09D0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         YesVotes;                                          // 0x09E8(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NoVotes;                                           // 0x09EC(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9F0[0x10];                                     // 0x09F0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TOCDelay;                                          // 0x0A00(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A04[0x4];                                      // 0x0A04(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CanChangeSpawn(bool bBlueTeam, ESelectedSpawn NewSpawn);
	TArray<int32> GetEnabledDeployables();
	TArray<class FText> GetEnabledDeployablesShortNames();
	TArray<int32> GetEnabledPersonnel();
	int32 GetNoVotes();
	int32 GetPersonnelForMapNum(int32 MapPointNum);
	TArray<int32> GetUnenabledDeployables();
	TArray<int32> GetUnenabledPersonnel();
	TArray<int32> GetUsedPersonnelPoints();
	int32 GetYesVotes();
	bool IsDeployableEnabled(int32 DeployableNumber);
	bool IsPersonnelEnabled(int32 PersonnelNum);
	void Multicast_BroadcastNewSquadLeader(class APlayerCharacter* NewLeader);
	void Multicast_GrantProgressionTags(float ScorePercentage);
	void Multicast_OnMissionEnd(bool bSuccess);
	void OnRep_COOPMode();
	void OnRep_MapElement();
	bool PlayerControllerVoted(class AReadyOrNotPlayerController* PlayerController, bool bVoteYes);
	void Server_SetDeployableDepot(class AReadyOrNotPlayerController* Controller, int32 NewDepotNum);
	void StartTOCBriefing(const class FString& TOCLine);
	void UpdateVotes(int32 Yes, int32 No);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoopGS">();
	}
	static class ACoopGS* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACoopGS>();
	}
};
static_assert(alignof(ACoopGS) == 0x000008, "Wrong alignment on ACoopGS");
static_assert(sizeof(ACoopGS) == 0x000A08, "Wrong size on ACoopGS");
static_assert(offsetof(ACoopGS, bMissionSucceded) == 0x000908, "Member 'ACoopGS::bMissionSucceded' has a wrong offset!");
static_assert(offsetof(ACoopGS, bMissionSoftCompleted) == 0x000909, "Member 'ACoopGS::bMissionSoftCompleted' has a wrong offset!");
static_assert(offsetof(ACoopGS, Mode) == 0x00090A, "Member 'ACoopGS::Mode' has a wrong offset!");
static_assert(offsetof(ACoopGS, EntryPointTag) == 0x00090C, "Member 'ACoopGS::EntryPointTag' has a wrong offset!");
static_assert(offsetof(ACoopGS, bCrouchingTigerHiddenDragon) == 0x000914, "Member 'ACoopGS::bCrouchingTigerHiddenDragon' has a wrong offset!");
static_assert(offsetof(ACoopGS, CurrentDeployables) == 0x000918, "Member 'ACoopGS::CurrentDeployables' has a wrong offset!");
static_assert(offsetof(ACoopGS, DeployableDepot) == 0x000920, "Member 'ACoopGS::DeployableDepot' has a wrong offset!");
static_assert(offsetof(ACoopGS, DepotLabel) == 0x000928, "Member 'ACoopGS::DepotLabel' has a wrong offset!");
static_assert(offsetof(ACoopGS, DepotNumber) == 0x000930, "Member 'ACoopGS::DepotNumber' has a wrong offset!");
static_assert(offsetof(ACoopGS, DepotCost) == 0x000934, "Member 'ACoopGS::DepotCost' has a wrong offset!");
static_assert(offsetof(ACoopGS, CurrentPersonnel) == 0x000938, "Member 'ACoopGS::CurrentPersonnel' has a wrong offset!");
static_assert(offsetof(ACoopGS, CurrentUsedPersonnelPoints) == 0x00093C, "Member 'ACoopGS::CurrentUsedPersonnelPoints' has a wrong offset!");
static_assert(offsetof(ACoopGS, PersonnelMapping) == 0x000940, "Member 'ACoopGS::PersonnelMapping' has a wrong offset!");
static_assert(offsetof(ACoopGS, TotalAIOfficers) == 0x000990, "Member 'ACoopGS::TotalAIOfficers' has a wrong offset!");
static_assert(offsetof(ACoopGS, TotalOfficers) == 0x000994, "Member 'ACoopGS::TotalOfficers' has a wrong offset!");
static_assert(offsetof(ACoopGS, NumCompleteExtraObjectives) == 0x000998, "Member 'ACoopGS::NumCompleteExtraObjectives' has a wrong offset!");
static_assert(offsetof(ACoopGS, NumTotalExtraObjectives) == 0x00099C, "Member 'ACoopGS::NumTotalExtraObjectives' has a wrong offset!");
static_assert(offsetof(ACoopGS, TeamKills) == 0x0009A0, "Member 'ACoopGS::TeamKills' has a wrong offset!");
static_assert(offsetof(ACoopGS, bAllPlayerCharactesDead) == 0x0009A4, "Member 'ACoopGS::bAllPlayerCharactesDead' has a wrong offset!");
static_assert(offsetof(ACoopGS, SquadPointsRemaining) == 0x0009A8, "Member 'ACoopGS::SquadPointsRemaining' has a wrong offset!");
static_assert(offsetof(ACoopGS, SelectedRedSpawnPoint) == 0x0009AC, "Member 'ACoopGS::SelectedRedSpawnPoint' has a wrong offset!");
static_assert(offsetof(ACoopGS, RedSpawnSquadPoints) == 0x0009B0, "Member 'ACoopGS::RedSpawnSquadPoints' has a wrong offset!");
static_assert(offsetof(ACoopGS, SelectedBlueSpawnPoint) == 0x0009B4, "Member 'ACoopGS::SelectedBlueSpawnPoint' has a wrong offset!");
static_assert(offsetof(ACoopGS, BlueSpawnSquadPoints) == 0x0009B8, "Member 'ACoopGS::BlueSpawnSquadPoints' has a wrong offset!");
static_assert(offsetof(ACoopGS, missionMusic) == 0x0009C0, "Member 'ACoopGS::missionMusic' has a wrong offset!");
static_assert(offsetof(ACoopGS, musicInstance) == 0x0009C8, "Member 'ACoopGS::musicInstance' has a wrong offset!");
static_assert(offsetof(ACoopGS, PromotedLeaderFormat) == 0x0009D0, "Member 'ACoopGS::PromotedLeaderFormat' has a wrong offset!");
static_assert(offsetof(ACoopGS, YesVotes) == 0x0009E8, "Member 'ACoopGS::YesVotes' has a wrong offset!");
static_assert(offsetof(ACoopGS, NoVotes) == 0x0009EC, "Member 'ACoopGS::NoVotes' has a wrong offset!");
static_assert(offsetof(ACoopGS, TOCDelay) == 0x000A00, "Member 'ACoopGS::TOCDelay' has a wrong offset!");

// Class ReadyOrNot.CommanderGS
// 0x0000 (0x0A08 - 0x0A08)
class ACommanderGS final : public ACoopGS
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommanderGS">();
	}
	static class ACommanderGS* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACommanderGS>();
	}
};
static_assert(alignof(ACommanderGS) == 0x000008, "Wrong alignment on ACommanderGS");
static_assert(sizeof(ACommanderGS) == 0x000A08, "Wrong size on ACommanderGS");

// Class ReadyOrNot.Elevator
// 0x0070 (0x0308 - 0x0298)
class AElevator final : public AActor
{
public:
	class USplineComponent*                       ElevatorPath;                                      // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMoveElevator;                                     // 0x02A0(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCloseDoors;                                       // 0x02A1(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A2[0x6];                                      // 0x02A2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 ElevatorMesh;                                      // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODAudioComponent*                    DestinationReachedSound;                           // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODAudioComponent*                    FloorReachedSound;                                 // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODAudioComponent*                    DoorOpenSoundFMOD;                                 // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODAudioComponent*                    DoorCloseSoundFMOD;                                // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DefaultElevatorLoc;                                // 0x02D0(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Floors;                                            // 0x02E8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ElevatorSpeed;                                     // 0x02EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentFloor;                                      // 0x02F0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveElevatorDelay;                                 // 0x02F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerHandle                           MoveElevatorDelay_Handle;                          // 0x02F8(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SelectedFloor;                                     // 0x0300(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_304[0x4];                                      // 0x0304(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Multicast_PlayDestinationReachedSound();
	void Multicast_PlayDoorCloseSound();
	void Multicast_PlayDoorOpenSound();
	void Multicast_PlayFloorReachedSound();
	void Server_OpenCloseDoors(bool bShouldCloseDoors);
	void Server_SetSelectedFloor(int32 Floor);
	void SetSelectedFloor(int32 Floor);
	void StartMovingElevator();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Elevator">();
	}
	static class AElevator* GetDefaultObj()
	{
		return GetDefaultObjImpl<AElevator>();
	}
};
static_assert(alignof(AElevator) == 0x000008, "Wrong alignment on AElevator");
static_assert(sizeof(AElevator) == 0x000308, "Wrong size on AElevator");
static_assert(offsetof(AElevator, ElevatorPath) == 0x000298, "Member 'AElevator::ElevatorPath' has a wrong offset!");
static_assert(offsetof(AElevator, bMoveElevator) == 0x0002A0, "Member 'AElevator::bMoveElevator' has a wrong offset!");
static_assert(offsetof(AElevator, bCloseDoors) == 0x0002A1, "Member 'AElevator::bCloseDoors' has a wrong offset!");
static_assert(offsetof(AElevator, ElevatorMesh) == 0x0002A8, "Member 'AElevator::ElevatorMesh' has a wrong offset!");
static_assert(offsetof(AElevator, DestinationReachedSound) == 0x0002B0, "Member 'AElevator::DestinationReachedSound' has a wrong offset!");
static_assert(offsetof(AElevator, FloorReachedSound) == 0x0002B8, "Member 'AElevator::FloorReachedSound' has a wrong offset!");
static_assert(offsetof(AElevator, DoorOpenSoundFMOD) == 0x0002C0, "Member 'AElevator::DoorOpenSoundFMOD' has a wrong offset!");
static_assert(offsetof(AElevator, DoorCloseSoundFMOD) == 0x0002C8, "Member 'AElevator::DoorCloseSoundFMOD' has a wrong offset!");
static_assert(offsetof(AElevator, DefaultElevatorLoc) == 0x0002D0, "Member 'AElevator::DefaultElevatorLoc' has a wrong offset!");
static_assert(offsetof(AElevator, Floors) == 0x0002E8, "Member 'AElevator::Floors' has a wrong offset!");
static_assert(offsetof(AElevator, ElevatorSpeed) == 0x0002EC, "Member 'AElevator::ElevatorSpeed' has a wrong offset!");
static_assert(offsetof(AElevator, CurrentFloor) == 0x0002F0, "Member 'AElevator::CurrentFloor' has a wrong offset!");
static_assert(offsetof(AElevator, MoveElevatorDelay) == 0x0002F4, "Member 'AElevator::MoveElevatorDelay' has a wrong offset!");
static_assert(offsetof(AElevator, MoveElevatorDelay_Handle) == 0x0002F8, "Member 'AElevator::MoveElevatorDelay_Handle' has a wrong offset!");
static_assert(offsetof(AElevator, SelectedFloor) == 0x000300, "Member 'AElevator::SelectedFloor' has a wrong offset!");

// Class ReadyOrNot.CommanderProfile
// 0x01A8 (0x0468 - 0x02C0)
class UCommanderProfile final : public UBaseProfile
{
public:
	int32                                         CommanderVersion;                                  // 0x02C0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C4[0x4];                                      // 0x02C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCampaignData*                          Campaign;                                          // 0x02C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         CompletedLevels;                                   // 0x02D0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         CompletedIronmanLevels;                            // 0x02E0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         LostOfficers;                                      // 0x02F0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F4[0x4];                                      // 0x02F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         NewCompletedLevels;                                // 0x02F8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TSet<class FName>                             ProgressionTags;                                   // 0x0308(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FDateTime                              SaveDate;                                          // 0x0358(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimespan                              TotalPlaytime;                                     // 0x0360(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIronmanMode;                                      // 0x0368(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsModded;                                         // 0x0369(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36A[0x2];                                      // 0x036A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         GameChecksum;                                      // 0x036C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReturningFromMission;                             // 0x0370(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_371[0x7];                                      // 0x0371(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRosterSaveData                        RosterSaveData;                                    // 0x0378(0x0080)(NativeAccessSpecifierPublic)
	struct FLobbySaveData                         LobbySaveData;                                     // 0x03F8(0x0060)(NativeAccessSpecifierPublic)
	uint8                                         Pad_458[0x10];                                     // 0x0458(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UCommanderProfile* GetDebugProfile();
	static class UCommanderProfile* LoadProfile(int32 Slot);

	void DeleteProfile();

	float GetCompletionPercentage() const;
	TSoftObjectPtr<class UTexture2D> GetMostRecentLevelImage() const;
	class FText GetMostRecentLevelName(const class FText& NothingCompletedText) const;
	class FString GetNextLevel() const;
	TSoftObjectPtr<class UTexture2D> GetNextLevelImage() const;
	class FText GetNextLevelName(const class FText& CompletedText) const;
	bool IsChecksumMismatched() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommanderProfile">();
	}
	static class UCommanderProfile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommanderProfile>();
	}
};
static_assert(alignof(UCommanderProfile) == 0x000008, "Wrong alignment on UCommanderProfile");
static_assert(sizeof(UCommanderProfile) == 0x000468, "Wrong size on UCommanderProfile");
static_assert(offsetof(UCommanderProfile, CommanderVersion) == 0x0002C0, "Member 'UCommanderProfile::CommanderVersion' has a wrong offset!");
static_assert(offsetof(UCommanderProfile, Campaign) == 0x0002C8, "Member 'UCommanderProfile::Campaign' has a wrong offset!");
static_assert(offsetof(UCommanderProfile, CompletedLevels) == 0x0002D0, "Member 'UCommanderProfile::CompletedLevels' has a wrong offset!");
static_assert(offsetof(UCommanderProfile, CompletedIronmanLevels) == 0x0002E0, "Member 'UCommanderProfile::CompletedIronmanLevels' has a wrong offset!");
static_assert(offsetof(UCommanderProfile, LostOfficers) == 0x0002F0, "Member 'UCommanderProfile::LostOfficers' has a wrong offset!");
static_assert(offsetof(UCommanderProfile, NewCompletedLevels) == 0x0002F8, "Member 'UCommanderProfile::NewCompletedLevels' has a wrong offset!");
static_assert(offsetof(UCommanderProfile, ProgressionTags) == 0x000308, "Member 'UCommanderProfile::ProgressionTags' has a wrong offset!");
static_assert(offsetof(UCommanderProfile, SaveDate) == 0x000358, "Member 'UCommanderProfile::SaveDate' has a wrong offset!");
static_assert(offsetof(UCommanderProfile, TotalPlaytime) == 0x000360, "Member 'UCommanderProfile::TotalPlaytime' has a wrong offset!");
static_assert(offsetof(UCommanderProfile, bIronmanMode) == 0x000368, "Member 'UCommanderProfile::bIronmanMode' has a wrong offset!");
static_assert(offsetof(UCommanderProfile, bIsModded) == 0x000369, "Member 'UCommanderProfile::bIsModded' has a wrong offset!");
static_assert(offsetof(UCommanderProfile, GameChecksum) == 0x00036C, "Member 'UCommanderProfile::GameChecksum' has a wrong offset!");
static_assert(offsetof(UCommanderProfile, bReturningFromMission) == 0x000370, "Member 'UCommanderProfile::bReturningFromMission' has a wrong offset!");
static_assert(offsetof(UCommanderProfile, RosterSaveData) == 0x000378, "Member 'UCommanderProfile::RosterSaveData' has a wrong offset!");
static_assert(offsetof(UCommanderProfile, LobbySaveData) == 0x0003F8, "Member 'UCommanderProfile::LobbySaveData' has a wrong offset!");

// Class ReadyOrNot.TOCManager
// 0x0058 (0x02F0 - 0x0298)
class ATOCManager final : public AActor
{
public:
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        SceneComponent;                                    // 0x02A0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundSource*                           VoiceSoundSource;                                  // 0x02A8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODEvent*                             TocEvent;                                          // 0x02B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTOCData                               CurrentTOCData;                                    // 0x02B8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<struct FTOCData>                       QueuedTOCData;                                     // 0x02E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, Protected, NativeAccessSpecifierProtected)

public:
	static class ATOCManager* Get();

	void IterateTOCQueue();
	void Multicast_PlayTOCSound2D(const class FString& Filename, const class FString& Speaker);
	void StartTOCResponse(const class FString& Line, bool bIsNetworked, ETOCPriority Priority);
	void StartTOCResponseWithSpeaker(const class FString& Line, const class FString& Speaker, bool bIsNetworked, ETOCPriority Priority);
	void StopTOCAudio(bool bClearQueue);

	bool IsTOCSpeaking() const;
	bool IsTOCSpeakingLine(const class FString& Line) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TOCManager">();
	}
	static class ATOCManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATOCManager>();
	}
};
static_assert(alignof(ATOCManager) == 0x000008, "Wrong alignment on ATOCManager");
static_assert(sizeof(ATOCManager) == 0x0002F0, "Wrong size on ATOCManager");
static_assert(offsetof(ATOCManager, SceneComponent) == 0x0002A0, "Member 'ATOCManager::SceneComponent' has a wrong offset!");
static_assert(offsetof(ATOCManager, VoiceSoundSource) == 0x0002A8, "Member 'ATOCManager::VoiceSoundSource' has a wrong offset!");
static_assert(offsetof(ATOCManager, TocEvent) == 0x0002B0, "Member 'ATOCManager::TocEvent' has a wrong offset!");
static_assert(offsetof(ATOCManager, CurrentTOCData) == 0x0002B8, "Member 'ATOCManager::CurrentTOCData' has a wrong offset!");
static_assert(offsetof(ATOCManager, QueuedTOCData) == 0x0002E0, "Member 'ATOCManager::QueuedTOCData' has a wrong offset!");

// Class ReadyOrNot.CommandInterface
// 0x0040 (0x0300 - 0x02C0)
class UCommandInterface : public UUserWidget
{
public:
	class UImage*                                 SelectionLeft;                                     // 0x02C0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 SelectionRight;                                    // 0x02C8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 SelectionUp;                                       // 0x02D0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 SelectionDown;                                     // 0x02D8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 MoveIn;                                            // 0x02E0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 FallIn;                                            // 0x02E8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Cover;                                             // 0x02F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Deploy;                                            // 0x02F8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void DisableSelectionWidgets();
	void EnableSelectionWidgets(const struct FVector2D& Selection);
	void SetBlueColor();
	void SetGoldColor();
	void SetRedColor();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandInterface">();
	}
	static class UCommandInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandInterface>();
	}
};
static_assert(alignof(UCommandInterface) == 0x000008, "Wrong alignment on UCommandInterface");
static_assert(sizeof(UCommandInterface) == 0x000300, "Wrong size on UCommandInterface");
static_assert(offsetof(UCommandInterface, SelectionLeft) == 0x0002C0, "Member 'UCommandInterface::SelectionLeft' has a wrong offset!");
static_assert(offsetof(UCommandInterface, SelectionRight) == 0x0002C8, "Member 'UCommandInterface::SelectionRight' has a wrong offset!");
static_assert(offsetof(UCommandInterface, SelectionUp) == 0x0002D0, "Member 'UCommandInterface::SelectionUp' has a wrong offset!");
static_assert(offsetof(UCommandInterface, SelectionDown) == 0x0002D8, "Member 'UCommandInterface::SelectionDown' has a wrong offset!");
static_assert(offsetof(UCommandInterface, MoveIn) == 0x0002E0, "Member 'UCommandInterface::MoveIn' has a wrong offset!");
static_assert(offsetof(UCommandInterface, FallIn) == 0x0002E8, "Member 'UCommandInterface::FallIn' has a wrong offset!");
static_assert(offsetof(UCommandInterface, Cover) == 0x0002F0, "Member 'UCommandInterface::Cover' has a wrong offset!");
static_assert(offsetof(UCommandInterface, Deploy) == 0x0002F8, "Member 'UCommandInterface::Deploy' has a wrong offset!");

// Class ReadyOrNot.CommandWheel
// 0x0268 (0x0528 - 0x02C0)
class UCommandWheel : public UUserWidget
{
public:
	class UDataTable*                             CommandWheelIcons;                                 // 0x02C0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReadyOrNotCommandFunctionLibrary*      CommandLibrary;                                    // 0x02C8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ABaseGrenade>               Flashbang;                                         // 0x02D0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ABaseGrenade>               Stinger;                                           // 0x02D8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ABaseGrenade>               CSGas;                                             // 0x02E0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           RedColor;                                          // 0x02E8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           BlueColor;                                         // 0x02F8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           GoldColor;                                         // 0x0308(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           WhiteColor;                                        // 0x0318(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentIndex;                                      // 0x0328(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_32C[0x4];                                      // 0x032C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UOverlay*                               QueueTextContainer;                                // 0x0330(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         QueueText;                                         // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidget*                            InnerWheel;                                        // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidget*                            OuterWheel;                                        // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         OptionLabel;                                       // 0x0350(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               HeaderOverlay;                                     // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           FreeViewInstructionsCanvasPanel;                   // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         QueueText_1;                                       // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGamepadButtonImage*                    NavigateBackImage;                                 // 0x0370(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<bool>                                  bCommandEnabled;                                   // 0x0378(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_388[0x1A0];                                    // 0x0388(0x01A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AnimateWheelUpdate();
	void CommandWheelDisabled();
	void CommandWheelEnabled();
	void DisableOuterWheel();
	void ForceSetInDeadzone(bool bInDeadzone);
	struct FLinearColor GetBlueColor();
	struct FLinearColor GetGoldColor();
	struct FSlateBrush GetIconForCommand(const struct FSwatCommand& Command);
	struct FLinearColor GetRedColor();
	struct FLinearColor GetWhiteColor();
	void SetInnerCommands(const TArray<struct FSwatCommand>& Options);
	void SetInnerSegments(int32 Num);
	void SetInnerWheelDirection(const struct FVector& Direction);
	void SetOuterSegments(int32 Num);
	void UpdateIconColors();
	void UpdateOuterWheel(const struct FVector& Direction, const TArray<struct FSwatCommand>& Options, const int32 SelectedIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandWheel">();
	}
	static class UCommandWheel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandWheel>();
	}
};
static_assert(alignof(UCommandWheel) == 0x000008, "Wrong alignment on UCommandWheel");
static_assert(sizeof(UCommandWheel) == 0x000528, "Wrong size on UCommandWheel");
static_assert(offsetof(UCommandWheel, CommandWheelIcons) == 0x0002C0, "Member 'UCommandWheel::CommandWheelIcons' has a wrong offset!");
static_assert(offsetof(UCommandWheel, CommandLibrary) == 0x0002C8, "Member 'UCommandWheel::CommandLibrary' has a wrong offset!");
static_assert(offsetof(UCommandWheel, Flashbang) == 0x0002D0, "Member 'UCommandWheel::Flashbang' has a wrong offset!");
static_assert(offsetof(UCommandWheel, Stinger) == 0x0002D8, "Member 'UCommandWheel::Stinger' has a wrong offset!");
static_assert(offsetof(UCommandWheel, CSGas) == 0x0002E0, "Member 'UCommandWheel::CSGas' has a wrong offset!");
static_assert(offsetof(UCommandWheel, RedColor) == 0x0002E8, "Member 'UCommandWheel::RedColor' has a wrong offset!");
static_assert(offsetof(UCommandWheel, BlueColor) == 0x0002F8, "Member 'UCommandWheel::BlueColor' has a wrong offset!");
static_assert(offsetof(UCommandWheel, GoldColor) == 0x000308, "Member 'UCommandWheel::GoldColor' has a wrong offset!");
static_assert(offsetof(UCommandWheel, WhiteColor) == 0x000318, "Member 'UCommandWheel::WhiteColor' has a wrong offset!");
static_assert(offsetof(UCommandWheel, CurrentIndex) == 0x000328, "Member 'UCommandWheel::CurrentIndex' has a wrong offset!");
static_assert(offsetof(UCommandWheel, QueueTextContainer) == 0x000330, "Member 'UCommandWheel::QueueTextContainer' has a wrong offset!");
static_assert(offsetof(UCommandWheel, QueueText) == 0x000338, "Member 'UCommandWheel::QueueText' has a wrong offset!");
static_assert(offsetof(UCommandWheel, InnerWheel) == 0x000340, "Member 'UCommandWheel::InnerWheel' has a wrong offset!");
static_assert(offsetof(UCommandWheel, OuterWheel) == 0x000348, "Member 'UCommandWheel::OuterWheel' has a wrong offset!");
static_assert(offsetof(UCommandWheel, OptionLabel) == 0x000350, "Member 'UCommandWheel::OptionLabel' has a wrong offset!");
static_assert(offsetof(UCommandWheel, HeaderOverlay) == 0x000358, "Member 'UCommandWheel::HeaderOverlay' has a wrong offset!");
static_assert(offsetof(UCommandWheel, FreeViewInstructionsCanvasPanel) == 0x000360, "Member 'UCommandWheel::FreeViewInstructionsCanvasPanel' has a wrong offset!");
static_assert(offsetof(UCommandWheel, QueueText_1) == 0x000368, "Member 'UCommandWheel::QueueText_1' has a wrong offset!");
static_assert(offsetof(UCommandWheel, NavigateBackImage) == 0x000370, "Member 'UCommandWheel::NavigateBackImage' has a wrong offset!");
static_assert(offsetof(UCommandWheel, bCommandEnabled) == 0x000378, "Member 'UCommandWheel::bCommandEnabled' has a wrong offset!");

// Class ReadyOrNot.CommitSuicideActivity
// 0x0030 (0x0220 - 0x01F0)
class UCommitSuicideActivity final : public UBaseActivity
{
public:
	uint8                                         Pad_1F0[0x30];                                     // 0x01F0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDamaged(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* DamagedCharacter, class AActor* DamageCauser, float Damage, float HealthRemaining);
	void OnHeardYell(class AReadyOrNotCharacter* Shouter, bool bLOS);
	void OnMeleeHitTaken(class AReadyOrNotCharacter* InstigatorCharacter);
	void OnStunned(class AReadyOrNotCharacter* StunnedCharacter, float Duration, EStunType StunType, class AActor* DamageCauser);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommitSuicideActivity">();
	}
	static class UCommitSuicideActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommitSuicideActivity>();
	}
};
static_assert(alignof(UCommitSuicideActivity) == 0x000008, "Wrong alignment on UCommitSuicideActivity");
static_assert(sizeof(UCommitSuicideActivity) == 0x000220, "Wrong size on UCommitSuicideActivity");

// Class ReadyOrNot.TrackingSpotlightComponent
// 0x0058 (0x00F8 - 0x00A0)
class UTrackingSpotlightComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(float Attenuation)> OnAttenuationSet;                              // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class URadialTrackingComponent*               TrackingComponent;                                 // 0x00B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMeshComponent*                         MeshComponent;                                     // 0x00B8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDiegeticSoundComponent*                SpotlightOnSound;                                  // 0x00C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDiegeticSoundComponent*                SpotlightOffSound;                                 // 0x00C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        SpotlightRootComponent;                            // 0x00D0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpotLightComponent*                    SpotLightComponent;                                // 0x00D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     SpotlightOnMaterial;                               // 0x00E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     SpotlightOffMaterial;                              // 0x00E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpotlightIntensity;                                // 0x00F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F4[0x4];                                       // 0x00F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Initialise(const struct FTrackingSpotlightInitStruct& initStruct);
	void OnTargetFound(class ACyberneticCharacter* Target);
	void OnTargetLost(ETrackingTargetLoseReason LoseReason);
	void SetAttenuation(float Attenuation);
	void Stop();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TrackingSpotlightComponent">();
	}
	static class UTrackingSpotlightComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTrackingSpotlightComponent>();
	}
};
static_assert(alignof(UTrackingSpotlightComponent) == 0x000008, "Wrong alignment on UTrackingSpotlightComponent");
static_assert(sizeof(UTrackingSpotlightComponent) == 0x0000F8, "Wrong size on UTrackingSpotlightComponent");
static_assert(offsetof(UTrackingSpotlightComponent, OnAttenuationSet) == 0x0000A0, "Member 'UTrackingSpotlightComponent::OnAttenuationSet' has a wrong offset!");
static_assert(offsetof(UTrackingSpotlightComponent, TrackingComponent) == 0x0000B0, "Member 'UTrackingSpotlightComponent::TrackingComponent' has a wrong offset!");
static_assert(offsetof(UTrackingSpotlightComponent, MeshComponent) == 0x0000B8, "Member 'UTrackingSpotlightComponent::MeshComponent' has a wrong offset!");
static_assert(offsetof(UTrackingSpotlightComponent, SpotlightOnSound) == 0x0000C0, "Member 'UTrackingSpotlightComponent::SpotlightOnSound' has a wrong offset!");
static_assert(offsetof(UTrackingSpotlightComponent, SpotlightOffSound) == 0x0000C8, "Member 'UTrackingSpotlightComponent::SpotlightOffSound' has a wrong offset!");
static_assert(offsetof(UTrackingSpotlightComponent, SpotlightRootComponent) == 0x0000D0, "Member 'UTrackingSpotlightComponent::SpotlightRootComponent' has a wrong offset!");
static_assert(offsetof(UTrackingSpotlightComponent, SpotLightComponent) == 0x0000D8, "Member 'UTrackingSpotlightComponent::SpotLightComponent' has a wrong offset!");
static_assert(offsetof(UTrackingSpotlightComponent, SpotlightOnMaterial) == 0x0000E0, "Member 'UTrackingSpotlightComponent::SpotlightOnMaterial' has a wrong offset!");
static_assert(offsetof(UTrackingSpotlightComponent, SpotlightOffMaterial) == 0x0000E8, "Member 'UTrackingSpotlightComponent::SpotlightOffMaterial' has a wrong offset!");
static_assert(offsetof(UTrackingSpotlightComponent, SpotlightIntensity) == 0x0000F0, "Member 'UTrackingSpotlightComponent::SpotlightIntensity' has a wrong offset!");

// Class ReadyOrNot.CommonFooterActionWidget
// 0x0018 (0x0300 - 0x02E8)
class UCommonFooterActionWidget : public UCommonUserWidget
{
public:
	TArray<struct FDataTableRowHandle>            InputActions;                                      // 0x02E8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIsDynamicIcon;                                    // 0x02F8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequiresHold;                                     // 0x02F9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FA[0x6];                                      // 0x02FA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DetermineInputIconType();
	void GenerateDynamicIcon(const struct FKey& ActionKey, bool IsGamepad);
	struct FSlateBrush GetActionWidgetBrush(class UCommonActionWidget* InCommonActionWidget);
	struct FKey GetInputActionKey(const struct FDataTableRowHandle& InputActionRow);
	void OnActionProgress(float HeldPercent);
	void SetInputAction(const struct FDataTableRowHandle& InInputAction);
	void SetInputActions(const TArray<struct FDataTableRowHandle>& InInputActions);
	void UpdateInputActionWidget();
	void UpdateInputWidgetProgress(class UCommonActionWidget* InputActionWidget, float HeldPercent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommonFooterActionWidget">();
	}
	static class UCommonFooterActionWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommonFooterActionWidget>();
	}
};
static_assert(alignof(UCommonFooterActionWidget) == 0x000008, "Wrong alignment on UCommonFooterActionWidget");
static_assert(sizeof(UCommonFooterActionWidget) == 0x000300, "Wrong size on UCommonFooterActionWidget");
static_assert(offsetof(UCommonFooterActionWidget, InputActions) == 0x0002E8, "Member 'UCommonFooterActionWidget::InputActions' has a wrong offset!");
static_assert(offsetof(UCommonFooterActionWidget, bIsDynamicIcon) == 0x0002F8, "Member 'UCommonFooterActionWidget::bIsDynamicIcon' has a wrong offset!");
static_assert(offsetof(UCommonFooterActionWidget, bRequiresHold) == 0x0002F9, "Member 'UCommonFooterActionWidget::bRequiresHold' has a wrong offset!");

// Class ReadyOrNot.CommonFooterWidget
// 0x0048 (0x0458 - 0x0410)
class UCommonFooterWidget : public UCommonActivatableWidget
{
public:
	TMulticastInlineDelegate<void()>              OnDismissInputAction;                              // 0x0410(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    DismissInputActionSettings;                        // 0x0420(0x0010)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bConsumeInput;                                     // 0x0430(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsPersistent;                                     // 0x0431(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOverrideInputActionText;                          // 0x0432(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_433[0x5];                                      // 0x0433(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   OverrideInputActionText;                           // 0x0438(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_450[0x4];                                      // 0x0450(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bUsingGamepad;                                     // 0x0454(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_455[0x3];                                      // 0x0455(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_DismissInputActionProgress(float HeldTime);
	void BP_OnDismissInputAction();
	void OnDismissInputActionNative();
	void OnDismissInputActionProgressNative(float HeldPercent);
	void OnInputMethodChanged(const ECommonInputType InputMethod);
	void RefreshWidget();

	class FText GetFooterText() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommonFooterWidget">();
	}
	static class UCommonFooterWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommonFooterWidget>();
	}
};
static_assert(alignof(UCommonFooterWidget) == 0x000008, "Wrong alignment on UCommonFooterWidget");
static_assert(sizeof(UCommonFooterWidget) == 0x000458, "Wrong size on UCommonFooterWidget");
static_assert(offsetof(UCommonFooterWidget, OnDismissInputAction) == 0x000410, "Member 'UCommonFooterWidget::OnDismissInputAction' has a wrong offset!");
static_assert(offsetof(UCommonFooterWidget, DismissInputActionSettings) == 0x000420, "Member 'UCommonFooterWidget::DismissInputActionSettings' has a wrong offset!");
static_assert(offsetof(UCommonFooterWidget, bConsumeInput) == 0x000430, "Member 'UCommonFooterWidget::bConsumeInput' has a wrong offset!");
static_assert(offsetof(UCommonFooterWidget, bIsPersistent) == 0x000431, "Member 'UCommonFooterWidget::bIsPersistent' has a wrong offset!");
static_assert(offsetof(UCommonFooterWidget, bOverrideInputActionText) == 0x000432, "Member 'UCommonFooterWidget::bOverrideInputActionText' has a wrong offset!");
static_assert(offsetof(UCommonFooterWidget, OverrideInputActionText) == 0x000438, "Member 'UCommonFooterWidget::OverrideInputActionText' has a wrong offset!");
static_assert(offsetof(UCommonFooterWidget, bUsingGamepad) == 0x000454, "Member 'UCommonFooterWidget::bUsingGamepad' has a wrong offset!");

// Class ReadyOrNot.CommonIconButtonBase
// 0x0000 (0x15D0 - 0x15D0)
class UCommonIconButtonBase final : public UCommonBoundActionButton
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommonIconButtonBase">();
	}
	static class UCommonIconButtonBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommonIconButtonBase>();
	}
};
static_assert(alignof(UCommonIconButtonBase) == 0x000010, "Wrong alignment on UCommonIconButtonBase");
static_assert(sizeof(UCommonIconButtonBase) == 0x0015D0, "Wrong size on UCommonIconButtonBase");

// Class ReadyOrNot.TrainingGS
// 0x0008 (0x0900 - 0x08F8)
class ATrainingGS final : public AReadyOrNotGameState
{
public:
	uint8                                         Pad_8F8[0x8];                                      // 0x08F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TrainingGS">();
	}
	static class ATrainingGS* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATrainingGS>();
	}
};
static_assert(alignof(ATrainingGS) == 0x000008, "Wrong alignment on ATrainingGS");
static_assert(sizeof(ATrainingGS) == 0x000900, "Wrong size on ATrainingGS");

// Class ReadyOrNot.CommonInputReadyOrNotControllerData
// 0x0008 (0x0108 - 0x0100)
class UCommonInputReadyOrNotControllerData : public UCommonInputBaseControllerData
{
public:
	TSubclassOf<class UCommonInputBaseControllerData> ModioControllerData;                           // 0x0100(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommonInputReadyOrNotControllerData">();
	}
	static class UCommonInputReadyOrNotControllerData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommonInputReadyOrNotControllerData>();
	}
};
static_assert(alignof(UCommonInputReadyOrNotControllerData) == 0x000008, "Wrong alignment on UCommonInputReadyOrNotControllerData");
static_assert(sizeof(UCommonInputReadyOrNotControllerData) == 0x000108, "Wrong size on UCommonInputReadyOrNotControllerData");
static_assert(offsetof(UCommonInputReadyOrNotControllerData, ModioControllerData) == 0x000100, "Member 'UCommonInputReadyOrNotControllerData::ModioControllerData' has a wrong offset!");

// Class ReadyOrNot.ExfilActor
// 0x0020 (0x02B8 - 0x0298)
class AExfilActor final : public AActor
{
public:
	uint8                                         Pad_298[0x10];                                     // 0x0298(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   BaseMesh;                                          // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B0[0x8];                                      // 0x02B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExfilActor">();
	}
	static class AExfilActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AExfilActor>();
	}
};
static_assert(alignof(AExfilActor) == 0x000008, "Wrong alignment on AExfilActor");
static_assert(sizeof(AExfilActor) == 0x0002B8, "Wrong size on AExfilActor");
static_assert(offsetof(AExfilActor, BaseMesh) == 0x0002A8, "Member 'AExfilActor::BaseMesh' has a wrong offset!");

// Class ReadyOrNot.CommonInputRichTextDecorator
// 0x0000 (0x0028 - 0x0028)
class UCommonInputRichTextDecorator : public URichTextBlockDecorator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommonInputRichTextDecorator">();
	}
	static class UCommonInputRichTextDecorator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommonInputRichTextDecorator>();
	}
};
static_assert(alignof(UCommonInputRichTextDecorator) == 0x000008, "Wrong alignment on UCommonInputRichTextDecorator");
static_assert(sizeof(UCommonInputRichTextDecorator) == 0x000028, "Wrong size on UCommonInputRichTextDecorator");

// Class ReadyOrNot.CommonRichTextBlockImageDecorator
// 0x0050 (0x0080 - 0x0030)
class UCommonRichTextBlockImageDecorator : public URichTextBlockImageDecorator
{
public:
	uint8                                         Pad_30[0x50];                                      // 0x0030(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommonRichTextBlockImageDecorator">();
	}
	static class UCommonRichTextBlockImageDecorator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommonRichTextBlockImageDecorator>();
	}
};
static_assert(alignof(UCommonRichTextBlockImageDecorator) == 0x000008, "Wrong alignment on UCommonRichTextBlockImageDecorator");
static_assert(sizeof(UCommonRichTextBlockImageDecorator) == 0x000080, "Wrong size on UCommonRichTextBlockImageDecorator");

// Class ReadyOrNot.TrapDamage
// 0x0008 (0x0048 - 0x0040)
class UTrapDamage final : public UDamageType
{
public:
	uint8                                         bDestroyAllDoorChunks : 1;                         // 0x0040(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TrapDamage">();
	}
	static class UTrapDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTrapDamage>();
	}
};
static_assert(alignof(UTrapDamage) == 0x000008, "Wrong alignment on UTrapDamage");
static_assert(sizeof(UTrapDamage) == 0x000048, "Wrong size on UTrapDamage");

// Class ReadyOrNot.CommonTabListAnimationSwitcher
// 0x0000 (0x0220 - 0x0220)
class UCommonTabListAnimationSwitcher final : public UCommonAnimatedSwitcher
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommonTabListAnimationSwitcher">();
	}
	static class UCommonTabListAnimationSwitcher* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommonTabListAnimationSwitcher>();
	}
};
static_assert(alignof(UCommonTabListAnimationSwitcher) == 0x000008, "Wrong alignment on UCommonTabListAnimationSwitcher");
static_assert(sizeof(UCommonTabListAnimationSwitcher) == 0x000220, "Wrong size on UCommonTabListAnimationSwitcher");

// Class ReadyOrNot.CompetitionHelperLib
// 0x0000 (0x0028 - 0x0028)
class UCompetitionHelperLib final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CompetitionHelperLib">();
	}
	static class UCompetitionHelperLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCompetitionHelperLib>();
	}
};
static_assert(alignof(UCompetitionHelperLib) == 0x000008, "Wrong alignment on UCompetitionHelperLib");
static_assert(sizeof(UCompetitionHelperLib) == 0x000028, "Wrong size on UCompetitionHelperLib");

// Class ReadyOrNot.EvidenceExtractionDevice
// 0x0020 (0x02B8 - 0x0298)
class AEvidenceExtractionDevice : public AActor
{
public:
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractableComponent*                 InteractableComponent;                             // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EvidenceExtractionTime;                            // 0x02B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B4[0x4];                                      // 0x02B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void TryExtractEvidence(class APlayerCharacter* EvidencePossessor);

	bool CanCollectEvidence() const;
	bool CanStartExtraction() const;
	bool HasEvidenceToExtract() const;
	bool IsExtracting() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EvidenceExtractionDevice">();
	}
	static class AEvidenceExtractionDevice* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEvidenceExtractionDevice>();
	}
};
static_assert(alignof(AEvidenceExtractionDevice) == 0x000008, "Wrong alignment on AEvidenceExtractionDevice");
static_assert(sizeof(AEvidenceExtractionDevice) == 0x0002B8, "Wrong size on AEvidenceExtractionDevice");
static_assert(offsetof(AEvidenceExtractionDevice, StaticMeshComponent) == 0x0002A0, "Member 'AEvidenceExtractionDevice::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AEvidenceExtractionDevice, InteractableComponent) == 0x0002A8, "Member 'AEvidenceExtractionDevice::InteractableComponent' has a wrong offset!");
static_assert(offsetof(AEvidenceExtractionDevice, EvidenceExtractionTime) == 0x0002B0, "Member 'AEvidenceExtractionDevice::EvidenceExtractionTime' has a wrong offset!");

// Class ReadyOrNot.EvidenceExtractionDevice_Incrim
// 0x0028 (0x02E0 - 0x02B8)
class AEvidenceExtractionDevice_Incrim final : public AEvidenceExtractionDevice
{
public:
	class UObjectiveMarkerComponent*              ObjectiveMarkerComponent;                          // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UObjectiveMarkerComponent*              ObjectiveMarkerComponent_WayPoint;                 // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMapActorComponent*                     MapActorComponent;                                 // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 MapSectionName;                                    // 0x02D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EvidenceExtractionDevice_Incrim">();
	}
	static class AEvidenceExtractionDevice_Incrim* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEvidenceExtractionDevice_Incrim>();
	}
};
static_assert(alignof(AEvidenceExtractionDevice_Incrim) == 0x000008, "Wrong alignment on AEvidenceExtractionDevice_Incrim");
static_assert(sizeof(AEvidenceExtractionDevice_Incrim) == 0x0002E0, "Wrong size on AEvidenceExtractionDevice_Incrim");
static_assert(offsetof(AEvidenceExtractionDevice_Incrim, ObjectiveMarkerComponent) == 0x0002B8, "Member 'AEvidenceExtractionDevice_Incrim::ObjectiveMarkerComponent' has a wrong offset!");
static_assert(offsetof(AEvidenceExtractionDevice_Incrim, ObjectiveMarkerComponent_WayPoint) == 0x0002C0, "Member 'AEvidenceExtractionDevice_Incrim::ObjectiveMarkerComponent_WayPoint' has a wrong offset!");
static_assert(offsetof(AEvidenceExtractionDevice_Incrim, MapActorComponent) == 0x0002C8, "Member 'AEvidenceExtractionDevice_Incrim::MapActorComponent' has a wrong offset!");
static_assert(offsetof(AEvidenceExtractionDevice_Incrim, MapSectionName) == 0x0002D0, "Member 'AEvidenceExtractionDevice_Incrim::MapSectionName' has a wrong offset!");

// Class ReadyOrNot.CompliantAction
// 0x0238 (0x0290 - 0x0058)
class UCompliantAction : public UAIAction
{
public:
	bool                                          bMoveTowardSwat;                                   // 0x0058(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     DistanceToMoveSpeedCurve;                          // 0x0060(0x0088)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         SurrenderRadius;                                   // 0x00E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChanceToFake;                                      // 0x00EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChanceToDropImmediately;                           // 0x00F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChanceToDropWithoutAnimation;                      // 0x00F4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MoveStyleOverride;                                 // 0x00F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EAnimWeaponType, struct FCompliantActionAnimationArray> EntryAnimations;                    // 0x0100(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EAnimWeaponType, struct FCompliantActionAnimationArray> LoopAnimations;                     // 0x0150(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EAnimWeaponType, struct FCompliantActionAnimationArray> DropWeaponAnimations;               // 0x01A0(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EAnimWeaponType, struct FCompliantActionAnimationArray> FakeDropWeaponAnimations;           // 0x01F0(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EAnimWeaponType, struct FCompliantActionAnimationArray> PostDropLoopAnimations;             // 0x0240(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CompliantAction">();
	}
	static class UCompliantAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCompliantAction>();
	}
};
static_assert(alignof(UCompliantAction) == 0x000008, "Wrong alignment on UCompliantAction");
static_assert(sizeof(UCompliantAction) == 0x000290, "Wrong size on UCompliantAction");
static_assert(offsetof(UCompliantAction, bMoveTowardSwat) == 0x000058, "Member 'UCompliantAction::bMoveTowardSwat' has a wrong offset!");
static_assert(offsetof(UCompliantAction, DistanceToMoveSpeedCurve) == 0x000060, "Member 'UCompliantAction::DistanceToMoveSpeedCurve' has a wrong offset!");
static_assert(offsetof(UCompliantAction, SurrenderRadius) == 0x0000E8, "Member 'UCompliantAction::SurrenderRadius' has a wrong offset!");
static_assert(offsetof(UCompliantAction, ChanceToFake) == 0x0000EC, "Member 'UCompliantAction::ChanceToFake' has a wrong offset!");
static_assert(offsetof(UCompliantAction, ChanceToDropImmediately) == 0x0000F0, "Member 'UCompliantAction::ChanceToDropImmediately' has a wrong offset!");
static_assert(offsetof(UCompliantAction, ChanceToDropWithoutAnimation) == 0x0000F4, "Member 'UCompliantAction::ChanceToDropWithoutAnimation' has a wrong offset!");
static_assert(offsetof(UCompliantAction, MoveStyleOverride) == 0x0000F8, "Member 'UCompliantAction::MoveStyleOverride' has a wrong offset!");
static_assert(offsetof(UCompliantAction, EntryAnimations) == 0x000100, "Member 'UCompliantAction::EntryAnimations' has a wrong offset!");
static_assert(offsetof(UCompliantAction, LoopAnimations) == 0x000150, "Member 'UCompliantAction::LoopAnimations' has a wrong offset!");
static_assert(offsetof(UCompliantAction, DropWeaponAnimations) == 0x0001A0, "Member 'UCompliantAction::DropWeaponAnimations' has a wrong offset!");
static_assert(offsetof(UCompliantAction, FakeDropWeaponAnimations) == 0x0001F0, "Member 'UCompliantAction::FakeDropWeaponAnimations' has a wrong offset!");
static_assert(offsetof(UCompliantAction, PostDropLoopAnimations) == 0x000240, "Member 'UCompliantAction::PostDropLoopAnimations' has a wrong offset!");

// Class ReadyOrNot.SuspectCombatActivity
// 0x0020 (0x04D0 - 0x04B0)
class USuspectCombatActivity final : public UBaseCombatActivity
{
public:
	uint8                                         Pad_4B0[0x20];                                     // 0x04B0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SuspectCombatActivity">();
	}
	static class USuspectCombatActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<USuspectCombatActivity>();
	}
};
static_assert(alignof(USuspectCombatActivity) == 0x000008, "Wrong alignment on USuspectCombatActivity");
static_assert(sizeof(USuspectCombatActivity) == 0x0004D0, "Wrong size on USuspectCombatActivity");

// Class ReadyOrNot.CompliantActivity
// 0x0030 (0x0220 - 0x01F0)
class UCompliantActivity final : public UBaseActivity
{
public:
	class UCompliantAction*                       Action;                                            // 0x01F0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AReadyOrNotCharacter*                   ClosestSwat;                                       // 0x01F8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_200[0x20];                                     // 0x0200(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHeardOfficerYell(class AReadyOrNotCharacter* Shouter, bool bLOS);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CompliantActivity">();
	}
	static class UCompliantActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCompliantActivity>();
	}
};
static_assert(alignof(UCompliantActivity) == 0x000008, "Wrong alignment on UCompliantActivity");
static_assert(sizeof(UCompliantActivity) == 0x000220, "Wrong size on UCompliantActivity");
static_assert(offsetof(UCompliantActivity, Action) == 0x0001F0, "Member 'UCompliantActivity::Action' has a wrong offset!");
static_assert(offsetof(UCompliantActivity, ClosestSwat) == 0x0001F8, "Member 'UCompliantActivity::ClosestSwat' has a wrong offset!");

// Class ReadyOrNot.SuspectArmour
// 0x0090 (0x0CB0 - 0x0C20)
class ASuspectArmour : public ABaseArmour
{
public:
	struct FSuspectArmourData                     ArmourData;                                        // 0x0C20(0x0070)(Net, RepNotify, NativeAccessSpecifierPrivate)
	float                                         Durability;                                        // 0x0C90(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C94[0x4];                                      // 0x0C94(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             BlockedSoundEvent;                                 // 0x0C98(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             PenetratedSoundEvent;                              // 0x0CA0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CA8[0x8];                                      // 0x0CA8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_ArmourData();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SuspectArmour">();
	}
	static class ASuspectArmour* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASuspectArmour>();
	}
};
static_assert(alignof(ASuspectArmour) == 0x000010, "Wrong alignment on ASuspectArmour");
static_assert(sizeof(ASuspectArmour) == 0x000CB0, "Wrong size on ASuspectArmour");
static_assert(offsetof(ASuspectArmour, ArmourData) == 0x000C20, "Member 'ASuspectArmour::ArmourData' has a wrong offset!");
static_assert(offsetof(ASuspectArmour, Durability) == 0x000C90, "Member 'ASuspectArmour::Durability' has a wrong offset!");
static_assert(offsetof(ASuspectArmour, BlockedSoundEvent) == 0x000C98, "Member 'ASuspectArmour::BlockedSoundEvent' has a wrong offset!");
static_assert(offsetof(ASuspectArmour, PenetratedSoundEvent) == 0x000CA0, "Member 'ASuspectArmour::PenetratedSoundEvent' has a wrong offset!");

// Class ReadyOrNot.ConsoleContextSwitcher
// 0x0040 (0x0328 - 0x02E8)
class UConsoleContextSwitcher final : public UBaseWidget
{
public:
	class UWidgetSwitcher*                        ContextSwitcher;                                   // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UConsoleSelection*                      GrenadeSelection;                                  // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UConsoleSelection*                      TacticalSelection;                                 // 0x02F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UConsoleFireModes*                      FireModes;                                         // 0x0300(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UConsoleMagSelection*                   MagSelection;                                      // 0x0308(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       FadeIn;                                            // 0x0310(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       FadeOut;                                           // 0x0318(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_320[0x8];                                      // 0x0320(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SwapToFireModes();
	void SwapToGrenades();
	void SwapToMag(class ABaseMagazineWeapon* MagazineWeapon);
	void SwapToTactical();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConsoleContextSwitcher">();
	}
	static class UConsoleContextSwitcher* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConsoleContextSwitcher>();
	}
};
static_assert(alignof(UConsoleContextSwitcher) == 0x000008, "Wrong alignment on UConsoleContextSwitcher");
static_assert(sizeof(UConsoleContextSwitcher) == 0x000328, "Wrong size on UConsoleContextSwitcher");
static_assert(offsetof(UConsoleContextSwitcher, ContextSwitcher) == 0x0002E8, "Member 'UConsoleContextSwitcher::ContextSwitcher' has a wrong offset!");
static_assert(offsetof(UConsoleContextSwitcher, GrenadeSelection) == 0x0002F0, "Member 'UConsoleContextSwitcher::GrenadeSelection' has a wrong offset!");
static_assert(offsetof(UConsoleContextSwitcher, TacticalSelection) == 0x0002F8, "Member 'UConsoleContextSwitcher::TacticalSelection' has a wrong offset!");
static_assert(offsetof(UConsoleContextSwitcher, FireModes) == 0x000300, "Member 'UConsoleContextSwitcher::FireModes' has a wrong offset!");
static_assert(offsetof(UConsoleContextSwitcher, MagSelection) == 0x000308, "Member 'UConsoleContextSwitcher::MagSelection' has a wrong offset!");
static_assert(offsetof(UConsoleContextSwitcher, FadeIn) == 0x000310, "Member 'UConsoleContextSwitcher::FadeIn' has a wrong offset!");
static_assert(offsetof(UConsoleContextSwitcher, FadeOut) == 0x000318, "Member 'UConsoleContextSwitcher::FadeOut' has a wrong offset!");

// Class ReadyOrNot.ConsoleFireMode
// 0x0000 (0x02C0 - 0x02C0)
class UConsoleFireMode final : public UUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConsoleFireMode">();
	}
	static class UConsoleFireMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConsoleFireMode>();
	}
};
static_assert(alignof(UConsoleFireMode) == 0x000008, "Wrong alignment on UConsoleFireMode");
static_assert(sizeof(UConsoleFireMode) == 0x0002C0, "Wrong size on UConsoleFireMode");

// Class ReadyOrNot.FMODAudioPropagationComponent
// 0x0050 (0x0490 - 0x0440)
class UFMODAudioPropagationComponent final : public UFMODAudioComponent
{
public:
	uint8                                         Pad_440[0x18];                                     // 0x0440(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AudioPlayLocation;                                 // 0x0458(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         volumeToSet;                                       // 0x0470(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         silentDistance;                                    // 0x0474(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OcclusionAmount;                                   // 0x0478(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         minDistance;                                       // 0x047C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPlayPropagation;                                  // 0x0480(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_481[0xF];                                      // 0x0481(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CheckOcclusion();
	struct FFMODEventInstance PlayEvent(class UFMODEvent* EventToPlay, const struct FVector& Origin, const TArray<struct FMODParam>& Params_0);
	void PlayEventAttached(class UFMODEvent* EventToPlay, class USceneComponent* CompToAttach, class FName AttachPoint, const TArray<struct FMODParam>& Params_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FMODAudioPropagationComponent">();
	}
	static class UFMODAudioPropagationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFMODAudioPropagationComponent>();
	}
};
static_assert(alignof(UFMODAudioPropagationComponent) == 0x000010, "Wrong alignment on UFMODAudioPropagationComponent");
static_assert(sizeof(UFMODAudioPropagationComponent) == 0x000490, "Wrong size on UFMODAudioPropagationComponent");
static_assert(offsetof(UFMODAudioPropagationComponent, AudioPlayLocation) == 0x000458, "Member 'UFMODAudioPropagationComponent::AudioPlayLocation' has a wrong offset!");
static_assert(offsetof(UFMODAudioPropagationComponent, volumeToSet) == 0x000470, "Member 'UFMODAudioPropagationComponent::volumeToSet' has a wrong offset!");
static_assert(offsetof(UFMODAudioPropagationComponent, silentDistance) == 0x000474, "Member 'UFMODAudioPropagationComponent::silentDistance' has a wrong offset!");
static_assert(offsetof(UFMODAudioPropagationComponent, OcclusionAmount) == 0x000478, "Member 'UFMODAudioPropagationComponent::OcclusionAmount' has a wrong offset!");
static_assert(offsetof(UFMODAudioPropagationComponent, minDistance) == 0x00047C, "Member 'UFMODAudioPropagationComponent::minDistance' has a wrong offset!");
static_assert(offsetof(UFMODAudioPropagationComponent, bPlayPropagation) == 0x000480, "Member 'UFMODAudioPropagationComponent::bPlayPropagation' has a wrong offset!");

// Class ReadyOrNot.ConsoleFireModes
// 0x0020 (0x02E0 - 0x02C0)
class UConsoleFireModes final : public UUserWidget
{
public:
	class UUserWidget*                            FireModeSafe;                                      // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidget*                            FireModeSingle;                                    // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidget*                            FireModeBurst;                                     // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidget*                            FireModeAuto;                                      // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnEquipped(class ABaseItem* Item);
	void OnFireModeChanged(class APlayerCharacter* PlayerCharacter, EFireMode newFireMode, EFireMode LastFireMode);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConsoleFireModes">();
	}
	static class UConsoleFireModes* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConsoleFireModes>();
	}
};
static_assert(alignof(UConsoleFireModes) == 0x000008, "Wrong alignment on UConsoleFireModes");
static_assert(sizeof(UConsoleFireModes) == 0x0002E0, "Wrong size on UConsoleFireModes");
static_assert(offsetof(UConsoleFireModes, FireModeSafe) == 0x0002C0, "Member 'UConsoleFireModes::FireModeSafe' has a wrong offset!");
static_assert(offsetof(UConsoleFireModes, FireModeSingle) == 0x0002C8, "Member 'UConsoleFireModes::FireModeSingle' has a wrong offset!");
static_assert(offsetof(UConsoleFireModes, FireModeBurst) == 0x0002D0, "Member 'UConsoleFireModes::FireModeBurst' has a wrong offset!");
static_assert(offsetof(UConsoleFireModes, FireModeAuto) == 0x0002D8, "Member 'UConsoleFireModes::FireModeAuto' has a wrong offset!");

// Class ReadyOrNot.SWATArmour
// 0x0040 (0x0C60 - 0x0C20)
class ASWATArmour : public ABaseArmour
{
public:
	EArmourCoverage                               MaxArmourCoverage;                                 // 0x0C20(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C21[0x7];                                      // 0x0C21(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UArmourMaterial*                        CarrierMaterial;                                   // 0x0C28(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalSlots;                                        // 0x0C30(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultPrimaryAmmoSlots;                           // 0x0C34(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultSecondaryAmmoSlots;                         // 0x0C38(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultGrenadeSlots;                               // 0x0C3C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultTacticalDeviceSlots;                        // 0x0C40(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EArmourCoverage                               ArmourCoverage;                                    // 0x0C44(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C45[0x3];                                      // 0x0C45(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UArmourMaterial*                        ArmourMaterial;                                    // 0x0C48(0x0008)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<float>                                 Durabilities;                                      // 0x0C50(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SWATArmour">();
	}
	static class ASWATArmour* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASWATArmour>();
	}
};
static_assert(alignof(ASWATArmour) == 0x000010, "Wrong alignment on ASWATArmour");
static_assert(sizeof(ASWATArmour) == 0x000C60, "Wrong size on ASWATArmour");
static_assert(offsetof(ASWATArmour, MaxArmourCoverage) == 0x000C20, "Member 'ASWATArmour::MaxArmourCoverage' has a wrong offset!");
static_assert(offsetof(ASWATArmour, CarrierMaterial) == 0x000C28, "Member 'ASWATArmour::CarrierMaterial' has a wrong offset!");
static_assert(offsetof(ASWATArmour, TotalSlots) == 0x000C30, "Member 'ASWATArmour::TotalSlots' has a wrong offset!");
static_assert(offsetof(ASWATArmour, DefaultPrimaryAmmoSlots) == 0x000C34, "Member 'ASWATArmour::DefaultPrimaryAmmoSlots' has a wrong offset!");
static_assert(offsetof(ASWATArmour, DefaultSecondaryAmmoSlots) == 0x000C38, "Member 'ASWATArmour::DefaultSecondaryAmmoSlots' has a wrong offset!");
static_assert(offsetof(ASWATArmour, DefaultGrenadeSlots) == 0x000C3C, "Member 'ASWATArmour::DefaultGrenadeSlots' has a wrong offset!");
static_assert(offsetof(ASWATArmour, DefaultTacticalDeviceSlots) == 0x000C40, "Member 'ASWATArmour::DefaultTacticalDeviceSlots' has a wrong offset!");
static_assert(offsetof(ASWATArmour, ArmourCoverage) == 0x000C44, "Member 'ASWATArmour::ArmourCoverage' has a wrong offset!");
static_assert(offsetof(ASWATArmour, ArmourMaterial) == 0x000C48, "Member 'ASWATArmour::ArmourMaterial' has a wrong offset!");
static_assert(offsetof(ASWATArmour, Durabilities) == 0x000C50, "Member 'ASWATArmour::Durabilities' has a wrong offset!");

// Class ReadyOrNot.ConsoleHotkey
// 0x0100 (0x03C0 - 0x02C0)
class UConsoleHotkey : public UUserWidget
{
public:
	class URichTextBlock*                         Counter;                                           // 0x02C0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C8[0x8];                                      // 0x02C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            Icon_Brush;                                        // 0x02D0(0x00D0)(Edit, Protected, NativeAccessSpecifierProtected)
	class UImage*                                 Icon_Image;                                        // 0x03A0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGamepadButtonImage*                    ShoulderButtonImage;                               // 0x03A8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGamepadButtonImage*                    ShoulderButtonImage_Highlight;                     // 0x03B0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B8[0x8];                                      // 0x03B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ShoulderButtonPressed(bool Pressed);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConsoleHotkey">();
	}
	static class UConsoleHotkey* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConsoleHotkey>();
	}
};
static_assert(alignof(UConsoleHotkey) == 0x000010, "Wrong alignment on UConsoleHotkey");
static_assert(sizeof(UConsoleHotkey) == 0x0003C0, "Wrong size on UConsoleHotkey");
static_assert(offsetof(UConsoleHotkey, Counter) == 0x0002C0, "Member 'UConsoleHotkey::Counter' has a wrong offset!");
static_assert(offsetof(UConsoleHotkey, Icon_Brush) == 0x0002D0, "Member 'UConsoleHotkey::Icon_Brush' has a wrong offset!");
static_assert(offsetof(UConsoleHotkey, Icon_Image) == 0x0003A0, "Member 'UConsoleHotkey::Icon_Image' has a wrong offset!");
static_assert(offsetof(UConsoleHotkey, ShoulderButtonImage) == 0x0003A8, "Member 'UConsoleHotkey::ShoulderButtonImage' has a wrong offset!");
static_assert(offsetof(UConsoleHotkey, ShoulderButtonImage_Highlight) == 0x0003B0, "Member 'UConsoleHotkey::ShoulderButtonImage_Highlight' has a wrong offset!");

// Class ReadyOrNot.ExplosionGibs
// 0x0008 (0x02A0 - 0x0298)
class AExplosionGibs : public AActor
{
public:
	class UBloodData*                             BloodData;                                         // 0x0298(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void SetupGibsForSkeletalMesh(const class USkeletalMeshComponent* Mesh);
	void SpawnBloodDecal(const struct FHitResult& Hit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExplosionGibs">();
	}
	static class AExplosionGibs* GetDefaultObj()
	{
		return GetDefaultObjImpl<AExplosionGibs>();
	}
};
static_assert(alignof(AExplosionGibs) == 0x000008, "Wrong alignment on AExplosionGibs");
static_assert(sizeof(AExplosionGibs) == 0x0002A0, "Wrong size on AExplosionGibs");
static_assert(offsetof(AExplosionGibs, BloodData) == 0x000298, "Member 'AExplosionGibs::BloodData' has a wrong offset!");

// Class ReadyOrNot.ConsoleLobbyManager
// 0x0000 (0x0410 - 0x0410)
class UConsoleLobbyManager : public UMenuWidget
{
public:
	void SetLobbyPrivacy(ELobbyPrivacy privacy);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConsoleLobbyManager">();
	}
	static class UConsoleLobbyManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConsoleLobbyManager>();
	}
};
static_assert(alignof(UConsoleLobbyManager) == 0x000008, "Wrong alignment on UConsoleLobbyManager");
static_assert(sizeof(UConsoleLobbyManager) == 0x000410, "Wrong size on UConsoleLobbyManager");

// Class ReadyOrNot.SwatCommandEntryWidget
// 0x00C8 (0x0388 - 0x02C0)
class USwatCommandEntryWidget : public UUserWidget
{
public:
	struct FSwatCommand                           SwatCommand;                                       // 0x02C0(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, ExposeOnSpawn, NativeAccessSpecifierPublic)
	ETeamType                                     ActiveTeamType;                                    // 0x0320(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_321[0x3];                                      // 0x0321(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           RedTeamColor;                                      // 0x0324(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           BlueTeamColor;                                     // 0x0334(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           GoldTeamColor;                                     // 0x0344(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLast;                                             // 0x0354(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBack;                                             // 0x0355(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExtended;                                         // 0x0356(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_357[0x1];                                      // 0x0357(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextWidget*                            CommandText;                                       // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextWidget*                            KeybindText;                                       // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBorder*                                EntryBorder;                                       // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ExtendedImage;                                     // 0x0370(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             BackIcon;                                          // 0x0378(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       Flash;                                             // 0x0380(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SwatCommandEntryWidget">();
	}
	static class USwatCommandEntryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USwatCommandEntryWidget>();
	}
};
static_assert(alignof(USwatCommandEntryWidget) == 0x000008, "Wrong alignment on USwatCommandEntryWidget");
static_assert(sizeof(USwatCommandEntryWidget) == 0x000388, "Wrong size on USwatCommandEntryWidget");
static_assert(offsetof(USwatCommandEntryWidget, SwatCommand) == 0x0002C0, "Member 'USwatCommandEntryWidget::SwatCommand' has a wrong offset!");
static_assert(offsetof(USwatCommandEntryWidget, ActiveTeamType) == 0x000320, "Member 'USwatCommandEntryWidget::ActiveTeamType' has a wrong offset!");
static_assert(offsetof(USwatCommandEntryWidget, RedTeamColor) == 0x000324, "Member 'USwatCommandEntryWidget::RedTeamColor' has a wrong offset!");
static_assert(offsetof(USwatCommandEntryWidget, BlueTeamColor) == 0x000334, "Member 'USwatCommandEntryWidget::BlueTeamColor' has a wrong offset!");
static_assert(offsetof(USwatCommandEntryWidget, GoldTeamColor) == 0x000344, "Member 'USwatCommandEntryWidget::GoldTeamColor' has a wrong offset!");
static_assert(offsetof(USwatCommandEntryWidget, bLast) == 0x000354, "Member 'USwatCommandEntryWidget::bLast' has a wrong offset!");
static_assert(offsetof(USwatCommandEntryWidget, bBack) == 0x000355, "Member 'USwatCommandEntryWidget::bBack' has a wrong offset!");
static_assert(offsetof(USwatCommandEntryWidget, bExtended) == 0x000356, "Member 'USwatCommandEntryWidget::bExtended' has a wrong offset!");
static_assert(offsetof(USwatCommandEntryWidget, CommandText) == 0x000358, "Member 'USwatCommandEntryWidget::CommandText' has a wrong offset!");
static_assert(offsetof(USwatCommandEntryWidget, KeybindText) == 0x000360, "Member 'USwatCommandEntryWidget::KeybindText' has a wrong offset!");
static_assert(offsetof(USwatCommandEntryWidget, EntryBorder) == 0x000368, "Member 'USwatCommandEntryWidget::EntryBorder' has a wrong offset!");
static_assert(offsetof(USwatCommandEntryWidget, ExtendedImage) == 0x000370, "Member 'USwatCommandEntryWidget::ExtendedImage' has a wrong offset!");
static_assert(offsetof(USwatCommandEntryWidget, BackIcon) == 0x000378, "Member 'USwatCommandEntryWidget::BackIcon' has a wrong offset!");
static_assert(offsetof(USwatCommandEntryWidget, Flash) == 0x000380, "Member 'USwatCommandEntryWidget::Flash' has a wrong offset!");

// Class ReadyOrNot.ConsoleMagSelection
// 0x0010 (0x02D0 - 0x02C0)
class UConsoleMagSelection final : public UUserWidget
{
public:
	class UHorizontalBox*                         Container;                                         // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerCharacter*                       PlayerCharacter;                                   // 0x02C8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnMagCheck(class ABaseMagazineWeapon* MagazineWeapon);
	void OnWeaponFired(class ABaseWeapon* Weapon);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConsoleMagSelection">();
	}
	static class UConsoleMagSelection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConsoleMagSelection>();
	}
};
static_assert(alignof(UConsoleMagSelection) == 0x000008, "Wrong alignment on UConsoleMagSelection");
static_assert(sizeof(UConsoleMagSelection) == 0x0002D0, "Wrong size on UConsoleMagSelection");
static_assert(offsetof(UConsoleMagSelection, Container) == 0x0002C0, "Member 'UConsoleMagSelection::Container' has a wrong offset!");
static_assert(offsetof(UConsoleMagSelection, PlayerCharacter) == 0x0002C8, "Member 'UConsoleMagSelection::PlayerCharacter' has a wrong offset!");

// Class ReadyOrNot.FlashLightTrackingPoint
// 0x0038 (0x02D0 - 0x0298)
class AFlashLightTrackingPoint final : public AActor
{
public:
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bIsPrimary : 1;                                    // 0x02A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2A1[0x7];                                      // 0x02A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   MeshComp;                                          // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAIPerceptionStimuliSourceComponent*    PerceptionStimuliComp;                             // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ACyberneticController*>          SensedByControllers;                               // 0x02B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C8[0x8];                                      // 0x02C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlashLightTrackingPoint">();
	}
	static class AFlashLightTrackingPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFlashLightTrackingPoint>();
	}
};
static_assert(alignof(AFlashLightTrackingPoint) == 0x000008, "Wrong alignment on AFlashLightTrackingPoint");
static_assert(sizeof(AFlashLightTrackingPoint) == 0x0002D0, "Wrong size on AFlashLightTrackingPoint");
static_assert(offsetof(AFlashLightTrackingPoint, MeshComp) == 0x0002A8, "Member 'AFlashLightTrackingPoint::MeshComp' has a wrong offset!");
static_assert(offsetof(AFlashLightTrackingPoint, PerceptionStimuliComp) == 0x0002B0, "Member 'AFlashLightTrackingPoint::PerceptionStimuliComp' has a wrong offset!");
static_assert(offsetof(AFlashLightTrackingPoint, SensedByControllers) == 0x0002B8, "Member 'AFlashLightTrackingPoint::SensedByControllers' has a wrong offset!");

// Class ReadyOrNot.ConsoleMagSelectionItem
// 0x0030 (0x02F0 - 0x02C0)
class UConsoleMagSelectionItem : public UUserWidget
{
public:
	class UMaterial*                              MagazineMaterial;                                  // 0x02C0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 MagazineIcon;                                      // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 SelectedIcon;                                      // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             MagazineText;                                      // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               MagazineMaterialDynamic;                           // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E8[0x8];                                      // 0x02E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetMagIndex();
	void SetMagIndex(int32 Index_0);
	void SetSelected(bool bCond);
	void UpdateMagPercentage(float Percentage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConsoleMagSelectionItem">();
	}
	static class UConsoleMagSelectionItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConsoleMagSelectionItem>();
	}
};
static_assert(alignof(UConsoleMagSelectionItem) == 0x000008, "Wrong alignment on UConsoleMagSelectionItem");
static_assert(sizeof(UConsoleMagSelectionItem) == 0x0002F0, "Wrong size on UConsoleMagSelectionItem");
static_assert(offsetof(UConsoleMagSelectionItem, MagazineMaterial) == 0x0002C0, "Member 'UConsoleMagSelectionItem::MagazineMaterial' has a wrong offset!");
static_assert(offsetof(UConsoleMagSelectionItem, MagazineIcon) == 0x0002C8, "Member 'UConsoleMagSelectionItem::MagazineIcon' has a wrong offset!");
static_assert(offsetof(UConsoleMagSelectionItem, SelectedIcon) == 0x0002D0, "Member 'UConsoleMagSelectionItem::SelectedIcon' has a wrong offset!");
static_assert(offsetof(UConsoleMagSelectionItem, MagazineText) == 0x0002D8, "Member 'UConsoleMagSelectionItem::MagazineText' has a wrong offset!");
static_assert(offsetof(UConsoleMagSelectionItem, MagazineMaterialDynamic) == 0x0002E0, "Member 'UConsoleMagSelectionItem::MagazineMaterialDynamic' has a wrong offset!");

// Class ReadyOrNot.ConsoleSelection
// 0x0028 (0x02E8 - 0x02C0)
class UConsoleSelection final : public UUserWidget
{
public:
	class UHorizontalBox*                         Container;                                         // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Button;                                            // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 ButtonName;                                        // 0x02D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EItemCategory                                 ItemCategory;                                      // 0x02E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E1[0x7];                                      // 0x02E1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ItemAdded(class ABaseItem* Item);
	void ItemEquipped(class ABaseItem* Item);
	void ItemRemoved(class ABaseItem* Item);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConsoleSelection">();
	}
	static class UConsoleSelection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConsoleSelection>();
	}
};
static_assert(alignof(UConsoleSelection) == 0x000008, "Wrong alignment on UConsoleSelection");
static_assert(sizeof(UConsoleSelection) == 0x0002E8, "Wrong size on UConsoleSelection");
static_assert(offsetof(UConsoleSelection, Container) == 0x0002C0, "Member 'UConsoleSelection::Container' has a wrong offset!");
static_assert(offsetof(UConsoleSelection, Button) == 0x0002C8, "Member 'UConsoleSelection::Button' has a wrong offset!");
static_assert(offsetof(UConsoleSelection, ButtonName) == 0x0002D0, "Member 'UConsoleSelection::ButtonName' has a wrong offset!");
static_assert(offsetof(UConsoleSelection, ItemCategory) == 0x0002E0, "Member 'UConsoleSelection::ItemCategory' has a wrong offset!");

// Class ReadyOrNot.GameFeatureLibrary
// 0x0000 (0x0028 - 0x0028)
class UGameFeatureLibrary final : public UBlueprintFunctionLibrary
{
public:
	static EGamePlatform GetPlatform();
	static bool IsFeatureEnabled(EGameFeature InFeature);
	static bool IsFullGame();
	static bool IsGameDemo();
	static bool IsGameVersionEnabled(EGameVersionRestriction InFeature);
	static bool IsRunningInGeforceNow();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameFeatureLibrary">();
	}
	static class UGameFeatureLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameFeatureLibrary>();
	}
};
static_assert(alignof(UGameFeatureLibrary) == 0x000008, "Wrong alignment on UGameFeatureLibrary");
static_assert(sizeof(UGameFeatureLibrary) == 0x000028, "Wrong size on UGameFeatureLibrary");

// Class ReadyOrNot.ConsoleSelectionItem
// 0x0028 (0x02E8 - 0x02C0)
class UConsoleSelectionItem : public UUserWidget
{
public:
	class FString                                 Name_0;                                            // 0x02C0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x02D0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D4[0x4];                                      // 0x02D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 Icon_Image;                                        // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Selected_Image;                                    // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConsoleSelectionItem">();
	}
	static class UConsoleSelectionItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConsoleSelectionItem>();
	}
};
static_assert(alignof(UConsoleSelectionItem) == 0x000008, "Wrong alignment on UConsoleSelectionItem");
static_assert(sizeof(UConsoleSelectionItem) == 0x0002E8, "Wrong size on UConsoleSelectionItem");
static_assert(offsetof(UConsoleSelectionItem, Name_0) == 0x0002C0, "Member 'UConsoleSelectionItem::Name_0' has a wrong offset!");
static_assert(offsetof(UConsoleSelectionItem, Count) == 0x0002D0, "Member 'UConsoleSelectionItem::Count' has a wrong offset!");
static_assert(offsetof(UConsoleSelectionItem, Icon_Image) == 0x0002D8, "Member 'UConsoleSelectionItem::Icon_Image' has a wrong offset!");
static_assert(offsetof(UConsoleSelectionItem, Selected_Image) == 0x0002E0, "Member 'UConsoleSelectionItem::Selected_Image' has a wrong offset!");

// Class ReadyOrNot.SWATManager
// 0x0CB0 (0x0CF0 - 0x0040)
class USWATManager final : public UTickableWorldSubsystem
{
public:
	uint8                                         Pad_40[0x90];                                      // 0x0040(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ASWATCharacter*>                 SwatAI;                                            // 0x00D0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class ATrailerSWATCharacter*>          SwatTrailers;                                      // 0x00E0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class ASWATCharacter*                         ClosestFallInSwat;                                 // 0x00F0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class ASWATCharacter*, float>            FallInSwat_PathFound;                              // 0x00F8(0x0050)(NativeAccessSpecifierPublic)
	TArray<class ASWATCharacter*>                 FallInSwat;                                        // 0x0148(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class ASWATCharacter*>                 FallInSwat_FileA;                                  // 0x0158(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class ASWATCharacter*>                 FallInSwat_FileB;                                  // 0x0168(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class ASWATCharacter*>                 FallInSwat_Diamond;                                // 0x0178(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<ETeamType, struct FClearQueueInfo>       ClearingQueue;                                     // 0x0188(0x0050)(NativeAccessSpecifierPublic)
	TMap<struct FIntVector, class ASWATCharacter*> OccupiedLookAtPoints;                             // 0x01D8(0x0050)(UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<class AActor*, class FString>            CallOutQueue;                                      // 0x0228(0x0050)(NativeAccessSpecifierPublic)
	TArray<class AActor*>                         CallOutHistory;                                    // 0x0278(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<class AActor*, class ASWATCharacter*>    ReportQueue;                                       // 0x0288(0x0050)(UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D8[0x9B0];                                    // 0x02D8(0x09B0)(Fixing Size After Last Property [ Dumper-7 ])
	class AReadyOrNotCharacter*                   SquadLeader;                                       // 0x0C88(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<ETeamType, struct FQueuedSwatCommand>    QueuedSwatCommandMap;                              // 0x0C90(0x0050)(BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, NativeAccessSpecifierPublic)
	ESwatCommand                                  CurrentDefaultCommand;                             // 0x0CE0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETeamType                                     ActiveCommandTeam;                                 // 0x0CE1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CE2[0xE];                                      // 0x0CE2(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TArray<class ASWATCharacter*> GetSWATSortedByDistanceToLocation(const struct FVector& Location, ETeamType FilterTeam, class ADoor* StackUpDoor, bool bAscendingOrder);
	TArray<class ASWATCharacter*> GetSWATSortedByDistanceToLocationV2(const struct FVector& Location, const TArray<class ASWATCharacter*>& ExcludedSwat, ETeamType FilterTeam, bool bAscendingOrder);
	void GiveBreachAndClearCommand(class ADoor* Door, EDoorBreachType DoorBreachType, ETeamType TeamType, const struct FVector& CommandLocation, TSubclassOf<class ABaseItem> DoorBreachItemClass, TSubclassOf<class ABaseItem> DoorUseItemClass, bool bWithLeader, bool bWithLeaderItem, bool bAutoClear, bool bLastAutoClear, EStackUpStyle CustomStackUpStyle);
	void GiveCheckForContactsCommand(class AActor* Target, ETeamType TeamType, const struct FVector& CommandLocation, const struct FVector& CommandNormal);
	void GiveCheckForTrapsCommand(class AActor* Target, ETeamType TeamType, const struct FVector& CommandLocation, const struct FVector& CommandNormal);
	void GiveCloseDoorCommand(class AActor* Target, ETeamType TeamType, const struct FVector& CommandLocation);
	void GiveCollectEvidenceCommand(class AActor* Target, ETeamType TeamType);
	void GiveCoverAreaCommand(ETeamType TeamType, const struct FVector& CommandLocation);
	void GiveDeployGrenadeAtLocation(ETeamType TeamType, const struct FVector& CommandLocation, TSubclassOf<class ABaseGrenade> Grenade);
	void GiveDeployNonLethalItemAtTargetCommand(class AReadyOrNotCharacter* Target, ETeamType TeamType, EItemCategory Item);
	void GiveDeployShield(ETeamType TeamType);
	void GiveDisarmStandaloneTrapCommand(class AActor* Target, ETeamType TeamType);
	void GiveDisarmTrapOnDoorCommand(class AActor* Target, ETeamType TeamType, const struct FVector& CommandLocation);
	void GiveDropChemlightAtLocation(ETeamType TeamType, const struct FVector& CommandLocation);
	void GiveFallInCommand(ETeamType TeamType, EFallInPattern FallInPattern);
	void GiveHoldCommand(ETeamType TeamType);
	void GiveMoveCommand(ETeamType TeamType, const struct FVector& CommandLocation);
	void GiveOpenDoorCommand(class AActor* Target, ETeamType TeamType, const struct FVector& CommandLocation);
	void GivePickLockCommand(class AActor* Target, ETeamType TeamType, const struct FVector& CommandLocation);
	void GiveRemoveWedgeCommand(class AActor* Target, ETeamType TeamType, const struct FVector& CommandLocation, const struct FVector& CommandNormal);
	void GiveReportTargetCommand(class AActor* Target, ETeamType TeamType);
	void GiveRestrainCommand(class AActor* Target, ETeamType TeamType, const struct FVector& CommandLocation);
	void GiveScanDoorCommand(class AActor* Target, ETeamType TeamType, const struct FVector& CommandLocation, EDoorScanMethod ScanMethod);
	void GiveSearchAndSecureCommand(ETeamType TeamType, const struct FVector& CommandLocation, bool bOnlyCurrentRoom);
	void GiveSearchAndSecureCommand_Individual(class AActor* Target, const struct FVector& CommandLocation, bool bOnlyCurrentRoom);
	void GiveStackUpCommand(class AActor* Target, ETeamType TeamType, const struct FVector& CommandLocation, const struct FVector& CommandNormal, bool bCheckDoor, EStackUpStyle StackUpStyle);
	void GiveWedgeDoorCommand(class AActor* Target, ETeamType TeamType, const struct FVector& CommandLocation, const struct FVector& CommandNormal);
	void OnActivityStarted(class UBaseActivity* Activity, class ACyberneticController* OwningController);
	void OnLeaderToggledNightvision(class AReadyOrNotCharacter* Character, bool bOn);
	void OnSwatFinishedClearing(class UTeamBreachAndClearActivity* BreachAndClearActivity, bool bAuto);
	void OnSwatFinishedRoomSearch(class USearchAndSecureActivity* SearchAndSecureActivity, class ADoor* BreachedDoor);
	void OnTrailerSearchComplete(class UBaseActivity* Activity, class ACyberneticController* Controller);
	void PlaySwatCommandVoiceLine(const class FString& VoiceLine, const class FString& OverrideSpearkerName, bool bTeamPrefix);
	void RemoveHoldCommand(ETeamType TeamType);

	bool CanGiveActivityToSWAT(class ASWATCharacter* swat, ETeamType Team) const;
	struct FVector GetAverageSwatLocation() const;
	ESwatCommand GetQueuedSwatCommandForSquadPosition(ESquadPosition SquadPosition) const;
	class AReadyOrNotCharacter* GetSquadLeader() const;
	class ASWATCharacter* GetSwatCharacterAtSquadPosition(ESquadPosition InSquadPosition) const;
	uint8 GetSWATCount() const;
	TArray<class ASWATCharacter*> GetSwatTeam() const;
	bool IsCharacterKnownEnemy(class AReadyOrNotCharacter* InCharacter) const;
	bool IsSWATTeamDead(ETeamType Team) const;
	bool IsSWATTeamHoldingPosition(ETeamType Team) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SWATManager">();
	}
	static class USWATManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<USWATManager>();
	}
};
static_assert(alignof(USWATManager) == 0x000008, "Wrong alignment on USWATManager");
static_assert(sizeof(USWATManager) == 0x000CF0, "Wrong size on USWATManager");
static_assert(offsetof(USWATManager, SwatAI) == 0x0000D0, "Member 'USWATManager::SwatAI' has a wrong offset!");
static_assert(offsetof(USWATManager, SwatTrailers) == 0x0000E0, "Member 'USWATManager::SwatTrailers' has a wrong offset!");
static_assert(offsetof(USWATManager, ClosestFallInSwat) == 0x0000F0, "Member 'USWATManager::ClosestFallInSwat' has a wrong offset!");
static_assert(offsetof(USWATManager, FallInSwat_PathFound) == 0x0000F8, "Member 'USWATManager::FallInSwat_PathFound' has a wrong offset!");
static_assert(offsetof(USWATManager, FallInSwat) == 0x000148, "Member 'USWATManager::FallInSwat' has a wrong offset!");
static_assert(offsetof(USWATManager, FallInSwat_FileA) == 0x000158, "Member 'USWATManager::FallInSwat_FileA' has a wrong offset!");
static_assert(offsetof(USWATManager, FallInSwat_FileB) == 0x000168, "Member 'USWATManager::FallInSwat_FileB' has a wrong offset!");
static_assert(offsetof(USWATManager, FallInSwat_Diamond) == 0x000178, "Member 'USWATManager::FallInSwat_Diamond' has a wrong offset!");
static_assert(offsetof(USWATManager, ClearingQueue) == 0x000188, "Member 'USWATManager::ClearingQueue' has a wrong offset!");
static_assert(offsetof(USWATManager, OccupiedLookAtPoints) == 0x0001D8, "Member 'USWATManager::OccupiedLookAtPoints' has a wrong offset!");
static_assert(offsetof(USWATManager, CallOutQueue) == 0x000228, "Member 'USWATManager::CallOutQueue' has a wrong offset!");
static_assert(offsetof(USWATManager, CallOutHistory) == 0x000278, "Member 'USWATManager::CallOutHistory' has a wrong offset!");
static_assert(offsetof(USWATManager, ReportQueue) == 0x000288, "Member 'USWATManager::ReportQueue' has a wrong offset!");
static_assert(offsetof(USWATManager, SquadLeader) == 0x000C88, "Member 'USWATManager::SquadLeader' has a wrong offset!");
static_assert(offsetof(USWATManager, QueuedSwatCommandMap) == 0x000C90, "Member 'USWATManager::QueuedSwatCommandMap' has a wrong offset!");
static_assert(offsetof(USWATManager, CurrentDefaultCommand) == 0x000CE0, "Member 'USWATManager::CurrentDefaultCommand' has a wrong offset!");
static_assert(offsetof(USWATManager, ActiveCommandTeam) == 0x000CE1, "Member 'USWATManager::ActiveCommandTeam' has a wrong offset!");

// Class ReadyOrNot.ControllableByTablet
// 0x0000 (0x0000 - 0x0000)
class IControllableByTablet final
{
public:
	void AssumeTabletControl(class APlayerCharacter* TabletOwner);
	bool CanControlWithTablet(class APlayerCharacter* TabletOwner);
	bool CanTabletViewMe(class APlayerCharacter* TabletOwner, class AReadyOrNotGameState* GameState);
	class FText GetTabletNameText();
	class USceneComponent* GetTabletViewComponent();
	class FName GetTabletViewSocket();
	ETeamType GetTabletViewTeamColor();
	void HideActorsForTabletView(class USceneCaptureComponent2D* Component);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ControllableByTablet">();
	}
	static class IControllableByTablet* GetDefaultObj()
	{
		return GetDefaultObjImpl<IControllableByTablet>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IControllableByTablet) == 0x000001, "Wrong alignment on IControllableByTablet");
static_assert(sizeof(IControllableByTablet) == 0x000001, "Wrong size on IControllableByTablet");

// Class ReadyOrNot.Conversation
// 0x0058 (0x0080 - 0x0028)
class UConversation final : public UObject
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FConversationData>              ConversationData;                                  // 0x0040(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x10];                                      // 0x0050(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(int32 Idx)>     OnConversationContinuing;                          // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnEndConversation;                                 // 0x0070(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void BeginConversation(class ACyberneticCharacter* ConversationStarter, class FName ID);
	void BuildConversation(class FName ID);
	void ContinueConversation();
	struct FConversationData GetConversationData();
	class ACyberneticCharacter* GetSpeakerForConversationIdx(int32 Idx);
	class ACyberneticCharacter* GetSpeakerForId(class FName ID);
	void GiveWorldBuildingActivityByTag(class FName SpeakerId, class FName Tag);
	void GoToSpecificConversationIdAndContinueConversation(int32 Idx);
	void ReplyToConversation(class AReadyOrNotCharacter* Speaker);
	bool RequirementsMet();
	void TryGetSpeakers();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Conversation">();
	}
	static class UConversation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConversation>();
	}
};
static_assert(alignof(UConversation) == 0x000008, "Wrong alignment on UConversation");
static_assert(sizeof(UConversation) == 0x000080, "Wrong size on UConversation");
static_assert(offsetof(UConversation, ConversationData) == 0x000040, "Member 'UConversation::ConversationData' has a wrong offset!");
static_assert(offsetof(UConversation, OnConversationContinuing) == 0x000060, "Member 'UConversation::OnConversationContinuing' has a wrong offset!");
static_assert(offsetof(UConversation, OnEndConversation) == 0x000070, "Member 'UConversation::OnEndConversation' has a wrong offset!");

// Class ReadyOrNot.FlankingCombatMove
// 0x0060 (0x0290 - 0x0230)
class UFlankingCombatMove final : public UBaseCombatMoveActivity
{
public:
	class AReadyOrNotCharacter*                   FlankingAgainstCharacter;                          // 0x0230(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFlankingAvoidanceVolume*               FlankingAvoidanceVolume;                           // 0x0238(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_240[0x50];                                     // 0x0240(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlankingCombatMove">();
	}
	static class UFlankingCombatMove* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlankingCombatMove>();
	}
};
static_assert(alignof(UFlankingCombatMove) == 0x000008, "Wrong alignment on UFlankingCombatMove");
static_assert(sizeof(UFlankingCombatMove) == 0x000290, "Wrong size on UFlankingCombatMove");
static_assert(offsetof(UFlankingCombatMove, FlankingAgainstCharacter) == 0x000230, "Member 'UFlankingCombatMove::FlankingAgainstCharacter' has a wrong offset!");
static_assert(offsetof(UFlankingCombatMove, FlankingAvoidanceVolume) == 0x000238, "Member 'UFlankingCombatMove::FlankingAvoidanceVolume' has a wrong offset!");

// Class ReadyOrNot.ConversationManager
// 0x0010 (0x02A8 - 0x0298)
class AConversationManager final : public AInfo
{
public:
	TArray<class UConversation*>                  RunningConversations;                              // 0x0298(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	void PlayConversationInst(class UConversation* Conversation, class ACyberneticCharacter* ConversationStarter);
	class UConversation* PlayPrebuiltConversation(TSubclassOf<class UConversation> Conversation, class ACyberneticCharacter* ConversationStarter, class FName ConversationId);
	class UConversation* TryPlayConversation(class FName ConversationId, class ACyberneticCharacter* ConversationStarter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConversationManager">();
	}
	static class AConversationManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AConversationManager>();
	}
};
static_assert(alignof(AConversationManager) == 0x000008, "Wrong alignment on AConversationManager");
static_assert(sizeof(AConversationManager) == 0x0002A8, "Wrong size on AConversationManager");
static_assert(offsetof(AConversationManager, RunningConversations) == 0x000298, "Member 'AConversationManager::RunningConversations' has a wrong offset!");

// Class ReadyOrNot.InventoryComponent
// 0x0530 (0x05D0 - 0x00A0)
class UInventoryComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnEquippedItemChanged;                             // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ABaseItem* Item)> OnClientItemAddedToInventory;              // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ABaseItem* Item)> OnItemAddedToInventory;                    // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ABaseItem* Item)> OnItemRemovedFromInventory;                // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ABaseItem* Item)> OnItemEquipped;                            // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ABaseItem* Item)> OnItemHolstered;                           // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_108[0x48];                                     // 0x0108(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	struct FItemChangeRequest                     LatestItemChangeRequest;                           // 0x0150(0x0038)(Net, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FItemChangeRequest                     LastReceivedItemChangeRequest;                     // 0x0188(0x0038)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	class ABaseItem*                              QueuedItemSwap;                                    // 0x01C0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABaseItem*                              LastEquippedItem;                                  // 0x01C8(0x0008)(Edit, Net, ZeroConstructor, EditConst, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   LastEquippedIteName;                               // 0x01D0(0x0008)(Edit, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABaseWeapon*                            LastEquippedWeapon;                                // 0x01D8(0x0008)(Edit, Net, ZeroConstructor, EditConst, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABaseItem*                              LastEquippedItemWheel;                             // 0x01E0(0x0008)(Edit, Net, ZeroConstructor, EditConst, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   LastEquippedItemWheelName;                         // 0x01E8(0x0008)(Edit, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ABaseItem*>                      InventoryItems;                                    // 0x01F0(0x0010)(Edit, Net, ZeroConstructor, EditConst, RepNotify, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<class ABaseItem*>                      RemovedInventoryItems;                             // 0x0200(0x0010)(Edit, Net, ZeroConstructor, EditConst, RepNotify, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	struct FSpawnedGear                           SpawnedGear;                                       // 0x0210(0x0088)(BlueprintVisible, Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FSavedLoadout                          LastEquippedLoadout;                               // 0x0298(0x02E8)(Net, Transient, Protected, NativeAccessSpecifierProtected)
	class ABaseItem*                              SelectedDevice;                                    // 0x0580(0x0008)(BlueprintVisible, Net, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_588[0x38];                                     // 0x0588(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FItemSelectionGroup>            ItemSelectionGroups;                               // 0x05C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	bool AddInventoryItem(class ABaseItem* Item);
	bool CanEquip(class ABaseItem* Item);
	void Client_NotifyInventoryItemsChanged();
	void Client_NotifyInventoryItemsDestroyed();
	void Client_NotifyInventorySpawned();
	void DestroyAllEquippedItems();
	bool DestroyInventoryItem(class ABaseItem* Item);
	bool EquipHolsteredItem(bool bInstant);
	class ABaseItem* EquipItemFromGroup_Index(int32 GroupIndex, int32 ItemCategoryIndex);
	class ABaseItem* EquipItemFromGroup_Name(class FName GroupName, int32 ItemCategoryIndex);
	class ABaseItem* EquipItemOfClass(class UClass* ClassType, bool bInstant);
	class ABaseItem* EquipItemOfType(const EItemCategory ItemCategory, const bool bInstant);
	void EquipLastEquippedItem(bool bInstant, bool bForce);
	void EquipLastEquippedItemWheel(bool bInstant, bool bForce);
	void EquipLastEquippedWeapon(bool bInstant, bool bForce);
	class ABaseItem* GetLastEquippedItemWheel();
	bool Holster(class ABaseItem* Item, bool bInstant);
	bool HolsterEquippedItem(bool bInstant);
	bool IsEquippingItem();
	bool IsEquippingItemOfClass(class UClass* ClassType);
	bool IsEquippingItemOfType(EItemCategory ItemCategory);
	bool IsEquippingSpecificItem(class ABaseItem* Item);
	void Multicast_NotifyInventoryItemsChanged();
	void OnActorRelevancyChanged(class AActor* Actor, bool bIsRelevant);
	void OnNewItemChangeDrawComplete(class ABaseItem* Item);
	void OnRep_InventoryItemsChanged();
	void OnRep_ItemChangeRequest();
	void OnRep_SpawnedGear();
	void PlayLocalDraw(const struct FItemChangeRequest& ItemChangeRequest);
	void PlayLocalHolster(const struct FItemChangeRequest& ItemChangeRequest);
	void PlayTPDraw(const struct FItemChangeRequest& ItemChangeRequest);
	bool PutItemInHands(class ABaseItem* Item, bool bInstant, bool bForce);
	bool RemoveInventoryItem(class ABaseItem* Item, bool bNullOwner);
	void ResetLatestItemChangeRequest(class ABaseItem* Item);
	void Server_AttemptEquipNewLoadout(const struct FSavedLoadout& Loadout);
	void Server_ChangeEquippedItem(const struct FItemChangeRequest& ItemChangeRequest);
	void Server_PlayTPHolster(const struct FItemChangeRequest& ItemChangeRequest);
	void ThrowAllItems();
	void ThrowAllWeapons();
	void ThrowEquippedItem();
	void ThrowSpecificItem(class ABaseItem* Item, bool bMarkAsEvidence);

	int32 CountInventoryItemType(EItemCategory ItemCategory) const;
	class ABaseArmour* GetArmour() const;
	class ABaseItem* GetEquippedItem() const;
	class AHeadwear* GetFacewear() const;
	class AHeadwear* GetHelmet() const;
	class ABaseItem* GetHolsteredItem() const;
	class ABaseItem* GetInventoryItemOfClass(class UClass* Class_0, bool bCanEquipCheck) const;
	class ABaseItem* GetInventoryItemOfClassType(EItemClass ItemClass) const;
	class ABaseItem* GetInventoryItemOfType(EItemCategory ItemCategory) const;
	TArray<class ABaseItem*> GetInventoryItems() const;
	TArray<class ABaseItem*> GetInventoryItemsOfType(EItemCategory ItemCategory) const;
	class ABaseItem* GetLastEquippedItem() const;
	struct FSavedLoadout GetLastEquippedLoadout() const;
	class ABaseWeapon* GetLastEquippedWeapon() const;
	TArray<class ABaseItem*> GetRemovedInventoryItems() const;
	bool HasAnyInventoryItems() const;
	bool HasAnyInventoryItemsOfClass(TSubclassOf<class ABaseItem> ItemClass) const;
	bool HasAnyInventoryItemsOfType(EItemCategory ItemCategory) const;
	bool HasInventoryItem(class ABaseItem* Item) const;
	bool IsAnyBlockingAnimationPlaying() const;
	bool IsAnyItemAttachedToBody() const;
	bool IsAnyItemAttachedToHands() const;
	bool IsEquippedWithShield(const class ABaseItem* Item) const;
	bool IsItemEquipped(EItemCategory ItemCategory) const;
	bool IsItemEquipped_Class(TSubclassOf<class ABaseItem> ItemClass) const;
	bool IsWearingAntiFlashGoggles() const;
	bool IsWearingArmour() const;
	bool IsWearingExplosiveVest() const;
	bool IsWearingHeadArmour() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryComponent">();
	}
	static class UInventoryComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryComponent>();
	}
};
static_assert(alignof(UInventoryComponent) == 0x000008, "Wrong alignment on UInventoryComponent");
static_assert(sizeof(UInventoryComponent) == 0x0005D0, "Wrong size on UInventoryComponent");
static_assert(offsetof(UInventoryComponent, OnEquippedItemChanged) == 0x0000A8, "Member 'UInventoryComponent::OnEquippedItemChanged' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, OnClientItemAddedToInventory) == 0x0000B8, "Member 'UInventoryComponent::OnClientItemAddedToInventory' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, OnItemAddedToInventory) == 0x0000C8, "Member 'UInventoryComponent::OnItemAddedToInventory' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, OnItemRemovedFromInventory) == 0x0000D8, "Member 'UInventoryComponent::OnItemRemovedFromInventory' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, OnItemEquipped) == 0x0000E8, "Member 'UInventoryComponent::OnItemEquipped' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, OnItemHolstered) == 0x0000F8, "Member 'UInventoryComponent::OnItemHolstered' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, LatestItemChangeRequest) == 0x000150, "Member 'UInventoryComponent::LatestItemChangeRequest' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, LastReceivedItemChangeRequest) == 0x000188, "Member 'UInventoryComponent::LastReceivedItemChangeRequest' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, QueuedItemSwap) == 0x0001C0, "Member 'UInventoryComponent::QueuedItemSwap' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, LastEquippedItem) == 0x0001C8, "Member 'UInventoryComponent::LastEquippedItem' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, LastEquippedIteName) == 0x0001D0, "Member 'UInventoryComponent::LastEquippedIteName' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, LastEquippedWeapon) == 0x0001D8, "Member 'UInventoryComponent::LastEquippedWeapon' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, LastEquippedItemWheel) == 0x0001E0, "Member 'UInventoryComponent::LastEquippedItemWheel' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, LastEquippedItemWheelName) == 0x0001E8, "Member 'UInventoryComponent::LastEquippedItemWheelName' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, InventoryItems) == 0x0001F0, "Member 'UInventoryComponent::InventoryItems' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, RemovedInventoryItems) == 0x000200, "Member 'UInventoryComponent::RemovedInventoryItems' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, SpawnedGear) == 0x000210, "Member 'UInventoryComponent::SpawnedGear' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, LastEquippedLoadout) == 0x000298, "Member 'UInventoryComponent::LastEquippedLoadout' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, SelectedDevice) == 0x000580, "Member 'UInventoryComponent::SelectedDevice' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, ItemSelectionGroups) == 0x0005C0, "Member 'UInventoryComponent::ItemSelectionGroups' has a wrong offset!");

// Class ReadyOrNot.CoverFinderPreview
// 0x0528 (0x07C0 - 0x0298)
class ACoverFinderPreview final : public AActor
{
public:
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SearchExtent;                                      // 0x02A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SearchDangerZone;                                  // 0x02A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECoverSearchMode                              SearchMode;                                        // 0x02A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECoverStance                                  CoverStance;                                       // 0x02A9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AA[0x6];                                      // 0x02AA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCoverQueryTest                        SearchModeTest;                                    // 0x02B0(0x0050)(Edit, NativeAccessSpecifierPublic)
	struct FCoverQueryTest                        HeightDifferenceTest;                              // 0x0300(0x0050)(Edit, NativeAccessSpecifierPublic)
	struct FCoverQueryTest                        LineOfSightTest;                                   // 0x0350(0x0050)(Edit, NativeAccessSpecifierPublic)
	struct FCoverQueryTest                        CoverBehindInstigatorTest;                         // 0x03A0(0x0050)(Edit, NativeAccessSpecifierPublic)
	struct FCoverQueryTest                        SufficientCoverTest;                               // 0x03F0(0x0050)(Edit, NativeAccessSpecifierPublic)
	struct FCoverQueryTest                        DistanceToInstigatorTest;                          // 0x0440(0x0050)(Edit, NativeAccessSpecifierPublic)
	struct FCoverQueryTest                        DirectionMatchTest;                                // 0x0490(0x0050)(Edit, NativeAccessSpecifierPublic)
	struct FCoverQueryTest                        RoomTest;                                          // 0x04E0(0x0050)(Edit, NativeAccessSpecifierPublic)
	int32                                         NumCoverPointsFound;                               // 0x0530(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CoverSearchTimeMs;                                 // 0x0534(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ACoverPoint>             BestCover;                                         // 0x0538(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bDrawLabels : 1;                                   // 0x0540(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawScore : 1;                                    // 0x0540(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawPass : 1;                                     // 0x0540(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawFail : 1;                                     // 0x0540(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawFailReason : 1;                               // 0x0540(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_541[0x7];                                      // 0x0541(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        SceneComponent;                                    // 0x0548(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_550[0x270];                                    // 0x0550(0x0270)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoverFinderPreview">();
	}
	static class ACoverFinderPreview* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACoverFinderPreview>();
	}
};
static_assert(alignof(ACoverFinderPreview) == 0x000010, "Wrong alignment on ACoverFinderPreview");
static_assert(sizeof(ACoverFinderPreview) == 0x0007C0, "Wrong size on ACoverFinderPreview");
static_assert(offsetof(ACoverFinderPreview, SearchExtent) == 0x0002A0, "Member 'ACoverFinderPreview::SearchExtent' has a wrong offset!");
static_assert(offsetof(ACoverFinderPreview, SearchDangerZone) == 0x0002A4, "Member 'ACoverFinderPreview::SearchDangerZone' has a wrong offset!");
static_assert(offsetof(ACoverFinderPreview, SearchMode) == 0x0002A8, "Member 'ACoverFinderPreview::SearchMode' has a wrong offset!");
static_assert(offsetof(ACoverFinderPreview, CoverStance) == 0x0002A9, "Member 'ACoverFinderPreview::CoverStance' has a wrong offset!");
static_assert(offsetof(ACoverFinderPreview, SearchModeTest) == 0x0002B0, "Member 'ACoverFinderPreview::SearchModeTest' has a wrong offset!");
static_assert(offsetof(ACoverFinderPreview, HeightDifferenceTest) == 0x000300, "Member 'ACoverFinderPreview::HeightDifferenceTest' has a wrong offset!");
static_assert(offsetof(ACoverFinderPreview, LineOfSightTest) == 0x000350, "Member 'ACoverFinderPreview::LineOfSightTest' has a wrong offset!");
static_assert(offsetof(ACoverFinderPreview, CoverBehindInstigatorTest) == 0x0003A0, "Member 'ACoverFinderPreview::CoverBehindInstigatorTest' has a wrong offset!");
static_assert(offsetof(ACoverFinderPreview, SufficientCoverTest) == 0x0003F0, "Member 'ACoverFinderPreview::SufficientCoverTest' has a wrong offset!");
static_assert(offsetof(ACoverFinderPreview, DistanceToInstigatorTest) == 0x000440, "Member 'ACoverFinderPreview::DistanceToInstigatorTest' has a wrong offset!");
static_assert(offsetof(ACoverFinderPreview, DirectionMatchTest) == 0x000490, "Member 'ACoverFinderPreview::DirectionMatchTest' has a wrong offset!");
static_assert(offsetof(ACoverFinderPreview, RoomTest) == 0x0004E0, "Member 'ACoverFinderPreview::RoomTest' has a wrong offset!");
static_assert(offsetof(ACoverFinderPreview, NumCoverPointsFound) == 0x000530, "Member 'ACoverFinderPreview::NumCoverPointsFound' has a wrong offset!");
static_assert(offsetof(ACoverFinderPreview, CoverSearchTimeMs) == 0x000534, "Member 'ACoverFinderPreview::CoverSearchTimeMs' has a wrong offset!");
static_assert(offsetof(ACoverFinderPreview, BestCover) == 0x000538, "Member 'ACoverFinderPreview::BestCover' has a wrong offset!");
static_assert(offsetof(ACoverFinderPreview, SceneComponent) == 0x000548, "Member 'ACoverFinderPreview::SceneComponent' has a wrong offset!");

// Class ReadyOrNot.CoverFinderRenderingComponent
// 0x00B0 (0x0620 - 0x0570)
class UCoverFinderRenderingComponent final : public UPrimitiveComponent
{
public:
	uint8                                         Pad_570[0xB0];                                     // 0x0570(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoverFinderRenderingComponent">();
	}
	static class UCoverFinderRenderingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoverFinderRenderingComponent>();
	}
};
static_assert(alignof(UCoverFinderRenderingComponent) == 0x000010, "Wrong alignment on UCoverFinderRenderingComponent");
static_assert(sizeof(UCoverFinderRenderingComponent) == 0x000620, "Wrong size on UCoverFinderRenderingComponent");

// Class ReadyOrNot.GameplayConfig
// 0x0000 (0x0028 - 0x0028)
class UGameplayConfig : public UObject
{
public:
	bool GetBool(const class FString& ConfigKey, bool FallbackValue);
	float GetFloat(const class FString& ConfigKey, float FallbackValue);
	int32 GetInt(const class FString& ConfigKey, int32 FallbackValue);
	class FString GetString(const class FString& ConfigKey, const class FString& FallbackValue);
	TArray<class FString> GetStringArray(const class FString& ConfigKey, const TArray<class FString>& FallbackValue);
	TArray<class FString> GetStringArray_SingleLine(const class FString& ConfigKey, const TArray<class FString>& FallbackValue);
	struct FVector GetVector(const class FString& ConfigKey, const struct FVector& FallbackValue);
	struct FVector2D GetVector2D(const class FString& ConfigKey, const struct FVector2D& FallbackValue);
	void ReloadConfig();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayConfig">();
	}
	static class UGameplayConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayConfig>();
	}
};
static_assert(alignof(UGameplayConfig) == 0x000008, "Wrong alignment on UGameplayConfig");
static_assert(sizeof(UGameplayConfig) == 0x000028, "Wrong size on UGameplayConfig");

// Class ReadyOrNot.CoverLandmark
// 0x0348 (0x05E0 - 0x0298)
class ACoverLandmark final : public AActor
{
public:
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        SceneComponent;                                    // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bEnabled : 1;                                      // 0x02A8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2A9[0x7];                                      // 0x02A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LandmarkName;                                      // 0x02B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECoverLandmarkType                            Type;                                              // 0x02C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C1[0x7];                                      // 0x02C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class USearchLandmarkActivity>    CustomSearchActivityClass;                         // 0x02C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SwatSearchAnimation;                               // 0x02D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class AActor>                  CoverObject;                                       // 0x02E0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bDisableCollision : 1;                             // 0x0308(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_309[0x7];                                      // 0x0309(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ETeamType>                             AllowedTeamsForCover;                              // 0x0310(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class AStaticMeshActor>> IgnoredMeshActors;                                // 0x0320(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         CooldownAfterUse;                                  // 0x0330(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCharacterHiddenInWaitingState;                    // 0x0334(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_335[0xB];                                      // 0x0335(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ExitTriggerBoxTransform;                           // 0x0340(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ExitTriggerBoxExtent;                              // 0x03A0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B8[0x8];                                      // 0x03B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             IdleTriggerBoxTransform;                           // 0x03C0(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                IdleTriggerBoxExtent;                              // 0x0420(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCoverLandmarkAnimData                 Entry;                                             // 0x0438(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FCoverLandmarkAnimData                 Loop;                                              // 0x0490(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FCoverLandmarkAnimData                 Exit;                                              // 0x04E8(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         bAllowAbruptExit : 1;                              // 0x0540(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_541[0x7];                                      // 0x0541(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ACoverLandmarkProxy*>            EntryPoints;                                       // 0x0548(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class ACoverLandmarkProxy*>            ExitPoints;                                        // 0x0558(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, UObjectWrapper, NativeAccessSpecifierPublic)
	class ACoverLandmarkProxy*                    IdlePoint;                                         // 0x0568(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            OccupiedByController;                              // 0x0570(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            LastUsedByController;                              // 0x0578(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AReadyOrNotCharacter*                   CurrentSwatWithLineOfSight;                        // 0x0580(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClearedBySwat;                                    // 0x0588(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_589[0x7];                                      // 0x0589(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class AController*, float>               CooldownMap;                                       // 0x0590(0x0050)(Protected, NativeAccessSpecifierProtected)

public:
	void AddCooldownFor(class AController* InController, float InCooldownTime);
	void DisableLandmark();
	void EnableLandmark();
	void PreviewEntryAnim();
	void PreviewExitAnim();
	void PreviewIdleAnim();
	void ToggleLandmarkEnabled(bool bEnable);

	bool IsCooldownActiveFor(const class AController* InController) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoverLandmark">();
	}
	static class ACoverLandmark* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACoverLandmark>();
	}
};
static_assert(alignof(ACoverLandmark) == 0x000010, "Wrong alignment on ACoverLandmark");
static_assert(sizeof(ACoverLandmark) == 0x0005E0, "Wrong size on ACoverLandmark");
static_assert(offsetof(ACoverLandmark, SceneComponent) == 0x0002A0, "Member 'ACoverLandmark::SceneComponent' has a wrong offset!");
static_assert(offsetof(ACoverLandmark, LandmarkName) == 0x0002B0, "Member 'ACoverLandmark::LandmarkName' has a wrong offset!");
static_assert(offsetof(ACoverLandmark, Type) == 0x0002C0, "Member 'ACoverLandmark::Type' has a wrong offset!");
static_assert(offsetof(ACoverLandmark, CustomSearchActivityClass) == 0x0002C8, "Member 'ACoverLandmark::CustomSearchActivityClass' has a wrong offset!");
static_assert(offsetof(ACoverLandmark, SwatSearchAnimation) == 0x0002D0, "Member 'ACoverLandmark::SwatSearchAnimation' has a wrong offset!");
static_assert(offsetof(ACoverLandmark, CoverObject) == 0x0002E0, "Member 'ACoverLandmark::CoverObject' has a wrong offset!");
static_assert(offsetof(ACoverLandmark, AllowedTeamsForCover) == 0x000310, "Member 'ACoverLandmark::AllowedTeamsForCover' has a wrong offset!");
static_assert(offsetof(ACoverLandmark, IgnoredMeshActors) == 0x000320, "Member 'ACoverLandmark::IgnoredMeshActors' has a wrong offset!");
static_assert(offsetof(ACoverLandmark, CooldownAfterUse) == 0x000330, "Member 'ACoverLandmark::CooldownAfterUse' has a wrong offset!");
static_assert(offsetof(ACoverLandmark, bCharacterHiddenInWaitingState) == 0x000334, "Member 'ACoverLandmark::bCharacterHiddenInWaitingState' has a wrong offset!");
static_assert(offsetof(ACoverLandmark, ExitTriggerBoxTransform) == 0x000340, "Member 'ACoverLandmark::ExitTriggerBoxTransform' has a wrong offset!");
static_assert(offsetof(ACoverLandmark, ExitTriggerBoxExtent) == 0x0003A0, "Member 'ACoverLandmark::ExitTriggerBoxExtent' has a wrong offset!");
static_assert(offsetof(ACoverLandmark, IdleTriggerBoxTransform) == 0x0003C0, "Member 'ACoverLandmark::IdleTriggerBoxTransform' has a wrong offset!");
static_assert(offsetof(ACoverLandmark, IdleTriggerBoxExtent) == 0x000420, "Member 'ACoverLandmark::IdleTriggerBoxExtent' has a wrong offset!");
static_assert(offsetof(ACoverLandmark, Entry) == 0x000438, "Member 'ACoverLandmark::Entry' has a wrong offset!");
static_assert(offsetof(ACoverLandmark, Loop) == 0x000490, "Member 'ACoverLandmark::Loop' has a wrong offset!");
static_assert(offsetof(ACoverLandmark, Exit) == 0x0004E8, "Member 'ACoverLandmark::Exit' has a wrong offset!");
static_assert(offsetof(ACoverLandmark, EntryPoints) == 0x000548, "Member 'ACoverLandmark::EntryPoints' has a wrong offset!");
static_assert(offsetof(ACoverLandmark, ExitPoints) == 0x000558, "Member 'ACoverLandmark::ExitPoints' has a wrong offset!");
static_assert(offsetof(ACoverLandmark, IdlePoint) == 0x000568, "Member 'ACoverLandmark::IdlePoint' has a wrong offset!");
static_assert(offsetof(ACoverLandmark, OccupiedByController) == 0x000570, "Member 'ACoverLandmark::OccupiedByController' has a wrong offset!");
static_assert(offsetof(ACoverLandmark, LastUsedByController) == 0x000578, "Member 'ACoverLandmark::LastUsedByController' has a wrong offset!");
static_assert(offsetof(ACoverLandmark, CurrentSwatWithLineOfSight) == 0x000580, "Member 'ACoverLandmark::CurrentSwatWithLineOfSight' has a wrong offset!");
static_assert(offsetof(ACoverLandmark, bClearedBySwat) == 0x000588, "Member 'ACoverLandmark::bClearedBySwat' has a wrong offset!");
static_assert(offsetof(ACoverLandmark, CooldownMap) == 0x000590, "Member 'ACoverLandmark::CooldownMap' has a wrong offset!");

// Class ReadyOrNot.RadialWidgetBase
// 0x01A0 (0x0488 - 0x02E8)
class URadialWidgetBase : public UBaseWidget
{
public:
	TMulticastInlineDelegate<void()>              OnRadialMenuOpened_Delegate;                       // 0x02E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnRadialMenuClosed_Delegate;                       // 0x02F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         CurrentSelectionIndex;                             // 0x0308(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PreviousSelectionIndex;                            // 0x030C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Angle;                                             // 0x0310(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AngleSpread;                                       // 0x0314(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PercentageWithoutGap;                              // 0x0318(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PercentageWithGap;                                 // 0x031C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bIsWheelCreated : 1;                               // 0x0320(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsWheelRefreshed : 1;                             // 0x0320(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bNavigatingWithGamepad : 1;                        // 0x0320(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_321[0x7];                                      // 0x0321(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              RadialCursorPosition;                              // 0x0328(0x0010)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<float>                                 Angles;                                            // 0x0338(0x0010)(BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class URadialSectorWidget*>            Sectors;                                           // 0x0348(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class UPanelWidget*                           RadialWheel;                                       // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 RadialWheelCursor;                                 // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APlayerController*                      OwningPlayer;                                      // 0x0368(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APawn*                                  OwningPawn;                                        // 0x0370(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APlayerCharacter*                       OwningPlayerCharacter;                             // 0x0378(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumOfSectors;                                      // 0x0380(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OpenDelay;                                         // 0x0384(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CloseDelay;                                        // 0x0388(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinWheelSize;                                      // 0x038C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxWheelSize;                                      // 0x0390(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinCursorAngle;                                    // 0x0394(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxCursorAngle;                                    // 0x0398(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERadialCursorBehaviour                        RadialCursorBehaviour;                             // 0x039C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39D[0x3];                                      // 0x039D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class URadialSectorWidget>        RadialSectorWidgetClass;                           // 0x03A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bAlwaysHideRadialWheelCursor : 1;                  // 0x03A8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCanMoveWhileMenuIsOpened : 1;                     // 0x03A8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCanPerformActionsWhileMenuIsOpened : 1;           // 0x03A8(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCanAimWhileMenuIsOpened : 1;                      // 0x03A8(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bShowDebugMessages : 1;                            // 0x03A8(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bShowMouseCursor : 1;                              // 0x03A8(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_3A9[0x3];                                      // 0x03A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         StartingSectorIndex;                               // 0x03AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StartingSectorAngle;                               // 0x03B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IconSize;                                          // 0x03B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IconPadding;                                       // 0x03B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SectorInnerRadius;                                 // 0x03BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SectorOuterRadius;                                 // 0x03C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GapSize;                                           // 0x03C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WheelSize;                                         // 0x03C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WheelCursorDistanceFromCenterWheel;                // 0x03CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bHideRadialWheelCursorOnMenuOpened : 1;            // 0x03D0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_3D1[0x3];                                      // 0x03D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           SelectedColor;                                     // 0x03D4(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           UnselectedColor;                                   // 0x03E4(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           UnselectableColor;                                 // 0x03F4(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_404[0x4];                                      // 0x0404(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFont*                                  Font;                                              // 0x0408(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODEvent*                             SelectionSound;                                    // 0x0410(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODEvent*                             MenuOpenSound;                                     // 0x0418(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODEvent*                             MenuCloseSound;                                    // 0x0420(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODEvent*                             MenuCloseSound_NoSelection;                        // 0x0428(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URadialWidgetThemeData*                 RadialWidgetTheme;                                 // 0x0430(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              MousePosition;                                     // 0x0438(0x0010)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              MouseAxisDelta;                                    // 0x0448(0x0010)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MouseWheelDelta;                                   // 0x0458(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MouseAngle;                                        // 0x045C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GamepadXAxis;                                      // 0x0460(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GamepadYAxis;                                      // 0x0464(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GamepadAngle;                                      // 0x0468(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GlobalTimeDilation;                                // 0x046C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_470[0x18];                                     // 0x0470(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginCloseWheel();
	void BeginOpenWheel();
	struct FVector2D CalculatePositionOnCircleFromWidget(class UPanelWidget* PanelWidget, const struct FVector2D& Origin, const struct FVector2D& InPadding, float InAngle);
	bool CloseWheel(bool bExecuteRadial, bool bRemoveFromParent, bool bHideMouseCursor, ERadialMenuCloseReason CloseReason);
	void CloseWheel_Internal(bool bExecuteRadial, bool bRemoveFromParent, bool bHideMouseCursor, ERadialMenuCloseReason CloseReason);
	bool CreateWheel();
	bool CreateWheelSector(class UPanelWidget* PanelWidget, float InAngle, float InSectorInnerRadius, float InSectorOuterRadius, class UMaterialInterface* InSectorMaterial, bool bCreateGap);
	bool Deselect(int32 Index_0);
	bool DeselectAll();
	void DetermineInputDevice();
	bool DetermineSelectedSector(float InAngle);
	bool ExecuteRadial();
	float GetCorrectAngle();
	struct FLinearColor GetCorrectSelectionColor();
	float GetDirectionToGamepadAxis();
	float GetDirectionToMouse(const struct FVector2D& MidWidgetCoordinates);
	struct FVector2D GetPixelPositionOfWidget(class UWidget* InWidget, const struct FVector2D& InCoordinates);
	struct FVector2D GetPixelPositionOfWidgetCenter(class UWidget* InWidget);
	struct FVector2D GetViewportPositionOfWidget(class UWidget* InWidget, const struct FVector2D& InCoordinates);
	struct FVector2D GetViewportPositionOfWidgetCenter(class UWidget* InWidget);
	void HideMouseCursor();
	bool HideWheel();
	bool InitializeMenu(int32 Index_0);
	bool InitializeMenuProperties();
	bool IsMenuClosing();
	bool IsMenuOpening();
	bool IsWheelClosed();
	bool IsWheelCursorVisible();
	bool IsWheelOpen();
	bool Next();
	void OnRadialMenuClosed();
	void OnRadialMenuCreated();
	bool OnRadialMenuInitialized();
	void OnRadialMenuOpened();
	bool OnRadialSectorCreated(int32 Index_0, float InAngle);
	void OnSectorDeselected(int32 DeselectedIndex);
	void OnSectorSelected(int32 SelectedIndex);
	bool OpenWheel(bool bForceRefresh);
	void OpenWheel_Internal(bool bForceRefresh);
	bool Previous();
	bool RefreshWheel(int32 InStartingSectorIndex);
	void RestoreMousePosition();
	void SaveMousePosition();
	bool Select(int32 Index_0);
	void SetCloseDelay(float NewDelay);
	void SetGamepadXAxis(float InGamepadXAxis);
	void SetGamepadXYAxis(float InGamepadXAxis, float InGamepadYAxis);
	void SetGamepadYAxis(float InGamepadYAxis);
	void SetMousePosition(const struct FVector2D& NewMousePosition);
	void SetMousePositionToCenterScreen();
	void SetMouseWheelDelta(float InDelta);
	void Setup(const struct FRadialWidgetSpawnProperties& RadialWidgetSpawnProperties);
	void ShowMouseCursor();
	bool ShowWheel();
	void UpdateGamepadSelectionLogic(class UWidget* RadialCursorWidget);
	void UpdateMouseSelectionLogic(class UWidget* RadialCursorWidget);
	void UpdateSectorColor(int32 SectorIndex, const struct FLinearColor& SectorColor);
	void UseGamepadControl();
	void UseMouseControl();

	ERadialMenuCloseReason GetLastClosedReason() const;
	bool WasForceClosed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RadialWidgetBase">();
	}
	static class URadialWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<URadialWidgetBase>();
	}
};
static_assert(alignof(URadialWidgetBase) == 0x000008, "Wrong alignment on URadialWidgetBase");
static_assert(sizeof(URadialWidgetBase) == 0x000488, "Wrong size on URadialWidgetBase");
static_assert(offsetof(URadialWidgetBase, OnRadialMenuOpened_Delegate) == 0x0002E8, "Member 'URadialWidgetBase::OnRadialMenuOpened_Delegate' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, OnRadialMenuClosed_Delegate) == 0x0002F8, "Member 'URadialWidgetBase::OnRadialMenuClosed_Delegate' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, CurrentSelectionIndex) == 0x000308, "Member 'URadialWidgetBase::CurrentSelectionIndex' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, PreviousSelectionIndex) == 0x00030C, "Member 'URadialWidgetBase::PreviousSelectionIndex' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, Angle) == 0x000310, "Member 'URadialWidgetBase::Angle' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, AngleSpread) == 0x000314, "Member 'URadialWidgetBase::AngleSpread' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, PercentageWithoutGap) == 0x000318, "Member 'URadialWidgetBase::PercentageWithoutGap' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, PercentageWithGap) == 0x00031C, "Member 'URadialWidgetBase::PercentageWithGap' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, RadialCursorPosition) == 0x000328, "Member 'URadialWidgetBase::RadialCursorPosition' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, Angles) == 0x000338, "Member 'URadialWidgetBase::Angles' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, Sectors) == 0x000348, "Member 'URadialWidgetBase::Sectors' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, RadialWheel) == 0x000358, "Member 'URadialWidgetBase::RadialWheel' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, RadialWheelCursor) == 0x000360, "Member 'URadialWidgetBase::RadialWheelCursor' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, OwningPlayer) == 0x000368, "Member 'URadialWidgetBase::OwningPlayer' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, OwningPawn) == 0x000370, "Member 'URadialWidgetBase::OwningPawn' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, OwningPlayerCharacter) == 0x000378, "Member 'URadialWidgetBase::OwningPlayerCharacter' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, NumOfSectors) == 0x000380, "Member 'URadialWidgetBase::NumOfSectors' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, OpenDelay) == 0x000384, "Member 'URadialWidgetBase::OpenDelay' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, CloseDelay) == 0x000388, "Member 'URadialWidgetBase::CloseDelay' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, MinWheelSize) == 0x00038C, "Member 'URadialWidgetBase::MinWheelSize' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, MaxWheelSize) == 0x000390, "Member 'URadialWidgetBase::MaxWheelSize' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, MinCursorAngle) == 0x000394, "Member 'URadialWidgetBase::MinCursorAngle' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, MaxCursorAngle) == 0x000398, "Member 'URadialWidgetBase::MaxCursorAngle' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, RadialCursorBehaviour) == 0x00039C, "Member 'URadialWidgetBase::RadialCursorBehaviour' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, RadialSectorWidgetClass) == 0x0003A0, "Member 'URadialWidgetBase::RadialSectorWidgetClass' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, StartingSectorIndex) == 0x0003AC, "Member 'URadialWidgetBase::StartingSectorIndex' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, StartingSectorAngle) == 0x0003B0, "Member 'URadialWidgetBase::StartingSectorAngle' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, IconSize) == 0x0003B4, "Member 'URadialWidgetBase::IconSize' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, IconPadding) == 0x0003B8, "Member 'URadialWidgetBase::IconPadding' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, SectorInnerRadius) == 0x0003BC, "Member 'URadialWidgetBase::SectorInnerRadius' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, SectorOuterRadius) == 0x0003C0, "Member 'URadialWidgetBase::SectorOuterRadius' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, GapSize) == 0x0003C4, "Member 'URadialWidgetBase::GapSize' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, WheelSize) == 0x0003C8, "Member 'URadialWidgetBase::WheelSize' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, WheelCursorDistanceFromCenterWheel) == 0x0003CC, "Member 'URadialWidgetBase::WheelCursorDistanceFromCenterWheel' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, SelectedColor) == 0x0003D4, "Member 'URadialWidgetBase::SelectedColor' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, UnselectedColor) == 0x0003E4, "Member 'URadialWidgetBase::UnselectedColor' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, UnselectableColor) == 0x0003F4, "Member 'URadialWidgetBase::UnselectableColor' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, Font) == 0x000408, "Member 'URadialWidgetBase::Font' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, SelectionSound) == 0x000410, "Member 'URadialWidgetBase::SelectionSound' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, MenuOpenSound) == 0x000418, "Member 'URadialWidgetBase::MenuOpenSound' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, MenuCloseSound) == 0x000420, "Member 'URadialWidgetBase::MenuCloseSound' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, MenuCloseSound_NoSelection) == 0x000428, "Member 'URadialWidgetBase::MenuCloseSound_NoSelection' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, RadialWidgetTheme) == 0x000430, "Member 'URadialWidgetBase::RadialWidgetTheme' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, MousePosition) == 0x000438, "Member 'URadialWidgetBase::MousePosition' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, MouseAxisDelta) == 0x000448, "Member 'URadialWidgetBase::MouseAxisDelta' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, MouseWheelDelta) == 0x000458, "Member 'URadialWidgetBase::MouseWheelDelta' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, MouseAngle) == 0x00045C, "Member 'URadialWidgetBase::MouseAngle' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, GamepadXAxis) == 0x000460, "Member 'URadialWidgetBase::GamepadXAxis' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, GamepadYAxis) == 0x000464, "Member 'URadialWidgetBase::GamepadYAxis' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, GamepadAngle) == 0x000468, "Member 'URadialWidgetBase::GamepadAngle' has a wrong offset!");
static_assert(offsetof(URadialWidgetBase, GlobalTimeDilation) == 0x00046C, "Member 'URadialWidgetBase::GlobalTimeDilation' has a wrong offset!");

// Class ReadyOrNot.WeaponWheelWidget
// 0x0010 (0x0498 - 0x0488)
class UWeaponWheelWidget : public URadialWidgetBase
{
public:
	TArray<class FName>                           Categories;                                        // 0x0488(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	bool RemoveNullItemsFromAllCategories();
	bool RemoveNullItemsFromCategory(const class FName& WeaponWheelCategoryName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponWheelWidget">();
	}
	static class UWeaponWheelWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponWheelWidget>();
	}
};
static_assert(alignof(UWeaponWheelWidget) == 0x000008, "Wrong alignment on UWeaponWheelWidget");
static_assert(sizeof(UWeaponWheelWidget) == 0x000498, "Wrong size on UWeaponWheelWidget");
static_assert(offsetof(UWeaponWheelWidget, Categories) == 0x000488, "Member 'UWeaponWheelWidget::Categories' has a wrong offset!");

// Class ReadyOrNot.CoverLandmarkProxy
// 0x0018 (0x02B0 - 0x0298)
class ACoverLandmarkProxy final : public AActor
{
public:
	class ACoverLandmark*                         LandmarkOwner;                                     // 0x0298(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECoverLandmarkAnimDirection                   EntryDirection;                                    // 0x02A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECoverLandmarkAnimDirection                   ExitDirection;                                     // 0x02A1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A2[0x6];                                      // 0x02A2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        SceneComponent;                                    // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void DisableProxyInteraction();
	void EnableProxyInteraction();
	void OnProxyEnd(bool bSuccess);
	void OnProxyUse(bool bIsActive);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoverLandmarkProxy">();
	}
	static class ACoverLandmarkProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACoverLandmarkProxy>();
	}
};
static_assert(alignof(ACoverLandmarkProxy) == 0x000008, "Wrong alignment on ACoverLandmarkProxy");
static_assert(sizeof(ACoverLandmarkProxy) == 0x0002B0, "Wrong size on ACoverLandmarkProxy");
static_assert(offsetof(ACoverLandmarkProxy, LandmarkOwner) == 0x000298, "Member 'ACoverLandmarkProxy::LandmarkOwner' has a wrong offset!");
static_assert(offsetof(ACoverLandmarkProxy, EntryDirection) == 0x0002A0, "Member 'ACoverLandmarkProxy::EntryDirection' has a wrong offset!");
static_assert(offsetof(ACoverLandmarkProxy, ExitDirection) == 0x0002A1, "Member 'ACoverLandmarkProxy::ExitDirection' has a wrong offset!");
static_assert(offsetof(ACoverLandmarkProxy, SceneComponent) == 0x0002A8, "Member 'ACoverLandmarkProxy::SceneComponent' has a wrong offset!");

// Class ReadyOrNot.CacheResourceComponent
// 0x0008 (0x0100 - 0x00F8)
class UCacheResourceComponent : public UResourceComponent
{
public:
	ECacheItemTypes                               ItemType;                                          // 0x00F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F9[0x3];                                       // 0x00F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ResourceCountToGrab;                               // 0x00FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CacheResourceComponent">();
	}
	static class UCacheResourceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCacheResourceComponent>();
	}
};
static_assert(alignof(UCacheResourceComponent) == 0x000008, "Wrong alignment on UCacheResourceComponent");
static_assert(sizeof(UCacheResourceComponent) == 0x000100, "Wrong size on UCacheResourceComponent");
static_assert(offsetof(UCacheResourceComponent, ItemType) == 0x0000F8, "Member 'UCacheResourceComponent::ItemType' has a wrong offset!");
static_assert(offsetof(UCacheResourceComponent, ResourceCountToGrab) == 0x0000FC, "Member 'UCacheResourceComponent::ResourceCountToGrab' has a wrong offset!");

// Class ReadyOrNot.CoverQueryResultInterface
// 0x0000 (0x0000 - 0x0000)
class ICoverQueryResultInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoverQueryResultInterface">();
	}
	static class ICoverQueryResultInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICoverQueryResultInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ICoverQueryResultInterface) == 0x000001, "Wrong alignment on ICoverQueryResultInterface");
static_assert(sizeof(ICoverQueryResultInterface) == 0x000001, "Wrong size on ICoverQueryResultInterface");

// Class ReadyOrNot.CSGasDamageType
// 0x0000 (0x07B0 - 0x07B0)
class UCSGasDamageType : public UStunDamage
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CSGasDamageType">();
	}
	static class UCSGasDamageType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCSGasDamageType>();
	}
};
static_assert(alignof(UCSGasDamageType) == 0x000010, "Wrong alignment on UCSGasDamageType");
static_assert(sizeof(UCSGasDamageType) == 0x0007B0, "Wrong size on UCSGasDamageType");

// Class ReadyOrNot.InterestOverrideZone
// 0x00D0 (0x03A0 - 0x02D0)
class AInterestOverrideZone final : public AVolume
{
public:
	TArray<struct FInterestPoint>                 InterestPoints;                                    // 0x02D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	TArray<struct FInterestStationPoint>          StationPoints;                                     // 0x02E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	TArray<class ACyberneticCharacter*>           CharactersInZone;                                  // 0x02F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditFixedSize, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TMap<class ACyberneticCharacter*, uint8>      FocusIndexMap;                                     // 0x0300(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditFixedSize, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	TMap<class ACyberneticCharacter*, uint8>      MoveIndexMap;                                      // 0x0350(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditFixedSize, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)

public:
	void OnBeginOverlap(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnEndOverlap(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnWorldBeginPlay();

	bool GetCurrentInterestInfo(class ACyberneticCharacter* AI, struct FVector* OutLocation, class AActor** OutActor) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterestOverrideZone">();
	}
	static class AInterestOverrideZone* GetDefaultObj()
	{
		return GetDefaultObjImpl<AInterestOverrideZone>();
	}
};
static_assert(alignof(AInterestOverrideZone) == 0x000008, "Wrong alignment on AInterestOverrideZone");
static_assert(sizeof(AInterestOverrideZone) == 0x0003A0, "Wrong size on AInterestOverrideZone");
static_assert(offsetof(AInterestOverrideZone, InterestPoints) == 0x0002D0, "Member 'AInterestOverrideZone::InterestPoints' has a wrong offset!");
static_assert(offsetof(AInterestOverrideZone, StationPoints) == 0x0002E0, "Member 'AInterestOverrideZone::StationPoints' has a wrong offset!");
static_assert(offsetof(AInterestOverrideZone, CharactersInZone) == 0x0002F0, "Member 'AInterestOverrideZone::CharactersInZone' has a wrong offset!");
static_assert(offsetof(AInterestOverrideZone, FocusIndexMap) == 0x000300, "Member 'AInterestOverrideZone::FocusIndexMap' has a wrong offset!");
static_assert(offsetof(AInterestOverrideZone, MoveIndexMap) == 0x000350, "Member 'AInterestOverrideZone::MoveIndexMap' has a wrong offset!");

// Class ReadyOrNot.CSGasData
// 0x0038 (0x0068 - 0x0030)
class UCSGasData final : public UDataAsset
{
public:
	class UEnvQuery*                              GasGenerationQuery;                                // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageType>                DamageType;                                        // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class APepperGasCloud>            PepperGasCloud;                                    // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SafePointsBufferDistance;                          // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                NavModifierExtents;                                // 0x0050(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CSGasData">();
	}
	static class UCSGasData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCSGasData>();
	}
};
static_assert(alignof(UCSGasData) == 0x000008, "Wrong alignment on UCSGasData");
static_assert(sizeof(UCSGasData) == 0x000068, "Wrong size on UCSGasData");
static_assert(offsetof(UCSGasData, GasGenerationQuery) == 0x000030, "Member 'UCSGasData::GasGenerationQuery' has a wrong offset!");
static_assert(offsetof(UCSGasData, DamageType) == 0x000038, "Member 'UCSGasData::DamageType' has a wrong offset!");
static_assert(offsetof(UCSGasData, PepperGasCloud) == 0x000040, "Member 'UCSGasData::PepperGasCloud' has a wrong offset!");
static_assert(offsetof(UCSGasData, SafePointsBufferDistance) == 0x000048, "Member 'UCSGasData::SafePointsBufferDistance' has a wrong offset!");
static_assert(offsetof(UCSGasData, NavModifierExtents) == 0x000050, "Member 'UCSGasData::NavModifierExtents' has a wrong offset!");

// Class ReadyOrNot.GamepadSubsystem
// 0x0010 (0x0040 - 0x0030)
class UGamepadSubsystem final : public ULocalPlayerSubsystem
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateAdaptiveTriggerSettings();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GamepadSubsystem">();
	}
	static class UGamepadSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGamepadSubsystem>();
	}
};
static_assert(alignof(UGamepadSubsystem) == 0x000008, "Wrong alignment on UGamepadSubsystem");
static_assert(sizeof(UGamepadSubsystem) == 0x000040, "Wrong size on UGamepadSubsystem");

// Class ReadyOrNot.CSGasManager
// 0x0210 (0x0250 - 0x0040)
class UCSGasManager final : public UTickableWorldSubsystem
{
public:
	class UEnvQuery*                              GasGenerationQuery;                                // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxGasPointsPerSource;                             // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 NavVolumesContainer;                               // 0x0050(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCSGasData*                             GasData;                                           // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         GasSources;                                        // 0x0060(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<struct FVector>                        SafePoints;                                        // 0x0070(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FVector>                        GasPoints;                                         // 0x0080(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class AReadyOrNotCharacter*>           CharactersInGasSourceRadius;                       // 0x0090(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                         PepperbalLGasSources;                              // 0x00A0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B0[0x8];                                       // 0x00B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                NavModifierBoxExtents;                             // 0x00B8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D0[0xC0];                                      // 0x00D0(0x00C0)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, class AActor*>                    QueryIdToGasSourceMap;                             // 0x0190(0x0050)(NativeAccessSpecifierPrivate)
	TMap<class AActor*, struct FGasVolumesContainer> GasSourceToGasVolumesMap;                       // 0x01E0(0x0050)(ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UGasVolumeComponent*>            FreeGasVolumes;                                    // 0x0230(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<struct FVector>                        NewGasPoints;                                      // 0x0240(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UCSGasManager* Get(class UWorld* World);

	void AddGasSource(class AActor* Source);
	void AddPepperballLocation(class APepperProjectile* Projectile, const struct FVector& Location, const struct FVector& Normal);
	void GetGasSafePoints(TArray<struct FVector>* OutGasSafePoints);
	int32 GetGasSourceCount();
	void GetGasSources(TArray<class AActor*>* OutGasSources);
	void OnPepperCloudSpawned(struct FVector* Location);
	void RemoveGasSource(class AActor* Source);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CSGasManager">();
	}
	static class UCSGasManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCSGasManager>();
	}
};
static_assert(alignof(UCSGasManager) == 0x000008, "Wrong alignment on UCSGasManager");
static_assert(sizeof(UCSGasManager) == 0x000250, "Wrong size on UCSGasManager");
static_assert(offsetof(UCSGasManager, GasGenerationQuery) == 0x000040, "Member 'UCSGasManager::GasGenerationQuery' has a wrong offset!");
static_assert(offsetof(UCSGasManager, MaxGasPointsPerSource) == 0x000048, "Member 'UCSGasManager::MaxGasPointsPerSource' has a wrong offset!");
static_assert(offsetof(UCSGasManager, NavVolumesContainer) == 0x000050, "Member 'UCSGasManager::NavVolumesContainer' has a wrong offset!");
static_assert(offsetof(UCSGasManager, GasData) == 0x000058, "Member 'UCSGasManager::GasData' has a wrong offset!");
static_assert(offsetof(UCSGasManager, GasSources) == 0x000060, "Member 'UCSGasManager::GasSources' has a wrong offset!");
static_assert(offsetof(UCSGasManager, SafePoints) == 0x000070, "Member 'UCSGasManager::SafePoints' has a wrong offset!");
static_assert(offsetof(UCSGasManager, GasPoints) == 0x000080, "Member 'UCSGasManager::GasPoints' has a wrong offset!");
static_assert(offsetof(UCSGasManager, CharactersInGasSourceRadius) == 0x000090, "Member 'UCSGasManager::CharactersInGasSourceRadius' has a wrong offset!");
static_assert(offsetof(UCSGasManager, PepperbalLGasSources) == 0x0000A0, "Member 'UCSGasManager::PepperbalLGasSources' has a wrong offset!");
static_assert(offsetof(UCSGasManager, NavModifierBoxExtents) == 0x0000B8, "Member 'UCSGasManager::NavModifierBoxExtents' has a wrong offset!");
static_assert(offsetof(UCSGasManager, QueryIdToGasSourceMap) == 0x000190, "Member 'UCSGasManager::QueryIdToGasSourceMap' has a wrong offset!");
static_assert(offsetof(UCSGasManager, GasSourceToGasVolumesMap) == 0x0001E0, "Member 'UCSGasManager::GasSourceToGasVolumesMap' has a wrong offset!");
static_assert(offsetof(UCSGasManager, FreeGasVolumes) == 0x000230, "Member 'UCSGasManager::FreeGasVolumes' has a wrong offset!");
static_assert(offsetof(UCSGasManager, NewGasPoints) == 0x000240, "Member 'UCSGasManager::NewGasPoints' has a wrong offset!");

// Class ReadyOrNot.CTFTriggerBox
// 0x0008 (0x02A8 - 0x02A0)
class ACTFTriggerBox final : public ATriggerBox
{
public:
	class UTextRenderComponent*                   TextRender;                                        // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool FulfillsRequirements();
	void OnBeginOverlap(class AActor* OverlappedActor, class AActor* OtherActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CTFTriggerBox">();
	}
	static class ACTFTriggerBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACTFTriggerBox>();
	}
};
static_assert(alignof(ACTFTriggerBox) == 0x000008, "Wrong alignment on ACTFTriggerBox");
static_assert(sizeof(ACTFTriggerBox) == 0x0002A8, "Wrong size on ACTFTriggerBox");
static_assert(offsetof(ACTFTriggerBox, TextRender) == 0x0002A0, "Member 'ACTFTriggerBox::TextRender' has a wrong offset!");

// Class ReadyOrNot.GrenadeLauncher
// 0x0350 (0x1A90 - 0x1740)
class AGrenadeLauncher : public ABaseMagazineWeapon
{
public:
	TArray<class AGrenadeProjectile*>             AppliedGrenadeProjectilePaths;                     // 0x1738(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	class AGrenadeProjectile*                     LastSimulatedGrenade;                              // 0x1748(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LaunchDistance;                                    // 0x1750(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         GrenadeBounciness;                                 // 0x1754(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1758[0x8];                                     // 0x1758(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        BounceParticleEffect;                              // 0x1760(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFMODEvent*                             BounceFMODEvent;                                   // 0x1768(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FVector>                        FirstBouncePath;                                   // 0x1770(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FHitResult                             FirstBounceHit;                                    // 0x1780(0x00E8)(IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1868[0x8];                                     // 0x1868(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        SecondBouncePath;                                  // 0x1870(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FHitResult                             SecondBounceHit;                                   // 0x1880(0x00E8)(IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1968[0x8];                                     // 0x1968(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        ThirdBouncePath;                                   // 0x1970(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FHitResult                             ThirdBounceHit;                                    // 0x1980(0x00E8)(IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A68[0x18];                                    // 0x1A68(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BouncePt1;                                         // 0x1A80(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         BouncePt2;                                         // 0x1A84(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         BouncePt3;                                         // 0x1A88(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A8C[0x4];                                     // 0x1A8C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateServerPath(const TArray<struct FVector_NetQuantize>& Path, int32 Bounce1, int32 Bounce2, int32 Bounce3);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GrenadeLauncher">();
	}
	static class AGrenadeLauncher* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGrenadeLauncher>();
	}
};
static_assert(alignof(AGrenadeLauncher) == 0x000010, "Wrong alignment on AGrenadeLauncher");
static_assert(sizeof(AGrenadeLauncher) == 0x001A90, "Wrong size on AGrenadeLauncher");
static_assert(offsetof(AGrenadeLauncher, AppliedGrenadeProjectilePaths) == 0x001738, "Member 'AGrenadeLauncher::AppliedGrenadeProjectilePaths' has a wrong offset!");
static_assert(offsetof(AGrenadeLauncher, LastSimulatedGrenade) == 0x001748, "Member 'AGrenadeLauncher::LastSimulatedGrenade' has a wrong offset!");
static_assert(offsetof(AGrenadeLauncher, LaunchDistance) == 0x001750, "Member 'AGrenadeLauncher::LaunchDistance' has a wrong offset!");
static_assert(offsetof(AGrenadeLauncher, GrenadeBounciness) == 0x001754, "Member 'AGrenadeLauncher::GrenadeBounciness' has a wrong offset!");
static_assert(offsetof(AGrenadeLauncher, BounceParticleEffect) == 0x001760, "Member 'AGrenadeLauncher::BounceParticleEffect' has a wrong offset!");
static_assert(offsetof(AGrenadeLauncher, BounceFMODEvent) == 0x001768, "Member 'AGrenadeLauncher::BounceFMODEvent' has a wrong offset!");
static_assert(offsetof(AGrenadeLauncher, FirstBouncePath) == 0x001770, "Member 'AGrenadeLauncher::FirstBouncePath' has a wrong offset!");
static_assert(offsetof(AGrenadeLauncher, FirstBounceHit) == 0x001780, "Member 'AGrenadeLauncher::FirstBounceHit' has a wrong offset!");
static_assert(offsetof(AGrenadeLauncher, SecondBouncePath) == 0x001870, "Member 'AGrenadeLauncher::SecondBouncePath' has a wrong offset!");
static_assert(offsetof(AGrenadeLauncher, SecondBounceHit) == 0x001880, "Member 'AGrenadeLauncher::SecondBounceHit' has a wrong offset!");
static_assert(offsetof(AGrenadeLauncher, ThirdBouncePath) == 0x001970, "Member 'AGrenadeLauncher::ThirdBouncePath' has a wrong offset!");
static_assert(offsetof(AGrenadeLauncher, ThirdBounceHit) == 0x001980, "Member 'AGrenadeLauncher::ThirdBounceHit' has a wrong offset!");
static_assert(offsetof(AGrenadeLauncher, BouncePt1) == 0x001A80, "Member 'AGrenadeLauncher::BouncePt1' has a wrong offset!");
static_assert(offsetof(AGrenadeLauncher, BouncePt2) == 0x001A84, "Member 'AGrenadeLauncher::BouncePt2' has a wrong offset!");
static_assert(offsetof(AGrenadeLauncher, BouncePt3) == 0x001A88, "Member 'AGrenadeLauncher::BouncePt3' has a wrong offset!");

// Class ReadyOrNot.CTF_Flag
// 0x0028 (0x02C0 - 0x0298)
class ACTF_Flag final : public AActor
{
public:
	class USceneComponent*                        SceneComponent;                                    // 0x0298(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   FlagMeshComponent;                                 // 0x02A0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          CaptureBoxComponent;                               // 0x02A8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UObjectiveMarkerComponent*              ObjectiveMarkerComponent;                          // 0x02B0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   BoneToAttach;                                      // 0x02B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnFlagBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void ResetFlagTransforms();

	class FName GetBoneToAttachName() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CTF_Flag">();
	}
	static class ACTF_Flag* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACTF_Flag>();
	}
};
static_assert(alignof(ACTF_Flag) == 0x000008, "Wrong alignment on ACTF_Flag");
static_assert(sizeof(ACTF_Flag) == 0x0002C0, "Wrong size on ACTF_Flag");
static_assert(offsetof(ACTF_Flag, SceneComponent) == 0x000298, "Member 'ACTF_Flag::SceneComponent' has a wrong offset!");
static_assert(offsetof(ACTF_Flag, FlagMeshComponent) == 0x0002A0, "Member 'ACTF_Flag::FlagMeshComponent' has a wrong offset!");
static_assert(offsetof(ACTF_Flag, CaptureBoxComponent) == 0x0002A8, "Member 'ACTF_Flag::CaptureBoxComponent' has a wrong offset!");
static_assert(offsetof(ACTF_Flag, ObjectiveMarkerComponent) == 0x0002B0, "Member 'ACTF_Flag::ObjectiveMarkerComponent' has a wrong offset!");
static_assert(offsetof(ACTF_Flag, BoneToAttach) == 0x0002B8, "Member 'ACTF_Flag::BoneToAttach' has a wrong offset!");

// Class ReadyOrNot.WorldGenSave
// 0x0040 (0x0068 - 0x0028)
class UWorldGenSave final : public USaveGame
{
public:
	TArray<struct FSavedThreatAwarenessActor>     SavedThreatAwarenessActors;                        // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSavedDoorActor>                SavedDoorActors;                                   // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSavedCoverActor>               SavedCoverActors;                                  // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSavedRoomData>                 SavedRooms;                                        // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldGenSave">();
	}
	static class UWorldGenSave* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWorldGenSave>();
	}
};
static_assert(alignof(UWorldGenSave) == 0x000008, "Wrong alignment on UWorldGenSave");
static_assert(sizeof(UWorldGenSave) == 0x000068, "Wrong size on UWorldGenSave");
static_assert(offsetof(UWorldGenSave, SavedThreatAwarenessActors) == 0x000028, "Member 'UWorldGenSave::SavedThreatAwarenessActors' has a wrong offset!");
static_assert(offsetof(UWorldGenSave, SavedDoorActors) == 0x000038, "Member 'UWorldGenSave::SavedDoorActors' has a wrong offset!");
static_assert(offsetof(UWorldGenSave, SavedCoverActors) == 0x000048, "Member 'UWorldGenSave::SavedCoverActors' has a wrong offset!");
static_assert(offsetof(UWorldGenSave, SavedRooms) == 0x000058, "Member 'UWorldGenSave::SavedRooms' has a wrong offset!");

// Class ReadyOrNot.CTF_FlagSpawnPoint
// 0x0000 (0x02B0 - 0x02B0)
class ACTF_FlagSpawnPoint final : public AActorSpawnPoint
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CTF_FlagSpawnPoint">();
	}
	static class ACTF_FlagSpawnPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACTF_FlagSpawnPoint>();
	}
};
static_assert(alignof(ACTF_FlagSpawnPoint) == 0x000008, "Wrong alignment on ACTF_FlagSpawnPoint");
static_assert(sizeof(ACTF_FlagSpawnPoint) == 0x0002B0, "Wrong size on ACTF_FlagSpawnPoint");

// Class ReadyOrNot.GasSource
// 0x0000 (0x0000 - 0x0000)
class IGasSource final
{
public:
	bool AffectsNavigation() const;
	bool AppliesStunDamage() const;
	float GetGasRadius() const;
	bool GetGasReleaseLocation(struct FVector* OutLocation) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GasSource">();
	}
	static class IGasSource* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGasSource>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IGasSource) == 0x000001, "Wrong alignment on IGasSource");
static_assert(sizeof(IGasSource) == 0x000001, "Wrong size on IGasSource");

// Class ReadyOrNot.CurrentMatchRoundWidget
// 0x0010 (0x02F8 - 0x02E8)
class UCurrentMatchRoundWidget final : public UBaseWidget
{
public:
	class UTextBlock*                             CurrentRound_Text;                                 // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             CurrentRound_Text_Style2;                          // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CurrentMatchRoundWidget">();
	}
	static class UCurrentMatchRoundWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCurrentMatchRoundWidget>();
	}
};
static_assert(alignof(UCurrentMatchRoundWidget) == 0x000008, "Wrong alignment on UCurrentMatchRoundWidget");
static_assert(sizeof(UCurrentMatchRoundWidget) == 0x0002F8, "Wrong size on UCurrentMatchRoundWidget");
static_assert(offsetof(UCurrentMatchRoundWidget, CurrentRound_Text) == 0x0002E8, "Member 'UCurrentMatchRoundWidget::CurrentRound_Text' has a wrong offset!");
static_assert(offsetof(UCurrentMatchRoundWidget, CurrentRound_Text_Style2) == 0x0002F0, "Member 'UCurrentMatchRoundWidget::CurrentRound_Text_Style2' has a wrong offset!");

// Class ReadyOrNot.CursorWidget
// 0x0000 (0x02C0 - 0x02C0)
class UCursorWidget : public UUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CursorWidget">();
	}
	static class UCursorWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCursorWidget>();
	}
};
static_assert(alignof(UCursorWidget) == 0x000008, "Wrong alignment on UCursorWidget");
static_assert(sizeof(UCursorWidget) == 0x0002C0, "Wrong size on UCursorWidget");

// Class ReadyOrNot.GamepadHelperLib
// 0x0000 (0x0028 - 0x0028)
class UGamepadHelperLib final : public UBlueprintFunctionLibrary
{
public:
	static bool EnableCommonInputPreprocessing(class UWorld* World, bool Enable);
	static int32 GetActiveButton(int32 CurrentIndex, int32 navigationDirection, const TArray<bool>& buttonAvailability);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GamepadHelperLib">();
	}
	static class UGamepadHelperLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGamepadHelperLib>();
	}
};
static_assert(alignof(UGamepadHelperLib) == 0x000008, "Wrong alignment on UGamepadHelperLib");
static_assert(sizeof(UGamepadHelperLib) == 0x000028, "Wrong size on UGamepadHelperLib");

// Class ReadyOrNot.GibComponent
// 0x0070 (0x0110 - 0x00A0)
class UGibComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x18];                                      // 0x00A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EGibAreas>                             GibbedAreas;                                       // 0x00B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, Protected, NativeAccessSpecifierProtected)
	class UBloodData*                             BloodData;                                         // 0x00C8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 BodyMesh;                                          // 0x00D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 FaceMesh;                                          // 0x00D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            GibHead;                                           // 0x00E0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            GibArms;                                           // 0x00E8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            GibLegs;                                           // 0x00F0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            BoneHead;                                          // 0x00F8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            BoneArms;                                          // 0x0100(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            BoneLegs;                                          // 0x0108(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GibComponent">();
	}
	static class UGibComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGibComponent>();
	}
};
static_assert(alignof(UGibComponent) == 0x000008, "Wrong alignment on UGibComponent");
static_assert(sizeof(UGibComponent) == 0x000110, "Wrong size on UGibComponent");
static_assert(offsetof(UGibComponent, GibbedAreas) == 0x0000B8, "Member 'UGibComponent::GibbedAreas' has a wrong offset!");
static_assert(offsetof(UGibComponent, BloodData) == 0x0000C8, "Member 'UGibComponent::BloodData' has a wrong offset!");
static_assert(offsetof(UGibComponent, BodyMesh) == 0x0000D0, "Member 'UGibComponent::BodyMesh' has a wrong offset!");
static_assert(offsetof(UGibComponent, FaceMesh) == 0x0000D8, "Member 'UGibComponent::FaceMesh' has a wrong offset!");
static_assert(offsetof(UGibComponent, GibHead) == 0x0000E0, "Member 'UGibComponent::GibHead' has a wrong offset!");
static_assert(offsetof(UGibComponent, GibArms) == 0x0000E8, "Member 'UGibComponent::GibArms' has a wrong offset!");
static_assert(offsetof(UGibComponent, GibLegs) == 0x0000F0, "Member 'UGibComponent::GibLegs' has a wrong offset!");
static_assert(offsetof(UGibComponent, BoneHead) == 0x0000F8, "Member 'UGibComponent::BoneHead' has a wrong offset!");
static_assert(offsetof(UGibComponent, BoneArms) == 0x000100, "Member 'UGibComponent::BoneArms' has a wrong offset!");
static_assert(offsetof(UGibComponent, BoneLegs) == 0x000108, "Member 'UGibComponent::BoneLegs' has a wrong offset!");

// Class ReadyOrNot.CustomizationSkeletalMesh
// 0x0098 (0x0218 - 0x0180)
class UCustomizationSkeletalMesh : public UCustomizationDataBase
{
public:
	TSoftObjectPtr<class USkeletalMesh>           SkeletalMesh;                                      // 0x0180(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Socket;                                            // 0x01A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseMasterPose;                                    // 0x01B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B1[0x7];                                      // 0x01B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCustomizationMaterialSlot>     MaterialOverrides;                                 // 0x01B8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class FName, class FName>                SocketOverridesMap;                                // 0x01C8(0x0050)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationSkeletalMesh">();
	}
	static class UCustomizationSkeletalMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomizationSkeletalMesh>();
	}
};
static_assert(alignof(UCustomizationSkeletalMesh) == 0x000008, "Wrong alignment on UCustomizationSkeletalMesh");
static_assert(sizeof(UCustomizationSkeletalMesh) == 0x000218, "Wrong size on UCustomizationSkeletalMesh");
static_assert(offsetof(UCustomizationSkeletalMesh, SkeletalMesh) == 0x000180, "Member 'UCustomizationSkeletalMesh::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(UCustomizationSkeletalMesh, Socket) == 0x0001A8, "Member 'UCustomizationSkeletalMesh::Socket' has a wrong offset!");
static_assert(offsetof(UCustomizationSkeletalMesh, bUseMasterPose) == 0x0001B0, "Member 'UCustomizationSkeletalMesh::bUseMasterPose' has a wrong offset!");
static_assert(offsetof(UCustomizationSkeletalMesh, MaterialOverrides) == 0x0001B8, "Member 'UCustomizationSkeletalMesh::MaterialOverrides' has a wrong offset!");
static_assert(offsetof(UCustomizationSkeletalMesh, SocketOverridesMap) == 0x0001C8, "Member 'UCustomizationSkeletalMesh::SocketOverridesMap' has a wrong offset!");

// Class ReadyOrNot.CustomizationStaticMesh
// 0x0030 (0x01B0 - 0x0180)
class UCustomizationStaticMesh final : public UCustomizationDataBase
{
public:
	TSoftObjectPtr<class UStaticMesh>             StaticMesh;                                        // 0x0180(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Socket;                                            // 0x01A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationStaticMesh">();
	}
	static class UCustomizationStaticMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomizationStaticMesh>();
	}
};
static_assert(alignof(UCustomizationStaticMesh) == 0x000008, "Wrong alignment on UCustomizationStaticMesh");
static_assert(sizeof(UCustomizationStaticMesh) == 0x0001B0, "Wrong size on UCustomizationStaticMesh");
static_assert(offsetof(UCustomizationStaticMesh, StaticMesh) == 0x000180, "Member 'UCustomizationStaticMesh::StaticMesh' has a wrong offset!");
static_assert(offsetof(UCustomizationStaticMesh, Socket) == 0x0001A8, "Member 'UCustomizationStaticMesh::Socket' has a wrong offset!");

// Class ReadyOrNot.PortalVolume
// 0x0070 (0x0340 - 0x02D0)
class APortalVolume final : public AVolume
{
public:
	bool                                          bIsOutside;                                        // 0x02D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSameRoom;                                         // 0x02D1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPortalType                                   PortalType;                                        // 0x02D2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D3[0x5];                                      // 0x02D3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         OverlappingActors;                                 // 0x02D8(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class AActor>>          AttachedObjects;                                   // 0x02E8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class ADoor*>                          Doors;                                             // 0x02F8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class AActor>                  BreakableGlass_SoftPointer;                        // 0x0308(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ABreakableGlass*>                BreakableGlasses;                                  // 0x0330(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PortalVolume">();
	}
	static class APortalVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<APortalVolume>();
	}
};
static_assert(alignof(APortalVolume) == 0x000008, "Wrong alignment on APortalVolume");
static_assert(sizeof(APortalVolume) == 0x000340, "Wrong size on APortalVolume");
static_assert(offsetof(APortalVolume, bIsOutside) == 0x0002D0, "Member 'APortalVolume::bIsOutside' has a wrong offset!");
static_assert(offsetof(APortalVolume, bSameRoom) == 0x0002D1, "Member 'APortalVolume::bSameRoom' has a wrong offset!");
static_assert(offsetof(APortalVolume, PortalType) == 0x0002D2, "Member 'APortalVolume::PortalType' has a wrong offset!");
static_assert(offsetof(APortalVolume, OverlappingActors) == 0x0002D8, "Member 'APortalVolume::OverlappingActors' has a wrong offset!");
static_assert(offsetof(APortalVolume, AttachedObjects) == 0x0002E8, "Member 'APortalVolume::AttachedObjects' has a wrong offset!");
static_assert(offsetof(APortalVolume, Doors) == 0x0002F8, "Member 'APortalVolume::Doors' has a wrong offset!");
static_assert(offsetof(APortalVolume, BreakableGlass_SoftPointer) == 0x000308, "Member 'APortalVolume::BreakableGlass_SoftPointer' has a wrong offset!");
static_assert(offsetof(APortalVolume, BreakableGlasses) == 0x000330, "Member 'APortalVolume::BreakableGlasses' has a wrong offset!");

// Class ReadyOrNot.HealthStatusWidget
// 0x01D0 (0x0490 - 0x02C0)
class UHealthStatusWidget final : public UUserWidget
{
public:
	class UImage*                                 Icon_Image;                                        // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Percentage_Text;                                   // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSlateBrush                            HealthIconBrush;                                   // 0x02D0(0x00D0)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, ExposeOnSpawn, NativeAccessSpecifierProtected)
	struct FSlateBrush                            EmptyHealthIconBrush;                              // 0x03A0(0x00D0)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, ExposeOnSpawn, NativeAccessSpecifierProtected)
	struct FLinearColor                           ZeroPercentColor;                                  // 0x0470(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           OneHundredPercentColor;                            // 0x0480(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AutoDetermineIconImage();
	void UpdateHealthPercentage(float CurrentValue, float MaxValue);
	void UpdateIconColor(float CurrentValue, float MinValue, float MaxValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HealthStatusWidget">();
	}
	static class UHealthStatusWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHealthStatusWidget>();
	}
};
static_assert(alignof(UHealthStatusWidget) == 0x000010, "Wrong alignment on UHealthStatusWidget");
static_assert(sizeof(UHealthStatusWidget) == 0x000490, "Wrong size on UHealthStatusWidget");
static_assert(offsetof(UHealthStatusWidget, Icon_Image) == 0x0002C0, "Member 'UHealthStatusWidget::Icon_Image' has a wrong offset!");
static_assert(offsetof(UHealthStatusWidget, Percentage_Text) == 0x0002C8, "Member 'UHealthStatusWidget::Percentage_Text' has a wrong offset!");
static_assert(offsetof(UHealthStatusWidget, HealthIconBrush) == 0x0002D0, "Member 'UHealthStatusWidget::HealthIconBrush' has a wrong offset!");
static_assert(offsetof(UHealthStatusWidget, EmptyHealthIconBrush) == 0x0003A0, "Member 'UHealthStatusWidget::EmptyHealthIconBrush' has a wrong offset!");
static_assert(offsetof(UHealthStatusWidget, ZeroPercentColor) == 0x000470, "Member 'UHealthStatusWidget::ZeroPercentColor' has a wrong offset!");
static_assert(offsetof(UHealthStatusWidget, OneHundredPercentColor) == 0x000480, "Member 'UHealthStatusWidget::OneHundredPercentColor' has a wrong offset!");

// Class ReadyOrNot.CustomizationBlueprint
// 0x0038 (0x01B8 - 0x0180)
class UCustomizationBlueprint final : public UCustomizationDataBase
{
public:
	TSoftClassPtr<class UClass>                   BlueprintClass;                                    // 0x0180(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTickInThirdPerson;                                // 0x01A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A9[0x3];                                      // 0x01A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Socket;                                            // 0x01AC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B4[0x4];                                      // 0x01B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationBlueprint">();
	}
	static class UCustomizationBlueprint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomizationBlueprint>();
	}
};
static_assert(alignof(UCustomizationBlueprint) == 0x000008, "Wrong alignment on UCustomizationBlueprint");
static_assert(sizeof(UCustomizationBlueprint) == 0x0001B8, "Wrong size on UCustomizationBlueprint");
static_assert(offsetof(UCustomizationBlueprint, BlueprintClass) == 0x000180, "Member 'UCustomizationBlueprint::BlueprintClass' has a wrong offset!");
static_assert(offsetof(UCustomizationBlueprint, bTickInThirdPerson) == 0x0001A8, "Member 'UCustomizationBlueprint::bTickInThirdPerson' has a wrong offset!");
static_assert(offsetof(UCustomizationBlueprint, Socket) == 0x0001AC, "Member 'UCustomizationBlueprint::Socket' has a wrong offset!");

// Class ReadyOrNot.CustomizationSkin
// 0x0058 (0x01D8 - 0x0180)
class UCustomizationSkin final : public UCustomizationDataBase
{
public:
	TArray<class FName>                           CompatibleItemTags;                                // 0x0180(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           MeshOverride;                                      // 0x0190(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCustomizationMaterialSlot>     MaterialSlots;                                     // 0x01B8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bUseSocketOverride;                                // 0x01C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C9[0x3];                                      // 0x01C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SocketOverride;                                    // 0x01CC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D4[0x4];                                      // 0x01D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationSkin">();
	}
	static class UCustomizationSkin* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomizationSkin>();
	}
};
static_assert(alignof(UCustomizationSkin) == 0x000008, "Wrong alignment on UCustomizationSkin");
static_assert(sizeof(UCustomizationSkin) == 0x0001D8, "Wrong size on UCustomizationSkin");
static_assert(offsetof(UCustomizationSkin, CompatibleItemTags) == 0x000180, "Member 'UCustomizationSkin::CompatibleItemTags' has a wrong offset!");
static_assert(offsetof(UCustomizationSkin, MeshOverride) == 0x000190, "Member 'UCustomizationSkin::MeshOverride' has a wrong offset!");
static_assert(offsetof(UCustomizationSkin, MaterialSlots) == 0x0001B8, "Member 'UCustomizationSkin::MaterialSlots' has a wrong offset!");
static_assert(offsetof(UCustomizationSkin, bUseSocketOverride) == 0x0001C8, "Member 'UCustomizationSkin::bUseSocketOverride' has a wrong offset!");
static_assert(offsetof(UCustomizationSkin, SocketOverride) == 0x0001CC, "Member 'UCustomizationSkin::SocketOverride' has a wrong offset!");

// Class ReadyOrNot.GunGameGM
// 0x0310 (0x0CE0 - 0x09D0)
class AGunGameGM final : public AReadyOrNotGameMode_PVP
{
public:
	float                                         RespawnTime;                                       // 0x09D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSuddenDeath;                                      // 0x09D4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9D5[0x3];                                      // 0x09D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftClassPtr<class UClass>>           Itemlist;                                          // 0x09D8(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FSavedLoadout                          DefaultItems;                                      // 0x09E8(0x02E8)(Edit, NativeAccessSpecifierPublic)
	int32                                         KillsToProgress;                                   // 0x0CD0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CD4[0xC];                                      // 0x0CD4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class ABaseItem* EquipNextGun(class APlayerCharacter* Player, bool bAdvanceGunIdx);
	TArray<class AReadyOrNotPlayerState*> FindTopKillers();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GunGameGM">();
	}
	static class AGunGameGM* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGunGameGM>();
	}
};
static_assert(alignof(AGunGameGM) == 0x000010, "Wrong alignment on AGunGameGM");
static_assert(sizeof(AGunGameGM) == 0x000CE0, "Wrong size on AGunGameGM");
static_assert(offsetof(AGunGameGM, RespawnTime) == 0x0009D0, "Member 'AGunGameGM::RespawnTime' has a wrong offset!");
static_assert(offsetof(AGunGameGM, bSuddenDeath) == 0x0009D4, "Member 'AGunGameGM::bSuddenDeath' has a wrong offset!");
static_assert(offsetof(AGunGameGM, Itemlist) == 0x0009D8, "Member 'AGunGameGM::Itemlist' has a wrong offset!");
static_assert(offsetof(AGunGameGM, DefaultItems) == 0x0009E8, "Member 'AGunGameGM::DefaultItems' has a wrong offset!");
static_assert(offsetof(AGunGameGM, KillsToProgress) == 0x000CD0, "Member 'AGunGameGM::KillsToProgress' has a wrong offset!");

// Class ReadyOrNot.CustomizationCharacter
// 0x00A8 (0x0228 - 0x0180)
class UCustomizationCharacter final : public UCustomizationDataBase
{
public:
	TSoftObjectPtr<class USkeletalMesh>           HeadMesh;                                          // 0x0180(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterialInterface>      ArmsMaterial;                                      // 0x01A8(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UPoseAsset>              FaceROM;                                           // 0x01D0(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HairMaterialIndex;                                 // 0x01F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FC[0x4];                                      // 0x01FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              ProfileImage;                                      // 0x0200(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationCharacter">();
	}
	static class UCustomizationCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomizationCharacter>();
	}
};
static_assert(alignof(UCustomizationCharacter) == 0x000008, "Wrong alignment on UCustomizationCharacter");
static_assert(sizeof(UCustomizationCharacter) == 0x000228, "Wrong size on UCustomizationCharacter");
static_assert(offsetof(UCustomizationCharacter, HeadMesh) == 0x000180, "Member 'UCustomizationCharacter::HeadMesh' has a wrong offset!");
static_assert(offsetof(UCustomizationCharacter, ArmsMaterial) == 0x0001A8, "Member 'UCustomizationCharacter::ArmsMaterial' has a wrong offset!");
static_assert(offsetof(UCustomizationCharacter, FaceROM) == 0x0001D0, "Member 'UCustomizationCharacter::FaceROM' has a wrong offset!");
static_assert(offsetof(UCustomizationCharacter, HairMaterialIndex) == 0x0001F8, "Member 'UCustomizationCharacter::HairMaterialIndex' has a wrong offset!");
static_assert(offsetof(UCustomizationCharacter, ProfileImage) == 0x000200, "Member 'UCustomizationCharacter::ProfileImage' has a wrong offset!");

// Class ReadyOrNot.CustomizationHelmet
// 0x0020 (0x0238 - 0x0218)
class UCustomizationHelmet final : public UCustomizationSkeletalMesh
{
public:
	TArray<int32>                                 HeadsetMaterialSlots;                              // 0x0218(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           CompatibleHelmetTags;                              // 0x0228(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationHelmet">();
	}
	static class UCustomizationHelmet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomizationHelmet>();
	}
};
static_assert(alignof(UCustomizationHelmet) == 0x000008, "Wrong alignment on UCustomizationHelmet");
static_assert(sizeof(UCustomizationHelmet) == 0x000238, "Wrong size on UCustomizationHelmet");
static_assert(offsetof(UCustomizationHelmet, HeadsetMaterialSlots) == 0x000218, "Member 'UCustomizationHelmet::HeadsetMaterialSlots' has a wrong offset!");
static_assert(offsetof(UCustomizationHelmet, CompatibleHelmetTags) == 0x000228, "Member 'UCustomizationHelmet::CompatibleHelmetTags' has a wrong offset!");

// Class ReadyOrNot.GatherDebugInterface
// 0x0000 (0x0000 - 0x0000)
class IGatherDebugInterface final
{
public:
	void DrawVisualDebug();
	void GatherDebugData(TArray<struct FDebugData>* OutDebugData);
	void GatherDebugText(class FString* OutText);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GatherDebugInterface">();
	}
	static class IGatherDebugInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGatherDebugInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IGatherDebugInterface) == 0x000001, "Wrong alignment on IGatherDebugInterface");
static_assert(sizeof(IGatherDebugInterface) == 0x000001, "Wrong size on IGatherDebugInterface");

// Class ReadyOrNot.CustomizationVoice
// 0x0008 (0x0188 - 0x0180)
class UCustomizationVoice final : public UCustomizationDataBase
{
public:
	class FName                                   VoiceHandle;                                       // 0x0180(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationVoice">();
	}
	static class UCustomizationVoice* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomizationVoice>();
	}
};
static_assert(alignof(UCustomizationVoice) == 0x000008, "Wrong alignment on UCustomizationVoice");
static_assert(sizeof(UCustomizationVoice) == 0x000188, "Wrong size on UCustomizationVoice");
static_assert(offsetof(UCustomizationVoice, VoiceHandle) == 0x000180, "Member 'UCustomizationVoice::VoiceHandle' has a wrong offset!");

// Class ReadyOrNot.CustomizationTattoo
// 0x0058 (0x01D8 - 0x0180)
class UCustomizationTattoo final : public UCustomizationDataBase
{
public:
	TSoftObjectPtr<class UTexture2D>              TattooTexture;                                     // 0x0180(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCustomizationMaterialSlot             ArmSlotOverride;                                   // 0x01A8(0x0030)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationTattoo">();
	}
	static class UCustomizationTattoo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomizationTattoo>();
	}
};
static_assert(alignof(UCustomizationTattoo) == 0x000008, "Wrong alignment on UCustomizationTattoo");
static_assert(sizeof(UCustomizationTattoo) == 0x0001D8, "Wrong size on UCustomizationTattoo");
static_assert(offsetof(UCustomizationTattoo, TattooTexture) == 0x000180, "Member 'UCustomizationTattoo::TattooTexture' has a wrong offset!");
static_assert(offsetof(UCustomizationTattoo, ArmSlotOverride) == 0x0001A8, "Member 'UCustomizationTattoo::ArmSlotOverride' has a wrong offset!");

// Class ReadyOrNot.HardCoverCombatMove
// 0x0400 (0x0630 - 0x0230)
class UHardCoverCombatMove final : public UBaseCombatMoveActivity
{
public:
	uint8                                         Pad_230[0x78];                                     // 0x0230(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	class UTakeCoverActivity*                     TakeCoverActivity;                                 // 0x02A8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTakeCoverAtLandmarkActivity*           TakeCoverAtLandmarkActivity;                       // 0x02B0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B8[0x270];                                    // 0x02B8(0x0270)(Fixing Size After Last Property [ Dumper-7 ])
	class AReadyOrNotCharacter*                   LastTrackedEnemy;                                  // 0x0528(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FCoverInstigatorStimulus               LastCoverInstigatorStimulus;                       // 0x0530(0x0080)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FCoverInstigatorStimulus               PendingCoverInstigatorStimulus;                    // 0x05B0(0x0080)(NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	void OnTakeCoverActivityFinished(class UBaseActivity* Activity, class ACyberneticController* Controller);
	void OnTakeCoverAtLandmarkActivityFinished(class UBaseActivity* Activity, class ACyberneticController* Controller);
	void TrackNewEnemy(class AReadyOrNotCharacter* NewTrackedEnemy);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HardCoverCombatMove">();
	}
	static class UHardCoverCombatMove* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHardCoverCombatMove>();
	}
};
static_assert(alignof(UHardCoverCombatMove) == 0x000010, "Wrong alignment on UHardCoverCombatMove");
static_assert(sizeof(UHardCoverCombatMove) == 0x000630, "Wrong size on UHardCoverCombatMove");
static_assert(offsetof(UHardCoverCombatMove, TakeCoverActivity) == 0x0002A8, "Member 'UHardCoverCombatMove::TakeCoverActivity' has a wrong offset!");
static_assert(offsetof(UHardCoverCombatMove, TakeCoverAtLandmarkActivity) == 0x0002B0, "Member 'UHardCoverCombatMove::TakeCoverAtLandmarkActivity' has a wrong offset!");
static_assert(offsetof(UHardCoverCombatMove, LastTrackedEnemy) == 0x000528, "Member 'UHardCoverCombatMove::LastTrackedEnemy' has a wrong offset!");
static_assert(offsetof(UHardCoverCombatMove, LastCoverInstigatorStimulus) == 0x000530, "Member 'UHardCoverCombatMove::LastCoverInstigatorStimulus' has a wrong offset!");
static_assert(offsetof(UHardCoverCombatMove, PendingCoverInstigatorStimulus) == 0x0005B0, "Member 'UHardCoverCombatMove::PendingCoverInstigatorStimulus' has a wrong offset!");

// Class ReadyOrNot.CustomizationExtra
// 0x0010 (0x02A8 - 0x0298)
class ACustomizationExtra : public AActor
{
public:
	class UCustomizationSocket*                   Socket;                                            // 0x0298(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AReadyOrNotPlayerState*                 LastPlayerState;                                   // 0x02A0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationExtra">();
	}
	static class ACustomizationExtra* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACustomizationExtra>();
	}
};
static_assert(alignof(ACustomizationExtra) == 0x000008, "Wrong alignment on ACustomizationExtra");
static_assert(sizeof(ACustomizationExtra) == 0x0002A8, "Wrong size on ACustomizationExtra");
static_assert(offsetof(ACustomizationExtra, Socket) == 0x000298, "Member 'ACustomizationExtra::Socket' has a wrong offset!");
static_assert(offsetof(ACustomizationExtra, LastPlayerState) == 0x0002A0, "Member 'ACustomizationExtra::LastPlayerState' has a wrong offset!");

// Class ReadyOrNot.ReadyOrNotProfile
// 0x00B8 (0x00E0 - 0x0028)
class UReadyOrNotProfile : public USaveGame
{
public:
	class FString                                 SaveSlotName;                                      // 0x0028(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        UserIndex;                                         // 0x0038(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, struct FBasicLevelStats>  LevelStats;                                        // 0x0040(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	TMap<class FName, int32>                      ChallengeProgress;                                 // 0x0090(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)

public:
	static class UReadyOrNotProfile* CreateDefaultSavegame(TSubclassOf<class UReadyOrNotProfile> ProfileClass, const class FString& LoadSlotName);
	static void LoadLevelStats(struct FBasicLevelStats* OutStats, ECOOPMode Mode, const class FString& MapName);
	static void SaveLevelStats(const struct FBasicLevelStats& InStats, bool* NewBestRating, bool* NewBestTime);

	void ResetProfile();
	void SaveProfile();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotProfile">();
	}
	static class UReadyOrNotProfile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotProfile>();
	}
};
static_assert(alignof(UReadyOrNotProfile) == 0x000008, "Wrong alignment on UReadyOrNotProfile");
static_assert(sizeof(UReadyOrNotProfile) == 0x0000E0, "Wrong size on UReadyOrNotProfile");
static_assert(offsetof(UReadyOrNotProfile, SaveSlotName) == 0x000028, "Member 'UReadyOrNotProfile::SaveSlotName' has a wrong offset!");
static_assert(offsetof(UReadyOrNotProfile, UserIndex) == 0x000038, "Member 'UReadyOrNotProfile::UserIndex' has a wrong offset!");
static_assert(offsetof(UReadyOrNotProfile, LevelStats) == 0x000040, "Member 'UReadyOrNotProfile::LevelStats' has a wrong offset!");
static_assert(offsetof(UReadyOrNotProfile, ChallengeProgress) == 0x000090, "Member 'UReadyOrNotProfile::ChallengeProgress' has a wrong offset!");

// Class ReadyOrNot.ReadyOrNotMultiplayerProfile
// 0x0000 (0x00E0 - 0x00E0)
class UReadyOrNotMultiplayerProfile final : public UReadyOrNotProfile
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotMultiplayerProfile">();
	}
	static class UReadyOrNotMultiplayerProfile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotMultiplayerProfile>();
	}
};
static_assert(alignof(UReadyOrNotMultiplayerProfile) == 0x000008, "Wrong alignment on UReadyOrNotMultiplayerProfile");
static_assert(sizeof(UReadyOrNotMultiplayerProfile) == 0x0000E0, "Wrong size on UReadyOrNotMultiplayerProfile");

// Class ReadyOrNot.HelicopterPathNodeBehaviourComponent
// 0x0000 (0x00A0 - 0x00A0)
class UHelicopterPathNodeBehaviourComponent : public UActorComponent
{
public:
	void Multicast_OnPathEnterBehaviour(class AHelicopter* Helicopter);
	void Multicast_OnPathExitBehaviour(class AHelicopter* Helicopter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HelicopterPathNodeBehaviourComponent">();
	}
	static class UHelicopterPathNodeBehaviourComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHelicopterPathNodeBehaviourComponent>();
	}
};
static_assert(alignof(UHelicopterPathNodeBehaviourComponent) == 0x000008, "Wrong alignment on UHelicopterPathNodeBehaviourComponent");
static_assert(sizeof(UHelicopterPathNodeBehaviourComponent) == 0x0000A0, "Wrong size on UHelicopterPathNodeBehaviourComponent");

// Class ReadyOrNot.HelicopterPathNodeLightAttenuationComponent
// 0x0008 (0x00A8 - 0x00A0)
class UHelicopterPathNodeLightAttenuationComponent final : public UHelicopterPathNodeBehaviourComponent
{
public:
	float                                         AttenuationOverride;                               // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HelicopterPathNodeLightAttenuationComponent">();
	}
	static class UHelicopterPathNodeLightAttenuationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHelicopterPathNodeLightAttenuationComponent>();
	}
};
static_assert(alignof(UHelicopterPathNodeLightAttenuationComponent) == 0x000008, "Wrong alignment on UHelicopterPathNodeLightAttenuationComponent");
static_assert(sizeof(UHelicopterPathNodeLightAttenuationComponent) == 0x0000A8, "Wrong size on UHelicopterPathNodeLightAttenuationComponent");
static_assert(offsetof(UHelicopterPathNodeLightAttenuationComponent, AttenuationOverride) == 0x0000A0, "Member 'UHelicopterPathNodeLightAttenuationComponent::AttenuationOverride' has a wrong offset!");

// Class ReadyOrNot.LoadoutItem
// 0x0058 (0x0080 - 0x0028)
class ULoadoutItem : public UObject
{
public:
	class FText                                   Name_0;                                            // 0x0028(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0040(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Icon;                                              // 0x0058(0x0028)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadoutItem">();
	}
	static class ULoadoutItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadoutItem>();
	}
};
static_assert(alignof(ULoadoutItem) == 0x000008, "Wrong alignment on ULoadoutItem");
static_assert(sizeof(ULoadoutItem) == 0x000080, "Wrong size on ULoadoutItem");
static_assert(offsetof(ULoadoutItem, Name_0) == 0x000028, "Member 'ULoadoutItem::Name_0' has a wrong offset!");
static_assert(offsetof(ULoadoutItem, Description) == 0x000040, "Member 'ULoadoutItem::Description' has a wrong offset!");
static_assert(offsetof(ULoadoutItem, Icon) == 0x000058, "Member 'ULoadoutItem::Icon' has a wrong offset!");

// Class ReadyOrNot.LoadoutEquipment
// 0x0008 (0x0088 - 0x0080)
class ULoadoutEquipment : public ULoadoutItem
{
public:
	TSubclassOf<class ABaseItem>                  Class_0;                                           // 0x0080(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadoutEquipment">();
	}
	static class ULoadoutEquipment* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadoutEquipment>();
	}
};
static_assert(alignof(ULoadoutEquipment) == 0x000008, "Wrong alignment on ULoadoutEquipment");
static_assert(sizeof(ULoadoutEquipment) == 0x000088, "Wrong size on ULoadoutEquipment");
static_assert(offsetof(ULoadoutEquipment, Class_0) == 0x000080, "Member 'ULoadoutEquipment::Class_0' has a wrong offset!");

// Class ReadyOrNot.HelicopterTriggerComponent
// 0x0008 (0x00A8 - 0x00A0)
class UHelicopterTriggerComponent : public UActorComponent
{
public:
	bool                                          bAllowMultiTrigger;                                // 0x00A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DoTrigger();
	void ExitTrigger();
	void OnTrigger();
	void OnTriggerExit();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HelicopterTriggerComponent">();
	}
	static class UHelicopterTriggerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHelicopterTriggerComponent>();
	}
};
static_assert(alignof(UHelicopterTriggerComponent) == 0x000008, "Wrong alignment on UHelicopterTriggerComponent");
static_assert(sizeof(UHelicopterTriggerComponent) == 0x0000A8, "Wrong size on UHelicopterTriggerComponent");
static_assert(offsetof(UHelicopterTriggerComponent, bAllowMultiTrigger) == 0x0000A0, "Member 'UHelicopterTriggerComponent::bAllowMultiTrigger' has a wrong offset!");

// Class ReadyOrNot.LoadoutWeapon
// 0x0000 (0x0088 - 0x0088)
class ULoadoutWeapon final : public ULoadoutEquipment
{
public:
	TArray<TSubclassOf<class UWeaponAttachment>> GetSupportedAttachmentsOfType(EWeaponAttachmentType Type) const;
	TArray<EWeaponAttachmentType> GetSupportedAttachmentTypes() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadoutWeapon">();
	}
	static class ULoadoutWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadoutWeapon>();
	}
};
static_assert(alignof(ULoadoutWeapon) == 0x000008, "Wrong alignment on ULoadoutWeapon");
static_assert(sizeof(ULoadoutWeapon) == 0x000088, "Wrong size on ULoadoutWeapon");

// Class ReadyOrNot.LoadoutCustomization
// 0x0078 (0x00F8 - 0x0080)
class ULoadoutCustomization final : public ULoadoutItem
{
public:
	class UCustomizationDataBase*                 Asset;                                             // 0x0080(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Variant;                                           // 0x0088(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterialInterface>      VariantIcon;                                       // 0x00A0(0x0028)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocked;                                           // 0x00C8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   RequirementsText;                                  // 0x00D0(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<class ULoadoutCustomization*>          Children;                                          // 0x00E8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	ECustomizationType GetCustomizationType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadoutCustomization">();
	}
	static class ULoadoutCustomization* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadoutCustomization>();
	}
};
static_assert(alignof(ULoadoutCustomization) == 0x000008, "Wrong alignment on ULoadoutCustomization");
static_assert(sizeof(ULoadoutCustomization) == 0x0000F8, "Wrong size on ULoadoutCustomization");
static_assert(offsetof(ULoadoutCustomization, Asset) == 0x000080, "Member 'ULoadoutCustomization::Asset' has a wrong offset!");
static_assert(offsetof(ULoadoutCustomization, Variant) == 0x000088, "Member 'ULoadoutCustomization::Variant' has a wrong offset!");
static_assert(offsetof(ULoadoutCustomization, VariantIcon) == 0x0000A0, "Member 'ULoadoutCustomization::VariantIcon' has a wrong offset!");
static_assert(offsetof(ULoadoutCustomization, bLocked) == 0x0000C8, "Member 'ULoadoutCustomization::bLocked' has a wrong offset!");
static_assert(offsetof(ULoadoutCustomization, RequirementsText) == 0x0000D0, "Member 'ULoadoutCustomization::RequirementsText' has a wrong offset!");
static_assert(offsetof(ULoadoutCustomization, Children) == 0x0000E8, "Member 'ULoadoutCustomization::Children' has a wrong offset!");

// Class ReadyOrNot.PlayerStart_VIP_Spawn
// 0x0040 (0x0308 - 0x02C8)
class APlayerStart_VIP_Spawn final : public APlayerStart
{
public:
	uint8                                         bHasVisited : 1;                                   // 0x02C8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2C9[0x7];                                      // 0x02C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   VIPSpawnDescriptor;                                // 0x02D0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	int32                                         SuffixNumber;                                      // 0x02E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2EC[0x4];                                      // 0x02EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          SpawnBox;                                          // 0x02F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextRenderComponent*                   TextRender;                                        // 0x02F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UArrowComponent*                        SpawnDirection;                                    // 0x0300(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	struct FVector GetRandomSpawnPoint();
	struct FRotator GetSpawnDirection();

	class FText GetVIPSpawnDescriptor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerStart_VIP_Spawn">();
	}
	static class APlayerStart_VIP_Spawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayerStart_VIP_Spawn>();
	}
};
static_assert(alignof(APlayerStart_VIP_Spawn) == 0x000008, "Wrong alignment on APlayerStart_VIP_Spawn");
static_assert(sizeof(APlayerStart_VIP_Spawn) == 0x000308, "Wrong size on APlayerStart_VIP_Spawn");
static_assert(offsetof(APlayerStart_VIP_Spawn, VIPSpawnDescriptor) == 0x0002D0, "Member 'APlayerStart_VIP_Spawn::VIPSpawnDescriptor' has a wrong offset!");
static_assert(offsetof(APlayerStart_VIP_Spawn, SuffixNumber) == 0x0002E8, "Member 'APlayerStart_VIP_Spawn::SuffixNumber' has a wrong offset!");
static_assert(offsetof(APlayerStart_VIP_Spawn, SpawnBox) == 0x0002F0, "Member 'APlayerStart_VIP_Spawn::SpawnBox' has a wrong offset!");
static_assert(offsetof(APlayerStart_VIP_Spawn, TextRender) == 0x0002F8, "Member 'APlayerStart_VIP_Spawn::TextRender' has a wrong offset!");
static_assert(offsetof(APlayerStart_VIP_Spawn, SpawnDirection) == 0x000300, "Member 'APlayerStart_VIP_Spawn::SpawnDirection' has a wrong offset!");

// Class ReadyOrNot.HardcoreMoneyGM
// 0x0000 (0x0E10 - 0x0E10)
class AHardcoreMoneyGM final : public ACoopGM
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HardcoreMoneyGM">();
	}
	static class AHardcoreMoneyGM* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHardcoreMoneyGM>();
	}
};
static_assert(alignof(AHardcoreMoneyGM) == 0x000010, "Wrong alignment on AHardcoreMoneyGM");
static_assert(sizeof(AHardcoreMoneyGM) == 0x000E10, "Wrong size on AHardcoreMoneyGM");

// Class ReadyOrNot.CustomizationWidget
// 0x05F8 (0x0A08 - 0x0410)
class UCustomizationWidget : public UCommonActivatableWidget
{
public:
	TMap<ECustomizationType, class UFMODEvent*>   CustomizationEquipEvents;                          // 0x0410(0x0050)(Edit, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(const class FString& Name)> OnCustomizationPresetApplied;          // 0x0460(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnAvailableCustomizationPresetsChanged;            // 0x0470(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class ULoadoutManager*                        LoadoutManager;                                    // 0x0480(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBaseProfile*                           Profile;                                           // 0x0488(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_490[0x8];                                      // 0x0490(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSavedLoadout                          CurrentLoadout;                                    // 0x0498(0x02E8)(Transient, NativeAccessSpecifierPrivate)
	class AReadyOrNotCharacter*                   PreviewCharacter;                                  // 0x0780(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class ULoadoutWeapon*>                 CachedPrimaryWeapons;                              // 0x0788(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class ULoadoutWeapon*>                 CachedSecondaryWeapons;                            // 0x0798(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class ULoadoutEquipment*>              CachedLongTacticalItems;                           // 0x07A8(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class ULoadoutEquipment*>              CachedTacticalItems;                               // 0x07B8(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class ULoadoutEquipment*>              CachedArmorItems;                                  // 0x07C8(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class ULoadoutEquipment*>              CachedHelmetItems;                                 // 0x07D8(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	struct FSavedCustomization                    CurrentCustomization;                              // 0x07E8(0x0140)(Transient, NativeAccessSpecifierPrivate)
	TArray<class ULoadoutCustomization*>          CachedCustomizationItems;                          // 0x0928(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class ULoadoutCustomization*>          CachedCustomizationFamilies;                       // 0x0938(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	TMap<class FName, struct FCompatibleItemsArray> ItemToSkinsMap;                                  // 0x0948(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<class FName, struct FCompatibleItemsArray> ItemToHelmetsMap;                                // 0x0998(0x0050)(Transient, NativeAccessSpecifierPrivate)
	class ABaseItem*                              CustomizationTargetPrimaryWeapon;                  // 0x09E8(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABaseItem*                              CustomizationTargetSecondaryWeapon;                // 0x09F0(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABaseItem*                              CustomizationTargetArmor;                          // 0x09F8(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABaseItem*                              CustomizationTargetHelmet;                         // 0x0A00(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void ArmorSet(TSubclassOf<class ABaseItem> Class_0);
	bool CanCustomizeType(ECustomizationType Type);
	void ClearCustomizationPreview();
	void ExitCustomization();
	const TArray<class ULoadoutEquipment*> GetArmorItems();
	TArray<class ULoadoutCustomization*> GetCustomizationItems(ECustomizationType Type, bool bFamiliesOnly);
	class ULoadoutCustomization* GetEquippedCustomizationItem(ECustomizationType Type);
	const TArray<class ULoadoutEquipment*> GetHelmetItems();
	const TArray<class ULoadoutEquipment*> GetLongTacticalItems();
	const TArray<class ULoadoutWeapon*> GetPrimaryWeapons();
	const TArray<class ULoadoutWeapon*> GetSecondaryWeapons();
	const TArray<class ULoadoutEquipment*> GetTacticalItems();
	void HelmetSet(TSubclassOf<class ABaseItem> Class_0);
	void OnCurrentCustomizationUpdated();
	void OnLoadoutPresetApplied(const class FString& Name_0, const struct FSavedLoadout& Loadout);
	void PreviewCustomizationItem(class ULoadoutCustomization* Item);
	void PreviewCustomizationPreset(const class FString& Name_0);
	void PrimarySet(TSubclassOf<class ABaseItem> Class_0);
	void SecondarySet(TSubclassOf<class ABaseItem> Class_0);
	void SetActiveSwatMember(EEquippingSwat InSwat);
	void SetArmor(class ULoadoutEquipment* Item);
	void SetCustomizationItem(class ULoadoutCustomization* Item);
	void SetHelmet(class ULoadoutEquipment* Item);
	void SetLongTactical(class ULoadoutEquipment* Item);
	void SetPrimaryAttachment(class UWeaponAttachment* Attachment);
	void SetPrimaryWeapon(class ULoadoutWeapon* Item);
	void SetSecondaryAttachment(class UWeaponAttachment* Attachment);
	void SetSecondaryWeapon(class ULoadoutWeapon* Item);

	EEquippingSwat GetActiveSwatMember() const;
	class ULoadoutEquipment* GetArmor() const;
	class ULoadoutEquipment* GetHelmet() const;
	class ULoadoutEquipment* GetLongTactical() const;
	class ULoadoutWeapon* GetPrimaryWeapon() const;
	class ULoadoutWeapon* GetSecondaryWeapon() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationWidget">();
	}
	static class UCustomizationWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomizationWidget>();
	}
};
static_assert(alignof(UCustomizationWidget) == 0x000008, "Wrong alignment on UCustomizationWidget");
static_assert(sizeof(UCustomizationWidget) == 0x000A08, "Wrong size on UCustomizationWidget");
static_assert(offsetof(UCustomizationWidget, CustomizationEquipEvents) == 0x000410, "Member 'UCustomizationWidget::CustomizationEquipEvents' has a wrong offset!");
static_assert(offsetof(UCustomizationWidget, OnCustomizationPresetApplied) == 0x000460, "Member 'UCustomizationWidget::OnCustomizationPresetApplied' has a wrong offset!");
static_assert(offsetof(UCustomizationWidget, OnAvailableCustomizationPresetsChanged) == 0x000470, "Member 'UCustomizationWidget::OnAvailableCustomizationPresetsChanged' has a wrong offset!");
static_assert(offsetof(UCustomizationWidget, LoadoutManager) == 0x000480, "Member 'UCustomizationWidget::LoadoutManager' has a wrong offset!");
static_assert(offsetof(UCustomizationWidget, Profile) == 0x000488, "Member 'UCustomizationWidget::Profile' has a wrong offset!");
static_assert(offsetof(UCustomizationWidget, CurrentLoadout) == 0x000498, "Member 'UCustomizationWidget::CurrentLoadout' has a wrong offset!");
static_assert(offsetof(UCustomizationWidget, PreviewCharacter) == 0x000780, "Member 'UCustomizationWidget::PreviewCharacter' has a wrong offset!");
static_assert(offsetof(UCustomizationWidget, CachedPrimaryWeapons) == 0x000788, "Member 'UCustomizationWidget::CachedPrimaryWeapons' has a wrong offset!");
static_assert(offsetof(UCustomizationWidget, CachedSecondaryWeapons) == 0x000798, "Member 'UCustomizationWidget::CachedSecondaryWeapons' has a wrong offset!");
static_assert(offsetof(UCustomizationWidget, CachedLongTacticalItems) == 0x0007A8, "Member 'UCustomizationWidget::CachedLongTacticalItems' has a wrong offset!");
static_assert(offsetof(UCustomizationWidget, CachedTacticalItems) == 0x0007B8, "Member 'UCustomizationWidget::CachedTacticalItems' has a wrong offset!");
static_assert(offsetof(UCustomizationWidget, CachedArmorItems) == 0x0007C8, "Member 'UCustomizationWidget::CachedArmorItems' has a wrong offset!");
static_assert(offsetof(UCustomizationWidget, CachedHelmetItems) == 0x0007D8, "Member 'UCustomizationWidget::CachedHelmetItems' has a wrong offset!");
static_assert(offsetof(UCustomizationWidget, CurrentCustomization) == 0x0007E8, "Member 'UCustomizationWidget::CurrentCustomization' has a wrong offset!");
static_assert(offsetof(UCustomizationWidget, CachedCustomizationItems) == 0x000928, "Member 'UCustomizationWidget::CachedCustomizationItems' has a wrong offset!");
static_assert(offsetof(UCustomizationWidget, CachedCustomizationFamilies) == 0x000938, "Member 'UCustomizationWidget::CachedCustomizationFamilies' has a wrong offset!");
static_assert(offsetof(UCustomizationWidget, ItemToSkinsMap) == 0x000948, "Member 'UCustomizationWidget::ItemToSkinsMap' has a wrong offset!");
static_assert(offsetof(UCustomizationWidget, ItemToHelmetsMap) == 0x000998, "Member 'UCustomizationWidget::ItemToHelmetsMap' has a wrong offset!");
static_assert(offsetof(UCustomizationWidget, CustomizationTargetPrimaryWeapon) == 0x0009E8, "Member 'UCustomizationWidget::CustomizationTargetPrimaryWeapon' has a wrong offset!");
static_assert(offsetof(UCustomizationWidget, CustomizationTargetSecondaryWeapon) == 0x0009F0, "Member 'UCustomizationWidget::CustomizationTargetSecondaryWeapon' has a wrong offset!");
static_assert(offsetof(UCustomizationWidget, CustomizationTargetArmor) == 0x0009F8, "Member 'UCustomizationWidget::CustomizationTargetArmor' has a wrong offset!");
static_assert(offsetof(UCustomizationWidget, CustomizationTargetHelmet) == 0x000A00, "Member 'UCustomizationWidget::CustomizationTargetHelmet' has a wrong offset!");

// Class ReadyOrNot.CustomPhysicalMaterial
// 0x0008 (0x0090 - 0x0088)
class UCustomPhysicalMaterial final : public UPhysicalMaterial
{
public:
	float                                         FullOcclusionDepth;                                // 0x0088(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomPhysicalMaterial">();
	}
	static class UCustomPhysicalMaterial* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomPhysicalMaterial>();
	}
};
static_assert(alignof(UCustomPhysicalMaterial) == 0x000008, "Wrong alignment on UCustomPhysicalMaterial");
static_assert(sizeof(UCustomPhysicalMaterial) == 0x000090, "Wrong size on UCustomPhysicalMaterial");
static_assert(offsetof(UCustomPhysicalMaterial, FullOcclusionDepth) == 0x000088, "Member 'UCustomPhysicalMaterial::FullOcclusionDepth' has a wrong offset!");

// Class ReadyOrNot.EventFiredEventCondition
// 0x0008 (0x0048 - 0x0040)
class UEventFiredEventCondition final : public UMissionEventCondition
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0040(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void HandleEventFired(const struct FGameplayTag& SourceTag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventFiredEventCondition">();
	}
	static class UEventFiredEventCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventFiredEventCondition>();
	}
};
static_assert(alignof(UEventFiredEventCondition) == 0x000008, "Wrong alignment on UEventFiredEventCondition");
static_assert(sizeof(UEventFiredEventCondition) == 0x000048, "Wrong size on UEventFiredEventCondition");
static_assert(offsetof(UEventFiredEventCondition, EventTag) == 0x000040, "Member 'UEventFiredEventCondition::EventTag' has a wrong offset!");

// Class ReadyOrNot.DataSingleton
// 0x0288 (0x02B0 - 0x0028)
class UDataSingleton : public UObject
{
public:
	bool                                          bDrawBulletDebug;                                  // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawNoNameplates;                                 // 0x0029(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FText>                           LoadingScreen_Tips;                                // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FText                                   YouKilledFormat;                                   // 0x0040(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<class FText>                           KillfeedFormatRandom;                              // 0x0058(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FText>                           ArrestfeedFormatRandom;                            // 0x0068(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FText>                           FreefeedFormatRandom;                              // 0x0078(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FText>                           TeamkillfeedFormatRandom;                          // 0x0088(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FText                                   KillfeedWithA;                                     // 0x0098(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bShowGrenadeDamage;                                // 0x00B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UItemData*                              ItemData;                                          // 0x00B8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetsData*                           WidgetData;                                        // 0x00C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPenetrationData*                       PenetrationData;                                   // 0x00C8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCampaignData*                          CampaignData;                                      // 0x00D0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             AmmoDataLookupTable;                               // 0x00D8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             AIDataLookupTable;                                 // 0x00E0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             AnimationDataLookupTable;                          // 0x00E8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             AnimatedIconLookupTable;                           // 0x00F0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             DoorDataLookupTable;                               // 0x00F8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             TrapDataLookupTable;                               // 0x0100(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             ConversationLookupTable;                           // 0x0108(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             GameSettingsLookupTable;                           // 0x0110(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             CharacterLookOverrideTable;                        // 0x0118(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             RonInputKeyTable;                                  // 0x0120(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             InputKeyGamePadIconTable;                          // 0x0128(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, class UDataTable*>        SpeechDataLookupTable;                             // 0x0130(0x0050)(Edit, UObjectWrapper, NativeAccessSpecifierPublic)
	class UDataTable*                             WidgetDataLookupTable;                             // 0x0180(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             SuspectArmourDataTable;                            // 0x0188(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             PairedInteractionDataTable;                        // 0x0190(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             MoveStyleDataTable;                                // 0x0198(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             GamepadHoldTimesDataTable;                         // 0x01A0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CustomizationCharacterLevel;                       // 0x01A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CustomizationMenuLevel;                            // 0x01B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UWorldBuildingActivity>> RandomWorldBuildingActivities;                 // 0x01B8(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C8[0xE8];                                     // 0x01C8(0x00E8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void LoadLevels();
	void RefreshInputKeyTable();
	void UnloadLevels();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DataSingleton">();
	}
	static class UDataSingleton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDataSingleton>();
	}
};
static_assert(alignof(UDataSingleton) == 0x000008, "Wrong alignment on UDataSingleton");
static_assert(sizeof(UDataSingleton) == 0x0002B0, "Wrong size on UDataSingleton");
static_assert(offsetof(UDataSingleton, bDrawBulletDebug) == 0x000028, "Member 'UDataSingleton::bDrawBulletDebug' has a wrong offset!");
static_assert(offsetof(UDataSingleton, bDrawNoNameplates) == 0x000029, "Member 'UDataSingleton::bDrawNoNameplates' has a wrong offset!");
static_assert(offsetof(UDataSingleton, LoadingScreen_Tips) == 0x000030, "Member 'UDataSingleton::LoadingScreen_Tips' has a wrong offset!");
static_assert(offsetof(UDataSingleton, YouKilledFormat) == 0x000040, "Member 'UDataSingleton::YouKilledFormat' has a wrong offset!");
static_assert(offsetof(UDataSingleton, KillfeedFormatRandom) == 0x000058, "Member 'UDataSingleton::KillfeedFormatRandom' has a wrong offset!");
static_assert(offsetof(UDataSingleton, ArrestfeedFormatRandom) == 0x000068, "Member 'UDataSingleton::ArrestfeedFormatRandom' has a wrong offset!");
static_assert(offsetof(UDataSingleton, FreefeedFormatRandom) == 0x000078, "Member 'UDataSingleton::FreefeedFormatRandom' has a wrong offset!");
static_assert(offsetof(UDataSingleton, TeamkillfeedFormatRandom) == 0x000088, "Member 'UDataSingleton::TeamkillfeedFormatRandom' has a wrong offset!");
static_assert(offsetof(UDataSingleton, KillfeedWithA) == 0x000098, "Member 'UDataSingleton::KillfeedWithA' has a wrong offset!");
static_assert(offsetof(UDataSingleton, bShowGrenadeDamage) == 0x0000B0, "Member 'UDataSingleton::bShowGrenadeDamage' has a wrong offset!");
static_assert(offsetof(UDataSingleton, ItemData) == 0x0000B8, "Member 'UDataSingleton::ItemData' has a wrong offset!");
static_assert(offsetof(UDataSingleton, WidgetData) == 0x0000C0, "Member 'UDataSingleton::WidgetData' has a wrong offset!");
static_assert(offsetof(UDataSingleton, PenetrationData) == 0x0000C8, "Member 'UDataSingleton::PenetrationData' has a wrong offset!");
static_assert(offsetof(UDataSingleton, CampaignData) == 0x0000D0, "Member 'UDataSingleton::CampaignData' has a wrong offset!");
static_assert(offsetof(UDataSingleton, AmmoDataLookupTable) == 0x0000D8, "Member 'UDataSingleton::AmmoDataLookupTable' has a wrong offset!");
static_assert(offsetof(UDataSingleton, AIDataLookupTable) == 0x0000E0, "Member 'UDataSingleton::AIDataLookupTable' has a wrong offset!");
static_assert(offsetof(UDataSingleton, AnimationDataLookupTable) == 0x0000E8, "Member 'UDataSingleton::AnimationDataLookupTable' has a wrong offset!");
static_assert(offsetof(UDataSingleton, AnimatedIconLookupTable) == 0x0000F0, "Member 'UDataSingleton::AnimatedIconLookupTable' has a wrong offset!");
static_assert(offsetof(UDataSingleton, DoorDataLookupTable) == 0x0000F8, "Member 'UDataSingleton::DoorDataLookupTable' has a wrong offset!");
static_assert(offsetof(UDataSingleton, TrapDataLookupTable) == 0x000100, "Member 'UDataSingleton::TrapDataLookupTable' has a wrong offset!");
static_assert(offsetof(UDataSingleton, ConversationLookupTable) == 0x000108, "Member 'UDataSingleton::ConversationLookupTable' has a wrong offset!");
static_assert(offsetof(UDataSingleton, GameSettingsLookupTable) == 0x000110, "Member 'UDataSingleton::GameSettingsLookupTable' has a wrong offset!");
static_assert(offsetof(UDataSingleton, CharacterLookOverrideTable) == 0x000118, "Member 'UDataSingleton::CharacterLookOverrideTable' has a wrong offset!");
static_assert(offsetof(UDataSingleton, RonInputKeyTable) == 0x000120, "Member 'UDataSingleton::RonInputKeyTable' has a wrong offset!");
static_assert(offsetof(UDataSingleton, InputKeyGamePadIconTable) == 0x000128, "Member 'UDataSingleton::InputKeyGamePadIconTable' has a wrong offset!");
static_assert(offsetof(UDataSingleton, SpeechDataLookupTable) == 0x000130, "Member 'UDataSingleton::SpeechDataLookupTable' has a wrong offset!");
static_assert(offsetof(UDataSingleton, WidgetDataLookupTable) == 0x000180, "Member 'UDataSingleton::WidgetDataLookupTable' has a wrong offset!");
static_assert(offsetof(UDataSingleton, SuspectArmourDataTable) == 0x000188, "Member 'UDataSingleton::SuspectArmourDataTable' has a wrong offset!");
static_assert(offsetof(UDataSingleton, PairedInteractionDataTable) == 0x000190, "Member 'UDataSingleton::PairedInteractionDataTable' has a wrong offset!");
static_assert(offsetof(UDataSingleton, MoveStyleDataTable) == 0x000198, "Member 'UDataSingleton::MoveStyleDataTable' has a wrong offset!");
static_assert(offsetof(UDataSingleton, GamepadHoldTimesDataTable) == 0x0001A0, "Member 'UDataSingleton::GamepadHoldTimesDataTable' has a wrong offset!");
static_assert(offsetof(UDataSingleton, CustomizationCharacterLevel) == 0x0001A8, "Member 'UDataSingleton::CustomizationCharacterLevel' has a wrong offset!");
static_assert(offsetof(UDataSingleton, CustomizationMenuLevel) == 0x0001B0, "Member 'UDataSingleton::CustomizationMenuLevel' has a wrong offset!");
static_assert(offsetof(UDataSingleton, RandomWorldBuildingActivities) == 0x0001B8, "Member 'UDataSingleton::RandomWorldBuildingActivities' has a wrong offset!");

// Class ReadyOrNot.DebugDisplayWidget
// 0x0000 (0x02C0 - 0x02C0)
class UDebugDisplayWidget : public UUserWidget
{
public:
	int32 AddDebugText(const class FString& NewText);
	void SetDebugText(int32 ID, const class FString& NewText);
	void SetDebugTitle(const class FString& NewTitle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugDisplayWidget">();
	}
	static class UDebugDisplayWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDebugDisplayWidget>();
	}
};
static_assert(alignof(UDebugDisplayWidget) == 0x000008, "Wrong alignment on UDebugDisplayWidget");
static_assert(sizeof(UDebugDisplayWidget) == 0x0002C0, "Wrong size on UDebugDisplayWidget");

// Class ReadyOrNot.HoldActivity
// 0x0018 (0x0218 - 0x0200)
class UHoldActivity final : public UTeamBaseActivity
{
public:
	uint8                                         Pad_200[0x18];                                     // 0x0200(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HoldActivity">();
	}
	static class UHoldActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHoldActivity>();
	}
};
static_assert(alignof(UHoldActivity) == 0x000008, "Wrong alignment on UHoldActivity");
static_assert(sizeof(UHoldActivity) == 0x000218, "Wrong size on UHoldActivity");

// Class ReadyOrNot.DefusalGM
// 0x00B0 (0x0A80 - 0x09D0)
class ADefusalGM final : public AReadyOrNotGameMode_PVP
{
public:
	class ABombActor*                             SelectedBombActor;                                 // 0x09D0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AAISpawn*>                       SpawnPoints;                                       // 0x09D8(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	class APlayerStart*                           SwatSpawn;                                         // 0x09E8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APlayerStart*                           SuspectSpawn;                                      // 0x09F0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class APlayerCharacter*, struct FCharacterLookOverride> CharacterLookMap;                   // 0x09F8(0x0050)(NativeAccessSpecifierPrivate)
	class USkeletalMesh*                          BlankFaceMesh;                                     // 0x0A48(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class APlayerController*>              PendingPlayerSpawn;                                // 0x0A50(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<struct FSpawnData>                     SuspectSpawnData;                                  // 0x0A60(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	class USkeletalMesh*                          SuspectFPArmsOverride;                             // 0x0A70(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A78[0x8];                                      // 0x0A78(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DefusalGM">();
	}
	static class ADefusalGM* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADefusalGM>();
	}
};
static_assert(alignof(ADefusalGM) == 0x000010, "Wrong alignment on ADefusalGM");
static_assert(sizeof(ADefusalGM) == 0x000A80, "Wrong size on ADefusalGM");
static_assert(offsetof(ADefusalGM, SelectedBombActor) == 0x0009D0, "Member 'ADefusalGM::SelectedBombActor' has a wrong offset!");
static_assert(offsetof(ADefusalGM, SpawnPoints) == 0x0009D8, "Member 'ADefusalGM::SpawnPoints' has a wrong offset!");
static_assert(offsetof(ADefusalGM, SwatSpawn) == 0x0009E8, "Member 'ADefusalGM::SwatSpawn' has a wrong offset!");
static_assert(offsetof(ADefusalGM, SuspectSpawn) == 0x0009F0, "Member 'ADefusalGM::SuspectSpawn' has a wrong offset!");
static_assert(offsetof(ADefusalGM, CharacterLookMap) == 0x0009F8, "Member 'ADefusalGM::CharacterLookMap' has a wrong offset!");
static_assert(offsetof(ADefusalGM, BlankFaceMesh) == 0x000A48, "Member 'ADefusalGM::BlankFaceMesh' has a wrong offset!");
static_assert(offsetof(ADefusalGM, PendingPlayerSpawn) == 0x000A50, "Member 'ADefusalGM::PendingPlayerSpawn' has a wrong offset!");
static_assert(offsetof(ADefusalGM, SuspectSpawnData) == 0x000A60, "Member 'ADefusalGM::SuspectSpawnData' has a wrong offset!");
static_assert(offsetof(ADefusalGM, SuspectFPArmsOverride) == 0x000A70, "Member 'ADefusalGM::SuspectFPArmsOverride' has a wrong offset!");

// Class ReadyOrNot.DefusalGS
// 0x0030 (0x0928 - 0x08F8)
class ADefusalGS final : public AReadyOrNotGameState
{
public:
	EDefusalMatchSate                             DefusalMatchState;                                 // 0x08F8(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8F9[0x7];                                      // 0x08F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserWidget*                            DefusalHudInst;                                    // 0x0900(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUserWidget>                DefusalHudClass;                                   // 0x0908(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ALoadoutPortal*                         LoadoutPortal;                                     // 0x0910(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CountdownUntilMatchStarts;                         // 0x0918(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ElapsedRoundTime;                                  // 0x091C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BombTimeRemaining;                                 // 0x0920(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_924[0x4];                                      // 0x0924(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DefusalGS">();
	}
	static class ADefusalGS* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADefusalGS>();
	}
};
static_assert(alignof(ADefusalGS) == 0x000008, "Wrong alignment on ADefusalGS");
static_assert(sizeof(ADefusalGS) == 0x000928, "Wrong size on ADefusalGS");
static_assert(offsetof(ADefusalGS, DefusalMatchState) == 0x0008F8, "Member 'ADefusalGS::DefusalMatchState' has a wrong offset!");
static_assert(offsetof(ADefusalGS, DefusalHudInst) == 0x000900, "Member 'ADefusalGS::DefusalHudInst' has a wrong offset!");
static_assert(offsetof(ADefusalGS, DefusalHudClass) == 0x000908, "Member 'ADefusalGS::DefusalHudClass' has a wrong offset!");
static_assert(offsetof(ADefusalGS, LoadoutPortal) == 0x000910, "Member 'ADefusalGS::LoadoutPortal' has a wrong offset!");
static_assert(offsetof(ADefusalGS, CountdownUntilMatchStarts) == 0x000918, "Member 'ADefusalGS::CountdownUntilMatchStarts' has a wrong offset!");
static_assert(offsetof(ADefusalGS, ElapsedRoundTime) == 0x00091C, "Member 'ADefusalGS::ElapsedRoundTime' has a wrong offset!");
static_assert(offsetof(ADefusalGS, BombTimeRemaining) == 0x000920, "Member 'ADefusalGS::BombTimeRemaining' has a wrong offset!");

// Class ReadyOrNot.EvidenceComponent
// 0x0068 (0x0108 - 0x00A0)
class UEvidenceComponent final : public UActorComponent
{
public:
	float                                         CurrentCollectionTime;                             // 0x00A0(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxCollectionTime;                                 // 0x00A4(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsBeingCollected;                                 // 0x00A8(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bEvidenceExtracted : 1;                            // 0x00A9(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_AA[0x6];                                       // 0x00AA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class AReadyOrNotCharacter*                   CollectingCharacter;                               // 0x00B0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMarkAsEvidenceWhenNoOwner;                        // 0x00B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPackageOnCollection;                              // 0x00B9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BA[0x6];                                       // 0x00BA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ACollectedEvidenceActor>    CollectedEvidenceClass;                            // 0x00C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInputEvent                                   CollectionInputEventType;                          // 0x00C8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEvidenceActorState                           EvidenceState;                                     // 0x00C9(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEvidenceActorState                           PreviousEvidenceState;                             // 0x00CA(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CB[0x5];                                       // 0x00CB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractableComponent*                 EvidenceInteractableComponent;                     // 0x00D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D8[0x20];                                      // 0x00D8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AReadyOrNotCharacter* CollectingCharacter)> OnEvidenceCollected; // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void OnRep_EvidenceState();

	bool CanBeCollected() const;
	bool CanBeDropped() const;
	float GetCurrentCollectionProgress() const;
	EEvidenceActorState GetEvidenceState() const;
	bool IsBeingCollected() const;
	bool IsEvidenceCollected() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EvidenceComponent">();
	}
	static class UEvidenceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEvidenceComponent>();
	}
};
static_assert(alignof(UEvidenceComponent) == 0x000008, "Wrong alignment on UEvidenceComponent");
static_assert(sizeof(UEvidenceComponent) == 0x000108, "Wrong size on UEvidenceComponent");
static_assert(offsetof(UEvidenceComponent, CurrentCollectionTime) == 0x0000A0, "Member 'UEvidenceComponent::CurrentCollectionTime' has a wrong offset!");
static_assert(offsetof(UEvidenceComponent, MaxCollectionTime) == 0x0000A4, "Member 'UEvidenceComponent::MaxCollectionTime' has a wrong offset!");
static_assert(offsetof(UEvidenceComponent, bIsBeingCollected) == 0x0000A8, "Member 'UEvidenceComponent::bIsBeingCollected' has a wrong offset!");
static_assert(offsetof(UEvidenceComponent, CollectingCharacter) == 0x0000B0, "Member 'UEvidenceComponent::CollectingCharacter' has a wrong offset!");
static_assert(offsetof(UEvidenceComponent, bMarkAsEvidenceWhenNoOwner) == 0x0000B8, "Member 'UEvidenceComponent::bMarkAsEvidenceWhenNoOwner' has a wrong offset!");
static_assert(offsetof(UEvidenceComponent, bPackageOnCollection) == 0x0000B9, "Member 'UEvidenceComponent::bPackageOnCollection' has a wrong offset!");
static_assert(offsetof(UEvidenceComponent, CollectedEvidenceClass) == 0x0000C0, "Member 'UEvidenceComponent::CollectedEvidenceClass' has a wrong offset!");
static_assert(offsetof(UEvidenceComponent, CollectionInputEventType) == 0x0000C8, "Member 'UEvidenceComponent::CollectionInputEventType' has a wrong offset!");
static_assert(offsetof(UEvidenceComponent, EvidenceState) == 0x0000C9, "Member 'UEvidenceComponent::EvidenceState' has a wrong offset!");
static_assert(offsetof(UEvidenceComponent, PreviousEvidenceState) == 0x0000CA, "Member 'UEvidenceComponent::PreviousEvidenceState' has a wrong offset!");
static_assert(offsetof(UEvidenceComponent, EvidenceInteractableComponent) == 0x0000D0, "Member 'UEvidenceComponent::EvidenceInteractableComponent' has a wrong offset!");
static_assert(offsetof(UEvidenceComponent, OnEvidenceCollected) == 0x0000F8, "Member 'UEvidenceComponent::OnEvidenceCollected' has a wrong offset!");

// Class ReadyOrNot.DefuseBombThreats
// 0x0010 (0x0330 - 0x0320)
class ADefuseBombThreats final : public AObjective
{
public:
	uint8                                         Pad_320[0x10];                                     // 0x0320(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBombDefused(class ABombActor* DefusedBomb);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DefuseBombThreats">();
	}
	static class ADefuseBombThreats* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADefuseBombThreats>();
	}
};
static_assert(alignof(ADefuseBombThreats) == 0x000008, "Wrong alignment on ADefuseBombThreats");
static_assert(sizeof(ADefuseBombThreats) == 0x000330, "Wrong size on ADefuseBombThreats");

// Class ReadyOrNot.DeployableData
// 0x0078 (0x00A8 - 0x0030)
class UDeployableData final : public UDataAsset
{
public:
	class FText                                   DeployableName;                                    // 0x0030(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   DeployableShortName;                               // 0x0048(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   DeployableDescription;                             // 0x0060(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              DeployableTexture;                                 // 0x0078(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DeployableLabel;                                   // 0x00A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeployableData">();
	}
	static class UDeployableData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeployableData>();
	}
};
static_assert(alignof(UDeployableData) == 0x000008, "Wrong alignment on UDeployableData");
static_assert(sizeof(UDeployableData) == 0x0000A8, "Wrong size on UDeployableData");
static_assert(offsetof(UDeployableData, DeployableName) == 0x000030, "Member 'UDeployableData::DeployableName' has a wrong offset!");
static_assert(offsetof(UDeployableData, DeployableShortName) == 0x000048, "Member 'UDeployableData::DeployableShortName' has a wrong offset!");
static_assert(offsetof(UDeployableData, DeployableDescription) == 0x000060, "Member 'UDeployableData::DeployableDescription' has a wrong offset!");
static_assert(offsetof(UDeployableData, DeployableTexture) == 0x000078, "Member 'UDeployableData::DeployableTexture' has a wrong offset!");
static_assert(offsetof(UDeployableData, DeployableLabel) == 0x0000A0, "Member 'UDeployableData::DeployableLabel' has a wrong offset!");

// Class ReadyOrNot.EOSMultiplayerSubsystem
// 0x0240 (0x0270 - 0x0030)
class UEOSMultiplayerSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x240];                                     // 0x0030(0x0240)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPlayerTalkingStateChangedEOS(const class FString& ChannelName, const class FString& PlayerName, bool bIsTalking);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EOSMultiplayerSubsystem">();
	}
	static class UEOSMultiplayerSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEOSMultiplayerSubsystem>();
	}
};
static_assert(alignof(UEOSMultiplayerSubsystem) == 0x000008, "Wrong alignment on UEOSMultiplayerSubsystem");
static_assert(sizeof(UEOSMultiplayerSubsystem) == 0x000270, "Wrong size on UEOSMultiplayerSubsystem");

// Class ReadyOrNot.DeployableDepot
// 0x0018 (0x02B0 - 0x0298)
class ADeployableDepot final : public AActor
{
public:
	TArray<class UDeployableSpawnComponent*>      SpawnedDeployableComponents;                       // 0x0298(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	class FName                                   DepotLabel;                                        // 0x02A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void Multicast_OnSuccessfulSpawn();
	void OnGameStarted();
	void OnSuccessfulSpawn();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeployableDepot">();
	}
	static class ADeployableDepot* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADeployableDepot>();
	}
};
static_assert(alignof(ADeployableDepot) == 0x000008, "Wrong alignment on ADeployableDepot");
static_assert(sizeof(ADeployableDepot) == 0x0002B0, "Wrong size on ADeployableDepot");
static_assert(offsetof(ADeployableDepot, SpawnedDeployableComponents) == 0x000298, "Member 'ADeployableDepot::SpawnedDeployableComponents' has a wrong offset!");
static_assert(offsetof(ADeployableDepot, DepotLabel) == 0x0002A8, "Member 'ADeployableDepot::DepotLabel' has a wrong offset!");

// Class ReadyOrNot.DeployableSpawnComponent
// 0x0010 (0x02B0 - 0x02A0)
class UDeployableSpawnComponent final : public USceneComponent
{
public:
	TSubclassOf<class AActor>                     ItemClass;                                         // 0x02A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DeployableLabel;                                   // 0x02A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void MutateSpawnedDeployable(class AActor* SpawnedDeployable);
	bool TrySpawnComponent(bool ShouldSpawn);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeployableSpawnComponent">();
	}
	static class UDeployableSpawnComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeployableSpawnComponent>();
	}
};
static_assert(alignof(UDeployableSpawnComponent) == 0x000010, "Wrong alignment on UDeployableSpawnComponent");
static_assert(sizeof(UDeployableSpawnComponent) == 0x0002B0, "Wrong size on UDeployableSpawnComponent");
static_assert(offsetof(UDeployableSpawnComponent, ItemClass) == 0x0002A0, "Member 'UDeployableSpawnComponent::ItemClass' has a wrong offset!");
static_assert(offsetof(UDeployableSpawnComponent, DeployableLabel) == 0x0002A8, "Member 'UDeployableSpawnComponent::DeployableLabel' has a wrong offset!");

// Class ReadyOrNot.HitRegistrationSettings
// 0x0030 (0x0068 - 0x0038)
class UHitRegistrationSettings final : public UDeveloperSettings
{
public:
	bool                                          bEnableValidation;                                 // 0x0038(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HitscanForgiveness;                                // 0x003C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShooterForgiveness;                                // 0x0040(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceDistanceForgiveness;                          // 0x0044(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SnapshotVelocityFactor;                            // 0x0048(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                MinimumSnapshotExtent;                             // 0x0050(0x0018)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitRegistrationSettings">();
	}
	static class UHitRegistrationSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHitRegistrationSettings>();
	}
};
static_assert(alignof(UHitRegistrationSettings) == 0x000008, "Wrong alignment on UHitRegistrationSettings");
static_assert(sizeof(UHitRegistrationSettings) == 0x000068, "Wrong size on UHitRegistrationSettings");
static_assert(offsetof(UHitRegistrationSettings, bEnableValidation) == 0x000038, "Member 'UHitRegistrationSettings::bEnableValidation' has a wrong offset!");
static_assert(offsetof(UHitRegistrationSettings, HitscanForgiveness) == 0x00003C, "Member 'UHitRegistrationSettings::HitscanForgiveness' has a wrong offset!");
static_assert(offsetof(UHitRegistrationSettings, ShooterForgiveness) == 0x000040, "Member 'UHitRegistrationSettings::ShooterForgiveness' has a wrong offset!");
static_assert(offsetof(UHitRegistrationSettings, TraceDistanceForgiveness) == 0x000044, "Member 'UHitRegistrationSettings::TraceDistanceForgiveness' has a wrong offset!");
static_assert(offsetof(UHitRegistrationSettings, SnapshotVelocityFactor) == 0x000048, "Member 'UHitRegistrationSettings::SnapshotVelocityFactor' has a wrong offset!");
static_assert(offsetof(UHitRegistrationSettings, MinimumSnapshotExtent) == 0x000050, "Member 'UHitRegistrationSettings::MinimumSnapshotExtent' has a wrong offset!");

// Class ReadyOrNot.DeployItemAtLocationActivity
// 0x0020 (0x0210 - 0x01F0)
class UDeployItemAtLocationActivity : public UBaseActivity
{
public:
	TSubclassOf<class ABaseItem>                  DeployItemClass;                                   // 0x01F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DeployLocation;                                    // 0x01F8(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void Blueprint_EnterDeployStage();
	void Blueprint_ExitDeployStage();
	void Blueprint_TickDeployStage(float DeltaTime, float Uptime);
	void EnterDeployStage();
	void EnterMoveToStage();
	void ExitDeployStage();
	void ExitMoveToStage();
	void TickDeployStage(float DeltaTime, float Uptime);
	void TickMoveToStage(float DeltaTime, float Uptime);

	bool CanDeploy() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeployItemAtLocationActivity">();
	}
	static class UDeployItemAtLocationActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeployItemAtLocationActivity>();
	}
};
static_assert(alignof(UDeployItemAtLocationActivity) == 0x000008, "Wrong alignment on UDeployItemAtLocationActivity");
static_assert(sizeof(UDeployItemAtLocationActivity) == 0x000210, "Wrong size on UDeployItemAtLocationActivity");
static_assert(offsetof(UDeployItemAtLocationActivity, DeployItemClass) == 0x0001F0, "Member 'UDeployItemAtLocationActivity::DeployItemClass' has a wrong offset!");
static_assert(offsetof(UDeployItemAtLocationActivity, DeployLocation) == 0x0001F8, "Member 'UDeployItemAtLocationActivity::DeployLocation' has a wrong offset!");

// Class ReadyOrNot.DeployChemlightActivity
// 0x0000 (0x0210 - 0x0210)
class UDeployChemlightActivity final : public UDeployItemAtLocationActivity
{
public:
	void OnChemlightThrown(class ABaseItem* Item);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeployChemlightActivity">();
	}
	static class UDeployChemlightActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeployChemlightActivity>();
	}
};
static_assert(alignof(UDeployChemlightActivity) == 0x000008, "Wrong alignment on UDeployChemlightActivity");
static_assert(sizeof(UDeployChemlightActivity) == 0x000210, "Wrong size on UDeployChemlightActivity");

// Class ReadyOrNot.ImpactEffect
// 0x0BE0 (0x0EC0 - 0x02E0)
class AImpactEffect : public APooledActor
{
public:
	class USceneComponent*                        SceneComponent;                                    // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystemComponent*               ParticleSystemComponent;                           // 0x02E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODAudioComponent*                    FMODAudioComponent;                                // 0x02F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDecalComponent*                        DecalComponent;                                    // 0x02F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UParticleSystemComponent*>       SpawnedParticles;                                  // 0x0300(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_310[0x1D0];                                    // 0x0310(0x01D0)(Fixing Size After Last Property [ Dumper-7 ])
	EImpactEffectType                             Type;                                              // 0x04E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayDefaultIfNull;                                // 0x04E1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E2[0x2];                                      // 0x04E2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DecalScale;                                        // 0x04E4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E8[0x8];                                      // 0x04E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DecalMinSize;                                      // 0x04F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecalMaxSize;                                      // 0x04F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParticleScale;                                     // 0x04F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReflectImpactEffectAcrossNormal;                  // 0x04FC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4FD[0x3];                                      // 0x04FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             FMODSoundFx;                                       // 0x0500(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             FMODHitmarker;                                     // 0x0508(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxDecalMeshes;                                    // 0x0510(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecalMeshScaleMultiplier;                          // 0x0514(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBulletGoneThroughPlayer;                          // 0x0518(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bArmorImpact;                                      // 0x0519(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpawnParticle;                                    // 0x051A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraceComplex;                                     // 0x051B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51C[0x4];                                      // 0x051C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMaterialInterface*>             BloodExitDecals;                                   // 0x0520(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FImpactFx                              DefaultImpactFx;                                   // 0x0530(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Aluminium;                                     // 0x0560(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Asphalt;                                       // 0x0590(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Brick;                                         // 0x05C0(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_CarbonFibre;                                   // 0x05F0(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Cardboard;                                     // 0x0620(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Ceramic;                                       // 0x0650(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_ConcreteSoft;                                  // 0x0680(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_ConcreteStrong;                                // 0x06B0(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Dirt;                                          // 0x06E0(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Drywall;                                       // 0x0710(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Electrical;                                    // 0x0740(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_EnergyShield;                                  // 0x0770(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Fabric_Carpet;                                 // 0x07A0(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Fabric_Stuffing;                               // 0x07D0(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Fabric_Thin;                                   // 0x0800(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Flesh;                                         // 0x0830(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Galvanized;                                    // 0x0860(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Glass_Plate;                                   // 0x0890(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Glass_Windshield;                              // 0x08C0(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Grass;                                         // 0x08F0(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Gravel;                                        // 0x0920(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Ice;                                           // 0x0950(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Lava;                                          // 0x0980(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Lead;                                          // 0x09B0(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Leaves;                                        // 0x09E0(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Limestone;                                     // 0x0A10(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Mahogany;                                      // 0x0A40(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Marble_Coated;                                 // 0x0A70(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Marble_Thick;                                  // 0x0AA0(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Mud;                                           // 0x0AD0(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Oil;                                           // 0x0B00(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Paper;                                         // 0x0B30(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Pine;                                          // 0x0B60(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Plaster;                                       // 0x0B90(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Plastic;                                       // 0x0BC0(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Plywood;                                       // 0x0BF0(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Polystyrene;                                   // 0x0C20(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Powder;                                        // 0x0C50(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Rock;                                          // 0x0C80(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Rubber;                                        // 0x0CB0(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Sand;                                          // 0x0CE0(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Snow;                                          // 0x0D10(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Soil;                                          // 0x0D40(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Steel;                                         // 0x0D70(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Tin;                                           // 0x0DA0(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Treewood;                                      // 0x0DD0(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Wallpaper;                                     // 0x0E00(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Water;                                         // 0x0E30(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Vehicle;                                       // 0x0E60(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FImpactFx                              RON_Bulletproof_Glass;                             // 0x0E90(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ImpactEffect">();
	}
	static class AImpactEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<AImpactEffect>();
	}
};
static_assert(alignof(AImpactEffect) == 0x000008, "Wrong alignment on AImpactEffect");
static_assert(sizeof(AImpactEffect) == 0x000EC0, "Wrong size on AImpactEffect");
static_assert(offsetof(AImpactEffect, SceneComponent) == 0x0002E0, "Member 'AImpactEffect::SceneComponent' has a wrong offset!");
static_assert(offsetof(AImpactEffect, ParticleSystemComponent) == 0x0002E8, "Member 'AImpactEffect::ParticleSystemComponent' has a wrong offset!");
static_assert(offsetof(AImpactEffect, FMODAudioComponent) == 0x0002F0, "Member 'AImpactEffect::FMODAudioComponent' has a wrong offset!");
static_assert(offsetof(AImpactEffect, DecalComponent) == 0x0002F8, "Member 'AImpactEffect::DecalComponent' has a wrong offset!");
static_assert(offsetof(AImpactEffect, SpawnedParticles) == 0x000300, "Member 'AImpactEffect::SpawnedParticles' has a wrong offset!");
static_assert(offsetof(AImpactEffect, Type) == 0x0004E0, "Member 'AImpactEffect::Type' has a wrong offset!");
static_assert(offsetof(AImpactEffect, bPlayDefaultIfNull) == 0x0004E1, "Member 'AImpactEffect::bPlayDefaultIfNull' has a wrong offset!");
static_assert(offsetof(AImpactEffect, DecalScale) == 0x0004E4, "Member 'AImpactEffect::DecalScale' has a wrong offset!");
static_assert(offsetof(AImpactEffect, DecalMinSize) == 0x0004F0, "Member 'AImpactEffect::DecalMinSize' has a wrong offset!");
static_assert(offsetof(AImpactEffect, DecalMaxSize) == 0x0004F4, "Member 'AImpactEffect::DecalMaxSize' has a wrong offset!");
static_assert(offsetof(AImpactEffect, ParticleScale) == 0x0004F8, "Member 'AImpactEffect::ParticleScale' has a wrong offset!");
static_assert(offsetof(AImpactEffect, bReflectImpactEffectAcrossNormal) == 0x0004FC, "Member 'AImpactEffect::bReflectImpactEffectAcrossNormal' has a wrong offset!");
static_assert(offsetof(AImpactEffect, FMODSoundFx) == 0x000500, "Member 'AImpactEffect::FMODSoundFx' has a wrong offset!");
static_assert(offsetof(AImpactEffect, FMODHitmarker) == 0x000508, "Member 'AImpactEffect::FMODHitmarker' has a wrong offset!");
static_assert(offsetof(AImpactEffect, MaxDecalMeshes) == 0x000510, "Member 'AImpactEffect::MaxDecalMeshes' has a wrong offset!");
static_assert(offsetof(AImpactEffect, DecalMeshScaleMultiplier) == 0x000514, "Member 'AImpactEffect::DecalMeshScaleMultiplier' has a wrong offset!");
static_assert(offsetof(AImpactEffect, bBulletGoneThroughPlayer) == 0x000518, "Member 'AImpactEffect::bBulletGoneThroughPlayer' has a wrong offset!");
static_assert(offsetof(AImpactEffect, bArmorImpact) == 0x000519, "Member 'AImpactEffect::bArmorImpact' has a wrong offset!");
static_assert(offsetof(AImpactEffect, bSpawnParticle) == 0x00051A, "Member 'AImpactEffect::bSpawnParticle' has a wrong offset!");
static_assert(offsetof(AImpactEffect, bTraceComplex) == 0x00051B, "Member 'AImpactEffect::bTraceComplex' has a wrong offset!");
static_assert(offsetof(AImpactEffect, BloodExitDecals) == 0x000520, "Member 'AImpactEffect::BloodExitDecals' has a wrong offset!");
static_assert(offsetof(AImpactEffect, DefaultImpactFx) == 0x000530, "Member 'AImpactEffect::DefaultImpactFx' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Aluminium) == 0x000560, "Member 'AImpactEffect::RON_Aluminium' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Asphalt) == 0x000590, "Member 'AImpactEffect::RON_Asphalt' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Brick) == 0x0005C0, "Member 'AImpactEffect::RON_Brick' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_CarbonFibre) == 0x0005F0, "Member 'AImpactEffect::RON_CarbonFibre' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Cardboard) == 0x000620, "Member 'AImpactEffect::RON_Cardboard' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Ceramic) == 0x000650, "Member 'AImpactEffect::RON_Ceramic' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_ConcreteSoft) == 0x000680, "Member 'AImpactEffect::RON_ConcreteSoft' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_ConcreteStrong) == 0x0006B0, "Member 'AImpactEffect::RON_ConcreteStrong' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Dirt) == 0x0006E0, "Member 'AImpactEffect::RON_Dirt' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Drywall) == 0x000710, "Member 'AImpactEffect::RON_Drywall' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Electrical) == 0x000740, "Member 'AImpactEffect::RON_Electrical' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_EnergyShield) == 0x000770, "Member 'AImpactEffect::RON_EnergyShield' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Fabric_Carpet) == 0x0007A0, "Member 'AImpactEffect::RON_Fabric_Carpet' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Fabric_Stuffing) == 0x0007D0, "Member 'AImpactEffect::RON_Fabric_Stuffing' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Fabric_Thin) == 0x000800, "Member 'AImpactEffect::RON_Fabric_Thin' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Flesh) == 0x000830, "Member 'AImpactEffect::RON_Flesh' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Galvanized) == 0x000860, "Member 'AImpactEffect::RON_Galvanized' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Glass_Plate) == 0x000890, "Member 'AImpactEffect::RON_Glass_Plate' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Glass_Windshield) == 0x0008C0, "Member 'AImpactEffect::RON_Glass_Windshield' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Grass) == 0x0008F0, "Member 'AImpactEffect::RON_Grass' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Gravel) == 0x000920, "Member 'AImpactEffect::RON_Gravel' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Ice) == 0x000950, "Member 'AImpactEffect::RON_Ice' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Lava) == 0x000980, "Member 'AImpactEffect::RON_Lava' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Lead) == 0x0009B0, "Member 'AImpactEffect::RON_Lead' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Leaves) == 0x0009E0, "Member 'AImpactEffect::RON_Leaves' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Limestone) == 0x000A10, "Member 'AImpactEffect::RON_Limestone' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Mahogany) == 0x000A40, "Member 'AImpactEffect::RON_Mahogany' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Marble_Coated) == 0x000A70, "Member 'AImpactEffect::RON_Marble_Coated' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Marble_Thick) == 0x000AA0, "Member 'AImpactEffect::RON_Marble_Thick' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Mud) == 0x000AD0, "Member 'AImpactEffect::RON_Mud' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Oil) == 0x000B00, "Member 'AImpactEffect::RON_Oil' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Paper) == 0x000B30, "Member 'AImpactEffect::RON_Paper' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Pine) == 0x000B60, "Member 'AImpactEffect::RON_Pine' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Plaster) == 0x000B90, "Member 'AImpactEffect::RON_Plaster' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Plastic) == 0x000BC0, "Member 'AImpactEffect::RON_Plastic' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Plywood) == 0x000BF0, "Member 'AImpactEffect::RON_Plywood' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Polystyrene) == 0x000C20, "Member 'AImpactEffect::RON_Polystyrene' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Powder) == 0x000C50, "Member 'AImpactEffect::RON_Powder' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Rock) == 0x000C80, "Member 'AImpactEffect::RON_Rock' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Rubber) == 0x000CB0, "Member 'AImpactEffect::RON_Rubber' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Sand) == 0x000CE0, "Member 'AImpactEffect::RON_Sand' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Snow) == 0x000D10, "Member 'AImpactEffect::RON_Snow' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Soil) == 0x000D40, "Member 'AImpactEffect::RON_Soil' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Steel) == 0x000D70, "Member 'AImpactEffect::RON_Steel' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Tin) == 0x000DA0, "Member 'AImpactEffect::RON_Tin' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Treewood) == 0x000DD0, "Member 'AImpactEffect::RON_Treewood' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Wallpaper) == 0x000E00, "Member 'AImpactEffect::RON_Wallpaper' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Water) == 0x000E30, "Member 'AImpactEffect::RON_Water' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Vehicle) == 0x000E60, "Member 'AImpactEffect::RON_Vehicle' has a wrong offset!");
static_assert(offsetof(AImpactEffect, RON_Bulletproof_Glass) == 0x000E90, "Member 'AImpactEffect::RON_Bulletproof_Glass' has a wrong offset!");

// Class ReadyOrNot.DeployGrenadeAtLocationActivity
// 0x0000 (0x0210 - 0x0210)
class UDeployGrenadeAtLocationActivity final : public UDeployItemAtLocationActivity
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeployGrenadeAtLocationActivity">();
	}
	static class UDeployGrenadeAtLocationActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeployGrenadeAtLocationActivity>();
	}
};
static_assert(alignof(UDeployGrenadeAtLocationActivity) == 0x000008, "Wrong alignment on UDeployGrenadeAtLocationActivity");
static_assert(sizeof(UDeployGrenadeAtLocationActivity) == 0x000210, "Wrong size on UDeployGrenadeAtLocationActivity");

// Class ReadyOrNot.HotkeysWidget
// 0x0050 (0x0338 - 0x02E8)
class UHotkeysWidget : public UBaseWidget
{
public:
	class UOverlay*                               Hotkeys_Overlay;                                   // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         Hotkeys_Container;                                 // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHotkeyWidget*                          Hotkey_Grenade;                                    // 0x02F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHotkeyWidget*                          Hotkey_Chemlight;                                  // 0x0300(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHotkeyWidget*                          Hotkey_NVG;                                        // 0x0308(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHotkeyWidget*                          Hotkey_Scope;                                      // 0x0310(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        IlluminatorAttachment_Switcher;                    // 0x0318(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHotkeyWidget*                          Hotkey_Laser;                                      // 0x0320(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHotkeyWidget*                          Hotkey_Flashlight;                                 // 0x0328(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APlayerCharacter*                       PlayerCharacter;                                   // 0x0330(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void RefreshHotkeyInput();
	void SetHotkeyVisibility(class UWidget* Widget, bool bCondition);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HotkeysWidget">();
	}
	static class UHotkeysWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHotkeysWidget>();
	}
};
static_assert(alignof(UHotkeysWidget) == 0x000008, "Wrong alignment on UHotkeysWidget");
static_assert(sizeof(UHotkeysWidget) == 0x000338, "Wrong size on UHotkeysWidget");
static_assert(offsetof(UHotkeysWidget, Hotkeys_Overlay) == 0x0002E8, "Member 'UHotkeysWidget::Hotkeys_Overlay' has a wrong offset!");
static_assert(offsetof(UHotkeysWidget, Hotkeys_Container) == 0x0002F0, "Member 'UHotkeysWidget::Hotkeys_Container' has a wrong offset!");
static_assert(offsetof(UHotkeysWidget, Hotkey_Grenade) == 0x0002F8, "Member 'UHotkeysWidget::Hotkey_Grenade' has a wrong offset!");
static_assert(offsetof(UHotkeysWidget, Hotkey_Chemlight) == 0x000300, "Member 'UHotkeysWidget::Hotkey_Chemlight' has a wrong offset!");
static_assert(offsetof(UHotkeysWidget, Hotkey_NVG) == 0x000308, "Member 'UHotkeysWidget::Hotkey_NVG' has a wrong offset!");
static_assert(offsetof(UHotkeysWidget, Hotkey_Scope) == 0x000310, "Member 'UHotkeysWidget::Hotkey_Scope' has a wrong offset!");
static_assert(offsetof(UHotkeysWidget, IlluminatorAttachment_Switcher) == 0x000318, "Member 'UHotkeysWidget::IlluminatorAttachment_Switcher' has a wrong offset!");
static_assert(offsetof(UHotkeysWidget, Hotkey_Laser) == 0x000320, "Member 'UHotkeysWidget::Hotkey_Laser' has a wrong offset!");
static_assert(offsetof(UHotkeysWidget, Hotkey_Flashlight) == 0x000328, "Member 'UHotkeysWidget::Hotkey_Flashlight' has a wrong offset!");
static_assert(offsetof(UHotkeysWidget, PlayerCharacter) == 0x000330, "Member 'UHotkeysWidget::PlayerCharacter' has a wrong offset!");

// Class ReadyOrNot.DeployWedgeActivity
// 0x0008 (0x0260 - 0x0258)
class UDeployWedgeActivity final : public UDoorInteractionActivity
{
public:
	uint8                                         Pad_258[0x8];                                      // 0x0258(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeployWedgeActivity">();
	}
	static class UDeployWedgeActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeployWedgeActivity>();
	}
};
static_assert(alignof(UDeployWedgeActivity) == 0x000008, "Wrong alignment on UDeployWedgeActivity");
static_assert(sizeof(UDeployWedgeActivity) == 0x000260, "Wrong size on UDeployWedgeActivity");

// Class ReadyOrNot.DestructibleDoorChunkComponent
// 0x0020 (0x0650 - 0x0630)
class UDestructibleDoorChunkComponent final : public UStaticMeshComponent
{
public:
	bool                                          bIsDoorHandle;                                     // 0x0628(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsHinge;                                          // 0x0629(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_62A[0x2];                                      // 0x062A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Health;                                            // 0x062C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCannotKickIfDestroyed;                            // 0x0630(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_631[0x7];                                      // 0x0631(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UDestructibleDoorChunkComponent*> SupportChunks;                                    // 0x0638(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_648[0x8];                                      // 0x0648(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DestructibleDoorChunkComponent">();
	}
	static class UDestructibleDoorChunkComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDestructibleDoorChunkComponent>();
	}
};
static_assert(alignof(UDestructibleDoorChunkComponent) == 0x000010, "Wrong alignment on UDestructibleDoorChunkComponent");
static_assert(sizeof(UDestructibleDoorChunkComponent) == 0x000650, "Wrong size on UDestructibleDoorChunkComponent");
static_assert(offsetof(UDestructibleDoorChunkComponent, bIsDoorHandle) == 0x000628, "Member 'UDestructibleDoorChunkComponent::bIsDoorHandle' has a wrong offset!");
static_assert(offsetof(UDestructibleDoorChunkComponent, bIsHinge) == 0x000629, "Member 'UDestructibleDoorChunkComponent::bIsHinge' has a wrong offset!");
static_assert(offsetof(UDestructibleDoorChunkComponent, Health) == 0x00062C, "Member 'UDestructibleDoorChunkComponent::Health' has a wrong offset!");
static_assert(offsetof(UDestructibleDoorChunkComponent, bCannotKickIfDestroyed) == 0x000630, "Member 'UDestructibleDoorChunkComponent::bCannotKickIfDestroyed' has a wrong offset!");
static_assert(offsetof(UDestructibleDoorChunkComponent, SupportChunks) == 0x000638, "Member 'UDestructibleDoorChunkComponent::SupportChunks' has a wrong offset!");

// Class ReadyOrNot.HideCursorWidget
// 0x0000 (0x02C0 - 0x02C0)
class UHideCursorWidget final : public UUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HideCursorWidget">();
	}
	static class UHideCursorWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHideCursorWidget>();
	}
};
static_assert(alignof(UHideCursorWidget) == 0x000008, "Wrong alignment on UHideCursorWidget");
static_assert(sizeof(UHideCursorWidget) == 0x0002C0, "Wrong size on UHideCursorWidget");

// Class ReadyOrNot.DestructibleVehicleBodyPart
// 0x0010 (0x0640 - 0x0630)
class UDestructibleVehicleBodyPart final : public UStaticMeshComponent
{
public:
	bool                                          bCanBeShotOff;                                     // 0x0628(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_629[0x3];                                      // 0x0629(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Health;                                            // 0x062C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBroken;                                           // 0x0630(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_631[0xF];                                      // 0x0631(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DestructibleVehicleBodyPart">();
	}
	static class UDestructibleVehicleBodyPart* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDestructibleVehicleBodyPart>();
	}
};
static_assert(alignof(UDestructibleVehicleBodyPart) == 0x000010, "Wrong alignment on UDestructibleVehicleBodyPart");
static_assert(sizeof(UDestructibleVehicleBodyPart) == 0x000640, "Wrong size on UDestructibleVehicleBodyPart");
static_assert(offsetof(UDestructibleVehicleBodyPart, bCanBeShotOff) == 0x000628, "Member 'UDestructibleVehicleBodyPart::bCanBeShotOff' has a wrong offset!");
static_assert(offsetof(UDestructibleVehicleBodyPart, Health) == 0x00062C, "Member 'UDestructibleVehicleBodyPart::Health' has a wrong offset!");
static_assert(offsetof(UDestructibleVehicleBodyPart, bBroken) == 0x000630, "Member 'UDestructibleVehicleBodyPart::bBroken' has a wrong offset!");

// Class ReadyOrNot.TugOfWarGS
// 0x0008 (0x0900 - 0x08F8)
class ATugOfWarGS final : public AReadyOrNotGameState
{
public:
	class ATugOfWarMover*                         Mover;                                             // 0x08F8(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TugOfWarGS">();
	}
	static class ATugOfWarGS* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATugOfWarGS>();
	}
};
static_assert(alignof(ATugOfWarGS) == 0x000008, "Wrong alignment on ATugOfWarGS");
static_assert(sizeof(ATugOfWarGS) == 0x000900, "Wrong size on ATugOfWarGS");
static_assert(offsetof(ATugOfWarGS, Mover) == 0x0008F8, "Member 'ATugOfWarGS::Mover' has a wrong offset!");

// Class ReadyOrNot.DestructibleVehicleParticleComponent
// 0x0000 (0x0590 - 0x0590)
class UDestructibleVehicleParticleComponent final : public UArrowComponent
{
public:
	class UParticleSystem*                        ParticleSystem;                                    // 0x0588(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DestructibleVehicleParticleComponent">();
	}
	static class UDestructibleVehicleParticleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDestructibleVehicleParticleComponent>();
	}
};
static_assert(alignof(UDestructibleVehicleParticleComponent) == 0x000010, "Wrong alignment on UDestructibleVehicleParticleComponent");
static_assert(sizeof(UDestructibleVehicleParticleComponent) == 0x000590, "Wrong size on UDestructibleVehicleParticleComponent");
static_assert(offsetof(UDestructibleVehicleParticleComponent, ParticleSystem) == 0x000588, "Member 'UDestructibleVehicleParticleComponent::ParticleSystem' has a wrong offset!");

// Class ReadyOrNot.StandardModal
// 0x00A8 (0x04B8 - 0x0410)
class UStandardModal : public UCommonActivatableWidget
{
public:
	class FText                                   TitleBar;                                          // 0x0410(0x0018)(Edit, BlueprintVisible, ExposeOnSpawn, NativeAccessSpecifierPublic)
	class FText                                   ModalDescription;                                  // 0x0428(0x0018)(Edit, BlueprintVisible, ExposeOnSpawn, NativeAccessSpecifierPublic)
	bool                                          ShowApplyButton;                                   // 0x0440(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowCancelButton;                                  // 0x0441(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowOkButton;                                      // 0x0442(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_443[0x5];                                      // 0x0443(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ApplyButtonText;                                   // 0x0448(0x0018)(Edit, BlueprintVisible, ExposeOnSpawn, NativeAccessSpecifierPublic)
	class FText                                   CancelButtonText;                                  // 0x0460(0x0018)(Edit, BlueprintVisible, ExposeOnSpawn, NativeAccessSpecifierPublic)
	class FText                                   OkButtonText;                                      // 0x0478(0x0018)(Edit, BlueprintVisible, ExposeOnSpawn, NativeAccessSpecifierPublic)
	bool                                          RequireScrollToBottom;                             // 0x0490(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_491[0x7];                                      // 0x0491(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              Size;                                              // 0x0498(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UStandardModal* CallingModal)> OnCancelClicked;              // 0x04A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StandardModal">();
	}
	static class UStandardModal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStandardModal>();
	}
};
static_assert(alignof(UStandardModal) == 0x000008, "Wrong alignment on UStandardModal");
static_assert(sizeof(UStandardModal) == 0x0004B8, "Wrong size on UStandardModal");
static_assert(offsetof(UStandardModal, TitleBar) == 0x000410, "Member 'UStandardModal::TitleBar' has a wrong offset!");
static_assert(offsetof(UStandardModal, ModalDescription) == 0x000428, "Member 'UStandardModal::ModalDescription' has a wrong offset!");
static_assert(offsetof(UStandardModal, ShowApplyButton) == 0x000440, "Member 'UStandardModal::ShowApplyButton' has a wrong offset!");
static_assert(offsetof(UStandardModal, ShowCancelButton) == 0x000441, "Member 'UStandardModal::ShowCancelButton' has a wrong offset!");
static_assert(offsetof(UStandardModal, ShowOkButton) == 0x000442, "Member 'UStandardModal::ShowOkButton' has a wrong offset!");
static_assert(offsetof(UStandardModal, ApplyButtonText) == 0x000448, "Member 'UStandardModal::ApplyButtonText' has a wrong offset!");
static_assert(offsetof(UStandardModal, CancelButtonText) == 0x000460, "Member 'UStandardModal::CancelButtonText' has a wrong offset!");
static_assert(offsetof(UStandardModal, OkButtonText) == 0x000478, "Member 'UStandardModal::OkButtonText' has a wrong offset!");
static_assert(offsetof(UStandardModal, RequireScrollToBottom) == 0x000490, "Member 'UStandardModal::RequireScrollToBottom' has a wrong offset!");
static_assert(offsetof(UStandardModal, Size) == 0x000498, "Member 'UStandardModal::Size' has a wrong offset!");
static_assert(offsetof(UStandardModal, OnCancelClicked) == 0x0004A8, "Member 'UStandardModal::OnCancelClicked' has a wrong offset!");

// Class ReadyOrNot.DestructibleVehicleGlassComponent
// 0x0000 (0x0630 - 0x0630)
class UDestructibleVehicleGlassComponent final : public UStaticMeshComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DestructibleVehicleGlassComponent">();
	}
	static class UDestructibleVehicleGlassComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDestructibleVehicleGlassComponent>();
	}
};
static_assert(alignof(UDestructibleVehicleGlassComponent) == 0x000010, "Wrong alignment on UDestructibleVehicleGlassComponent");
static_assert(sizeof(UDestructibleVehicleGlassComponent) == 0x000630, "Wrong size on UDestructibleVehicleGlassComponent");

// Class ReadyOrNot.DestructibleVehicle
// 0x01D0 (0x0468 - 0x0298)
class ADestructibleVehicle final : public AActor
{
public:
	bool                                          bComplexVehicle;                                   // 0x0298(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLightsOn;                                         // 0x0299(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29A[0x6];                                      // 0x029A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             BodyImpactEvent;                                   // 0x02A0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             BodyBreakEvent;                                    // 0x02A8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChanceToCauseAlarmOnDamage;                        // 0x02B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AlarmPlayLength;                                   // 0x02B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AlarmHeadLightsFlashInterval;                      // 0x02B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChanceToCauseAirbagToDeployOnDamage;               // 0x02BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        AirbagParticle;                                    // 0x02C0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             AirbagEvent;                                       // 0x02C8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlassHealth;                                       // 0x02D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlassDamageToApply;                                // 0x02D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMaterialInstance*>              RandomShatteredGlassMaterial;                      // 0x02D8(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class UFMODEvent*                             GlassImpactEvent;                                  // 0x02E8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             GlassBreakEvent;                                   // 0x02F0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RollAmountOnTireDamage;                            // 0x02F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchAmountOnTireDamage;                           // 0x02FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SinkAmountOnTireDamage;                            // 0x0300(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TireDeflationInterpSpeed;                          // 0x0304(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             TireDeflateEvent;                                  // 0x0308(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            FlatTireMesh;                                      // 0x0310(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseSimplifiedLights;                              // 0x0318(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_319[0x7];                                      // 0x0319(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstance*                      SimplifiedLightsOnMaterial;                        // 0x0320(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      SimplifiedLightsOffMaterial;                       // 0x0328(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      FrontLightsOnMaterial;                             // 0x0330(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      FrontLightsOffMaterial;                            // 0x0338(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      RearLightsOnMaterial;                              // 0x0340(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      RearLightsOffMaterial;                             // 0x0348(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SimplifiedLightsMaterialIndex;                     // 0x0350(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FrontLeftLightsMaterialIndex;                      // 0x0354(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FrontRightLightsMaterialIndex;                     // 0x0358(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RearLightsMaterialIndex;                           // 0x035C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_360[0x34];                                     // 0x0360(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bLeftLightDestroyed;                               // 0x0394(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bRightLightDestroyed;                              // 0x0395(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bFrontLeftTireDestroyed;                           // 0x0396(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bFrontRightTireDestroyed;                          // 0x0397(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bRearLeftTireDestroyed;                            // 0x0398(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bRearRightTireDestroyed;                           // 0x0399(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_39A[0x6];                                      // 0x039A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UDestructibleVehicleGlassComponent*, float> GlassHealthMap;                           // 0x03A0(0x0050)(ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F0[0x18];                                     // 0x03F0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   CarBody;                                           // 0x0408(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   AirBag;                                            // 0x0410(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UArrowComponent*                        AirBagEffects;                                     // 0x0418(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   FrontLeftTire;                                     // 0x0420(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   FrontRightTire;                                    // 0x0428(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RearLeftTire;                                      // 0x0430(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RearRightTire;                                     // 0x0438(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USphereComponent*                       LeftLightCollision;                                // 0x0440(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USphereComponent*                       RightLightCollision;                               // 0x0448(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USpotLightComponent*                    LeftHeadLight;                                     // 0x0450(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USpotLightComponent*                    RightHeadLight;                                    // 0x0458(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODAudioComponent*                    AlarmAudio;                                        // 0x0460(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void FlashHeadLights();
	void Multicast_BreakBodyPart(class UDestructibleVehicleBodyPart* BodyPart);
	void Multicast_BreakGlass(class UDestructibleVehicleGlassComponent* Glass);
	void Multicast_DeployCarFeatures(bool bAirbag, bool bCarAlarm, bool bDisableLeftLight, bool bDisableRightLight);
	void Multicast_PlayAudioEvent(class UFMODEvent* Event, const struct FVector_NetQuantize& Location);
	void Multicast_PlayTireDestroyedEffects(class UStaticMeshComponent* TireMesh);
	void Multicast_ShatterGlass(class UDestructibleVehicleGlassComponent* Glass);
	void StopCarAlarm();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DestructibleVehicle">();
	}
	static class ADestructibleVehicle* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADestructibleVehicle>();
	}
};
static_assert(alignof(ADestructibleVehicle) == 0x000008, "Wrong alignment on ADestructibleVehicle");
static_assert(sizeof(ADestructibleVehicle) == 0x000468, "Wrong size on ADestructibleVehicle");
static_assert(offsetof(ADestructibleVehicle, bComplexVehicle) == 0x000298, "Member 'ADestructibleVehicle::bComplexVehicle' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, bLightsOn) == 0x000299, "Member 'ADestructibleVehicle::bLightsOn' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, BodyImpactEvent) == 0x0002A0, "Member 'ADestructibleVehicle::BodyImpactEvent' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, BodyBreakEvent) == 0x0002A8, "Member 'ADestructibleVehicle::BodyBreakEvent' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, ChanceToCauseAlarmOnDamage) == 0x0002B0, "Member 'ADestructibleVehicle::ChanceToCauseAlarmOnDamage' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, AlarmPlayLength) == 0x0002B4, "Member 'ADestructibleVehicle::AlarmPlayLength' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, AlarmHeadLightsFlashInterval) == 0x0002B8, "Member 'ADestructibleVehicle::AlarmHeadLightsFlashInterval' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, ChanceToCauseAirbagToDeployOnDamage) == 0x0002BC, "Member 'ADestructibleVehicle::ChanceToCauseAirbagToDeployOnDamage' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, AirbagParticle) == 0x0002C0, "Member 'ADestructibleVehicle::AirbagParticle' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, AirbagEvent) == 0x0002C8, "Member 'ADestructibleVehicle::AirbagEvent' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, GlassHealth) == 0x0002D0, "Member 'ADestructibleVehicle::GlassHealth' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, GlassDamageToApply) == 0x0002D4, "Member 'ADestructibleVehicle::GlassDamageToApply' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, RandomShatteredGlassMaterial) == 0x0002D8, "Member 'ADestructibleVehicle::RandomShatteredGlassMaterial' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, GlassImpactEvent) == 0x0002E8, "Member 'ADestructibleVehicle::GlassImpactEvent' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, GlassBreakEvent) == 0x0002F0, "Member 'ADestructibleVehicle::GlassBreakEvent' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, RollAmountOnTireDamage) == 0x0002F8, "Member 'ADestructibleVehicle::RollAmountOnTireDamage' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, PitchAmountOnTireDamage) == 0x0002FC, "Member 'ADestructibleVehicle::PitchAmountOnTireDamage' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, SinkAmountOnTireDamage) == 0x000300, "Member 'ADestructibleVehicle::SinkAmountOnTireDamage' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, TireDeflationInterpSpeed) == 0x000304, "Member 'ADestructibleVehicle::TireDeflationInterpSpeed' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, TireDeflateEvent) == 0x000308, "Member 'ADestructibleVehicle::TireDeflateEvent' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, FlatTireMesh) == 0x000310, "Member 'ADestructibleVehicle::FlatTireMesh' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, bUseSimplifiedLights) == 0x000318, "Member 'ADestructibleVehicle::bUseSimplifiedLights' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, SimplifiedLightsOnMaterial) == 0x000320, "Member 'ADestructibleVehicle::SimplifiedLightsOnMaterial' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, SimplifiedLightsOffMaterial) == 0x000328, "Member 'ADestructibleVehicle::SimplifiedLightsOffMaterial' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, FrontLightsOnMaterial) == 0x000330, "Member 'ADestructibleVehicle::FrontLightsOnMaterial' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, FrontLightsOffMaterial) == 0x000338, "Member 'ADestructibleVehicle::FrontLightsOffMaterial' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, RearLightsOnMaterial) == 0x000340, "Member 'ADestructibleVehicle::RearLightsOnMaterial' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, RearLightsOffMaterial) == 0x000348, "Member 'ADestructibleVehicle::RearLightsOffMaterial' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, SimplifiedLightsMaterialIndex) == 0x000350, "Member 'ADestructibleVehicle::SimplifiedLightsMaterialIndex' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, FrontLeftLightsMaterialIndex) == 0x000354, "Member 'ADestructibleVehicle::FrontLeftLightsMaterialIndex' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, FrontRightLightsMaterialIndex) == 0x000358, "Member 'ADestructibleVehicle::FrontRightLightsMaterialIndex' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, RearLightsMaterialIndex) == 0x00035C, "Member 'ADestructibleVehicle::RearLightsMaterialIndex' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, bLeftLightDestroyed) == 0x000394, "Member 'ADestructibleVehicle::bLeftLightDestroyed' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, bRightLightDestroyed) == 0x000395, "Member 'ADestructibleVehicle::bRightLightDestroyed' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, bFrontLeftTireDestroyed) == 0x000396, "Member 'ADestructibleVehicle::bFrontLeftTireDestroyed' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, bFrontRightTireDestroyed) == 0x000397, "Member 'ADestructibleVehicle::bFrontRightTireDestroyed' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, bRearLeftTireDestroyed) == 0x000398, "Member 'ADestructibleVehicle::bRearLeftTireDestroyed' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, bRearRightTireDestroyed) == 0x000399, "Member 'ADestructibleVehicle::bRearRightTireDestroyed' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, GlassHealthMap) == 0x0003A0, "Member 'ADestructibleVehicle::GlassHealthMap' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, CarBody) == 0x000408, "Member 'ADestructibleVehicle::CarBody' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, AirBag) == 0x000410, "Member 'ADestructibleVehicle::AirBag' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, AirBagEffects) == 0x000418, "Member 'ADestructibleVehicle::AirBagEffects' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, FrontLeftTire) == 0x000420, "Member 'ADestructibleVehicle::FrontLeftTire' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, FrontRightTire) == 0x000428, "Member 'ADestructibleVehicle::FrontRightTire' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, RearLeftTire) == 0x000430, "Member 'ADestructibleVehicle::RearLeftTire' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, RearRightTire) == 0x000438, "Member 'ADestructibleVehicle::RearRightTire' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, LeftLightCollision) == 0x000440, "Member 'ADestructibleVehicle::LeftLightCollision' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, RightLightCollision) == 0x000448, "Member 'ADestructibleVehicle::RightLightCollision' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, LeftHeadLight) == 0x000450, "Member 'ADestructibleVehicle::LeftHeadLight' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, RightHeadLight) == 0x000458, "Member 'ADestructibleVehicle::RightHeadLight' has a wrong offset!");
static_assert(offsetof(ADestructibleVehicle, AlarmAudio) == 0x000460, "Member 'ADestructibleVehicle::AlarmAudio' has a wrong offset!");

// Class ReadyOrNot.InGameLogSubsystem
// 0x0040 (0x0070 - 0x0030)
class alignas(0x10) UInGameLogSubsystem final : public UWorldSubsystem
{
public:
	TMulticastInlineDelegate<void()>              OnLogMessageEnqueued;                              // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnLogMessageDequeued;                              // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x20];                                      // 0x0050(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnqueueLogMessage(const struct FInGameLogMessage& InLogMessage);
	void EnqueueLogMessages(const TArray<struct FInGameLogMessage>& InLogMessages);
	void EnqueuePVPMessage(const struct FInGameLogMessage_PVP& InLogMessage);
	void EnqueuePVPMessages(const TArray<struct FInGameLogMessage_PVP>& InLogMessages);
	bool GetNextLogMessage(struct FInGameLogMessage* OutLogMessage);
	bool GetNextLogMessage_PVP(struct FInGameLogMessage_PVP* OutLogMessage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InGameLogSubsystem">();
	}
	static class UInGameLogSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInGameLogSubsystem>();
	}
};
static_assert(alignof(UInGameLogSubsystem) == 0x000010, "Wrong alignment on UInGameLogSubsystem");
static_assert(sizeof(UInGameLogSubsystem) == 0x000070, "Wrong size on UInGameLogSubsystem");
static_assert(offsetof(UInGameLogSubsystem, OnLogMessageEnqueued) == 0x000030, "Member 'UInGameLogSubsystem::OnLogMessageEnqueued' has a wrong offset!");
static_assert(offsetof(UInGameLogSubsystem, OnLogMessageDequeued) == 0x000040, "Member 'UInGameLogSubsystem::OnLogMessageDequeued' has a wrong offset!");

// Class ReadyOrNot.Detonator
// 0x0020 (0x0BD0 - 0x0BB0)
class ADetonator : public ABaseItem
{
public:
	uint8                                         Pad_BB0[0x8];                                      // 0x0BB0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class APlacedC2Explosive*>             PlacedCharges;                                     // 0x0BB8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	int32                                         PlacedChargesCount;                                // 0x0BC8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDetonationDistance;                             // 0x0BCC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void Server_DetonateC2();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Detonator">();
	}
	static class ADetonator* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADetonator>();
	}
};
static_assert(alignof(ADetonator) == 0x000010, "Wrong alignment on ADetonator");
static_assert(sizeof(ADetonator) == 0x000BD0, "Wrong size on ADetonator");
static_assert(offsetof(ADetonator, PlacedCharges) == 0x000BB8, "Member 'ADetonator::PlacedCharges' has a wrong offset!");
static_assert(offsetof(ADetonator, PlacedChargesCount) == 0x000BC8, "Member 'ADetonator::PlacedChargesCount' has a wrong offset!");
static_assert(offsetof(ADetonator, MaxDetonationDistance) == 0x000BCC, "Member 'ADetonator::MaxDetonationDistance' has a wrong offset!");

// Class ReadyOrNot.TutorialMenu
// 0x0008 (0x02F0 - 0x02E8)
class UTutorialMenu : public UBaseWidget
{
public:
	uint8                                         Pad_2E8[0x8];                                      // 0x02E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialMenu">();
	}
	static class UTutorialMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTutorialMenu>();
	}
};
static_assert(alignof(UTutorialMenu) == 0x000008, "Wrong alignment on UTutorialMenu");
static_assert(sizeof(UTutorialMenu) == 0x0002F0, "Wrong size on UTutorialMenu");

// Class ReadyOrNot.DiegeticSoundComponent
// 0x0018 (0x00B8 - 0x00A0)
class UDiegeticSoundComponent final : public UActorComponent
{
public:
	class UFMODEvent*                             SoundEvent;                                        // 0x00A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOcclusionType                                OcclusionType;                                     // 0x00A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPropagationType                              PropagationType;                                   // 0x00A9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoPlay;                                         // 0x00AA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AB[0x5];                                       // 0x00AB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundSource*                           SoundSource;                                       // 0x00B0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnSoundStopped();
	void Play();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DiegeticSoundComponent">();
	}
	static class UDiegeticSoundComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDiegeticSoundComponent>();
	}
};
static_assert(alignof(UDiegeticSoundComponent) == 0x000008, "Wrong alignment on UDiegeticSoundComponent");
static_assert(sizeof(UDiegeticSoundComponent) == 0x0000B8, "Wrong size on UDiegeticSoundComponent");
static_assert(offsetof(UDiegeticSoundComponent, SoundEvent) == 0x0000A0, "Member 'UDiegeticSoundComponent::SoundEvent' has a wrong offset!");
static_assert(offsetof(UDiegeticSoundComponent, OcclusionType) == 0x0000A8, "Member 'UDiegeticSoundComponent::OcclusionType' has a wrong offset!");
static_assert(offsetof(UDiegeticSoundComponent, PropagationType) == 0x0000A9, "Member 'UDiegeticSoundComponent::PropagationType' has a wrong offset!");
static_assert(offsetof(UDiegeticSoundComponent, bAutoPlay) == 0x0000AA, "Member 'UDiegeticSoundComponent::bAutoPlay' has a wrong offset!");
static_assert(offsetof(UDiegeticSoundComponent, SoundSource) == 0x0000B0, "Member 'UDiegeticSoundComponent::SoundSource' has a wrong offset!");

// Class ReadyOrNot.IncriminationClue
// 0x0070 (0x0370 - 0x0300)
class AIncriminationClue final : public APickupActor
{
public:
	TMulticastInlineDelegate<void(class AIncriminationClue* ClueActor, class AActor* ClueFounder)> Delegate_OnClueFound; // 0x0300(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UMapActorComponent*                     MapActorComponent;                                 // 0x0310(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ClueNumber;                                        // 0x0318(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_319[0x3];                                      // 0x0319(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ShowObjectiveMarkerIn;                             // 0x031C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AIncriminationClue*                     NextClue;                                          // 0x0320(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   ClueName;                                          // 0x0328(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Net, Protected, NativeAccessSpecifierProtected)
	class FText                                   ClueFoundMessage;                                  // 0x0340(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Net, Protected, NativeAccessSpecifierProtected)
	class AIncriminationClueSpawnPoint*           SpawnPointOwner;                                   // 0x0358(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bClueFound : 1;                                    // 0x0360(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bClueTimerExpired : 1;                             // 0x0360(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	EClueState                                    ClueState;                                         // 0x0361(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_362[0xE];                                      // 0x0362(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Init(class AIncriminationClueSpawnPoint* OwningSpawn, uint8 InClueNumber, const class FText& InClueName, const class FText& InClueFoundMessage, float InShowObjectiveMarkerIn);
	void OnClueFound();
	void OnRep_OnClueFound();
	void OnRep_OnClueStateChanged();
	void RevealNextClue();

	bool IsClueFound() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IncriminationClue">();
	}
	static class AIncriminationClue* GetDefaultObj()
	{
		return GetDefaultObjImpl<AIncriminationClue>();
	}
};
static_assert(alignof(AIncriminationClue) == 0x000008, "Wrong alignment on AIncriminationClue");
static_assert(sizeof(AIncriminationClue) == 0x000370, "Wrong size on AIncriminationClue");
static_assert(offsetof(AIncriminationClue, Delegate_OnClueFound) == 0x000300, "Member 'AIncriminationClue::Delegate_OnClueFound' has a wrong offset!");
static_assert(offsetof(AIncriminationClue, MapActorComponent) == 0x000310, "Member 'AIncriminationClue::MapActorComponent' has a wrong offset!");
static_assert(offsetof(AIncriminationClue, ClueNumber) == 0x000318, "Member 'AIncriminationClue::ClueNumber' has a wrong offset!");
static_assert(offsetof(AIncriminationClue, ShowObjectiveMarkerIn) == 0x00031C, "Member 'AIncriminationClue::ShowObjectiveMarkerIn' has a wrong offset!");
static_assert(offsetof(AIncriminationClue, NextClue) == 0x000320, "Member 'AIncriminationClue::NextClue' has a wrong offset!");
static_assert(offsetof(AIncriminationClue, ClueName) == 0x000328, "Member 'AIncriminationClue::ClueName' has a wrong offset!");
static_assert(offsetof(AIncriminationClue, ClueFoundMessage) == 0x000340, "Member 'AIncriminationClue::ClueFoundMessage' has a wrong offset!");
static_assert(offsetof(AIncriminationClue, SpawnPointOwner) == 0x000358, "Member 'AIncriminationClue::SpawnPointOwner' has a wrong offset!");
static_assert(offsetof(AIncriminationClue, ClueState) == 0x000361, "Member 'AIncriminationClue::ClueState' has a wrong offset!");

// Class ReadyOrNot.DisarmBombActivity
// 0x0078 (0x0268 - 0x01F0)
class UDisarmBombActivity final : public UBaseActivity
{
public:
	class ACyberneticCharacter*                   Hostage;                                           // 0x01F0(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, class UInteractionsData*>   Interactions;                                      // 0x01F8(0x0050)(Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class UInteractionsData*                      DisarmInteraction;                                 // 0x0248(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_250[0x18];                                     // 0x0250(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnterDisarmState();
	void EnterMoveToState();
	void OnDisarmComplete_Slave(class AActor* Actor);
	void OnHostageKilled(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter);
	void OnTakeDamage(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* DamagedCharacter, class AActor* DamageCauser, float Damage, float HealthRemaining);
	void TickDisarmState(float DeltaTime, float Uptime);
	void TickMoveToState(float DeltaTime, float Uptime);

	bool CanStartDisarm() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DisarmBombActivity">();
	}
	static class UDisarmBombActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDisarmBombActivity>();
	}
};
static_assert(alignof(UDisarmBombActivity) == 0x000008, "Wrong alignment on UDisarmBombActivity");
static_assert(sizeof(UDisarmBombActivity) == 0x000268, "Wrong size on UDisarmBombActivity");
static_assert(offsetof(UDisarmBombActivity, Hostage) == 0x0001F0, "Member 'UDisarmBombActivity::Hostage' has a wrong offset!");
static_assert(offsetof(UDisarmBombActivity, Interactions) == 0x0001F8, "Member 'UDisarmBombActivity::Interactions' has a wrong offset!");
static_assert(offsetof(UDisarmBombActivity, DisarmInteraction) == 0x000248, "Member 'UDisarmBombActivity::DisarmInteraction' has a wrong offset!");

// Class ReadyOrNot.DisarmC2Activity
// 0x0010 (0x0200 - 0x01F0)
class UDisarmC2Activity final : public UBaseActivity
{
public:
	class APlacedC2Explosive*                     PlacedC2;                                          // 0x01F0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1F8[0x8];                                      // 0x01F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DisarmC2Activity">();
	}
	static class UDisarmC2Activity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDisarmC2Activity>();
	}
};
static_assert(alignof(UDisarmC2Activity) == 0x000008, "Wrong alignment on UDisarmC2Activity");
static_assert(sizeof(UDisarmC2Activity) == 0x000200, "Wrong size on UDisarmC2Activity");
static_assert(offsetof(UDisarmC2Activity, PlacedC2) == 0x0001F0, "Member 'UDisarmC2Activity::PlacedC2' has a wrong offset!");

// Class ReadyOrNot.HumanCharacterHUD_V2
// 0x0150 (0x0588 - 0x0438)
class UHumanCharacterHUD_V2 : public UActivatableBaseWidget
{
public:
	TMulticastInlineDelegate<void(class FText InText, bool ClearText, bool bAnimate, bool bLoopAnimation)> OnSlot1Updated; // 0x0438(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class FText InText, bool ClearText, bool bAnimate, bool bLoopAnimation)> OnSlot2Updated; // 0x0448(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class FText InText, bool ClearText, bool bAnimate, bool bLoopAnimation)> OnSlot3Updated; // 0x0458(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class FText InText, bool ClearText, bool bAnimate, bool bLoopAnimation)> OnSlot4Updated; // 0x0468(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class FText InText, class FText InTextGamepad, bool ClearText, bool bAnimate, bool bLoopAnimation)> OnSlotReserved1Updated; // 0x0478(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class FText InText, class FText InTextGamepad, bool ClearText, bool bAnimate, bool bLoopAnimation)> OnSlotReserved2Updated; // 0x0488(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       Anim_FadeInHUD;                                    // 0x0498(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           CanvasPanel_Main;                                  // 0x04A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           CanvasPanel_Gamepad;                               // 0x04A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URetainerBox*                           RetainerBox_SwayableElements;                      // 0x04B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlayerActionPromptWidget*              PlayerActionText_Slot_1;                           // 0x04B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlayerActionPromptWidget*              PlayerActionText_Slot_2;                           // 0x04C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlayerActionPromptWidget*              PlayerActionText_Slot_3;                           // 0x04C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlayerActionPromptWidget*              PlayerActionText_Slot_4;                           // 0x04D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlayerActionPromptWidget*              PlayerActionText_Slot_Reserved_1;                  // 0x04D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlayerActionPromptWidget*              PlayerActionText_Slot_Reserved_2;                  // 0x04E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UItemWheel*                             ItemWheel;                                         // 0x04E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCommandWheel*                          CommandWheel;                                      // 0x04F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         GamepadStopLeanText;                               // 0x04F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UConsoleHotkeys*                        ConsoleHotkeys;                                    // 0x0500(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHUDStyle                                     HUDStyle;                                          // 0x0508(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_509[0x7];                                      // 0x0509(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ObjectiveMarker_WidgetFadeZones;                   // 0x0510(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         bEnableHUDSway : 1;                                // 0x0520(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_521[0x7];                                      // 0x0521(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              MaxHUDSwayMovement;                                // 0x0528(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              SwayStrength;                                      // 0x0538(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              SwaySpeed;                                         // 0x0548(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bEnableCurvedHUD : 1;                              // 0x0558(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_559[0x3];                                      // 0x0559(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurvedHUDStrength;                                 // 0x055C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APlayerCharacter*                       PlayerCharacter;                                   // 0x0560(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AReadyOrNotPlayerController*            PlayerController;                                  // 0x0568(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              AccumulatedMouseDelta;                             // 0x0570(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bConsoleHotkeysHidden;                             // 0x0580(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_581[0x7];                                      // 0x0581(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UMapActorWidget* AddMapActor(class UMapActorComponent* MapActorComponent, TSubclassOf<class UMapActorWidget> MapActorIconWidgetClass, const struct FSlateBrush& IconBrush, const struct FLinearColor& IconColor, const struct FLinearColor& IconTextColor, float RotationOffset);
	void AddObjectivePopup(const class FText& PopupText);
	void AddScorePopup(const class FText& ScoreText, int32 ScoreValue, bool bGive);
	void AssignPlayerActionPrompt(int32 InSlot, const struct FKey& InputKey, EInputEvent InputEvent, const class FText& InActionText, const class FString& InColorLabel, bool bAnimate, bool bLoopAnimation);
	void AssignPlayerActionPrompt_Custom(int32 InSlot, const class FText& InCustomPromptText, bool bAnimate, bool bLoopAnimation);
	void AssignPlayerActionPrompt_Reserved(int32 InSlot, EInputEvent InputEvent, const class FText& InActionText, const class FString& InColorLabel, bool bAnimate, bool bLoopAnimation);
	void AssignPlayerActionPromptToFreeSlot(const struct FKey& InputKey, EInputEvent InputEvent, const class FText& InActionText, const class FString& InColorLabel, bool bAnimate, bool bLoopAnimation);
	int32 AssignPlayerActionPromptToFreeSlot_Reserved(const struct FKey& MKBKey, const struct FKey& GamepadKey, EInputEvent InputEvent, const class FText& InActionText, const class FString& InColorLabel, bool bAnimate, bool bLoopAnimation);
	void ChatPressed();
	void ClearAllPlayerActionPrompts();
	class UCommandWheel* GetCommandWheel();
	class UConsoleHotkeys* GetConsoleHotkeys();
	class UItemWheel* GetItemWheel();
	class UScreenspaceMarkerWidget* GetRoundupWidget();
	class UScreenspaceMarkerWidget* GetScreenspaceMarkerWidget();
	class UTutorialWidget* GetTutorialWidget();
	void HideHUD();
	void HideTutorialOverview(const class FString& MessageID);
	void HideTutorialPrompt(const class FString& MessageID);
	void LocalReadyStateChanged(bool bReady);
	void OnInventoryItemsChanged();
	void OnTabletClose();
	void OnTabletNotificationEvent();
	void OnTabletOpen();
	void ReadiedPlayersChanged();
	void ReflectHUDSettings();
	void RemoveMapActor(class UMapActorComponent* MapActorComponent);
	void RemovePlayerActionPrompt(int32 InSlot);
	void RemovePlayerActionPrompt_Reserved(int32 InSlot);
	void SetMissionCountdownTime(float Time);
	void ShowHUD();
	void ShowTutorialOverview(const class FString& MessageID, const class FText& MessageTitle, const TArray<class FText>& MessageContent);
	void ShowTutorialPrompt(const class FString& MessageID, bool bFirstShowing, const class FText& MessageTitle, const TArray<class FText>& MessageContent);
	void TeamChatPressed();
	void UpdateMapFloors(const TArray<struct FBuildingFloor>& Floors);

	bool IsActionSlotInUse(int32 InSlot) const;
	bool IsActionSlotInUse_Reserved(int32 InSlot) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HumanCharacterHUD_V2">();
	}
	static class UHumanCharacterHUD_V2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHumanCharacterHUD_V2>();
	}
};
static_assert(alignof(UHumanCharacterHUD_V2) == 0x000008, "Wrong alignment on UHumanCharacterHUD_V2");
static_assert(sizeof(UHumanCharacterHUD_V2) == 0x000588, "Wrong size on UHumanCharacterHUD_V2");
static_assert(offsetof(UHumanCharacterHUD_V2, OnSlot1Updated) == 0x000438, "Member 'UHumanCharacterHUD_V2::OnSlot1Updated' has a wrong offset!");
static_assert(offsetof(UHumanCharacterHUD_V2, OnSlot2Updated) == 0x000448, "Member 'UHumanCharacterHUD_V2::OnSlot2Updated' has a wrong offset!");
static_assert(offsetof(UHumanCharacterHUD_V2, OnSlot3Updated) == 0x000458, "Member 'UHumanCharacterHUD_V2::OnSlot3Updated' has a wrong offset!");
static_assert(offsetof(UHumanCharacterHUD_V2, OnSlot4Updated) == 0x000468, "Member 'UHumanCharacterHUD_V2::OnSlot4Updated' has a wrong offset!");
static_assert(offsetof(UHumanCharacterHUD_V2, OnSlotReserved1Updated) == 0x000478, "Member 'UHumanCharacterHUD_V2::OnSlotReserved1Updated' has a wrong offset!");
static_assert(offsetof(UHumanCharacterHUD_V2, OnSlotReserved2Updated) == 0x000488, "Member 'UHumanCharacterHUD_V2::OnSlotReserved2Updated' has a wrong offset!");
static_assert(offsetof(UHumanCharacterHUD_V2, Anim_FadeInHUD) == 0x000498, "Member 'UHumanCharacterHUD_V2::Anim_FadeInHUD' has a wrong offset!");
static_assert(offsetof(UHumanCharacterHUD_V2, CanvasPanel_Main) == 0x0004A0, "Member 'UHumanCharacterHUD_V2::CanvasPanel_Main' has a wrong offset!");
static_assert(offsetof(UHumanCharacterHUD_V2, CanvasPanel_Gamepad) == 0x0004A8, "Member 'UHumanCharacterHUD_V2::CanvasPanel_Gamepad' has a wrong offset!");
static_assert(offsetof(UHumanCharacterHUD_V2, RetainerBox_SwayableElements) == 0x0004B0, "Member 'UHumanCharacterHUD_V2::RetainerBox_SwayableElements' has a wrong offset!");
static_assert(offsetof(UHumanCharacterHUD_V2, PlayerActionText_Slot_1) == 0x0004B8, "Member 'UHumanCharacterHUD_V2::PlayerActionText_Slot_1' has a wrong offset!");
static_assert(offsetof(UHumanCharacterHUD_V2, PlayerActionText_Slot_2) == 0x0004C0, "Member 'UHumanCharacterHUD_V2::PlayerActionText_Slot_2' has a wrong offset!");
static_assert(offsetof(UHumanCharacterHUD_V2, PlayerActionText_Slot_3) == 0x0004C8, "Member 'UHumanCharacterHUD_V2::PlayerActionText_Slot_3' has a wrong offset!");
static_assert(offsetof(UHumanCharacterHUD_V2, PlayerActionText_Slot_4) == 0x0004D0, "Member 'UHumanCharacterHUD_V2::PlayerActionText_Slot_4' has a wrong offset!");
static_assert(offsetof(UHumanCharacterHUD_V2, PlayerActionText_Slot_Reserved_1) == 0x0004D8, "Member 'UHumanCharacterHUD_V2::PlayerActionText_Slot_Reserved_1' has a wrong offset!");
static_assert(offsetof(UHumanCharacterHUD_V2, PlayerActionText_Slot_Reserved_2) == 0x0004E0, "Member 'UHumanCharacterHUD_V2::PlayerActionText_Slot_Reserved_2' has a wrong offset!");
static_assert(offsetof(UHumanCharacterHUD_V2, ItemWheel) == 0x0004E8, "Member 'UHumanCharacterHUD_V2::ItemWheel' has a wrong offset!");
static_assert(offsetof(UHumanCharacterHUD_V2, CommandWheel) == 0x0004F0, "Member 'UHumanCharacterHUD_V2::CommandWheel' has a wrong offset!");
static_assert(offsetof(UHumanCharacterHUD_V2, GamepadStopLeanText) == 0x0004F8, "Member 'UHumanCharacterHUD_V2::GamepadStopLeanText' has a wrong offset!");
static_assert(offsetof(UHumanCharacterHUD_V2, ConsoleHotkeys) == 0x000500, "Member 'UHumanCharacterHUD_V2::ConsoleHotkeys' has a wrong offset!");
static_assert(offsetof(UHumanCharacterHUD_V2, HUDStyle) == 0x000508, "Member 'UHumanCharacterHUD_V2::HUDStyle' has a wrong offset!");
static_assert(offsetof(UHumanCharacterHUD_V2, ObjectiveMarker_WidgetFadeZones) == 0x000510, "Member 'UHumanCharacterHUD_V2::ObjectiveMarker_WidgetFadeZones' has a wrong offset!");
static_assert(offsetof(UHumanCharacterHUD_V2, MaxHUDSwayMovement) == 0x000528, "Member 'UHumanCharacterHUD_V2::MaxHUDSwayMovement' has a wrong offset!");
static_assert(offsetof(UHumanCharacterHUD_V2, SwayStrength) == 0x000538, "Member 'UHumanCharacterHUD_V2::SwayStrength' has a wrong offset!");
static_assert(offsetof(UHumanCharacterHUD_V2, SwaySpeed) == 0x000548, "Member 'UHumanCharacterHUD_V2::SwaySpeed' has a wrong offset!");
static_assert(offsetof(UHumanCharacterHUD_V2, CurvedHUDStrength) == 0x00055C, "Member 'UHumanCharacterHUD_V2::CurvedHUDStrength' has a wrong offset!");
static_assert(offsetof(UHumanCharacterHUD_V2, PlayerCharacter) == 0x000560, "Member 'UHumanCharacterHUD_V2::PlayerCharacter' has a wrong offset!");
static_assert(offsetof(UHumanCharacterHUD_V2, PlayerController) == 0x000568, "Member 'UHumanCharacterHUD_V2::PlayerController' has a wrong offset!");
static_assert(offsetof(UHumanCharacterHUD_V2, AccumulatedMouseDelta) == 0x000570, "Member 'UHumanCharacterHUD_V2::AccumulatedMouseDelta' has a wrong offset!");
static_assert(offsetof(UHumanCharacterHUD_V2, bConsoleHotkeysHidden) == 0x000580, "Member 'UHumanCharacterHUD_V2::bConsoleHotkeysHidden' has a wrong offset!");

// Class ReadyOrNot.DisarmDoorTrapActivity
// 0x0000 (0x0258 - 0x0258)
class UDisarmDoorTrapActivity final : public UDoorInteractionActivity
{
public:
	void OnTrapTriggered(class ATrapActor* Trap, class AReadyOrNotCharacter* TriggeredBy);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DisarmDoorTrapActivity">();
	}
	static class UDisarmDoorTrapActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDisarmDoorTrapActivity>();
	}
};
static_assert(alignof(UDisarmDoorTrapActivity) == 0x000008, "Wrong alignment on UDisarmDoorTrapActivity");
static_assert(sizeof(UDisarmDoorTrapActivity) == 0x000258, "Wrong size on UDisarmDoorTrapActivity");

// Class ReadyOrNot.UObjectListener
// 0x0010 (0x02A8 - 0x0298)
class AUObjectListener final : public AActor
{
public:
	uint8                                         Pad_298[0x10];                                     // 0x0298(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UObjectListener">();
	}
	static class AUObjectListener* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUObjectListener>();
	}
};
static_assert(alignof(AUObjectListener) == 0x000008, "Wrong alignment on AUObjectListener");
static_assert(sizeof(AUObjectListener) == 0x0002A8, "Wrong size on AUObjectListener");

// Class ReadyOrNot.DisarmStandaloneTrapActivity
// 0x0020 (0x0210 - 0x01F0)
class UDisarmStandaloneTrapActivity final : public UBaseActivity
{
public:
	class ATrapActor*                             TrapToDisarm;                                      // 0x01F0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F8[0x18];                                     // 0x01F8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnterDisarmStage();
	void EnterGetInPositionStage();
	void OnTrapDisarmed();
	void OnTrapTriggered(class ATrapActor* Trap, class AReadyOrNotCharacter* TriggeredBy);

	bool CanPerformDisarm() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DisarmStandaloneTrapActivity">();
	}
	static class UDisarmStandaloneTrapActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDisarmStandaloneTrapActivity>();
	}
};
static_assert(alignof(UDisarmStandaloneTrapActivity) == 0x000008, "Wrong alignment on UDisarmStandaloneTrapActivity");
static_assert(sizeof(UDisarmStandaloneTrapActivity) == 0x000210, "Wrong size on UDisarmStandaloneTrapActivity");
static_assert(offsetof(UDisarmStandaloneTrapActivity, TrapToDisarm) == 0x0001F0, "Member 'UDisarmStandaloneTrapActivity::TrapToDisarm' has a wrong offset!");

// Class ReadyOrNot.PVPTriggerBox
// 0x0068 (0x0308 - 0x02A0)
class APVPTriggerBox : public ATriggerBox
{
public:
	class UTextRenderComponent*                   TextRender;                                        // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UObjectiveMarkerComponent*              ObjectiveMarkerComponent;                          // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class APlayerCharacter*>               CharactersInTriggerBox;                            // 0x02B0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	float                                         TimeElapsed;                                       // 0x02C0(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PreviousTimeElapsed;                               // 0x02C4(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bEntered : 1;                                      // 0x02C8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_2C9[0x3];                                      // 0x02C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeNeededToStay_Editor;                           // 0x02CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeNeededToStay;                                  // 0x02D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeNeededToStay_Active;                           // 0x02D4(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<ETeamType>                             OnlyAcceptTeams;                                   // 0x02D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           OnlyAcceptActorsWithTags;                          // 0x02E8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         bLogDebugInfo : 1;                                 // 0x02F8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_2F9[0x7];                                      // 0x02F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           TH_TimerEventExpiry;                               // 0x0300(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void CancelTimerEvent();
	void HideObjectiveMarker();
	void OnBeginOverlap(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnEndOverlap(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnRep_CharactersInTriggerBoxUpdated();
	void OnTimerExpired();
	void PauseTimerEvent();
	void ResumeTimerEvent();
	void ShowObjectiveMarker();
	void StartTimerEvent();
	void ToggleObjectiveMarker();

	bool DoesActorHaveAnyAcceptedTags(class AActor* OtherActor) const;
	float GetCurrentElapsedTime() const;
	float GetLastElapsedTime() const;
	bool IsActorInTriggerBox(class AActor* InActor) const;
	bool IsPlayerOnAcceptedTeam(class APlayerCharacter* Player) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PVPTriggerBox">();
	}
	static class APVPTriggerBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<APVPTriggerBox>();
	}
};
static_assert(alignof(APVPTriggerBox) == 0x000008, "Wrong alignment on APVPTriggerBox");
static_assert(sizeof(APVPTriggerBox) == 0x000308, "Wrong size on APVPTriggerBox");
static_assert(offsetof(APVPTriggerBox, TextRender) == 0x0002A0, "Member 'APVPTriggerBox::TextRender' has a wrong offset!");
static_assert(offsetof(APVPTriggerBox, ObjectiveMarkerComponent) == 0x0002A8, "Member 'APVPTriggerBox::ObjectiveMarkerComponent' has a wrong offset!");
static_assert(offsetof(APVPTriggerBox, CharactersInTriggerBox) == 0x0002B0, "Member 'APVPTriggerBox::CharactersInTriggerBox' has a wrong offset!");
static_assert(offsetof(APVPTriggerBox, TimeElapsed) == 0x0002C0, "Member 'APVPTriggerBox::TimeElapsed' has a wrong offset!");
static_assert(offsetof(APVPTriggerBox, PreviousTimeElapsed) == 0x0002C4, "Member 'APVPTriggerBox::PreviousTimeElapsed' has a wrong offset!");
static_assert(offsetof(APVPTriggerBox, TimeNeededToStay_Editor) == 0x0002CC, "Member 'APVPTriggerBox::TimeNeededToStay_Editor' has a wrong offset!");
static_assert(offsetof(APVPTriggerBox, TimeNeededToStay) == 0x0002D0, "Member 'APVPTriggerBox::TimeNeededToStay' has a wrong offset!");
static_assert(offsetof(APVPTriggerBox, TimeNeededToStay_Active) == 0x0002D4, "Member 'APVPTriggerBox::TimeNeededToStay_Active' has a wrong offset!");
static_assert(offsetof(APVPTriggerBox, OnlyAcceptTeams) == 0x0002D8, "Member 'APVPTriggerBox::OnlyAcceptTeams' has a wrong offset!");
static_assert(offsetof(APVPTriggerBox, OnlyAcceptActorsWithTags) == 0x0002E8, "Member 'APVPTriggerBox::OnlyAcceptActorsWithTags' has a wrong offset!");
static_assert(offsetof(APVPTriggerBox, TH_TimerEventExpiry) == 0x000300, "Member 'APVPTriggerBox::TH_TimerEventExpiry' has a wrong offset!");

// Class ReadyOrNot.DontDie
// 0x0000 (0x0320 - 0x0320)
class ADontDie final : public AObjective
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DontDie">();
	}
	static class ADontDie* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADontDie>();
	}
};
static_assert(alignof(ADontDie) == 0x000008, "Wrong alignment on ADontDie");
static_assert(sizeof(ADontDie) == 0x000320, "Wrong size on ADontDie");

// Class ReadyOrNot.DoorwayWithoutDoor
// 0x0008 (0x02A0 - 0x0298)
class ADoorwayWithoutDoor : public AActor
{
public:
	class UDoorwayComponent*                      Doorway;                                           // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	struct FVector GetDoorSize() const;
	class UDoorwayComponent* GetDoorway() const;
	bool IsPointInFrontOfDoorway(const struct FVector& Point) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DoorwayWithoutDoor">();
	}
	static class ADoorwayWithoutDoor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADoorwayWithoutDoor>();
	}
};
static_assert(alignof(ADoorwayWithoutDoor) == 0x000008, "Wrong alignment on ADoorwayWithoutDoor");
static_assert(sizeof(ADoorwayWithoutDoor) == 0x0002A0, "Wrong size on ADoorwayWithoutDoor");
static_assert(offsetof(ADoorwayWithoutDoor, Doorway) == 0x000298, "Member 'ADoorwayWithoutDoor::Doorway' has a wrong offset!");

// Class ReadyOrNot.InvestigateActivity
// 0x0000 (0x02A0 - 0x02A0)
class UInvestigateActivity final : public UWorldBuildingActivity
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InvestigateActivity">();
	}
	static class UInvestigateActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInvestigateActivity>();
	}
};
static_assert(alignof(UInvestigateActivity) == 0x000008, "Wrong alignment on UInvestigateActivity");
static_assert(sizeof(UInvestigateActivity) == 0x0002A0, "Wrong size on UInvestigateActivity");

// Class ReadyOrNot.Door
// 0x1020 (0x12C0 - 0x02A0)
class ADoor final : public ADoorwayWithoutDoor
{
public:
	uint8                                         Pad_2A0[0x60];                                     // 0x02A0(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnDoorOpened;                                      // 0x0300(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnSubDoorOpened;                                   // 0x0310(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnDoorClosed;                                      // 0x0320(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnDoorBroken;                                      // 0x0330(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnDoorMovementBlocked;                             // 0x0340(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ADoor* Door, class AReadyOrNotCharacter* InstigatorCharacter)> OnDoorExploded; // 0x0350(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ADoor* Door, class AReadyOrNotCharacter* InstigatorCharacter, bool bSuccess)> OnDoorKicked; // 0x0360(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    TypeOfDoor;                                        // 0x0370(0x0010)(Edit, Net, NoDestructor, NativeAccessSpecifierPublic)
	float                                         StartingOpenAngle;                                 // 0x0380(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOneWay : 1;                                       // 0x0384(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	EDoorOneWayDirection                          OneWayDirection;                                   // 0x0385(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRandomlyOpenAtGameStart;                          // 0x0386(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSuspectAlwaysUnlocks;                             // 0x0387(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreForFlee;                                    // 0x0388(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNoNavBlockerForGen;                               // 0x0389(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNoAutomaticClearing;                              // 0x038A(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanUseC2;                                         // 0x038B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanUseBSG;                                        // 0x038C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanUseWedge;                                      // 0x038D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanUseRam;                                        // 0x038E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanUseOptiwand;                                   // 0x038F(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bCanPlayerInteract : 1;                            // 0x0390(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bCanIssueOrdersOnFrontSide;                        // 0x0391(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanIssueOrdersOnBackSide;                         // 0x0392(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasFrame;                                         // 0x0393(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_394[0x4];                                      // 0x0394(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AThreatAwarenessActor*                  FrontThreat;                                       // 0x0398(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AThreatAwarenessActor*                  BackThreat;                                        // 0x03A0(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AThreatAwarenessActor*>          FrontThreatAwarenessPoints;                        // 0x03A8(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class AThreatAwarenessActor*>          BackThreatAwarenessPoints;                         // 0x03B8(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class AStackUpActor*>                  FrontLeftStackUpPoints;                            // 0x03C8(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class AStackUpActor*>                  FrontRightStackUpPoints;                           // 0x03D8(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class AStackUpActor*>                  BackLeftStackUpPoints;                             // 0x03E8(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class AStackUpActor*>                  BackRightStackUpPoints;                            // 0x03F8(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FClearPoint>                    FrontLeftClearPoints;                              // 0x0408(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	TArray<struct FClearPoint>                    FrontRightClearPoints;                             // 0x0418(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	TArray<struct FClearPoint>                    BackLeftClearPoints;                               // 0x0428(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	TArray<struct FClearPoint>                    BackRightClearPoints;                              // 0x0438(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	uint8                                         bJamInProgress : 1;                                // 0x0448(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, Net, DisableEditOnTemplate, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bLocked : 1;                                       // 0x0448(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, Net, DisableEditOnTemplate, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_449[0x7];                                      // 0x0449(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 DestroyedChunkIdxs;                                // 0x0450(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPublic)
	bool                                          bHeldPushDoor;                                     // 0x0460(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_461[0x3];                                      // 0x0461(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PushDoorHoldTime;                                  // 0x0464(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDoorRoomPosition                             FrontRoomPosition;                                 // 0x0468(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDoorRoomPosition                             BackRoomPosition;                                  // 0x0469(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bManualRoomPositionSetup;                          // 0x046A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_46B[0x9];                                      // 0x046B(0x0009)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxFrontHorizontalClearingDistance;                // 0x0474(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxBackHorizontalClearingDistance;                 // 0x0478(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_47C[0x4];                                      // 0x047C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              MaxFrontRightClearThreshold;                       // 0x0480(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              MaxFrontLeftClearThreshold;                        // 0x0490(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              MaxBackRightClearThreshold;                        // 0x04A0(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              MaxBackLeftClearThreshold;                         // 0x04B0(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         MaxFrontRightClearPoints;                          // 0x04C0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         MaxFrontLeftClearPoints;                           // 0x04C1(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         MaxBackRightClearPoints;                           // 0x04C2(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         MaxBackLeftClearPoints;                            // 0x04C3(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bManualClearPointSetup;                            // 0x04C4(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C5[0x13];                                     // 0x04C5(0x0013)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        KickedParticleSystem;                              // 0x04D8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        LockBrokenParticleSystem;                          // 0x04E0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        RootScene;                                         // 0x04E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   DoorStatic;                                        // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   DoorHandleFront;                                   // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   DoorHandleBack;                                    // 0x0500(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMirrorPortalComponent*                 FrontMirrorPoint;                                  // 0x0508(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMirrorPortalComponent*                 BackMirrorPoint;                                   // 0x0510(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDestructibleDoorChunkComponent*        DoorChunk0;                                        // 0x0518(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDestructibleDoorChunkComponent*        DoorChunk1;                                        // 0x0520(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDestructibleDoorChunkComponent*        DoorChunk2;                                        // 0x0528(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDestructibleDoorChunkComponent*        DoorChunk3;                                        // 0x0530(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDestructibleDoorChunkComponent*        DoorChunk4;                                        // 0x0538(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDestructibleDoorChunkComponent*        DoorChunk5;                                        // 0x0540(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDestructibleDoorChunkComponent*        DoorChunk6;                                        // 0x0548(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDestructibleDoorChunkComponent*        DoorChunk7;                                        // 0x0550(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDestructibleDoorChunkComponent*        DoorChunk8;                                        // 0x0558(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   LightBlocker;                                      // 0x0560(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractableComponent*                 DoorOpenInteractableComp;                          // 0x0568(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractableComponent*                 DoorSublinkOpenInteractableComp;                   // 0x0570(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractableComponent*                 DoorSublinkPushInteractableComp;                   // 0x0578(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractableComponent*                 DoorPushInteractableComp;                          // 0x0580(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractableComponent*                 DoorKickInteractableComp;                          // 0x0588(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractableComponent*                 DoorSublinkKickInteractableComp;                   // 0x0590(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractableComponent*                 LockpickInteractableComponent;                     // 0x0598(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractableComponent*                 C2InteractableComponent;                           // 0x05A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractableComponent*                 WedgeInteractableComponent;                        // 0x05A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractableComponent*                 OptiwandInteractableComponent;                     // 0x05B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractableComponent*                 BSGInteractableComponent;                          // 0x05B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractableComponent*                 BSGInteractableComponent_2;                        // 0x05C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractableComponent*                 DoorRamInteractableComponent;                      // 0x05C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDecalComponent*                        C2ExplosionDecalComponent;                         // 0x05D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODAudioPropagationComponent*         FMODAudioPropagationComp;                          // 0x05D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        LockpickArea;                                      // 0x05E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        DoorArea;                                          // 0x05E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        C2Area;                                            // 0x05F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        BSGArea;                                           // 0x05F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        MirrorgunArea;                                     // 0x0600(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        WedgeArea;                                         // 0x0608(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        BatteringRamArea;                                  // 0x0610(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          DoorBlockerComponent;                              // 0x0618(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          BreachBlocker1Component;                           // 0x0620(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          BreachBlocker2Component;                           // 0x0628(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          BreachBlocker3Component;                           // 0x0630(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bHasEverBeenOpenedBySwat : 1;                      // 0x0638(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_639[0x7];                                      // 0x0639(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         OperatingStates;                                   // 0x0640(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPublic)
	class ANavLinkProxy*                          NavLinkProxy;                                      // 0x0650(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_658[0x30];                                     // 0x0658(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bNoSpawnTrap : 1;                                  // 0x0688(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	EDoorTrapSide                                 TrapSide;                                          // 0x0689(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_68A[0x6];                                      // 0x068A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataTableRowHandle                    TypeOfTrap;                                        // 0x0690(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TMap<EDoorDamageType, float>                  DoorKillDistance;                                  // 0x06A0(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<EDoorDamageType, float>                  DoorStunDistance;                                  // 0x06F0(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         MaxOpenClose;                                      // 0x0740(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OpenThreshold;                                     // 0x0744(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CloseThreshold;                                    // 0x0748(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IncrementAngle;                                    // 0x074C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhysicalPushAmount;                                // 0x0750(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_754[0x4];                                      // 0x0754(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ADoor*                                  DriveSubDoor;                                      // 0x0758(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bMainSubDoor : 1;                                  // 0x0760(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bKickAlwaysFails : 1;                              // 0x0760(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_761[0x3];                                      // 0x0761(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DoorKickSuccessChance;                             // 0x0764(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         NumSuccessfulKicksToBreakDown;                     // 0x0768(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_769[0x7];                                      // 0x0769(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     C2ExplosionDecal;                                  // 0x0770(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bAlwaysLocked : 1;                                 // 0x0778(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverrideLockChance : 1;                           // 0x0778(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_779[0x3];                                      // 0x0779(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LockedChance;                                      // 0x077C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsElectronicDoor;                                 // 0x0780(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_781[0x3];                                      // 0x0781(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ElectronicLockChance;                              // 0x0784(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DoorPushCurve;                                     // 0x0788(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DoorOpenCurve;                                     // 0x0790(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DoorCloseCurve;                                    // 0x0798(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DoorKickSuccessCurve;                              // 0x07A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DoorKickFailCurve;                                 // 0x07A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DoorLockedCurve;                                   // 0x07B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DoorRamCurve;                                      // 0x07B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DoorExplodeCurve;                                  // 0x07C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DoorBreachCurve;                                   // 0x07C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DoorHandleOpenCurve;                               // 0x07D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DoorHandlePushCurve;                               // 0x07D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DoorHandleLockedCurve;                             // 0x07E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlacedC2Explosive*                     PlacedC2;                                          // 0x07E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UDestructibleDoorChunkComponent*> ChunkComponents;                                  // 0x07F0(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, EditConst, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         bPendingSubDoorKick : 1;                           // 0x0800(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_801[0x7];                                      // 0x0801(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AReadyOrNotCharacter*                   LastDoorUser;                                      // 0x0808(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDoorDamageType                               LastDoorDamage;                                    // 0x0810(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_811[0x7];                                      // 0x0811(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ATrapActorAttachedToDoor*               AttachedTrap;                                      // 0x0818(0x0008)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADoorJam*                               AttachedWedge;                                     // 0x0820(0x0008)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACyberneticCharacter*                   AICheckingDoor;                                    // 0x0828(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UTeamStackUpActivity*>           CurrentStackUpActivities;                          // 0x0830(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UBaseActivity*>                  CurrentActivities;                                 // 0x0840(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         OpenCloseAmount;                                   // 0x0850(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DoorHandlePitchAmount;                             // 0x0854(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bC2Placed : 1;                                     // 0x0858(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSWATKnowsLockState : 1;                           // 0x0858(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSuspectKnowsLockState : 1;                        // 0x0858(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSWATKnowsTrapState : 1;                           // 0x0858(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSuspectKnowsTrapState : 1;                        // 0x0858(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDoorBroken : 1;                                   // 0x0858(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, Net, DisableEditOnTemplate, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bTrapInFront : 1;                                  // 0x0858(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bClientReset : 1;                                  // 0x0858(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Net, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDoorHandlesBroken : 1;                            // 0x0859(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSWATHasKeycard : 1;                               // 0x0859(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSuspectsHaveKeycard : 1;                          // 0x0859(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAlarmTriggered : 1;                               // 0x0859(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_85A[0x6];                                      // 0x085A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UInteractableComponent*>         CachedInteractables;                               // 0x0860(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_870[0x6C0];                                    // 0x0870(0x06C0)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AReadyOrNotCharacter*>           CharactersOverlappingDoor;                         // 0x0F30(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F40[0x10];                                     // 0x0F40(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDoorData                              DoorData;                                          // 0x0F50(0x02E0)(Edit, Net, DisableEditOnTemplate, EditConst, RepNotify, NativeAccessSpecifierPublic)
	struct FTrapData                              TrapData;                                          // 0x1230(0x0080)(Edit, Net, DisableEditOnTemplate, EditConst, RepNotify, NativeAccessSpecifierPublic)
	float                                         OcclusionMultiplier;                               // 0x12B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12B4[0xC];                                     // 0x12B4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void FlipStackUpArea(EStackupGenArea* OutStackUpArea, bool bHorizontalFlip, bool bVerticalFlip);
	static void SetAllElectronicLocks(class UObject* WorldContextObject, bool bLocked_0);
	static void SetSWATHasAllKeycards(class UObject* WorldContextObject);

	void ActivateDoorBlockerForWorldGen();
	void AIResponseToDoorDamage();
	void ApplyDoorDamage(EDoorDamageType InDoorDamage, class AReadyOrNotCharacter* Victim);
	void ApplyRandomDamageToChunks(float MinDamage, float MaxDamage);
	void AttachTrap(class ATrapActorAttachedToDoor* NewTrap, bool bAttachToDoor);
	void AttachWedge(class ADoorJam* NewWedge);
	void BlockAllDoorways();
	float BodyRamDoor(class AReadyOrNotCharacter* DoorRamCharacter);
	void BreachDoor(class AReadyOrNotCharacter* DoorBreacherCharacter, float InIncrementAngle);
	void BreachDoorFromPoint(class AReadyOrNotCharacter* DoorBreacherCharacter, const struct FVector& BreachPoint, float InIncrementAngle);
	void BreakAndDetachDoor(bool bDestroyAllChunks, class AReadyOrNotCharacter* DoorBreakerCharacter, float Impulse, float ForwardOffset);
	void BreakDoor(bool bDestroyAllChunks, class AReadyOrNotCharacter* DoorBreakerCharacter);
	void BreakDoorHandles();
	void CalculateRoomPositioning();
	void CloseDoor(class AReadyOrNotCharacter* DoorCloserCharacter, bool bInstant, bool bAnimateDoorHandle);
	void CloseDoor_Debug();
	void CloseSubDoor(class AReadyOrNotCharacter* DoorCloseCharacter, bool bInstant, bool bAnimateDoorHandle);
	void CollapseDoor(class AReadyOrNotCharacter* DoorBreacherCharacter, const struct FVector& BreachLocation);
	void DeactivateDoorBlocker();
	void DecreaseNumKicksToBreakDown(class AReadyOrNotCharacter* DoorKickCharacter, bool* bShouldOpenDoor, bool* bCanBreakLock, float KickChanceOffset);
	void DestroyAllChunks(const struct FVector& Impulse, float ImpulseStrength, bool bKeepHinges);
	void DestroyChunk(class UDestructibleDoorChunkComponent* InChunk, const struct FVector& Impulse, float ImpulseStrength);
	void DestroyChunk_Index(int32 ChunkIndex, const struct FVector& Impulse, float ImpulseStrength);
	void DestroyNavLink();
	void DisableAllInteractables();
	void DisableNavLink();
	void EnableNavLink();
	void ExplodeDoor(class AReadyOrNotCharacter* DoorBreacherCharacter, class AActor* ExplosionCauser, bool bKeepHinges);
	void Finished_DoorExplode();
	void Finished_DoorKick_Success();
	void Finished_DoorRam();
	void ForceDoorReset();
	void GenerateClearPoints();
	void GenerateStackUpPoints();
	class FName GetTypeOfDoorRow();
	class FName GetTypeOfDoorTrap();
	bool IsIgnoredForFlee();
	bool IsSubDoorOpen();
	void KickDoor(class AReadyOrNotCharacter* DoorKickCharacter, bool bKickSubDoor, bool bForce);
	void KickSubDoor(class AReadyOrNotCharacter* DoorKickCharacter);
	void LockDoor(bool bLockSubDoor);
	void Multicast_CheckSupports();
	void Multicast_DisableDoorInteraction(bool bSetClosed);
	void Multicast_ExplodeDoor(class AReadyOrNotCharacter* DoorBreacherCharacter, class AActor* ExplosionCauser, bool bKeepHinges);
	void Multicast_PlayDoorDamageSound(EDoorDamageType DoorDamage, const TArray<struct FMODParam>& Params_0);
	void Multicast_PlayDoorKickEffects(bool bBreakLock, bool bInFront);
	void Multicast_PlayDoorSound(EDoorInteraction DoorDamage, class AReadyOrNotCharacter* DoorInteractionInstigator, const TArray<struct FMODParam>& Params_0);
	void Multicast_PlayElectronicDoorSound(class UFMODEvent* Event);
	void Multicast_SetLocked(bool bShouldLocked);
	void OnRep_ClientResetDoor();
	void OnRep_DestroyedChunkIdxChanged();
	void OnRep_DoorDataUpdated();
	void OnRep_DoorHandlesBroken();
	void OnRep_TrapDataUpdated();
	float OpenDoor(class AReadyOrNotCharacter* DoorOpenCharacter, bool bInstant, bool bAnimateDoorHandle, const bool bNoCloseThreshold);
	void OpenDoor_Debug();
	void OpenDoor_SpecificAngle(class AReadyOrNotCharacter* DoorOpenCharacter, float CustomTargetAngle, bool bInstant, bool bAnimateDoorHandle);
	void OpenSubDoor(class AReadyOrNotCharacter* DoorOpenCharacter, bool bInstant, bool bAnimateDoorHandle);
	float PeekDoor(class AReadyOrNotCharacter* DoorPeekerCharacter, float InIncrementAngle, bool bAnimateDoorHandle);
	void PlayDoorDamageSound(EDoorDamageType DoorDamage, const TArray<struct FMODParam>& Params_0);
	void PlayDoorKickSound(class AReadyOrNotCharacter* Kicker, float Result);
	void PlayDoorSound(EDoorInteraction DoorInteraction, class AReadyOrNotCharacter* DoorInteractionInstigator, const TArray<struct FMODParam>& Params_0);
	float PushDoor(class AReadyOrNotCharacter* DoorPusherCharacter, float InIncrementAngle, bool bAnimateDoorHandle, bool bPlaySound);
	void PushDoor_SpecificAngle(class AReadyOrNotCharacter* DoorPusherCharacter, float CustomTargetAngle, bool bAnimateDoorHandle);
	float RamDoor(class AReadyOrNotCharacter* DoorRamCharacter, bool bPlayRamSound);
	void RemoveWedges();
	void ResetDoorLockKnowledge();
	void ResetDoorTrapKnowledge();
	void Restore();
	void Server_SetLockKnowledgeState(bool bSuspectTeam, bool bNewKnowledgeState);
	void Server_SetTrapKnowledgeState(bool bSuspectTeam, bool bNewKnowledgeState);
	void SetDoorLockKnowledge(bool bSuspectTeam, bool bKnowledge);
	void SetDoorTrapKnowledge(bool bSuspectTeam, bool bKnowledge);
	void SetLocked(bool bNewLocked);
	void Setup();
	void Tick_DoorBreach();
	void Tick_DoorExplode();
	void Tick_DoorHandle_Open();
	void Tick_DoorHandle_Push();
	void Tick_DoorHandleLocked();
	void Tick_DoorKick_Fail();
	void Tick_DoorKick_Success();
	void Tick_DoorLocked();
	void Tick_DoorOpenClose();
	void Tick_DoorPush();
	void Tick_DoorRam();
	void ToggleLightBlocker();
	void UnblockAllDoorways();
	void UnlockDoor(bool bUnlockSubDoor);

	bool AllBottomDoorChunksBroken() const;
	bool AllMajorDoorChunksDestroyed() const;
	bool AllMiddleDoorChunksBroken() const;
	bool AllTopDoorChunksBroken() const;
	bool AnyBottomDoorChunksBroken() const;
	bool AnyChunksDestroyed() const;
	bool AnyHingesLeft() const;
	bool AnyMiddleDoorChunksBroken() const;
	bool AnyTopDoorChunksBroken() const;
	struct FVector CalculateClosestPoint(const struct FVector& Location) const;
	bool CanCloseDoor(class AReadyOrNotCharacter* PlayerCharacter) const;
	bool CanCloseDoorIfOrdered(class AReadyOrNotCharacter* PlayerCharacter) const;
	bool CanDeployWedge(class AReadyOrNotCharacter* PlayerCharacter) const;
	bool CanEquipBatteringRam(class AReadyOrNotCharacter* PlayerCharacter) const;
	bool CanEquipBreachingShotgun(class AReadyOrNotCharacter* PlayerCharacter) const;
	bool CanEquipC2Explosive(class AReadyOrNotCharacter* PlayerCharacter) const;
	bool CanEquipMultitool(class AReadyOrNotCharacter* PlayerCharacter) const;
	bool CanEquipOptiwand(class AReadyOrNotCharacter* PlayerCharacter) const;
	bool CanEquipWedge(class AReadyOrNotCharacter* PlayerCharacter) const;
	bool CanKickDoor(class AReadyOrNotCharacter* PlayerCharacter) const;
	bool CanLockpickDoor(class AReadyOrNotCharacter* PlayerCharacter) const;
	bool CanMirrorUnderDoor(class AReadyOrNotCharacter* PlayerCharacter) const;
	bool CanOpenDoor(class AReadyOrNotCharacter* PlayerCharacter) const;
	bool CanPeekDoor(class AReadyOrNotCharacter* PlayerCharacter) const;
	bool CanPlaceC2Explosive(class AReadyOrNotCharacter* PlayerCharacter) const;
	bool CanPullDoor(class AReadyOrNotCharacter* PlayerCharacter) const;
	bool CanPushDoor(class AReadyOrNotCharacter* PlayerCharacter) const;
	bool CanPushDoorWhileBroken() const;
	bool CanRamDoor(class AReadyOrNotCharacter* PlayerCharacter) const;
	bool CanSpawnTrap() const;
	bool CanTakeDamage(float Damage, const struct FDamageEvent& DamageEvent, class AController* EventInstigator, class AActor* DamageCauser) const;
	bool DoesSuspectKnowTrapState() const;
	bool DoesSWATKnowTrapState() const;
	EStackupGenArea FindStackUpAreaFromLocation(const struct FVector& InInteractionLocation) const;
	class ATrapActorAttachedToDoor* GetAttachedTrap() const;
	class ADoorJam* GetAttachedWedge() const;
	class FName GetBackThreatOwningRoom() const;
	struct FVector GetBestDoorInteraction(const struct FVector& Location) const;
	struct FVector GetBestDoorInteraction_FromLocation(const struct FVector& InInteractionLocation, bool bDoorwayBased) const;
	struct FVector GetBestDoorInteraction_FromStackUpArea(const EStackupGenArea& InStackUpArea, bool bDoorwayBased) const;
	struct FVector GetBestOneWayDoorInteraction(const struct FVector& Location) const;
	TMap<EDoorDamageType, float> GetDoorKillDistance() const;
	struct FVector GetDoorMidLocation() const;
	TMap<EDoorDamageType, float> GetDoorStunDistance() const;
	class FName GetFrontThreatOwningRoom() const;
	float GetIncrementAngle() const;
	class AReadyOrNotCharacter* GetLastDoorUser() const;
	float GetMaxOpenAmount() const;
	float GetOpenAmount() const;
	float GetOpenAmountAsPercentage() const;
	float GetOpenThreshold() const;
	float GetOverrideLockChance() const;
	class APlacedC2Explosive* GetPlacedC2() const;
	float GetPseudoVelocity() const;
	struct FVector GetStackUpLocation(EStackupGenArea StackUpArea, ESquadPosition StackUpPosition) const;
	TArray<class AStackUpActor*> GetStackupsForArea(EStackupGenArea StackUpArea) const;
	float GetStartingOpenAngle() const;
	class ADoor* GetSubDoor() const;
	bool GetSuspectKnowsLockState() const;
	bool GetSWATKnowsLockState() const;
	float GetTargetAngle() const;
	struct FVector GetWedgeLocation() const;
	bool HasEverBeenOpened() const;
	bool HasTrapAndSuspectKnowsTrap() const;
	bool HasTrapAndSWATKnowsTrap() const;
	bool IsActorBehindDoor_Relative(class AActor* Actor) const;
	bool IsActorInFrontOfDoor(class AActor* Actor) const;
	bool IsActorInFrontOfDoorway(class AActor* Actor) const;
	bool IsActorRightOfDoorway(class AActor* Actor) const;
	bool IsActorSameSideAsTrap(class AActor* InActor) const;
	bool IsAlwaysLocked() const;
	bool IsAnyAIClosing() const;
	bool IsAnyAIOpening() const;
	bool IsAnyInteractionPlaying() const;
	bool IsAttachedToRoot() const;
	bool IsC2Placed() const;
	bool IsClosed() const;
	bool IsClosing() const;
	bool IsDestructible() const;
	bool IsDoorBroken() const;
	bool IsDoorChunkDestroyed(class UDestructibleDoorChunkComponent* InChunkComponent) const;
	bool IsDoorInteractionPlaying() const;
	bool IsDoorwayOnly() const;
	bool IsElectronicDoor() const;
	bool IsFullyOpen() const;
	bool IsFullyOpen_Backward() const;
	bool IsFullyOpen_Forward() const;
	bool IsHalfwayOpen() const;
	bool IsHandleBroken() const;
	bool IsJammed() const;
	bool IsLocationSameSideAsTrap(const struct FVector& InLocation) const;
	bool IsLockable() const;
	bool IsLockChanceOverridden() const;
	bool IsLocked() const;
	bool IsMainSubdoor() const;
	bool IsMiddleChunkBroken() const;
	bool IsMirrorBlocked() const;
	bool IsNonDoorInteractionPlaying() const;
	bool IsNonMainSubdoor() const;
	bool IsOneWayAndOpensTowardsPoint(const struct FVector& Vector) const;
	bool IsOpen() const;
	bool IsOpen_Backward() const;
	bool IsOpen_Forward() const;
	bool IsOpenAtOrBeyond(float Percentage) const;
	bool IsOpenAtOrBeyond_Angle(float Angle) const;
	bool IsOpenBeyond(float Percentage) const;
	bool IsOpenBeyond_Angle(float Angle) const;
	bool IsOpenBeyondCloseThreshold() const;
	bool IsOpenBeyondIncrementThreshold() const;
	bool IsOpenBy(float Percentage) const;
	bool IsOpenBy_Angle(float Angle) const;
	bool IsOpening() const;
	bool IsOutlineDisabled() const;
	bool IsOutlineEnabled(EActorOutlineType OutlineType) const;
	bool IsOverridingLockChance() const;
	bool IsPendingSubDoorKick() const;
	bool IsPointInFrontOfDoor(const struct FVector& Vector) const;
	bool IsPointRightOfDoorway(const struct FVector& Vector) const;
	bool IsStackUpDisabled(const struct FVector& CommandLocation) const;
	bool IsTooFarForKick() const;
	bool IsTrapLive() const;
	bool MainSubDoor_CanShowOpenDoorPrompt() const;
	bool NonMainSubDoor_CanShowOpenDoorPrompt() const;
	bool SubDoor_CanCloseDoors(class AReadyOrNotCharacter* PlayerCharacter) const;
	bool SubDoor_CanOpenDoors(class AReadyOrNotCharacter* PlayerCharacter) const;
	bool TeamKnowsDoorLockState(bool bSuspectTeam) const;
	bool TeamKnowsDoorTrapState(bool bSuspectTeam) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Door">();
	}
	static class ADoor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADoor>();
	}
};
static_assert(alignof(ADoor) == 0x000010, "Wrong alignment on ADoor");
static_assert(sizeof(ADoor) == 0x0012C0, "Wrong size on ADoor");
static_assert(offsetof(ADoor, OnDoorOpened) == 0x000300, "Member 'ADoor::OnDoorOpened' has a wrong offset!");
static_assert(offsetof(ADoor, OnSubDoorOpened) == 0x000310, "Member 'ADoor::OnSubDoorOpened' has a wrong offset!");
static_assert(offsetof(ADoor, OnDoorClosed) == 0x000320, "Member 'ADoor::OnDoorClosed' has a wrong offset!");
static_assert(offsetof(ADoor, OnDoorBroken) == 0x000330, "Member 'ADoor::OnDoorBroken' has a wrong offset!");
static_assert(offsetof(ADoor, OnDoorMovementBlocked) == 0x000340, "Member 'ADoor::OnDoorMovementBlocked' has a wrong offset!");
static_assert(offsetof(ADoor, OnDoorExploded) == 0x000350, "Member 'ADoor::OnDoorExploded' has a wrong offset!");
static_assert(offsetof(ADoor, OnDoorKicked) == 0x000360, "Member 'ADoor::OnDoorKicked' has a wrong offset!");
static_assert(offsetof(ADoor, TypeOfDoor) == 0x000370, "Member 'ADoor::TypeOfDoor' has a wrong offset!");
static_assert(offsetof(ADoor, StartingOpenAngle) == 0x000380, "Member 'ADoor::StartingOpenAngle' has a wrong offset!");
static_assert(offsetof(ADoor, OneWayDirection) == 0x000385, "Member 'ADoor::OneWayDirection' has a wrong offset!");
static_assert(offsetof(ADoor, bRandomlyOpenAtGameStart) == 0x000386, "Member 'ADoor::bRandomlyOpenAtGameStart' has a wrong offset!");
static_assert(offsetof(ADoor, bSuspectAlwaysUnlocks) == 0x000387, "Member 'ADoor::bSuspectAlwaysUnlocks' has a wrong offset!");
static_assert(offsetof(ADoor, bIgnoreForFlee) == 0x000388, "Member 'ADoor::bIgnoreForFlee' has a wrong offset!");
static_assert(offsetof(ADoor, bNoNavBlockerForGen) == 0x000389, "Member 'ADoor::bNoNavBlockerForGen' has a wrong offset!");
static_assert(offsetof(ADoor, bNoAutomaticClearing) == 0x00038A, "Member 'ADoor::bNoAutomaticClearing' has a wrong offset!");
static_assert(offsetof(ADoor, bCanUseC2) == 0x00038B, "Member 'ADoor::bCanUseC2' has a wrong offset!");
static_assert(offsetof(ADoor, bCanUseBSG) == 0x00038C, "Member 'ADoor::bCanUseBSG' has a wrong offset!");
static_assert(offsetof(ADoor, bCanUseWedge) == 0x00038D, "Member 'ADoor::bCanUseWedge' has a wrong offset!");
static_assert(offsetof(ADoor, bCanUseRam) == 0x00038E, "Member 'ADoor::bCanUseRam' has a wrong offset!");
static_assert(offsetof(ADoor, bCanUseOptiwand) == 0x00038F, "Member 'ADoor::bCanUseOptiwand' has a wrong offset!");
static_assert(offsetof(ADoor, bCanIssueOrdersOnFrontSide) == 0x000391, "Member 'ADoor::bCanIssueOrdersOnFrontSide' has a wrong offset!");
static_assert(offsetof(ADoor, bCanIssueOrdersOnBackSide) == 0x000392, "Member 'ADoor::bCanIssueOrdersOnBackSide' has a wrong offset!");
static_assert(offsetof(ADoor, bHasFrame) == 0x000393, "Member 'ADoor::bHasFrame' has a wrong offset!");
static_assert(offsetof(ADoor, FrontThreat) == 0x000398, "Member 'ADoor::FrontThreat' has a wrong offset!");
static_assert(offsetof(ADoor, BackThreat) == 0x0003A0, "Member 'ADoor::BackThreat' has a wrong offset!");
static_assert(offsetof(ADoor, FrontThreatAwarenessPoints) == 0x0003A8, "Member 'ADoor::FrontThreatAwarenessPoints' has a wrong offset!");
static_assert(offsetof(ADoor, BackThreatAwarenessPoints) == 0x0003B8, "Member 'ADoor::BackThreatAwarenessPoints' has a wrong offset!");
static_assert(offsetof(ADoor, FrontLeftStackUpPoints) == 0x0003C8, "Member 'ADoor::FrontLeftStackUpPoints' has a wrong offset!");
static_assert(offsetof(ADoor, FrontRightStackUpPoints) == 0x0003D8, "Member 'ADoor::FrontRightStackUpPoints' has a wrong offset!");
static_assert(offsetof(ADoor, BackLeftStackUpPoints) == 0x0003E8, "Member 'ADoor::BackLeftStackUpPoints' has a wrong offset!");
static_assert(offsetof(ADoor, BackRightStackUpPoints) == 0x0003F8, "Member 'ADoor::BackRightStackUpPoints' has a wrong offset!");
static_assert(offsetof(ADoor, FrontLeftClearPoints) == 0x000408, "Member 'ADoor::FrontLeftClearPoints' has a wrong offset!");
static_assert(offsetof(ADoor, FrontRightClearPoints) == 0x000418, "Member 'ADoor::FrontRightClearPoints' has a wrong offset!");
static_assert(offsetof(ADoor, BackLeftClearPoints) == 0x000428, "Member 'ADoor::BackLeftClearPoints' has a wrong offset!");
static_assert(offsetof(ADoor, BackRightClearPoints) == 0x000438, "Member 'ADoor::BackRightClearPoints' has a wrong offset!");
static_assert(offsetof(ADoor, DestroyedChunkIdxs) == 0x000450, "Member 'ADoor::DestroyedChunkIdxs' has a wrong offset!");
static_assert(offsetof(ADoor, bHeldPushDoor) == 0x000460, "Member 'ADoor::bHeldPushDoor' has a wrong offset!");
static_assert(offsetof(ADoor, PushDoorHoldTime) == 0x000464, "Member 'ADoor::PushDoorHoldTime' has a wrong offset!");
static_assert(offsetof(ADoor, FrontRoomPosition) == 0x000468, "Member 'ADoor::FrontRoomPosition' has a wrong offset!");
static_assert(offsetof(ADoor, BackRoomPosition) == 0x000469, "Member 'ADoor::BackRoomPosition' has a wrong offset!");
static_assert(offsetof(ADoor, bManualRoomPositionSetup) == 0x00046A, "Member 'ADoor::bManualRoomPositionSetup' has a wrong offset!");
static_assert(offsetof(ADoor, MaxFrontHorizontalClearingDistance) == 0x000474, "Member 'ADoor::MaxFrontHorizontalClearingDistance' has a wrong offset!");
static_assert(offsetof(ADoor, MaxBackHorizontalClearingDistance) == 0x000478, "Member 'ADoor::MaxBackHorizontalClearingDistance' has a wrong offset!");
static_assert(offsetof(ADoor, MaxFrontRightClearThreshold) == 0x000480, "Member 'ADoor::MaxFrontRightClearThreshold' has a wrong offset!");
static_assert(offsetof(ADoor, MaxFrontLeftClearThreshold) == 0x000490, "Member 'ADoor::MaxFrontLeftClearThreshold' has a wrong offset!");
static_assert(offsetof(ADoor, MaxBackRightClearThreshold) == 0x0004A0, "Member 'ADoor::MaxBackRightClearThreshold' has a wrong offset!");
static_assert(offsetof(ADoor, MaxBackLeftClearThreshold) == 0x0004B0, "Member 'ADoor::MaxBackLeftClearThreshold' has a wrong offset!");
static_assert(offsetof(ADoor, MaxFrontRightClearPoints) == 0x0004C0, "Member 'ADoor::MaxFrontRightClearPoints' has a wrong offset!");
static_assert(offsetof(ADoor, MaxFrontLeftClearPoints) == 0x0004C1, "Member 'ADoor::MaxFrontLeftClearPoints' has a wrong offset!");
static_assert(offsetof(ADoor, MaxBackRightClearPoints) == 0x0004C2, "Member 'ADoor::MaxBackRightClearPoints' has a wrong offset!");
static_assert(offsetof(ADoor, MaxBackLeftClearPoints) == 0x0004C3, "Member 'ADoor::MaxBackLeftClearPoints' has a wrong offset!");
static_assert(offsetof(ADoor, bManualClearPointSetup) == 0x0004C4, "Member 'ADoor::bManualClearPointSetup' has a wrong offset!");
static_assert(offsetof(ADoor, KickedParticleSystem) == 0x0004D8, "Member 'ADoor::KickedParticleSystem' has a wrong offset!");
static_assert(offsetof(ADoor, LockBrokenParticleSystem) == 0x0004E0, "Member 'ADoor::LockBrokenParticleSystem' has a wrong offset!");
static_assert(offsetof(ADoor, RootScene) == 0x0004E8, "Member 'ADoor::RootScene' has a wrong offset!");
static_assert(offsetof(ADoor, DoorStatic) == 0x0004F0, "Member 'ADoor::DoorStatic' has a wrong offset!");
static_assert(offsetof(ADoor, DoorHandleFront) == 0x0004F8, "Member 'ADoor::DoorHandleFront' has a wrong offset!");
static_assert(offsetof(ADoor, DoorHandleBack) == 0x000500, "Member 'ADoor::DoorHandleBack' has a wrong offset!");
static_assert(offsetof(ADoor, FrontMirrorPoint) == 0x000508, "Member 'ADoor::FrontMirrorPoint' has a wrong offset!");
static_assert(offsetof(ADoor, BackMirrorPoint) == 0x000510, "Member 'ADoor::BackMirrorPoint' has a wrong offset!");
static_assert(offsetof(ADoor, DoorChunk0) == 0x000518, "Member 'ADoor::DoorChunk0' has a wrong offset!");
static_assert(offsetof(ADoor, DoorChunk1) == 0x000520, "Member 'ADoor::DoorChunk1' has a wrong offset!");
static_assert(offsetof(ADoor, DoorChunk2) == 0x000528, "Member 'ADoor::DoorChunk2' has a wrong offset!");
static_assert(offsetof(ADoor, DoorChunk3) == 0x000530, "Member 'ADoor::DoorChunk3' has a wrong offset!");
static_assert(offsetof(ADoor, DoorChunk4) == 0x000538, "Member 'ADoor::DoorChunk4' has a wrong offset!");
static_assert(offsetof(ADoor, DoorChunk5) == 0x000540, "Member 'ADoor::DoorChunk5' has a wrong offset!");
static_assert(offsetof(ADoor, DoorChunk6) == 0x000548, "Member 'ADoor::DoorChunk6' has a wrong offset!");
static_assert(offsetof(ADoor, DoorChunk7) == 0x000550, "Member 'ADoor::DoorChunk7' has a wrong offset!");
static_assert(offsetof(ADoor, DoorChunk8) == 0x000558, "Member 'ADoor::DoorChunk8' has a wrong offset!");
static_assert(offsetof(ADoor, LightBlocker) == 0x000560, "Member 'ADoor::LightBlocker' has a wrong offset!");
static_assert(offsetof(ADoor, DoorOpenInteractableComp) == 0x000568, "Member 'ADoor::DoorOpenInteractableComp' has a wrong offset!");
static_assert(offsetof(ADoor, DoorSublinkOpenInteractableComp) == 0x000570, "Member 'ADoor::DoorSublinkOpenInteractableComp' has a wrong offset!");
static_assert(offsetof(ADoor, DoorSublinkPushInteractableComp) == 0x000578, "Member 'ADoor::DoorSublinkPushInteractableComp' has a wrong offset!");
static_assert(offsetof(ADoor, DoorPushInteractableComp) == 0x000580, "Member 'ADoor::DoorPushInteractableComp' has a wrong offset!");
static_assert(offsetof(ADoor, DoorKickInteractableComp) == 0x000588, "Member 'ADoor::DoorKickInteractableComp' has a wrong offset!");
static_assert(offsetof(ADoor, DoorSublinkKickInteractableComp) == 0x000590, "Member 'ADoor::DoorSublinkKickInteractableComp' has a wrong offset!");
static_assert(offsetof(ADoor, LockpickInteractableComponent) == 0x000598, "Member 'ADoor::LockpickInteractableComponent' has a wrong offset!");
static_assert(offsetof(ADoor, C2InteractableComponent) == 0x0005A0, "Member 'ADoor::C2InteractableComponent' has a wrong offset!");
static_assert(offsetof(ADoor, WedgeInteractableComponent) == 0x0005A8, "Member 'ADoor::WedgeInteractableComponent' has a wrong offset!");
static_assert(offsetof(ADoor, OptiwandInteractableComponent) == 0x0005B0, "Member 'ADoor::OptiwandInteractableComponent' has a wrong offset!");
static_assert(offsetof(ADoor, BSGInteractableComponent) == 0x0005B8, "Member 'ADoor::BSGInteractableComponent' has a wrong offset!");
static_assert(offsetof(ADoor, BSGInteractableComponent_2) == 0x0005C0, "Member 'ADoor::BSGInteractableComponent_2' has a wrong offset!");
static_assert(offsetof(ADoor, DoorRamInteractableComponent) == 0x0005C8, "Member 'ADoor::DoorRamInteractableComponent' has a wrong offset!");
static_assert(offsetof(ADoor, C2ExplosionDecalComponent) == 0x0005D0, "Member 'ADoor::C2ExplosionDecalComponent' has a wrong offset!");
static_assert(offsetof(ADoor, FMODAudioPropagationComp) == 0x0005D8, "Member 'ADoor::FMODAudioPropagationComp' has a wrong offset!");
static_assert(offsetof(ADoor, LockpickArea) == 0x0005E0, "Member 'ADoor::LockpickArea' has a wrong offset!");
static_assert(offsetof(ADoor, DoorArea) == 0x0005E8, "Member 'ADoor::DoorArea' has a wrong offset!");
static_assert(offsetof(ADoor, C2Area) == 0x0005F0, "Member 'ADoor::C2Area' has a wrong offset!");
static_assert(offsetof(ADoor, BSGArea) == 0x0005F8, "Member 'ADoor::BSGArea' has a wrong offset!");
static_assert(offsetof(ADoor, MirrorgunArea) == 0x000600, "Member 'ADoor::MirrorgunArea' has a wrong offset!");
static_assert(offsetof(ADoor, WedgeArea) == 0x000608, "Member 'ADoor::WedgeArea' has a wrong offset!");
static_assert(offsetof(ADoor, BatteringRamArea) == 0x000610, "Member 'ADoor::BatteringRamArea' has a wrong offset!");
static_assert(offsetof(ADoor, DoorBlockerComponent) == 0x000618, "Member 'ADoor::DoorBlockerComponent' has a wrong offset!");
static_assert(offsetof(ADoor, BreachBlocker1Component) == 0x000620, "Member 'ADoor::BreachBlocker1Component' has a wrong offset!");
static_assert(offsetof(ADoor, BreachBlocker2Component) == 0x000628, "Member 'ADoor::BreachBlocker2Component' has a wrong offset!");
static_assert(offsetof(ADoor, BreachBlocker3Component) == 0x000630, "Member 'ADoor::BreachBlocker3Component' has a wrong offset!");
static_assert(offsetof(ADoor, OperatingStates) == 0x000640, "Member 'ADoor::OperatingStates' has a wrong offset!");
static_assert(offsetof(ADoor, NavLinkProxy) == 0x000650, "Member 'ADoor::NavLinkProxy' has a wrong offset!");
static_assert(offsetof(ADoor, TrapSide) == 0x000689, "Member 'ADoor::TrapSide' has a wrong offset!");
static_assert(offsetof(ADoor, TypeOfTrap) == 0x000690, "Member 'ADoor::TypeOfTrap' has a wrong offset!");
static_assert(offsetof(ADoor, DoorKillDistance) == 0x0006A0, "Member 'ADoor::DoorKillDistance' has a wrong offset!");
static_assert(offsetof(ADoor, DoorStunDistance) == 0x0006F0, "Member 'ADoor::DoorStunDistance' has a wrong offset!");
static_assert(offsetof(ADoor, MaxOpenClose) == 0x000740, "Member 'ADoor::MaxOpenClose' has a wrong offset!");
static_assert(offsetof(ADoor, OpenThreshold) == 0x000744, "Member 'ADoor::OpenThreshold' has a wrong offset!");
static_assert(offsetof(ADoor, CloseThreshold) == 0x000748, "Member 'ADoor::CloseThreshold' has a wrong offset!");
static_assert(offsetof(ADoor, IncrementAngle) == 0x00074C, "Member 'ADoor::IncrementAngle' has a wrong offset!");
static_assert(offsetof(ADoor, PhysicalPushAmount) == 0x000750, "Member 'ADoor::PhysicalPushAmount' has a wrong offset!");
static_assert(offsetof(ADoor, DriveSubDoor) == 0x000758, "Member 'ADoor::DriveSubDoor' has a wrong offset!");
static_assert(offsetof(ADoor, DoorKickSuccessChance) == 0x000764, "Member 'ADoor::DoorKickSuccessChance' has a wrong offset!");
static_assert(offsetof(ADoor, NumSuccessfulKicksToBreakDown) == 0x000768, "Member 'ADoor::NumSuccessfulKicksToBreakDown' has a wrong offset!");
static_assert(offsetof(ADoor, C2ExplosionDecal) == 0x000770, "Member 'ADoor::C2ExplosionDecal' has a wrong offset!");
static_assert(offsetof(ADoor, LockedChance) == 0x00077C, "Member 'ADoor::LockedChance' has a wrong offset!");
static_assert(offsetof(ADoor, bIsElectronicDoor) == 0x000780, "Member 'ADoor::bIsElectronicDoor' has a wrong offset!");
static_assert(offsetof(ADoor, ElectronicLockChance) == 0x000784, "Member 'ADoor::ElectronicLockChance' has a wrong offset!");
static_assert(offsetof(ADoor, DoorPushCurve) == 0x000788, "Member 'ADoor::DoorPushCurve' has a wrong offset!");
static_assert(offsetof(ADoor, DoorOpenCurve) == 0x000790, "Member 'ADoor::DoorOpenCurve' has a wrong offset!");
static_assert(offsetof(ADoor, DoorCloseCurve) == 0x000798, "Member 'ADoor::DoorCloseCurve' has a wrong offset!");
static_assert(offsetof(ADoor, DoorKickSuccessCurve) == 0x0007A0, "Member 'ADoor::DoorKickSuccessCurve' has a wrong offset!");
static_assert(offsetof(ADoor, DoorKickFailCurve) == 0x0007A8, "Member 'ADoor::DoorKickFailCurve' has a wrong offset!");
static_assert(offsetof(ADoor, DoorLockedCurve) == 0x0007B0, "Member 'ADoor::DoorLockedCurve' has a wrong offset!");
static_assert(offsetof(ADoor, DoorRamCurve) == 0x0007B8, "Member 'ADoor::DoorRamCurve' has a wrong offset!");
static_assert(offsetof(ADoor, DoorExplodeCurve) == 0x0007C0, "Member 'ADoor::DoorExplodeCurve' has a wrong offset!");
static_assert(offsetof(ADoor, DoorBreachCurve) == 0x0007C8, "Member 'ADoor::DoorBreachCurve' has a wrong offset!");
static_assert(offsetof(ADoor, DoorHandleOpenCurve) == 0x0007D0, "Member 'ADoor::DoorHandleOpenCurve' has a wrong offset!");
static_assert(offsetof(ADoor, DoorHandlePushCurve) == 0x0007D8, "Member 'ADoor::DoorHandlePushCurve' has a wrong offset!");
static_assert(offsetof(ADoor, DoorHandleLockedCurve) == 0x0007E0, "Member 'ADoor::DoorHandleLockedCurve' has a wrong offset!");
static_assert(offsetof(ADoor, PlacedC2) == 0x0007E8, "Member 'ADoor::PlacedC2' has a wrong offset!");
static_assert(offsetof(ADoor, ChunkComponents) == 0x0007F0, "Member 'ADoor::ChunkComponents' has a wrong offset!");
static_assert(offsetof(ADoor, LastDoorUser) == 0x000808, "Member 'ADoor::LastDoorUser' has a wrong offset!");
static_assert(offsetof(ADoor, LastDoorDamage) == 0x000810, "Member 'ADoor::LastDoorDamage' has a wrong offset!");
static_assert(offsetof(ADoor, AttachedTrap) == 0x000818, "Member 'ADoor::AttachedTrap' has a wrong offset!");
static_assert(offsetof(ADoor, AttachedWedge) == 0x000820, "Member 'ADoor::AttachedWedge' has a wrong offset!");
static_assert(offsetof(ADoor, AICheckingDoor) == 0x000828, "Member 'ADoor::AICheckingDoor' has a wrong offset!");
static_assert(offsetof(ADoor, CurrentStackUpActivities) == 0x000830, "Member 'ADoor::CurrentStackUpActivities' has a wrong offset!");
static_assert(offsetof(ADoor, CurrentActivities) == 0x000840, "Member 'ADoor::CurrentActivities' has a wrong offset!");
static_assert(offsetof(ADoor, OpenCloseAmount) == 0x000850, "Member 'ADoor::OpenCloseAmount' has a wrong offset!");
static_assert(offsetof(ADoor, DoorHandlePitchAmount) == 0x000854, "Member 'ADoor::DoorHandlePitchAmount' has a wrong offset!");
static_assert(offsetof(ADoor, CachedInteractables) == 0x000860, "Member 'ADoor::CachedInteractables' has a wrong offset!");
static_assert(offsetof(ADoor, CharactersOverlappingDoor) == 0x000F30, "Member 'ADoor::CharactersOverlappingDoor' has a wrong offset!");
static_assert(offsetof(ADoor, DoorData) == 0x000F50, "Member 'ADoor::DoorData' has a wrong offset!");
static_assert(offsetof(ADoor, TrapData) == 0x001230, "Member 'ADoor::TrapData' has a wrong offset!");
static_assert(offsetof(ADoor, OcclusionMultiplier) == 0x0012B0, "Member 'ADoor::OcclusionMultiplier' has a wrong offset!");

// Class ReadyOrNot.VIPTriggerBox
// 0x0000 (0x0308 - 0x0308)
class AVIPTriggerBox final : public APVPTriggerBox
{
public:
	bool IsVIPInTriggerBox(class APlayerCharacter** OutVIPCharacter) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VIPTriggerBox">();
	}
	static class AVIPTriggerBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVIPTriggerBox>();
	}
};
static_assert(alignof(AVIPTriggerBox) == 0x000008, "Wrong alignment on AVIPTriggerBox");
static_assert(sizeof(AVIPTriggerBox) == 0x000308, "Wrong size on AVIPTriggerBox");

// Class ReadyOrNot.InteractionActor
// 0x0058 (0x02F0 - 0x0298)
class AInteractionActor : public AActor
{
public:
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        SceneRoot;                                         // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USphereComponent*                       UseIconRadius;                                     // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   Mesh_Static;                                       // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 Mesh_Skeletal;                                     // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanUseNow;                                        // 0x02C0(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAvailableForUse;                                  // 0x02C1(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCompleteIcon;                                     // 0x02C2(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bButtonPushAnimation;                              // 0x02C3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHoldButtonPrompt;                                 // 0x02C4(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideButtonPrompt;                             // 0x02C5(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C6[0x2];                                      // 0x02C6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   OverrideButtonPromptText;                          // 0x02C8(0x0018)(Edit, BlueprintVisible, Net, NativeAccessSpecifierPublic)
	TArray<class USceneComponent*>                CachedUseComponents;                               // 0x02E0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	bool CanBeUsedNow(class AActor* PotentialUser);
	void OnActorUsed(class AActor* User);
	void OnActorUsedEnd(class AActor* User);
	void Server_EndUse(class AActor* User);
	void Server_TryUse(class AActor* User);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionActor">();
	}
	static class AInteractionActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AInteractionActor>();
	}
};
static_assert(alignof(AInteractionActor) == 0x000008, "Wrong alignment on AInteractionActor");
static_assert(sizeof(AInteractionActor) == 0x0002F0, "Wrong size on AInteractionActor");
static_assert(offsetof(AInteractionActor, SceneRoot) == 0x0002A0, "Member 'AInteractionActor::SceneRoot' has a wrong offset!");
static_assert(offsetof(AInteractionActor, UseIconRadius) == 0x0002A8, "Member 'AInteractionActor::UseIconRadius' has a wrong offset!");
static_assert(offsetof(AInteractionActor, Mesh_Static) == 0x0002B0, "Member 'AInteractionActor::Mesh_Static' has a wrong offset!");
static_assert(offsetof(AInteractionActor, Mesh_Skeletal) == 0x0002B8, "Member 'AInteractionActor::Mesh_Skeletal' has a wrong offset!");
static_assert(offsetof(AInteractionActor, bCanUseNow) == 0x0002C0, "Member 'AInteractionActor::bCanUseNow' has a wrong offset!");
static_assert(offsetof(AInteractionActor, bAvailableForUse) == 0x0002C1, "Member 'AInteractionActor::bAvailableForUse' has a wrong offset!");
static_assert(offsetof(AInteractionActor, bCompleteIcon) == 0x0002C2, "Member 'AInteractionActor::bCompleteIcon' has a wrong offset!");
static_assert(offsetof(AInteractionActor, bButtonPushAnimation) == 0x0002C3, "Member 'AInteractionActor::bButtonPushAnimation' has a wrong offset!");
static_assert(offsetof(AInteractionActor, bHoldButtonPrompt) == 0x0002C4, "Member 'AInteractionActor::bHoldButtonPrompt' has a wrong offset!");
static_assert(offsetof(AInteractionActor, bOverrideButtonPrompt) == 0x0002C5, "Member 'AInteractionActor::bOverrideButtonPrompt' has a wrong offset!");
static_assert(offsetof(AInteractionActor, OverrideButtonPromptText) == 0x0002C8, "Member 'AInteractionActor::OverrideButtonPromptText' has a wrong offset!");
static_assert(offsetof(AInteractionActor, CachedUseComponents) == 0x0002E0, "Member 'AInteractionActor::CachedUseComponents' has a wrong offset!");

// Class ReadyOrNot.KickDoorActivity
// 0x0008 (0x0280 - 0x0278)
class UKickDoorActivity final : public UDoorBreachActivity
{
public:
	uint8                                         Pad_278[0x8];                                      // 0x0278(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDoorKicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KickDoorActivity">();
	}
	static class UKickDoorActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKickDoorActivity>();
	}
};
static_assert(alignof(UKickDoorActivity) == 0x000008, "Wrong alignment on UKickDoorActivity");
static_assert(sizeof(UKickDoorActivity) == 0x000280, "Wrong size on UKickDoorActivity");

// Class ReadyOrNot.C2DoorActivity
// 0x0010 (0x0288 - 0x0278)
class UC2DoorActivity final : public UDoorBreachActivity
{
public:
	uint8                                         Pad_278[0x10];                                     // 0x0278(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnterDetonateC2Stage();
	void OnC2Detonate();
	void OnC2Placed();
	void PerformDetonateC2Stage(float DeltaTime, float Uptime);

	bool CanDetonateC2() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"C2DoorActivity">();
	}
	static class UC2DoorActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UC2DoorActivity>();
	}
};
static_assert(alignof(UC2DoorActivity) == 0x000008, "Wrong alignment on UC2DoorActivity");
static_assert(sizeof(UC2DoorActivity) == 0x000288, "Wrong size on UC2DoorActivity");

// Class ReadyOrNot.IncriminationGM
// 0x0020 (0x09F0 - 0x09D0)
class AIncriminationGM final : public AReadyOrNotGameMode_PVP
{
public:
	uint8                                         MaxCluesToFind;                                    // 0x09D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9D1[0x7];                                      // 0x09D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ASpawnGenerator*                        ChosenSpawnGroup_BlueTeam;                         // 0x09D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ASpawnGenerator*                        ChosenSpawnGroup_RedTeam;                          // 0x09E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9E8[0x8];                                      // 0x09E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnClueFound(class AIncriminationClue* ClueActor, class AActor* ClueFounder);
	void OnEvidenceDropped(class AActor* DropActor);
	void OnEvidencePickedUp(class AActor* PickupActor);

	bool HasVisitedAllEvidenceSpawns() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IncriminationGM">();
	}
	static class AIncriminationGM* GetDefaultObj()
	{
		return GetDefaultObjImpl<AIncriminationGM>();
	}
};
static_assert(alignof(AIncriminationGM) == 0x000010, "Wrong alignment on AIncriminationGM");
static_assert(sizeof(AIncriminationGM) == 0x0009F0, "Wrong size on AIncriminationGM");
static_assert(offsetof(AIncriminationGM, MaxCluesToFind) == 0x0009D0, "Member 'AIncriminationGM::MaxCluesToFind' has a wrong offset!");
static_assert(offsetof(AIncriminationGM, ChosenSpawnGroup_BlueTeam) == 0x0009D8, "Member 'AIncriminationGM::ChosenSpawnGroup_BlueTeam' has a wrong offset!");
static_assert(offsetof(AIncriminationGM, ChosenSpawnGroup_RedTeam) == 0x0009E0, "Member 'AIncriminationGM::ChosenSpawnGroup_RedTeam' has a wrong offset!");

// Class ReadyOrNot.ShotgunDoorActivity
// 0x0008 (0x0280 - 0x0278)
class UShotgunDoorActivity final : public UDoorBreachActivity
{
public:
	uint8                                         Pad_278[0x8];                                      // 0x0278(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDoorKicked();
	void OnDoorShotgunned();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShotgunDoorActivity">();
	}
	static class UShotgunDoorActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShotgunDoorActivity>();
	}
};
static_assert(alignof(UShotgunDoorActivity) == 0x000008, "Wrong alignment on UShotgunDoorActivity");
static_assert(sizeof(UShotgunDoorActivity) == 0x000280, "Wrong size on UShotgunDoorActivity");

// Class ReadyOrNot.RoNAnimInstance_PlayerTP_V2
// 0x0970 (0x0F10 - 0x05A0)
class URoNAnimInstance_PlayerTP_V2 : public UReadyOrNotAnimInstance
{
public:
	class UReadyOrNotWeaponAnimData*              LastAnimWeaponData;                                // 0x0598(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReadyOrNotWeaponAnimData*              EditorWeaponAnimData;                              // 0x05A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowTurnInPlace;                                 // 0x05A8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A9[0x3];                                      // 0x05A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         YawOffsetLimit;                                    // 0x05AC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnInPlaceSpeedMultiplier;                        // 0x05B0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5B4[0x4];                                      // 0x05B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnimTurnInPlaceAnimSet                TurnInPlaceAnimSet;                                // 0x05B8(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FAnimTurnInPlaceState                  TurnInPlaceState;                                  // 0x05D0(0x0060)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FAnimTurnInPlaceAnimSet                StandRifAnimSet;                                   // 0x0630(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FAnimTurnInPlaceAnimSet                CrouchRifAnimSet;                                  // 0x0648(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bIsAIControlled;                                   // 0x0660(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWeaponDown;                                       // 0x0661(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAiming;                                         // 0x0662(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsShieldEquipped;                                 // 0x0663(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimingAlpha;                                       // 0x0664(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLeanLeft;                                         // 0x0668(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLeanRight;                                        // 0x0669(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_66A[0x2];                                      // 0x066A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         QuickLeanLeftAmount;                               // 0x066C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         QuickLeanRightAmount;                              // 0x0670(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         QuickLeanLeftAlpha;                                // 0x0674(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         QuickLeanRightAlpha;                               // 0x0678(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         QuickLeanIntensity;                                // 0x067C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         QuickLeanInterpSpeed;                              // 0x0680(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootIKValue;                                       // 0x0684(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootIKAlpha;                                       // 0x0688(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRagdoll;                                          // 0x068C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPlayingDeathAnim;                               // 0x068D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bArrested;                                         // 0x068E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDead;                                           // 0x068F(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDeathAnimEnd;                                     // 0x0690(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStunned;                                          // 0x0691(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTased;                                            // 0x0692(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnLadder;                                         // 0x0693(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LadderUpDownMovement;                              // 0x0694(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeanAngleY;                                        // 0x0698(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeanAngleZ;                                        // 0x069C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCoverLeft;                                        // 0x06A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCoverRight;                                       // 0x06A1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCoverMiddle;                                      // 0x06A2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCoverLeftLow;                                     // 0x06A3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCoverRightLow;                                    // 0x06A4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCoverPeek;                                        // 0x06A5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6A6[0x2];                                      // 0x06A6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AimOffsetAlpha;                                    // 0x06A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6AC[0x4];                                      // 0x06AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              AimOffsets;                                        // 0x06B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bJumpStartTrigger;                                 // 0x06C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C1[0x3];                                      // 0x06C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SmoothMappedLeanToAnimStandLeft;                   // 0x06C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SmoothMappedLeanToAnimStandRight;                  // 0x06C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SmoothMappedLeanToAnimCrouchLeft;                  // 0x06CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SmoothMappedLeanToAnimCrouchRight;                 // 0x06D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed_tp_rifle_stand_sprint_f;                     // 0x06D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Crouch_Idle_Pose_Low_TP;                           // 0x06D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Crouch_Idle_Pose_Up_TP;                            // 0x06E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Crouch_Idle_Pose_Shld_TP;                          // 0x06E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Crouch_Idle_Pose_Sights_TP;                        // 0x06F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Crouch_Idle_Pose_Ret_TP;                           // 0x06F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Crouch_Idle_Pose_Ovr_TP;                           // 0x0700(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Idle_Pose_Low_TP;                                  // 0x0708(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Idle_Pose_Up_TP;                                   // 0x0710(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Idle_Pose_Shld_TP;                                 // 0x0718(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Idle_Pose_Sights_TP;                               // 0x0720(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Idle_Pose_Ret_TP;                                  // 0x0728(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Idle_Pose_Ovr_TP;                                  // 0x0730(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Idle_Pose_VFG_TP;                                  // 0x0738(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Idle_Pose_AFG_TP;                                  // 0x0740(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Idle_Pose_HSTOP_TP;                                // 0x0748(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Idle_Pose_RK1_TP;                                  // 0x0750(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Idle_Pose_CQR_TP;                                  // 0x0758(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLeaningLeftNotCrouching;                          // 0x0760(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNotLeaningLeftOrCrouching;                        // 0x0761(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNotLeaningLeftOrNotCrouching;                     // 0x0762(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLeaningRightNotCrouching;                         // 0x0763(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNotLeaningRightOrCrouching;                       // 0x0764(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNotLeaningRightOrNotCrouching;                    // 0x0765(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCrouchingAndMoving;                               // 0x0766(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNotCrouchingAndMoving;                            // 0x0767(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAimingAndNotDeployable;                           // 0x0768(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_769[0x3];                                      // 0x0769(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WalkSpeedForward;                                  // 0x076C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkSpeedLeft;                                     // 0x0770(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkSpeedRight;                                    // 0x0774(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkSpeedBackward;                                 // 0x0778(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrouchWalkSpeedForward;                            // 0x077C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrouchWalkSpeedLeft;                               // 0x0780(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrouchWalkSpeedRight;                              // 0x0784(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrouchWalkSpeedBackward;                           // 0x0788(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RunSpeedForward;                                   // 0x078C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RunSpeedLeft;                                      // 0x0790(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RunSpeedRight;                                     // 0x0794(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RunSpeedBackward;                                  // 0x0798(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLessThanPointOneSecondOnRelevantAnim;             // 0x079C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInCombatOrAlerted;                              // 0x079D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMoving;                                           // 0x079E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAlerted;                                        // 0x079F(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AlertAlpha;                                        // 0x07A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInCombat;                                       // 0x07A4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSurrendering;                                   // 0x07A5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSprayed;                                          // 0x07A6(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStung;                                            // 0x07A7(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPseudoSpeedType                              CurPseudoSpeed;                                    // 0x07A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFemale;                                           // 0x07A9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChild;                                            // 0x07AA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasInjury;                                        // 0x07AB(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimSpeedFwdPlayrateSync;                          // 0x07AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimSpeedSidePlayrateSync;                         // 0x07B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimSpeedPlayrateSync;                             // 0x07B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RetentionAlpha;                                    // 0x07B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoweredAlpha;                                      // 0x07BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C0[0x8];                                      // 0x07C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SightAlpha;                                        // 0x07C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoweredCooldownTime;                               // 0x07CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLoweredUp;                                       // 0x07D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D1[0x13];                                     // 0x07D1(0x0013)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ArmsOnlySlotAlpha;                                 // 0x07E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftArmOnlySlotAlpha;                              // 0x07E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VelocityInterpTime;                                // 0x07EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VelocitySmoothed;                                  // 0x07F0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAnimCharacterMovementSnapshot         CharMovementSnapshot;                              // 0x0808(0x00F8)(Edit, BlueprintVisible, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	float                                         PostPivotTriggerThreshold;                         // 0x0900(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCardinalDirectionSnapshot             PivotingCardinalDirSnapShot;                       // 0x0904(0x0018)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_91C[0x1C];                                     // 0x091C(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	class AReadyOrNotCharacter*                   BaseCharacterRef;                                  // 0x0938(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerCharacter*                       CharacterRef;                                      // 0x0940(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACyberneticCharacter*                   CharacterAiRef;                                    // 0x0948(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseDistanceMatching;                              // 0x0950(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDistanceMatchingType                         DistanceMatchingCurrentState;                      // 0x0951(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_952[0x6];                                      // 0x0952(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPredictionResult                      StartMarker;                                       // 0x0958(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FPredictionResult                      StopMarker;                                        // 0x0988(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FPredictionResult                      PivotMarker;                                       // 0x09B8(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FPredictionResult                      PostPivotMarker;                                   // 0x09E8(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FPredictionResult                      TakeOffMarker;                                     // 0x0A18(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FPredictionResult                      ApexMarker;                                        // 0x0A48(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FPredictionResult                      LandingMarker;                                     // 0x0A78(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	EMoveDirectionExt                             CurrentPivotDirectionExt;                          // 0x0AA8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPivotDirectionBroken;                             // 0x0AA9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanPivotInCurDirection;                           // 0x0AAA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSMPrePivotRuleset;                                // 0x0AAB(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStartDirectionBroken;                             // 0x0AAC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AAD[0x3];                                      // 0x0AAD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReplicatedMaxSpeed;                                // 0x0AB0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSMStartRuleset;                                   // 0x0AB4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSMStopRuleset;                                    // 0x0AB5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDistanceMatchToTarget;                            // 0x0AB6(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AB7[0x1];                                      // 0x0AB7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DistanceCurveName;                                 // 0x0AB8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PelvisDefaultWorldPos;                             // 0x0AC0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CrouchedPelvisDefaultWorldPos;                     // 0x0AD8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CrouchedPelvisMovingWorldPos;                      // 0x0AF0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CrouchedPelvisCurrentWorldPos;                     // 0x0B08(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCachedAnimStateData                   IdleStateData;                                     // 0x0B20(0x001C)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FCachedAnimStateData                   StartStateData;                                    // 0x0B3C(0x001C)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FCachedAnimStateData                   MoveStateData;                                     // 0x0B58(0x001C)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FCachedAnimStateData                   StopStateData;                                     // 0x0B74(0x001C)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FCachedAnimStateData                   PrePivotStateData;                                 // 0x0B90(0x001C)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FCachedAnimStateData                   PostPivotStateData;                                // 0x0BAC(0x001C)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FCachedAnimStateData                   TurnInPlaceStateData;                              // 0x0BC8(0x001C)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FCachedAnimStateData                   LocalTurnInPlaceStateData;                         // 0x0BE4(0x001C)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_C00[0x92];                                     // 0x0C00(0x0092)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bStartToCycleRuleSet;                              // 0x0C92(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTriggerPivotARuleSet;                             // 0x0C93(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTriggerPivotBRuleSet;                             // 0x0C94(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPrePivotToPostPivotRuleSet;                       // 0x0C95(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPostPivotToPrePivotRuleSet;                       // 0x0C96(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPivotToCycleRuleSet;                              // 0x0C97(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopToIdleRuleSet;                                // 0x0C98(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanEnterPrePivotRuleSet;                          // 0x0C99(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9A[0x6];                                      // 0x0C9A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAnimSequence*>                  StandFastStartAnimations;                          // 0x0CA0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UAnimSequence*>                  StandFastStopAnimations;                           // 0x0CB0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UAnimSequence*>                  StandFastPivotAnimations;                          // 0x0CC0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UAnimSequence*>                  StandSlowStartAnimations;                          // 0x0CD0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UAnimSequence*>                  StandSlowStopAnimations;                           // 0x0CE0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UAnimSequence*>                  StandSlowPivotAnimations;                          // 0x0CF0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UAnimSequence*>                  CrouchFastStartAnimations;                         // 0x0D00(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UAnimSequence*>                  CrouchFastStopAnimations;                          // 0x0D10(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UAnimSequence*>                  CrouchFastPivotAnimations;                         // 0x0D20(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UAnimSequence*>                  CrouchSlowStartAnimations;                         // 0x0D30(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UAnimSequence*>                  CrouchSlowStopAnimations;                          // 0x0D40(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UAnimSequence*>                  CrouchSlowPivotAnimations;                         // 0x0D50(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ActiveStopAnim;                                    // 0x0D60(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActiveStopAnimTime;                                // 0x0D68(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D6C[0x4];                                      // 0x0D6C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          ActiveStartAnim;                                   // 0x0D70(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActiveStartAnimTime;                               // 0x0D78(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D7C[0x4];                                      // 0x0D7C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          ActivePrePivotAnim;                                // 0x0D80(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActivePrePivotAnimTime;                            // 0x0D88(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D8C[0x4];                                      // 0x0D8C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          ActivePostPivotAnim;                               // 0x0D90(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActivePostPivotAnimTime;                           // 0x0D98(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsIdleStateRelevant;                              // 0x0D9C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsStartStateRelevant;                             // 0x0D9D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsStopStateRelevant;                              // 0x0D9E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPrePivotStateRelevant;                          // 0x0D9F(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPostPivotStateRelevant;                         // 0x0DA0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMoveStateRelevant;                              // 0x0DA1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTurnInPlaceStateRelevant;                       // 0x0DA2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsStartStateFullWeight;                           // 0x0DA3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPrePivotStateFullWeight;                        // 0x0DA4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPostPivotStateFullWeight;                       // 0x0DA5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DA6[0x2];                                      // 0x0DA6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeInStartState;                                  // 0x0DA8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeInPostPivotState;                              // 0x0DAC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReadDisableSpeedCurve;                            // 0x0DB0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DB1[0x3];                                      // 0x0DB1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DisableSpeedWarping;                               // 0x0DB4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedScaling;                                      // 0x0DB8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayrateClampMax;                                  // 0x0DBC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              PlayRateClamp;                                     // 0x0DC0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              PlayRateClampCycle;                                // 0x0DD0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              PlayRateClampStartsPivots;                         // 0x0DE0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StrideWarpingBlendInStartOffset;                   // 0x0DF0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StrideWarpingBlendInDurationScaled;                // 0x0DF4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StrideWarpingStartAlpha;                           // 0x0DF8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StrideWarpingPivotAlpha;                           // 0x0DFC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DirectionBlendTime;                                // 0x0E00(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E04[0x4];                                      // 0x0E04(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPoseSnapshot                          DeathPose;                                         // 0x0E08(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	float                                         SlopeWarpingAlpha;                                 // 0x0E40(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsItemOrPistolMotionBlock;                        // 0x0E44(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRifleMotionBlock;                               // 0x0E45(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCrouchingWithShield;                            // 0x0E46(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E47[0x1];                                      // 0x0E47(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CrouchHighPoseAdditiveAlpha;                       // 0x0E48(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StandHighPoseAdditiveAlpha;                        // 0x0E4C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftHandIKAlpha_ItemBased;                         // 0x0E50(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E54[0x4];                                      // 0x0E54(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ZHeightLeanAdjustment;                             // 0x0E58(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IsCrouchingWithShield_AsFloat;                     // 0x0E70(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HandAdditiveLockOverride;                          // 0x0E74(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftHandAdditiveOvrBlend;                          // 0x0E78(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftHandTempFinIK;                                 // 0x0E7C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFastWalkSwitchRule;                               // 0x0E80(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCrouchFastWalkSwitchRule;                         // 0x0E81(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStartWalkSwitchTransitionRule;                    // 0x0E82(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E83[0x1];                                      // 0x0E83(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DefaultCrouchSpeed;                                // 0x0E84(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultStandSpeed;                                 // 0x0E88(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopWalkSwitchTransitionRule;                     // 0x0E8C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPivotWalkSwitchTransitionRule;                    // 0x0E8D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasUnderbarrelAttachment;                         // 0x0E8E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeaponUnderbarrelAnimationType               UnderbarrelType;                                   // 0x0E8F(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftHandGripAlpha;                                 // 0x0E90(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpperbodySlotNoWeight;                             // 0x0E94(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFastWalking;                                    // 0x0E98(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFastStop;                                       // 0x0E99(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFastStart;                                      // 0x0E9A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFastPivot;                                      // 0x0E9B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLocallyFirstPerson;                             // 0x0E9C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPFStartPhase;                                     // 0x0E9D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPFStoppingPhase;                                  // 0x0E9E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPFHasReachedStoppingPhase;                        // 0x0E9F(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PFStartDistanceThreshold;                          // 0x0EA0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PFStopDistanceThreshold;                           // 0x0EA4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PFLastStopLocation;                                // 0x0EA8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PFCurrentStopLocation;                             // 0x0EC0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PFStopDistance;                                    // 0x0ED8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PFCurrentAcceptanceRadius;                         // 0x0EDC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPFPathTooShort;                                   // 0x0EE0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPFPathIsValid;                                    // 0x0EE1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPFRequestedNewPath;                               // 0x0EE2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EE3[0x15];                                     // 0x0EE3(0x0015)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               HeadLookRotationSwapped;                           // 0x0EF8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

public:
	class UAnimSequenceBase* GetPlayerAnimation_TP(EBaseAnimType_TP AnimName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RoNAnimInstance_PlayerTP_V2">();
	}
	static class URoNAnimInstance_PlayerTP_V2* GetDefaultObj()
	{
		return GetDefaultObjImpl<URoNAnimInstance_PlayerTP_V2>();
	}
};
static_assert(alignof(URoNAnimInstance_PlayerTP_V2) == 0x000010, "Wrong alignment on URoNAnimInstance_PlayerTP_V2");
static_assert(sizeof(URoNAnimInstance_PlayerTP_V2) == 0x000F10, "Wrong size on URoNAnimInstance_PlayerTP_V2");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, LastAnimWeaponData) == 0x000598, "Member 'URoNAnimInstance_PlayerTP_V2::LastAnimWeaponData' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, EditorWeaponAnimData) == 0x0005A0, "Member 'URoNAnimInstance_PlayerTP_V2::EditorWeaponAnimData' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bAllowTurnInPlace) == 0x0005A8, "Member 'URoNAnimInstance_PlayerTP_V2::bAllowTurnInPlace' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, YawOffsetLimit) == 0x0005AC, "Member 'URoNAnimInstance_PlayerTP_V2::YawOffsetLimit' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, TurnInPlaceSpeedMultiplier) == 0x0005B0, "Member 'URoNAnimInstance_PlayerTP_V2::TurnInPlaceSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, TurnInPlaceAnimSet) == 0x0005B8, "Member 'URoNAnimInstance_PlayerTP_V2::TurnInPlaceAnimSet' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, TurnInPlaceState) == 0x0005D0, "Member 'URoNAnimInstance_PlayerTP_V2::TurnInPlaceState' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, StandRifAnimSet) == 0x000630, "Member 'URoNAnimInstance_PlayerTP_V2::StandRifAnimSet' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, CrouchRifAnimSet) == 0x000648, "Member 'URoNAnimInstance_PlayerTP_V2::CrouchRifAnimSet' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bIsAIControlled) == 0x000660, "Member 'URoNAnimInstance_PlayerTP_V2::bIsAIControlled' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bWeaponDown) == 0x000661, "Member 'URoNAnimInstance_PlayerTP_V2::bWeaponDown' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bIsAiming) == 0x000662, "Member 'URoNAnimInstance_PlayerTP_V2::bIsAiming' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bIsShieldEquipped) == 0x000663, "Member 'URoNAnimInstance_PlayerTP_V2::bIsShieldEquipped' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, AimingAlpha) == 0x000664, "Member 'URoNAnimInstance_PlayerTP_V2::AimingAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bLeanLeft) == 0x000668, "Member 'URoNAnimInstance_PlayerTP_V2::bLeanLeft' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bLeanRight) == 0x000669, "Member 'URoNAnimInstance_PlayerTP_V2::bLeanRight' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, QuickLeanLeftAmount) == 0x00066C, "Member 'URoNAnimInstance_PlayerTP_V2::QuickLeanLeftAmount' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, QuickLeanRightAmount) == 0x000670, "Member 'URoNAnimInstance_PlayerTP_V2::QuickLeanRightAmount' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, QuickLeanLeftAlpha) == 0x000674, "Member 'URoNAnimInstance_PlayerTP_V2::QuickLeanLeftAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, QuickLeanRightAlpha) == 0x000678, "Member 'URoNAnimInstance_PlayerTP_V2::QuickLeanRightAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, QuickLeanIntensity) == 0x00067C, "Member 'URoNAnimInstance_PlayerTP_V2::QuickLeanIntensity' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, QuickLeanInterpSpeed) == 0x000680, "Member 'URoNAnimInstance_PlayerTP_V2::QuickLeanInterpSpeed' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, FootIKValue) == 0x000684, "Member 'URoNAnimInstance_PlayerTP_V2::FootIKValue' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, FootIKAlpha) == 0x000688, "Member 'URoNAnimInstance_PlayerTP_V2::FootIKAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bRagdoll) == 0x00068C, "Member 'URoNAnimInstance_PlayerTP_V2::bRagdoll' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bIsPlayingDeathAnim) == 0x00068D, "Member 'URoNAnimInstance_PlayerTP_V2::bIsPlayingDeathAnim' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bArrested) == 0x00068E, "Member 'URoNAnimInstance_PlayerTP_V2::bArrested' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bIsDead) == 0x00068F, "Member 'URoNAnimInstance_PlayerTP_V2::bIsDead' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bDeathAnimEnd) == 0x000690, "Member 'URoNAnimInstance_PlayerTP_V2::bDeathAnimEnd' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bStunned) == 0x000691, "Member 'URoNAnimInstance_PlayerTP_V2::bStunned' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bTased) == 0x000692, "Member 'URoNAnimInstance_PlayerTP_V2::bTased' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bOnLadder) == 0x000693, "Member 'URoNAnimInstance_PlayerTP_V2::bOnLadder' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, LadderUpDownMovement) == 0x000694, "Member 'URoNAnimInstance_PlayerTP_V2::LadderUpDownMovement' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, LeanAngleY) == 0x000698, "Member 'URoNAnimInstance_PlayerTP_V2::LeanAngleY' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, LeanAngleZ) == 0x00069C, "Member 'URoNAnimInstance_PlayerTP_V2::LeanAngleZ' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bCoverLeft) == 0x0006A0, "Member 'URoNAnimInstance_PlayerTP_V2::bCoverLeft' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bCoverRight) == 0x0006A1, "Member 'URoNAnimInstance_PlayerTP_V2::bCoverRight' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bCoverMiddle) == 0x0006A2, "Member 'URoNAnimInstance_PlayerTP_V2::bCoverMiddle' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bCoverLeftLow) == 0x0006A3, "Member 'URoNAnimInstance_PlayerTP_V2::bCoverLeftLow' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bCoverRightLow) == 0x0006A4, "Member 'URoNAnimInstance_PlayerTP_V2::bCoverRightLow' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bCoverPeek) == 0x0006A5, "Member 'URoNAnimInstance_PlayerTP_V2::bCoverPeek' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, AimOffsetAlpha) == 0x0006A8, "Member 'URoNAnimInstance_PlayerTP_V2::AimOffsetAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, AimOffsets) == 0x0006B0, "Member 'URoNAnimInstance_PlayerTP_V2::AimOffsets' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bJumpStartTrigger) == 0x0006C0, "Member 'URoNAnimInstance_PlayerTP_V2::bJumpStartTrigger' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, SmoothMappedLeanToAnimStandLeft) == 0x0006C4, "Member 'URoNAnimInstance_PlayerTP_V2::SmoothMappedLeanToAnimStandLeft' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, SmoothMappedLeanToAnimStandRight) == 0x0006C8, "Member 'URoNAnimInstance_PlayerTP_V2::SmoothMappedLeanToAnimStandRight' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, SmoothMappedLeanToAnimCrouchLeft) == 0x0006CC, "Member 'URoNAnimInstance_PlayerTP_V2::SmoothMappedLeanToAnimCrouchLeft' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, SmoothMappedLeanToAnimCrouchRight) == 0x0006D0, "Member 'URoNAnimInstance_PlayerTP_V2::SmoothMappedLeanToAnimCrouchRight' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, Speed_tp_rifle_stand_sprint_f) == 0x0006D4, "Member 'URoNAnimInstance_PlayerTP_V2::Speed_tp_rifle_stand_sprint_f' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, Crouch_Idle_Pose_Low_TP) == 0x0006D8, "Member 'URoNAnimInstance_PlayerTP_V2::Crouch_Idle_Pose_Low_TP' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, Crouch_Idle_Pose_Up_TP) == 0x0006E0, "Member 'URoNAnimInstance_PlayerTP_V2::Crouch_Idle_Pose_Up_TP' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, Crouch_Idle_Pose_Shld_TP) == 0x0006E8, "Member 'URoNAnimInstance_PlayerTP_V2::Crouch_Idle_Pose_Shld_TP' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, Crouch_Idle_Pose_Sights_TP) == 0x0006F0, "Member 'URoNAnimInstance_PlayerTP_V2::Crouch_Idle_Pose_Sights_TP' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, Crouch_Idle_Pose_Ret_TP) == 0x0006F8, "Member 'URoNAnimInstance_PlayerTP_V2::Crouch_Idle_Pose_Ret_TP' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, Crouch_Idle_Pose_Ovr_TP) == 0x000700, "Member 'URoNAnimInstance_PlayerTP_V2::Crouch_Idle_Pose_Ovr_TP' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, Idle_Pose_Low_TP) == 0x000708, "Member 'URoNAnimInstance_PlayerTP_V2::Idle_Pose_Low_TP' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, Idle_Pose_Up_TP) == 0x000710, "Member 'URoNAnimInstance_PlayerTP_V2::Idle_Pose_Up_TP' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, Idle_Pose_Shld_TP) == 0x000718, "Member 'URoNAnimInstance_PlayerTP_V2::Idle_Pose_Shld_TP' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, Idle_Pose_Sights_TP) == 0x000720, "Member 'URoNAnimInstance_PlayerTP_V2::Idle_Pose_Sights_TP' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, Idle_Pose_Ret_TP) == 0x000728, "Member 'URoNAnimInstance_PlayerTP_V2::Idle_Pose_Ret_TP' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, Idle_Pose_Ovr_TP) == 0x000730, "Member 'URoNAnimInstance_PlayerTP_V2::Idle_Pose_Ovr_TP' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, Idle_Pose_VFG_TP) == 0x000738, "Member 'URoNAnimInstance_PlayerTP_V2::Idle_Pose_VFG_TP' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, Idle_Pose_AFG_TP) == 0x000740, "Member 'URoNAnimInstance_PlayerTP_V2::Idle_Pose_AFG_TP' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, Idle_Pose_HSTOP_TP) == 0x000748, "Member 'URoNAnimInstance_PlayerTP_V2::Idle_Pose_HSTOP_TP' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, Idle_Pose_RK1_TP) == 0x000750, "Member 'URoNAnimInstance_PlayerTP_V2::Idle_Pose_RK1_TP' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, Idle_Pose_CQR_TP) == 0x000758, "Member 'URoNAnimInstance_PlayerTP_V2::Idle_Pose_CQR_TP' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bLeaningLeftNotCrouching) == 0x000760, "Member 'URoNAnimInstance_PlayerTP_V2::bLeaningLeftNotCrouching' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bNotLeaningLeftOrCrouching) == 0x000761, "Member 'URoNAnimInstance_PlayerTP_V2::bNotLeaningLeftOrCrouching' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bNotLeaningLeftOrNotCrouching) == 0x000762, "Member 'URoNAnimInstance_PlayerTP_V2::bNotLeaningLeftOrNotCrouching' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bLeaningRightNotCrouching) == 0x000763, "Member 'URoNAnimInstance_PlayerTP_V2::bLeaningRightNotCrouching' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bNotLeaningRightOrCrouching) == 0x000764, "Member 'URoNAnimInstance_PlayerTP_V2::bNotLeaningRightOrCrouching' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bNotLeaningRightOrNotCrouching) == 0x000765, "Member 'URoNAnimInstance_PlayerTP_V2::bNotLeaningRightOrNotCrouching' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bCrouchingAndMoving) == 0x000766, "Member 'URoNAnimInstance_PlayerTP_V2::bCrouchingAndMoving' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bNotCrouchingAndMoving) == 0x000767, "Member 'URoNAnimInstance_PlayerTP_V2::bNotCrouchingAndMoving' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bAimingAndNotDeployable) == 0x000768, "Member 'URoNAnimInstance_PlayerTP_V2::bAimingAndNotDeployable' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, WalkSpeedForward) == 0x00076C, "Member 'URoNAnimInstance_PlayerTP_V2::WalkSpeedForward' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, WalkSpeedLeft) == 0x000770, "Member 'URoNAnimInstance_PlayerTP_V2::WalkSpeedLeft' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, WalkSpeedRight) == 0x000774, "Member 'URoNAnimInstance_PlayerTP_V2::WalkSpeedRight' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, WalkSpeedBackward) == 0x000778, "Member 'URoNAnimInstance_PlayerTP_V2::WalkSpeedBackward' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, CrouchWalkSpeedForward) == 0x00077C, "Member 'URoNAnimInstance_PlayerTP_V2::CrouchWalkSpeedForward' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, CrouchWalkSpeedLeft) == 0x000780, "Member 'URoNAnimInstance_PlayerTP_V2::CrouchWalkSpeedLeft' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, CrouchWalkSpeedRight) == 0x000784, "Member 'URoNAnimInstance_PlayerTP_V2::CrouchWalkSpeedRight' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, CrouchWalkSpeedBackward) == 0x000788, "Member 'URoNAnimInstance_PlayerTP_V2::CrouchWalkSpeedBackward' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, RunSpeedForward) == 0x00078C, "Member 'URoNAnimInstance_PlayerTP_V2::RunSpeedForward' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, RunSpeedLeft) == 0x000790, "Member 'URoNAnimInstance_PlayerTP_V2::RunSpeedLeft' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, RunSpeedRight) == 0x000794, "Member 'URoNAnimInstance_PlayerTP_V2::RunSpeedRight' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, RunSpeedBackward) == 0x000798, "Member 'URoNAnimInstance_PlayerTP_V2::RunSpeedBackward' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bLessThanPointOneSecondOnRelevantAnim) == 0x00079C, "Member 'URoNAnimInstance_PlayerTP_V2::bLessThanPointOneSecondOnRelevantAnim' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bIsInCombatOrAlerted) == 0x00079D, "Member 'URoNAnimInstance_PlayerTP_V2::bIsInCombatOrAlerted' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bMoving) == 0x00079E, "Member 'URoNAnimInstance_PlayerTP_V2::bMoving' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bIsAlerted) == 0x00079F, "Member 'URoNAnimInstance_PlayerTP_V2::bIsAlerted' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, AlertAlpha) == 0x0007A0, "Member 'URoNAnimInstance_PlayerTP_V2::AlertAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bIsInCombat) == 0x0007A4, "Member 'URoNAnimInstance_PlayerTP_V2::bIsInCombat' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bIsSurrendering) == 0x0007A5, "Member 'URoNAnimInstance_PlayerTP_V2::bIsSurrendering' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bSprayed) == 0x0007A6, "Member 'URoNAnimInstance_PlayerTP_V2::bSprayed' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bStung) == 0x0007A7, "Member 'URoNAnimInstance_PlayerTP_V2::bStung' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, CurPseudoSpeed) == 0x0007A8, "Member 'URoNAnimInstance_PlayerTP_V2::CurPseudoSpeed' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bFemale) == 0x0007A9, "Member 'URoNAnimInstance_PlayerTP_V2::bFemale' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bChild) == 0x0007AA, "Member 'URoNAnimInstance_PlayerTP_V2::bChild' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bHasInjury) == 0x0007AB, "Member 'URoNAnimInstance_PlayerTP_V2::bHasInjury' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, AnimSpeedFwdPlayrateSync) == 0x0007AC, "Member 'URoNAnimInstance_PlayerTP_V2::AnimSpeedFwdPlayrateSync' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, AnimSpeedSidePlayrateSync) == 0x0007B0, "Member 'URoNAnimInstance_PlayerTP_V2::AnimSpeedSidePlayrateSync' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, AnimSpeedPlayrateSync) == 0x0007B4, "Member 'URoNAnimInstance_PlayerTP_V2::AnimSpeedPlayrateSync' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, RetentionAlpha) == 0x0007B8, "Member 'URoNAnimInstance_PlayerTP_V2::RetentionAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, LoweredAlpha) == 0x0007BC, "Member 'URoNAnimInstance_PlayerTP_V2::LoweredAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, SightAlpha) == 0x0007C8, "Member 'URoNAnimInstance_PlayerTP_V2::SightAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, LoweredCooldownTime) == 0x0007CC, "Member 'URoNAnimInstance_PlayerTP_V2::LoweredCooldownTime' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, IsLoweredUp) == 0x0007D0, "Member 'URoNAnimInstance_PlayerTP_V2::IsLoweredUp' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, ArmsOnlySlotAlpha) == 0x0007E4, "Member 'URoNAnimInstance_PlayerTP_V2::ArmsOnlySlotAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, LeftArmOnlySlotAlpha) == 0x0007E8, "Member 'URoNAnimInstance_PlayerTP_V2::LeftArmOnlySlotAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, VelocityInterpTime) == 0x0007EC, "Member 'URoNAnimInstance_PlayerTP_V2::VelocityInterpTime' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, VelocitySmoothed) == 0x0007F0, "Member 'URoNAnimInstance_PlayerTP_V2::VelocitySmoothed' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, CharMovementSnapshot) == 0x000808, "Member 'URoNAnimInstance_PlayerTP_V2::CharMovementSnapshot' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, PostPivotTriggerThreshold) == 0x000900, "Member 'URoNAnimInstance_PlayerTP_V2::PostPivotTriggerThreshold' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, PivotingCardinalDirSnapShot) == 0x000904, "Member 'URoNAnimInstance_PlayerTP_V2::PivotingCardinalDirSnapShot' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, BaseCharacterRef) == 0x000938, "Member 'URoNAnimInstance_PlayerTP_V2::BaseCharacterRef' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, CharacterRef) == 0x000940, "Member 'URoNAnimInstance_PlayerTP_V2::CharacterRef' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, CharacterAiRef) == 0x000948, "Member 'URoNAnimInstance_PlayerTP_V2::CharacterAiRef' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bUseDistanceMatching) == 0x000950, "Member 'URoNAnimInstance_PlayerTP_V2::bUseDistanceMatching' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, DistanceMatchingCurrentState) == 0x000951, "Member 'URoNAnimInstance_PlayerTP_V2::DistanceMatchingCurrentState' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, StartMarker) == 0x000958, "Member 'URoNAnimInstance_PlayerTP_V2::StartMarker' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, StopMarker) == 0x000988, "Member 'URoNAnimInstance_PlayerTP_V2::StopMarker' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, PivotMarker) == 0x0009B8, "Member 'URoNAnimInstance_PlayerTP_V2::PivotMarker' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, PostPivotMarker) == 0x0009E8, "Member 'URoNAnimInstance_PlayerTP_V2::PostPivotMarker' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, TakeOffMarker) == 0x000A18, "Member 'URoNAnimInstance_PlayerTP_V2::TakeOffMarker' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, ApexMarker) == 0x000A48, "Member 'URoNAnimInstance_PlayerTP_V2::ApexMarker' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, LandingMarker) == 0x000A78, "Member 'URoNAnimInstance_PlayerTP_V2::LandingMarker' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, CurrentPivotDirectionExt) == 0x000AA8, "Member 'URoNAnimInstance_PlayerTP_V2::CurrentPivotDirectionExt' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bPivotDirectionBroken) == 0x000AA9, "Member 'URoNAnimInstance_PlayerTP_V2::bPivotDirectionBroken' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bCanPivotInCurDirection) == 0x000AAA, "Member 'URoNAnimInstance_PlayerTP_V2::bCanPivotInCurDirection' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bSMPrePivotRuleset) == 0x000AAB, "Member 'URoNAnimInstance_PlayerTP_V2::bSMPrePivotRuleset' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bStartDirectionBroken) == 0x000AAC, "Member 'URoNAnimInstance_PlayerTP_V2::bStartDirectionBroken' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, ReplicatedMaxSpeed) == 0x000AB0, "Member 'URoNAnimInstance_PlayerTP_V2::ReplicatedMaxSpeed' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bSMStartRuleset) == 0x000AB4, "Member 'URoNAnimInstance_PlayerTP_V2::bSMStartRuleset' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bSMStopRuleset) == 0x000AB5, "Member 'URoNAnimInstance_PlayerTP_V2::bSMStopRuleset' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bDistanceMatchToTarget) == 0x000AB6, "Member 'URoNAnimInstance_PlayerTP_V2::bDistanceMatchToTarget' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, DistanceCurveName) == 0x000AB8, "Member 'URoNAnimInstance_PlayerTP_V2::DistanceCurveName' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, PelvisDefaultWorldPos) == 0x000AC0, "Member 'URoNAnimInstance_PlayerTP_V2::PelvisDefaultWorldPos' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, CrouchedPelvisDefaultWorldPos) == 0x000AD8, "Member 'URoNAnimInstance_PlayerTP_V2::CrouchedPelvisDefaultWorldPos' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, CrouchedPelvisMovingWorldPos) == 0x000AF0, "Member 'URoNAnimInstance_PlayerTP_V2::CrouchedPelvisMovingWorldPos' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, CrouchedPelvisCurrentWorldPos) == 0x000B08, "Member 'URoNAnimInstance_PlayerTP_V2::CrouchedPelvisCurrentWorldPos' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, IdleStateData) == 0x000B20, "Member 'URoNAnimInstance_PlayerTP_V2::IdleStateData' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, StartStateData) == 0x000B3C, "Member 'URoNAnimInstance_PlayerTP_V2::StartStateData' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, MoveStateData) == 0x000B58, "Member 'URoNAnimInstance_PlayerTP_V2::MoveStateData' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, StopStateData) == 0x000B74, "Member 'URoNAnimInstance_PlayerTP_V2::StopStateData' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, PrePivotStateData) == 0x000B90, "Member 'URoNAnimInstance_PlayerTP_V2::PrePivotStateData' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, PostPivotStateData) == 0x000BAC, "Member 'URoNAnimInstance_PlayerTP_V2::PostPivotStateData' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, TurnInPlaceStateData) == 0x000BC8, "Member 'URoNAnimInstance_PlayerTP_V2::TurnInPlaceStateData' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, LocalTurnInPlaceStateData) == 0x000BE4, "Member 'URoNAnimInstance_PlayerTP_V2::LocalTurnInPlaceStateData' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bStartToCycleRuleSet) == 0x000C92, "Member 'URoNAnimInstance_PlayerTP_V2::bStartToCycleRuleSet' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bTriggerPivotARuleSet) == 0x000C93, "Member 'URoNAnimInstance_PlayerTP_V2::bTriggerPivotARuleSet' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bTriggerPivotBRuleSet) == 0x000C94, "Member 'URoNAnimInstance_PlayerTP_V2::bTriggerPivotBRuleSet' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bPrePivotToPostPivotRuleSet) == 0x000C95, "Member 'URoNAnimInstance_PlayerTP_V2::bPrePivotToPostPivotRuleSet' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bPostPivotToPrePivotRuleSet) == 0x000C96, "Member 'URoNAnimInstance_PlayerTP_V2::bPostPivotToPrePivotRuleSet' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bPivotToCycleRuleSet) == 0x000C97, "Member 'URoNAnimInstance_PlayerTP_V2::bPivotToCycleRuleSet' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bStopToIdleRuleSet) == 0x000C98, "Member 'URoNAnimInstance_PlayerTP_V2::bStopToIdleRuleSet' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bCanEnterPrePivotRuleSet) == 0x000C99, "Member 'URoNAnimInstance_PlayerTP_V2::bCanEnterPrePivotRuleSet' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, StandFastStartAnimations) == 0x000CA0, "Member 'URoNAnimInstance_PlayerTP_V2::StandFastStartAnimations' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, StandFastStopAnimations) == 0x000CB0, "Member 'URoNAnimInstance_PlayerTP_V2::StandFastStopAnimations' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, StandFastPivotAnimations) == 0x000CC0, "Member 'URoNAnimInstance_PlayerTP_V2::StandFastPivotAnimations' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, StandSlowStartAnimations) == 0x000CD0, "Member 'URoNAnimInstance_PlayerTP_V2::StandSlowStartAnimations' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, StandSlowStopAnimations) == 0x000CE0, "Member 'URoNAnimInstance_PlayerTP_V2::StandSlowStopAnimations' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, StandSlowPivotAnimations) == 0x000CF0, "Member 'URoNAnimInstance_PlayerTP_V2::StandSlowPivotAnimations' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, CrouchFastStartAnimations) == 0x000D00, "Member 'URoNAnimInstance_PlayerTP_V2::CrouchFastStartAnimations' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, CrouchFastStopAnimations) == 0x000D10, "Member 'URoNAnimInstance_PlayerTP_V2::CrouchFastStopAnimations' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, CrouchFastPivotAnimations) == 0x000D20, "Member 'URoNAnimInstance_PlayerTP_V2::CrouchFastPivotAnimations' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, CrouchSlowStartAnimations) == 0x000D30, "Member 'URoNAnimInstance_PlayerTP_V2::CrouchSlowStartAnimations' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, CrouchSlowStopAnimations) == 0x000D40, "Member 'URoNAnimInstance_PlayerTP_V2::CrouchSlowStopAnimations' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, CrouchSlowPivotAnimations) == 0x000D50, "Member 'URoNAnimInstance_PlayerTP_V2::CrouchSlowPivotAnimations' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, ActiveStopAnim) == 0x000D60, "Member 'URoNAnimInstance_PlayerTP_V2::ActiveStopAnim' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, ActiveStopAnimTime) == 0x000D68, "Member 'URoNAnimInstance_PlayerTP_V2::ActiveStopAnimTime' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, ActiveStartAnim) == 0x000D70, "Member 'URoNAnimInstance_PlayerTP_V2::ActiveStartAnim' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, ActiveStartAnimTime) == 0x000D78, "Member 'URoNAnimInstance_PlayerTP_V2::ActiveStartAnimTime' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, ActivePrePivotAnim) == 0x000D80, "Member 'URoNAnimInstance_PlayerTP_V2::ActivePrePivotAnim' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, ActivePrePivotAnimTime) == 0x000D88, "Member 'URoNAnimInstance_PlayerTP_V2::ActivePrePivotAnimTime' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, ActivePostPivotAnim) == 0x000D90, "Member 'URoNAnimInstance_PlayerTP_V2::ActivePostPivotAnim' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, ActivePostPivotAnimTime) == 0x000D98, "Member 'URoNAnimInstance_PlayerTP_V2::ActivePostPivotAnimTime' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bIsIdleStateRelevant) == 0x000D9C, "Member 'URoNAnimInstance_PlayerTP_V2::bIsIdleStateRelevant' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bIsStartStateRelevant) == 0x000D9D, "Member 'URoNAnimInstance_PlayerTP_V2::bIsStartStateRelevant' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bIsStopStateRelevant) == 0x000D9E, "Member 'URoNAnimInstance_PlayerTP_V2::bIsStopStateRelevant' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bIsPrePivotStateRelevant) == 0x000D9F, "Member 'URoNAnimInstance_PlayerTP_V2::bIsPrePivotStateRelevant' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bIsPostPivotStateRelevant) == 0x000DA0, "Member 'URoNAnimInstance_PlayerTP_V2::bIsPostPivotStateRelevant' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bIsMoveStateRelevant) == 0x000DA1, "Member 'URoNAnimInstance_PlayerTP_V2::bIsMoveStateRelevant' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bIsTurnInPlaceStateRelevant) == 0x000DA2, "Member 'URoNAnimInstance_PlayerTP_V2::bIsTurnInPlaceStateRelevant' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bIsStartStateFullWeight) == 0x000DA3, "Member 'URoNAnimInstance_PlayerTP_V2::bIsStartStateFullWeight' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bIsPrePivotStateFullWeight) == 0x000DA4, "Member 'URoNAnimInstance_PlayerTP_V2::bIsPrePivotStateFullWeight' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bIsPostPivotStateFullWeight) == 0x000DA5, "Member 'URoNAnimInstance_PlayerTP_V2::bIsPostPivotStateFullWeight' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, TimeInStartState) == 0x000DA8, "Member 'URoNAnimInstance_PlayerTP_V2::TimeInStartState' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, TimeInPostPivotState) == 0x000DAC, "Member 'URoNAnimInstance_PlayerTP_V2::TimeInPostPivotState' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bReadDisableSpeedCurve) == 0x000DB0, "Member 'URoNAnimInstance_PlayerTP_V2::bReadDisableSpeedCurve' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, DisableSpeedWarping) == 0x000DB4, "Member 'URoNAnimInstance_PlayerTP_V2::DisableSpeedWarping' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, SpeedScaling) == 0x000DB8, "Member 'URoNAnimInstance_PlayerTP_V2::SpeedScaling' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, PlayrateClampMax) == 0x000DBC, "Member 'URoNAnimInstance_PlayerTP_V2::PlayrateClampMax' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, PlayRateClamp) == 0x000DC0, "Member 'URoNAnimInstance_PlayerTP_V2::PlayRateClamp' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, PlayRateClampCycle) == 0x000DD0, "Member 'URoNAnimInstance_PlayerTP_V2::PlayRateClampCycle' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, PlayRateClampStartsPivots) == 0x000DE0, "Member 'URoNAnimInstance_PlayerTP_V2::PlayRateClampStartsPivots' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, StrideWarpingBlendInStartOffset) == 0x000DF0, "Member 'URoNAnimInstance_PlayerTP_V2::StrideWarpingBlendInStartOffset' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, StrideWarpingBlendInDurationScaled) == 0x000DF4, "Member 'URoNAnimInstance_PlayerTP_V2::StrideWarpingBlendInDurationScaled' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, StrideWarpingStartAlpha) == 0x000DF8, "Member 'URoNAnimInstance_PlayerTP_V2::StrideWarpingStartAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, StrideWarpingPivotAlpha) == 0x000DFC, "Member 'URoNAnimInstance_PlayerTP_V2::StrideWarpingPivotAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, DirectionBlendTime) == 0x000E00, "Member 'URoNAnimInstance_PlayerTP_V2::DirectionBlendTime' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, DeathPose) == 0x000E08, "Member 'URoNAnimInstance_PlayerTP_V2::DeathPose' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, SlopeWarpingAlpha) == 0x000E40, "Member 'URoNAnimInstance_PlayerTP_V2::SlopeWarpingAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bIsItemOrPistolMotionBlock) == 0x000E44, "Member 'URoNAnimInstance_PlayerTP_V2::bIsItemOrPistolMotionBlock' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bIsRifleMotionBlock) == 0x000E45, "Member 'URoNAnimInstance_PlayerTP_V2::bIsRifleMotionBlock' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bIsCrouchingWithShield) == 0x000E46, "Member 'URoNAnimInstance_PlayerTP_V2::bIsCrouchingWithShield' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, CrouchHighPoseAdditiveAlpha) == 0x000E48, "Member 'URoNAnimInstance_PlayerTP_V2::CrouchHighPoseAdditiveAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, StandHighPoseAdditiveAlpha) == 0x000E4C, "Member 'URoNAnimInstance_PlayerTP_V2::StandHighPoseAdditiveAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, LeftHandIKAlpha_ItemBased) == 0x000E50, "Member 'URoNAnimInstance_PlayerTP_V2::LeftHandIKAlpha_ItemBased' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, ZHeightLeanAdjustment) == 0x000E58, "Member 'URoNAnimInstance_PlayerTP_V2::ZHeightLeanAdjustment' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, IsCrouchingWithShield_AsFloat) == 0x000E70, "Member 'URoNAnimInstance_PlayerTP_V2::IsCrouchingWithShield_AsFloat' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, HandAdditiveLockOverride) == 0x000E74, "Member 'URoNAnimInstance_PlayerTP_V2::HandAdditiveLockOverride' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, LeftHandAdditiveOvrBlend) == 0x000E78, "Member 'URoNAnimInstance_PlayerTP_V2::LeftHandAdditiveOvrBlend' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, LeftHandTempFinIK) == 0x000E7C, "Member 'URoNAnimInstance_PlayerTP_V2::LeftHandTempFinIK' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bFastWalkSwitchRule) == 0x000E80, "Member 'URoNAnimInstance_PlayerTP_V2::bFastWalkSwitchRule' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bCrouchFastWalkSwitchRule) == 0x000E81, "Member 'URoNAnimInstance_PlayerTP_V2::bCrouchFastWalkSwitchRule' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bStartWalkSwitchTransitionRule) == 0x000E82, "Member 'URoNAnimInstance_PlayerTP_V2::bStartWalkSwitchTransitionRule' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, DefaultCrouchSpeed) == 0x000E84, "Member 'URoNAnimInstance_PlayerTP_V2::DefaultCrouchSpeed' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, DefaultStandSpeed) == 0x000E88, "Member 'URoNAnimInstance_PlayerTP_V2::DefaultStandSpeed' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bStopWalkSwitchTransitionRule) == 0x000E8C, "Member 'URoNAnimInstance_PlayerTP_V2::bStopWalkSwitchTransitionRule' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bPivotWalkSwitchTransitionRule) == 0x000E8D, "Member 'URoNAnimInstance_PlayerTP_V2::bPivotWalkSwitchTransitionRule' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bHasUnderbarrelAttachment) == 0x000E8E, "Member 'URoNAnimInstance_PlayerTP_V2::bHasUnderbarrelAttachment' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, UnderbarrelType) == 0x000E8F, "Member 'URoNAnimInstance_PlayerTP_V2::UnderbarrelType' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, LeftHandGripAlpha) == 0x000E90, "Member 'URoNAnimInstance_PlayerTP_V2::LeftHandGripAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, UpperbodySlotNoWeight) == 0x000E94, "Member 'URoNAnimInstance_PlayerTP_V2::UpperbodySlotNoWeight' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bIsFastWalking) == 0x000E98, "Member 'URoNAnimInstance_PlayerTP_V2::bIsFastWalking' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bIsFastStop) == 0x000E99, "Member 'URoNAnimInstance_PlayerTP_V2::bIsFastStop' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bIsFastStart) == 0x000E9A, "Member 'URoNAnimInstance_PlayerTP_V2::bIsFastStart' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bIsFastPivot) == 0x000E9B, "Member 'URoNAnimInstance_PlayerTP_V2::bIsFastPivot' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bIsLocallyFirstPerson) == 0x000E9C, "Member 'URoNAnimInstance_PlayerTP_V2::bIsLocallyFirstPerson' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bPFStartPhase) == 0x000E9D, "Member 'URoNAnimInstance_PlayerTP_V2::bPFStartPhase' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bPFStoppingPhase) == 0x000E9E, "Member 'URoNAnimInstance_PlayerTP_V2::bPFStoppingPhase' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bPFHasReachedStoppingPhase) == 0x000E9F, "Member 'URoNAnimInstance_PlayerTP_V2::bPFHasReachedStoppingPhase' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, PFStartDistanceThreshold) == 0x000EA0, "Member 'URoNAnimInstance_PlayerTP_V2::PFStartDistanceThreshold' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, PFStopDistanceThreshold) == 0x000EA4, "Member 'URoNAnimInstance_PlayerTP_V2::PFStopDistanceThreshold' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, PFLastStopLocation) == 0x000EA8, "Member 'URoNAnimInstance_PlayerTP_V2::PFLastStopLocation' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, PFCurrentStopLocation) == 0x000EC0, "Member 'URoNAnimInstance_PlayerTP_V2::PFCurrentStopLocation' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, PFStopDistance) == 0x000ED8, "Member 'URoNAnimInstance_PlayerTP_V2::PFStopDistance' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, PFCurrentAcceptanceRadius) == 0x000EDC, "Member 'URoNAnimInstance_PlayerTP_V2::PFCurrentAcceptanceRadius' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bPFPathTooShort) == 0x000EE0, "Member 'URoNAnimInstance_PlayerTP_V2::bPFPathTooShort' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bPFPathIsValid) == 0x000EE1, "Member 'URoNAnimInstance_PlayerTP_V2::bPFPathIsValid' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, bPFRequestedNewPath) == 0x000EE2, "Member 'URoNAnimInstance_PlayerTP_V2::bPFRequestedNewPath' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP_V2, HeadLookRotationSwapped) == 0x000EF8, "Member 'URoNAnimInstance_PlayerTP_V2::HeadLookRotationSwapped' has a wrong offset!");

// Class ReadyOrNot.LaunchGrenadeThroughDoorActivity
// 0x0018 (0x0290 - 0x0278)
class ULaunchGrenadeThroughDoorActivity final : public UDoorBreachActivity
{
public:
	TMulticastInlineDelegate<void()>              OnLauncherReady;                                   // 0x0278(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_288[0x8];                                      // 0x0288(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LaunchGrenadeThroughDoorActivity">();
	}
	static class ULaunchGrenadeThroughDoorActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULaunchGrenadeThroughDoorActivity>();
	}
};
static_assert(alignof(ULaunchGrenadeThroughDoorActivity) == 0x000008, "Wrong alignment on ULaunchGrenadeThroughDoorActivity");
static_assert(sizeof(ULaunchGrenadeThroughDoorActivity) == 0x000290, "Wrong size on ULaunchGrenadeThroughDoorActivity");
static_assert(offsetof(ULaunchGrenadeThroughDoorActivity, OnLauncherReady) == 0x000278, "Member 'ULaunchGrenadeThroughDoorActivity::OnLauncherReady' has a wrong offset!");

// Class ReadyOrNot.ThrowGrenadeThroughDoorActivity
// 0x0000 (0x02B8 - 0x02B8)
class UThrowGrenadeThroughDoorActivity final : public UThrowItemThroughDoorActivity
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ThrowGrenadeThroughDoorActivity">();
	}
	static class UThrowGrenadeThroughDoorActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UThrowGrenadeThroughDoorActivity>();
	}
};
static_assert(alignof(UThrowGrenadeThroughDoorActivity) == 0x000008, "Wrong alignment on UThrowGrenadeThroughDoorActivity");
static_assert(sizeof(UThrowGrenadeThroughDoorActivity) == 0x0002B8, "Wrong size on UThrowGrenadeThroughDoorActivity");

// Class ReadyOrNot.WeaponSound
// 0x0188 (0x01B8 - 0x0030)
class UWeaponSound final : public UDataAsset
{
public:
	bool                                          bPlayFMODFiringAudio;                              // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             FMODGunShot1P;                                     // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             FMODGunShot3P;                                     // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             MagCheck_FullSeq;                                  // 0x0048(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             QuickReload_FullSeq;                               // 0x0050(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             QuickReloadEmpty_FullSeq;                          // 0x0058(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             Reload_FullSeq;                                    // 0x0060(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             ReloadEmpty_FullSeq;                               // 0x0068(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             MagIn;                                             // 0x0070(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             MagOut;                                            // 0x0078(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             MagInQuick;                                        // 0x0080(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             MagOutQuick;                                       // 0x0088(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             MagDrop;                                           // 0x0090(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             MagDropQuick;                                      // 0x0098(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             WeaponDrop;                                        // 0x00A0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             BoltClose;                                         // 0x00A8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             BoltCloseQuick;                                    // 0x00B0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             BoltOpen;                                          // 0x00B8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             BoltOpenQuick;                                     // 0x00C0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             OnADSSound;                                        // 0x00C8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             OnEndADSSound;                                     // 0x00D0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             NightvisionOn;                                     // 0x00D8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             NightvisionOff;                                    // 0x00E0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             Holster;                                           // 0x00E8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             Draw;                                              // 0x00F0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             DrawFirst;                                         // 0x00F8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             SelectSemi;                                        // 0x0100(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             SelectBurst;                                       // 0x0108(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             SelectAuto;                                        // 0x0110(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             SelectSafe;                                        // 0x0118(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FWeaponSoundData                       Firing_Inside;                                     // 0x0120(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponSoundData                       Firing_Outside;                                    // 0x0140(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	class UFMODEvent*                             DryFire;                                           // 0x0160(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             FireLast;                                          // 0x0168(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayBulletWhizz;                                  // 0x0170(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_171[0x7];                                      // 0x0171(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             BulletWhizzFar;                                    // 0x0178(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             HitMarker;                                         // 0x0180(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             HeadshotMarker;                                    // 0x0188(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             KillMarker;                                        // 0x0190(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             PhysicsImpact;                                     // 0x0198(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             PlayerImpact;                                      // 0x01A0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhysicsImpactMinimumVelocity;                      // 0x01A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AC[0x4];                                      // 0x01AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             MovementLayer;                                     // 0x01B0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponSound">();
	}
	static class UWeaponSound* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponSound>();
	}
};
static_assert(alignof(UWeaponSound) == 0x000008, "Wrong alignment on UWeaponSound");
static_assert(sizeof(UWeaponSound) == 0x0001B8, "Wrong size on UWeaponSound");
static_assert(offsetof(UWeaponSound, bPlayFMODFiringAudio) == 0x000030, "Member 'UWeaponSound::bPlayFMODFiringAudio' has a wrong offset!");
static_assert(offsetof(UWeaponSound, FMODGunShot1P) == 0x000038, "Member 'UWeaponSound::FMODGunShot1P' has a wrong offset!");
static_assert(offsetof(UWeaponSound, FMODGunShot3P) == 0x000040, "Member 'UWeaponSound::FMODGunShot3P' has a wrong offset!");
static_assert(offsetof(UWeaponSound, MagCheck_FullSeq) == 0x000048, "Member 'UWeaponSound::MagCheck_FullSeq' has a wrong offset!");
static_assert(offsetof(UWeaponSound, QuickReload_FullSeq) == 0x000050, "Member 'UWeaponSound::QuickReload_FullSeq' has a wrong offset!");
static_assert(offsetof(UWeaponSound, QuickReloadEmpty_FullSeq) == 0x000058, "Member 'UWeaponSound::QuickReloadEmpty_FullSeq' has a wrong offset!");
static_assert(offsetof(UWeaponSound, Reload_FullSeq) == 0x000060, "Member 'UWeaponSound::Reload_FullSeq' has a wrong offset!");
static_assert(offsetof(UWeaponSound, ReloadEmpty_FullSeq) == 0x000068, "Member 'UWeaponSound::ReloadEmpty_FullSeq' has a wrong offset!");
static_assert(offsetof(UWeaponSound, MagIn) == 0x000070, "Member 'UWeaponSound::MagIn' has a wrong offset!");
static_assert(offsetof(UWeaponSound, MagOut) == 0x000078, "Member 'UWeaponSound::MagOut' has a wrong offset!");
static_assert(offsetof(UWeaponSound, MagInQuick) == 0x000080, "Member 'UWeaponSound::MagInQuick' has a wrong offset!");
static_assert(offsetof(UWeaponSound, MagOutQuick) == 0x000088, "Member 'UWeaponSound::MagOutQuick' has a wrong offset!");
static_assert(offsetof(UWeaponSound, MagDrop) == 0x000090, "Member 'UWeaponSound::MagDrop' has a wrong offset!");
static_assert(offsetof(UWeaponSound, MagDropQuick) == 0x000098, "Member 'UWeaponSound::MagDropQuick' has a wrong offset!");
static_assert(offsetof(UWeaponSound, WeaponDrop) == 0x0000A0, "Member 'UWeaponSound::WeaponDrop' has a wrong offset!");
static_assert(offsetof(UWeaponSound, BoltClose) == 0x0000A8, "Member 'UWeaponSound::BoltClose' has a wrong offset!");
static_assert(offsetof(UWeaponSound, BoltCloseQuick) == 0x0000B0, "Member 'UWeaponSound::BoltCloseQuick' has a wrong offset!");
static_assert(offsetof(UWeaponSound, BoltOpen) == 0x0000B8, "Member 'UWeaponSound::BoltOpen' has a wrong offset!");
static_assert(offsetof(UWeaponSound, BoltOpenQuick) == 0x0000C0, "Member 'UWeaponSound::BoltOpenQuick' has a wrong offset!");
static_assert(offsetof(UWeaponSound, OnADSSound) == 0x0000C8, "Member 'UWeaponSound::OnADSSound' has a wrong offset!");
static_assert(offsetof(UWeaponSound, OnEndADSSound) == 0x0000D0, "Member 'UWeaponSound::OnEndADSSound' has a wrong offset!");
static_assert(offsetof(UWeaponSound, NightvisionOn) == 0x0000D8, "Member 'UWeaponSound::NightvisionOn' has a wrong offset!");
static_assert(offsetof(UWeaponSound, NightvisionOff) == 0x0000E0, "Member 'UWeaponSound::NightvisionOff' has a wrong offset!");
static_assert(offsetof(UWeaponSound, Holster) == 0x0000E8, "Member 'UWeaponSound::Holster' has a wrong offset!");
static_assert(offsetof(UWeaponSound, Draw) == 0x0000F0, "Member 'UWeaponSound::Draw' has a wrong offset!");
static_assert(offsetof(UWeaponSound, DrawFirst) == 0x0000F8, "Member 'UWeaponSound::DrawFirst' has a wrong offset!");
static_assert(offsetof(UWeaponSound, SelectSemi) == 0x000100, "Member 'UWeaponSound::SelectSemi' has a wrong offset!");
static_assert(offsetof(UWeaponSound, SelectBurst) == 0x000108, "Member 'UWeaponSound::SelectBurst' has a wrong offset!");
static_assert(offsetof(UWeaponSound, SelectAuto) == 0x000110, "Member 'UWeaponSound::SelectAuto' has a wrong offset!");
static_assert(offsetof(UWeaponSound, SelectSafe) == 0x000118, "Member 'UWeaponSound::SelectSafe' has a wrong offset!");
static_assert(offsetof(UWeaponSound, Firing_Inside) == 0x000120, "Member 'UWeaponSound::Firing_Inside' has a wrong offset!");
static_assert(offsetof(UWeaponSound, Firing_Outside) == 0x000140, "Member 'UWeaponSound::Firing_Outside' has a wrong offset!");
static_assert(offsetof(UWeaponSound, DryFire) == 0x000160, "Member 'UWeaponSound::DryFire' has a wrong offset!");
static_assert(offsetof(UWeaponSound, FireLast) == 0x000168, "Member 'UWeaponSound::FireLast' has a wrong offset!");
static_assert(offsetof(UWeaponSound, bPlayBulletWhizz) == 0x000170, "Member 'UWeaponSound::bPlayBulletWhizz' has a wrong offset!");
static_assert(offsetof(UWeaponSound, BulletWhizzFar) == 0x000178, "Member 'UWeaponSound::BulletWhizzFar' has a wrong offset!");
static_assert(offsetof(UWeaponSound, HitMarker) == 0x000180, "Member 'UWeaponSound::HitMarker' has a wrong offset!");
static_assert(offsetof(UWeaponSound, HeadshotMarker) == 0x000188, "Member 'UWeaponSound::HeadshotMarker' has a wrong offset!");
static_assert(offsetof(UWeaponSound, KillMarker) == 0x000190, "Member 'UWeaponSound::KillMarker' has a wrong offset!");
static_assert(offsetof(UWeaponSound, PhysicsImpact) == 0x000198, "Member 'UWeaponSound::PhysicsImpact' has a wrong offset!");
static_assert(offsetof(UWeaponSound, PlayerImpact) == 0x0001A0, "Member 'UWeaponSound::PlayerImpact' has a wrong offset!");
static_assert(offsetof(UWeaponSound, PhysicsImpactMinimumVelocity) == 0x0001A8, "Member 'UWeaponSound::PhysicsImpactMinimumVelocity' has a wrong offset!");
static_assert(offsetof(UWeaponSound, MovementLayer) == 0x0001B0, "Member 'UWeaponSound::MovementLayer' has a wrong offset!");

// Class ReadyOrNot.DoorJam
// 0x0050 (0x0C00 - 0x0BB0)
class ADoorJam : public ABaseItem
{
public:
	uint8                                         Pad_BB0[0x8];                                      // 0x0BB0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bSet : 1;                                          // 0x0BB8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_BB9[0x7];                                      // 0x0BB9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AReadyOrNotCharacter*                   PlacedBy;                                          // 0x0BC0(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADoor*                                  PendingPlacement;                                  // 0x0BC8(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADoor*                                  JammedDoor;                                        // 0x0BD0(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DoorJamSocket;                                     // 0x0BD8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          PlacedMesh;                                        // 0x0BE0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlacementTimer;                                    // 0x0BE8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WedgeRemovalTime;                                  // 0x0BEC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BF0[0x10];                                     // 0x0BF0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void JamDoor(class ADoor* Door);
	void Multicast_StartPlacement();
	void OnRep_DoorjamSet();
	void Server_FinishDoorjamPlacement(class ADoor* PendingDoor);
	void Server_StartDoorjamPlacement(class ADoor* PendingDoor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DoorJam">();
	}
	static class ADoorJam* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADoorJam>();
	}
};
static_assert(alignof(ADoorJam) == 0x000010, "Wrong alignment on ADoorJam");
static_assert(sizeof(ADoorJam) == 0x000C00, "Wrong size on ADoorJam");
static_assert(offsetof(ADoorJam, PlacedBy) == 0x000BC0, "Member 'ADoorJam::PlacedBy' has a wrong offset!");
static_assert(offsetof(ADoorJam, PendingPlacement) == 0x000BC8, "Member 'ADoorJam::PendingPlacement' has a wrong offset!");
static_assert(offsetof(ADoorJam, JammedDoor) == 0x000BD0, "Member 'ADoorJam::JammedDoor' has a wrong offset!");
static_assert(offsetof(ADoorJam, DoorJamSocket) == 0x000BD8, "Member 'ADoorJam::DoorJamSocket' has a wrong offset!");
static_assert(offsetof(ADoorJam, PlacedMesh) == 0x000BE0, "Member 'ADoorJam::PlacedMesh' has a wrong offset!");
static_assert(offsetof(ADoorJam, PlacementTimer) == 0x000BE8, "Member 'ADoorJam::PlacementTimer' has a wrong offset!");
static_assert(offsetof(ADoorJam, WedgeRemovalTime) == 0x000BEC, "Member 'ADoorJam::WedgeRemovalTime' has a wrong offset!");

// Class ReadyOrNot.DoorwayComponent
// 0x0000 (0x05B0 - 0x05B0)
class UDoorwayComponent final : public UBoxComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DoorwayComponent">();
	}
	static class UDoorwayComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDoorwayComponent>();
	}
};
static_assert(alignof(UDoorwayComponent) == 0x000010, "Wrong alignment on UDoorwayComponent");
static_assert(sizeof(UDoorwayComponent) == 0x0005B0, "Wrong size on UDoorwayComponent");

// Class ReadyOrNot.RoomVolume
// 0x0030 (0x0300 - 0x02D0)
class ARoomVolume final : public AVolume
{
public:
	int32                                         RoomGroupID;                                       // 0x02D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D4[0x14];                                     // 0x02D4(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         OverlappingActors;                                 // 0x02E8(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class AReflectionProbe*                       ReflectionProbe;                                   // 0x02F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RoomVolume">();
	}
	static class ARoomVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARoomVolume>();
	}
};
static_assert(alignof(ARoomVolume) == 0x000008, "Wrong alignment on ARoomVolume");
static_assert(sizeof(ARoomVolume) == 0x000300, "Wrong size on ARoomVolume");
static_assert(offsetof(ARoomVolume, RoomGroupID) == 0x0002D0, "Member 'ARoomVolume::RoomGroupID' has a wrong offset!");
static_assert(offsetof(ARoomVolume, OverlappingActors) == 0x0002E8, "Member 'ARoomVolume::OverlappingActors' has a wrong offset!");
static_assert(offsetof(ARoomVolume, ReflectionProbe) == 0x0002F8, "Member 'ARoomVolume::ReflectionProbe' has a wrong offset!");

// Class ReadyOrNot.Drone
// 0x0358 (0x06C0 - 0x0368)
class ADrone final : public AUnmannedVehicle
{
public:
	TSubclassOf<class UUserWidget>                DroneWidgetClass;                                  // 0x0368(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            FPCameraRotationCurve;                             // 0x0370(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FPCameraRotationResetSpeed;                        // 0x0378(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_37C[0x4];                                      // 0x037C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           FPDamageCurve;                                     // 0x0380(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FPDamageSpeed;                                     // 0x0388(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxPitchTilt;                                      // 0x038C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxRollTilt;                                       // 0x0390(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxRPM;                                            // 0x0394(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IdleRPM;                                           // 0x0398(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RPMThrottleMultiplier;                             // 0x039C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ThrottleInterpSpeed;                               // 0x03A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RotationInterpSpeed;                               // 0x03A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TurnSpeed;                                         // 0x03A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RotationInterpSpeedWhenSteady;                     // 0x03AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TurnSpeedWhenSteady;                               // 0x03B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinSpeed;                                          // 0x03B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxSpeed;                                          // 0x03B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpeedIncrementRate;                                // 0x03BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EDroneDamageSpeed, float>                DroneSpeedToDamageValues;                          // 0x03C0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	float                                         InvincibilityTimeAfterDamageApplied;               // 0x0410(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_414[0x4];                                      // 0x0414(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               RotorRotation;                                     // 0x0418(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         RPM;                                               // 0x0430(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentAltitude;                                   // 0x0434(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentPilotDistance;                              // 0x0438(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_43C[0x4];                                      // 0x043C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             DroneTransform;                                    // 0x0440(0x0060)(BlueprintVisible, BlueprintReadOnly, Net, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               TargetRotation;                                    // 0x04A0(0x0018)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               TargetSteadyCameraRotation;                        // 0x04B8(0x0018)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bApplyingInput;                                    // 0x04D0(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSteadyDrone;                                      // 0x04D1(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDroneThirdPerson;                                 // 0x04D2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D3[0x5];                                      // 0x04D3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UWorld*                                 World;                                             // 0x04D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AReadyOrNotPlayerController*            DroneController;                                   // 0x04E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AReadyOrNotPlayerController*            OriginalController;                                // 0x04E8(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4F0[0x38];                                     // 0x04F0(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          FlightBox;                                         // 0x0528(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 Mesh;                                              // 0x0530(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USphereComponent*                       DetectionSphere;                                   // 0x0538(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFloatingPawnMovement*                  FloatingMovementComponent;                         // 0x0540(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USpringArmComponent*                    TPCameraArm;                                       // 0x0548(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCameraComponent*                       TPCamera;                                          // 0x0550(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAudioComponent*                        Audio;                                             // 0x0558(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCameraComponent*                       FPCamera;                                          // 0x0560(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUserWidget*                            DroneWidgetHUD;                                    // 0x0568(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_570[0x150];                                    // 0x0570(0x0150)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Client_UpdateDrone(const struct FTransform& NewTransform, float InRPM);
	void ExitDrone();
	void Finished_CameraDamage();
	void IncrementSpeed(float Value);
	bool IsSpeedThresholdMet(float InSpeedAsPercentage);
	void OnDetectionSphereOverlapped(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnDroneHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void QuickTurn();
	void Server_UpdateDrone(const struct FTransform& NewTransform, float InRPM);
	void SteadyDrone();
	void Tick_CameraDamage();
	void Tick_CameraReset();
	void ToggleThirdPerson();
	void UpdatePilotingInfo();

	float GetAltitude() const;
	struct FVector GetCurrentMovementDirection() const;
	float GetCurrentRPM() const;
	float GetCurrentSpeedAsPercentage() const;
	float GetDistanceToPilot() const;
	class AReadyOrNotPlayerController* GetDroneController() const;
	float GetIdleRPM() const;
	float GetMaxRPM() const;
	float GetMaxSpeed() const;
	float GetMinSpeed() const;
	bool HasPilot() const;
	bool IsApplyingInput() const;
	bool IsInThirdPersonMode() const;
	bool IsInvincible() const;
	bool IsMoving() const;
	bool IsMovingBackward() const;
	bool IsMovingForward() const;
	bool IsMovingLeft() const;
	bool IsMovingRight() const;
	bool IsStabilized() const;
	void RetrieveLastHitDamageInfo(EDroneDamageSpeed* InDroneDamageSpeed, float* InDamageAmount) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Drone">();
	}
	static class ADrone* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADrone>();
	}
};
static_assert(alignof(ADrone) == 0x000010, "Wrong alignment on ADrone");
static_assert(sizeof(ADrone) == 0x0006C0, "Wrong size on ADrone");
static_assert(offsetof(ADrone, DroneWidgetClass) == 0x000368, "Member 'ADrone::DroneWidgetClass' has a wrong offset!");
static_assert(offsetof(ADrone, FPCameraRotationCurve) == 0x000370, "Member 'ADrone::FPCameraRotationCurve' has a wrong offset!");
static_assert(offsetof(ADrone, FPCameraRotationResetSpeed) == 0x000378, "Member 'ADrone::FPCameraRotationResetSpeed' has a wrong offset!");
static_assert(offsetof(ADrone, FPDamageCurve) == 0x000380, "Member 'ADrone::FPDamageCurve' has a wrong offset!");
static_assert(offsetof(ADrone, FPDamageSpeed) == 0x000388, "Member 'ADrone::FPDamageSpeed' has a wrong offset!");
static_assert(offsetof(ADrone, MaxPitchTilt) == 0x00038C, "Member 'ADrone::MaxPitchTilt' has a wrong offset!");
static_assert(offsetof(ADrone, MaxRollTilt) == 0x000390, "Member 'ADrone::MaxRollTilt' has a wrong offset!");
static_assert(offsetof(ADrone, MaxRPM) == 0x000394, "Member 'ADrone::MaxRPM' has a wrong offset!");
static_assert(offsetof(ADrone, IdleRPM) == 0x000398, "Member 'ADrone::IdleRPM' has a wrong offset!");
static_assert(offsetof(ADrone, RPMThrottleMultiplier) == 0x00039C, "Member 'ADrone::RPMThrottleMultiplier' has a wrong offset!");
static_assert(offsetof(ADrone, ThrottleInterpSpeed) == 0x0003A0, "Member 'ADrone::ThrottleInterpSpeed' has a wrong offset!");
static_assert(offsetof(ADrone, RotationInterpSpeed) == 0x0003A4, "Member 'ADrone::RotationInterpSpeed' has a wrong offset!");
static_assert(offsetof(ADrone, TurnSpeed) == 0x0003A8, "Member 'ADrone::TurnSpeed' has a wrong offset!");
static_assert(offsetof(ADrone, RotationInterpSpeedWhenSteady) == 0x0003AC, "Member 'ADrone::RotationInterpSpeedWhenSteady' has a wrong offset!");
static_assert(offsetof(ADrone, TurnSpeedWhenSteady) == 0x0003B0, "Member 'ADrone::TurnSpeedWhenSteady' has a wrong offset!");
static_assert(offsetof(ADrone, MinSpeed) == 0x0003B4, "Member 'ADrone::MinSpeed' has a wrong offset!");
static_assert(offsetof(ADrone, MaxSpeed) == 0x0003B8, "Member 'ADrone::MaxSpeed' has a wrong offset!");
static_assert(offsetof(ADrone, SpeedIncrementRate) == 0x0003BC, "Member 'ADrone::SpeedIncrementRate' has a wrong offset!");
static_assert(offsetof(ADrone, DroneSpeedToDamageValues) == 0x0003C0, "Member 'ADrone::DroneSpeedToDamageValues' has a wrong offset!");
static_assert(offsetof(ADrone, InvincibilityTimeAfterDamageApplied) == 0x000410, "Member 'ADrone::InvincibilityTimeAfterDamageApplied' has a wrong offset!");
static_assert(offsetof(ADrone, RotorRotation) == 0x000418, "Member 'ADrone::RotorRotation' has a wrong offset!");
static_assert(offsetof(ADrone, RPM) == 0x000430, "Member 'ADrone::RPM' has a wrong offset!");
static_assert(offsetof(ADrone, CurrentAltitude) == 0x000434, "Member 'ADrone::CurrentAltitude' has a wrong offset!");
static_assert(offsetof(ADrone, CurrentPilotDistance) == 0x000438, "Member 'ADrone::CurrentPilotDistance' has a wrong offset!");
static_assert(offsetof(ADrone, DroneTransform) == 0x000440, "Member 'ADrone::DroneTransform' has a wrong offset!");
static_assert(offsetof(ADrone, TargetRotation) == 0x0004A0, "Member 'ADrone::TargetRotation' has a wrong offset!");
static_assert(offsetof(ADrone, TargetSteadyCameraRotation) == 0x0004B8, "Member 'ADrone::TargetSteadyCameraRotation' has a wrong offset!");
static_assert(offsetof(ADrone, bApplyingInput) == 0x0004D0, "Member 'ADrone::bApplyingInput' has a wrong offset!");
static_assert(offsetof(ADrone, bSteadyDrone) == 0x0004D1, "Member 'ADrone::bSteadyDrone' has a wrong offset!");
static_assert(offsetof(ADrone, bDroneThirdPerson) == 0x0004D2, "Member 'ADrone::bDroneThirdPerson' has a wrong offset!");
static_assert(offsetof(ADrone, World) == 0x0004D8, "Member 'ADrone::World' has a wrong offset!");
static_assert(offsetof(ADrone, DroneController) == 0x0004E0, "Member 'ADrone::DroneController' has a wrong offset!");
static_assert(offsetof(ADrone, OriginalController) == 0x0004E8, "Member 'ADrone::OriginalController' has a wrong offset!");
static_assert(offsetof(ADrone, FlightBox) == 0x000528, "Member 'ADrone::FlightBox' has a wrong offset!");
static_assert(offsetof(ADrone, Mesh) == 0x000530, "Member 'ADrone::Mesh' has a wrong offset!");
static_assert(offsetof(ADrone, DetectionSphere) == 0x000538, "Member 'ADrone::DetectionSphere' has a wrong offset!");
static_assert(offsetof(ADrone, FloatingMovementComponent) == 0x000540, "Member 'ADrone::FloatingMovementComponent' has a wrong offset!");
static_assert(offsetof(ADrone, TPCameraArm) == 0x000548, "Member 'ADrone::TPCameraArm' has a wrong offset!");
static_assert(offsetof(ADrone, TPCamera) == 0x000550, "Member 'ADrone::TPCamera' has a wrong offset!");
static_assert(offsetof(ADrone, Audio) == 0x000558, "Member 'ADrone::Audio' has a wrong offset!");
static_assert(offsetof(ADrone, FPCamera) == 0x000560, "Member 'ADrone::FPCamera' has a wrong offset!");
static_assert(offsetof(ADrone, DroneWidgetHUD) == 0x000568, "Member 'ADrone::DroneWidgetHUD' has a wrong offset!");

// Class ReadyOrNot.DropWeaponAnimNotify
// 0x0000 (0x0038 - 0x0038)
class UDropWeaponAnimNotify final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DropWeaponAnimNotify">();
	}
	static class UDropWeaponAnimNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDropWeaponAnimNotify>();
	}
};
static_assert(alignof(UDropWeaponAnimNotify) == 0x000008, "Wrong alignment on UDropWeaponAnimNotify");
static_assert(sizeof(UDropWeaponAnimNotify) == 0x000038, "Wrong size on UDropWeaponAnimNotify");

// Class ReadyOrNot.RosterCharacterArchetype
// 0x0050 (0x0080 - 0x0030)
class URosterCharacterArchetype final : public UPrimaryDataAsset
{
public:
	TArray<class UCustomizationCharacter*>        CharacterPool;                                     // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UCustomizationVoice*>            VoicePool;                                         // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class FText>                           BackgroundTextPool;                                // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FText>                           FirstNamePool;                                     // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FText>                           LastNamePool;                                      // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RosterCharacterArchetype">();
	}
	static class URosterCharacterArchetype* GetDefaultObj()
	{
		return GetDefaultObjImpl<URosterCharacterArchetype>();
	}
};
static_assert(alignof(URosterCharacterArchetype) == 0x000008, "Wrong alignment on URosterCharacterArchetype");
static_assert(sizeof(URosterCharacterArchetype) == 0x000080, "Wrong size on URosterCharacterArchetype");
static_assert(offsetof(URosterCharacterArchetype, CharacterPool) == 0x000030, "Member 'URosterCharacterArchetype::CharacterPool' has a wrong offset!");
static_assert(offsetof(URosterCharacterArchetype, VoicePool) == 0x000040, "Member 'URosterCharacterArchetype::VoicePool' has a wrong offset!");
static_assert(offsetof(URosterCharacterArchetype, BackgroundTextPool) == 0x000050, "Member 'URosterCharacterArchetype::BackgroundTextPool' has a wrong offset!");
static_assert(offsetof(URosterCharacterArchetype, FirstNamePool) == 0x000060, "Member 'URosterCharacterArchetype::FirstNamePool' has a wrong offset!");
static_assert(offsetof(URosterCharacterArchetype, LastNamePool) == 0x000070, "Member 'URosterCharacterArchetype::LastNamePool' has a wrong offset!");

// Class ReadyOrNot.DynamicInteractableWorldItem
// 0x00A0 (0x0338 - 0x0298)
class ADynamicInteractableWorldItem final : public AActor
{
public:
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bRestartOnToggle;                                  // 0x02A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanToggleIfDestroyed;                             // 0x02A1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bItemOn;                                           // 0x02A2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bItemDestroyed;                                    // 0x02A3(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A4[0x4];                                      // 0x02A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractableComponent*                 InteractableComponent;                             // 0x02A8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODAudioComponent*                    InteractAudioFMOD;                                 // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODAudioComponent*                    IntactRunningAudioFMOD1;                           // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODAudioComponent*                    DestroyedRunningAudioFMOD;                         // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODAudioComponent*                    ImpactAudioFMOD;                                   // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UMaterialInterface*>             IntactOnMaterials;                                 // 0x02D0(0x0010)(Edit, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<class UMaterialInterface*>             IntactOffMaterials;                                // 0x02E0(0x0010)(Edit, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<class UMaterialInterface*>             DestroyedOnMaterials;                              // 0x02F0(0x0010)(Edit, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<class UMaterialInterface*>             DestroyedOffMaterials;                             // 0x0300(0x0010)(Edit, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   ItemMesh;                                          // 0x0310(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            PostDestructionMesh;                               // 0x0318(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               ImpactParticle;                                    // 0x0320(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     PhysicsImpactDecal;                                // 0x0328(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PhysicsImpactDecalScale;                           // 0x0330(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_334[0x4];                                      // 0x0334(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Multicast_DestroyItem();
	void Multicast_ItemStateToggle();
	void OnHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComponent, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void OnItemDestroyed();
	void OnItemStateToggled();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicInteractableWorldItem">();
	}
	static class ADynamicInteractableWorldItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADynamicInteractableWorldItem>();
	}
};
static_assert(alignof(ADynamicInteractableWorldItem) == 0x000008, "Wrong alignment on ADynamicInteractableWorldItem");
static_assert(sizeof(ADynamicInteractableWorldItem) == 0x000338, "Wrong size on ADynamicInteractableWorldItem");
static_assert(offsetof(ADynamicInteractableWorldItem, bRestartOnToggle) == 0x0002A0, "Member 'ADynamicInteractableWorldItem::bRestartOnToggle' has a wrong offset!");
static_assert(offsetof(ADynamicInteractableWorldItem, bCanToggleIfDestroyed) == 0x0002A1, "Member 'ADynamicInteractableWorldItem::bCanToggleIfDestroyed' has a wrong offset!");
static_assert(offsetof(ADynamicInteractableWorldItem, bItemOn) == 0x0002A2, "Member 'ADynamicInteractableWorldItem::bItemOn' has a wrong offset!");
static_assert(offsetof(ADynamicInteractableWorldItem, bItemDestroyed) == 0x0002A3, "Member 'ADynamicInteractableWorldItem::bItemDestroyed' has a wrong offset!");
static_assert(offsetof(ADynamicInteractableWorldItem, InteractableComponent) == 0x0002A8, "Member 'ADynamicInteractableWorldItem::InteractableComponent' has a wrong offset!");
static_assert(offsetof(ADynamicInteractableWorldItem, InteractAudioFMOD) == 0x0002B0, "Member 'ADynamicInteractableWorldItem::InteractAudioFMOD' has a wrong offset!");
static_assert(offsetof(ADynamicInteractableWorldItem, IntactRunningAudioFMOD1) == 0x0002B8, "Member 'ADynamicInteractableWorldItem::IntactRunningAudioFMOD1' has a wrong offset!");
static_assert(offsetof(ADynamicInteractableWorldItem, DestroyedRunningAudioFMOD) == 0x0002C0, "Member 'ADynamicInteractableWorldItem::DestroyedRunningAudioFMOD' has a wrong offset!");
static_assert(offsetof(ADynamicInteractableWorldItem, ImpactAudioFMOD) == 0x0002C8, "Member 'ADynamicInteractableWorldItem::ImpactAudioFMOD' has a wrong offset!");
static_assert(offsetof(ADynamicInteractableWorldItem, IntactOnMaterials) == 0x0002D0, "Member 'ADynamicInteractableWorldItem::IntactOnMaterials' has a wrong offset!");
static_assert(offsetof(ADynamicInteractableWorldItem, IntactOffMaterials) == 0x0002E0, "Member 'ADynamicInteractableWorldItem::IntactOffMaterials' has a wrong offset!");
static_assert(offsetof(ADynamicInteractableWorldItem, DestroyedOnMaterials) == 0x0002F0, "Member 'ADynamicInteractableWorldItem::DestroyedOnMaterials' has a wrong offset!");
static_assert(offsetof(ADynamicInteractableWorldItem, DestroyedOffMaterials) == 0x000300, "Member 'ADynamicInteractableWorldItem::DestroyedOffMaterials' has a wrong offset!");
static_assert(offsetof(ADynamicInteractableWorldItem, ItemMesh) == 0x000310, "Member 'ADynamicInteractableWorldItem::ItemMesh' has a wrong offset!");
static_assert(offsetof(ADynamicInteractableWorldItem, PostDestructionMesh) == 0x000318, "Member 'ADynamicInteractableWorldItem::PostDestructionMesh' has a wrong offset!");
static_assert(offsetof(ADynamicInteractableWorldItem, ImpactParticle) == 0x000320, "Member 'ADynamicInteractableWorldItem::ImpactParticle' has a wrong offset!");
static_assert(offsetof(ADynamicInteractableWorldItem, PhysicsImpactDecal) == 0x000328, "Member 'ADynamicInteractableWorldItem::PhysicsImpactDecal' has a wrong offset!");
static_assert(offsetof(ADynamicInteractableWorldItem, PhysicsImpactDecalScale) == 0x000330, "Member 'ADynamicInteractableWorldItem::PhysicsImpactDecalScale' has a wrong offset!");

// Class ReadyOrNot.DynamicWorldItem
// 0x0038 (0x02D0 - 0x0298)
class ADynamicWorldItem final : public AActor
{
public:
	class UStaticMeshComponent*                   ItemMesh;                                          // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               ImpactParticle;                                    // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODAudioComponent*                    ImpactAudioFMOD;                                   // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            PostImpactMesh;                                    // 0x02B0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     PostImpactMaterial;                                // 0x02B8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     PhysicsImpactDecal;                                // 0x02C0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PhysicsImpactDecalScale;                           // 0x02C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bItemDestroyed;                                    // 0x02CC(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CD[0x3];                                      // 0x02CD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Multicast_DestroyItem();
	void OnHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComponent, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void OnItemDestroyed();
	void OnRep_ItemDestroyed();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicWorldItem">();
	}
	static class ADynamicWorldItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADynamicWorldItem>();
	}
};
static_assert(alignof(ADynamicWorldItem) == 0x000008, "Wrong alignment on ADynamicWorldItem");
static_assert(sizeof(ADynamicWorldItem) == 0x0002D0, "Wrong size on ADynamicWorldItem");
static_assert(offsetof(ADynamicWorldItem, ItemMesh) == 0x000298, "Member 'ADynamicWorldItem::ItemMesh' has a wrong offset!");
static_assert(offsetof(ADynamicWorldItem, ImpactParticle) == 0x0002A0, "Member 'ADynamicWorldItem::ImpactParticle' has a wrong offset!");
static_assert(offsetof(ADynamicWorldItem, ImpactAudioFMOD) == 0x0002A8, "Member 'ADynamicWorldItem::ImpactAudioFMOD' has a wrong offset!");
static_assert(offsetof(ADynamicWorldItem, PostImpactMesh) == 0x0002B0, "Member 'ADynamicWorldItem::PostImpactMesh' has a wrong offset!");
static_assert(offsetof(ADynamicWorldItem, PostImpactMaterial) == 0x0002B8, "Member 'ADynamicWorldItem::PostImpactMaterial' has a wrong offset!");
static_assert(offsetof(ADynamicWorldItem, PhysicsImpactDecal) == 0x0002C0, "Member 'ADynamicWorldItem::PhysicsImpactDecal' has a wrong offset!");
static_assert(offsetof(ADynamicWorldItem, PhysicsImpactDecalScale) == 0x0002C8, "Member 'ADynamicWorldItem::PhysicsImpactDecalScale' has a wrong offset!");
static_assert(offsetof(ADynamicWorldItem, bItemDestroyed) == 0x0002CC, "Member 'ADynamicWorldItem::bItemDestroyed' has a wrong offset!");

// Class ReadyOrNot.NavQuery_SwatBreachAndClear
// 0x0000 (0x0048 - 0x0048)
class UNavQuery_SwatBreachAndClear final : public UNavQuery_Swat
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavQuery_SwatBreachAndClear">();
	}
	static class UNavQuery_SwatBreachAndClear* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavQuery_SwatBreachAndClear>();
	}
};
static_assert(alignof(UNavQuery_SwatBreachAndClear) == 0x000008, "Wrong alignment on UNavQuery_SwatBreachAndClear");
static_assert(sizeof(UNavQuery_SwatBreachAndClear) == 0x000048, "Wrong size on UNavQuery_SwatBreachAndClear");

// Class ReadyOrNot.ElevatorButtonComponent
// 0x0040 (0x0670 - 0x0630)
class UElevatorButtonComponent final : public UStaticMeshComponent
{
public:
	uint8                                         Pad_628[0x10];                                     // 0x0628(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bOverrideButtonPromptText;                         // 0x0638(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_639[0x7];                                      // 0x0639(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ButtonPromptText;                                  // 0x0640(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class AElevator*                              OwningElevator;                                    // 0x0658(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoorButton;                                       // 0x0660(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoorClose;                                        // 0x0661(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_662[0x2];                                      // 0x0662(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Floor;                                             // 0x0664(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_668[0x8];                                      // 0x0668(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ElevatorButtonComponent">();
	}
	static class UElevatorButtonComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UElevatorButtonComponent>();
	}
};
static_assert(alignof(UElevatorButtonComponent) == 0x000010, "Wrong alignment on UElevatorButtonComponent");
static_assert(sizeof(UElevatorButtonComponent) == 0x000670, "Wrong size on UElevatorButtonComponent");
static_assert(offsetof(UElevatorButtonComponent, bOverrideButtonPromptText) == 0x000638, "Member 'UElevatorButtonComponent::bOverrideButtonPromptText' has a wrong offset!");
static_assert(offsetof(UElevatorButtonComponent, ButtonPromptText) == 0x000640, "Member 'UElevatorButtonComponent::ButtonPromptText' has a wrong offset!");
static_assert(offsetof(UElevatorButtonComponent, OwningElevator) == 0x000658, "Member 'UElevatorButtonComponent::OwningElevator' has a wrong offset!");
static_assert(offsetof(UElevatorButtonComponent, bDoorButton) == 0x000660, "Member 'UElevatorButtonComponent::bDoorButton' has a wrong offset!");
static_assert(offsetof(UElevatorButtonComponent, bDoorClose) == 0x000661, "Member 'UElevatorButtonComponent::bDoorClose' has a wrong offset!");
static_assert(offsetof(UElevatorButtonComponent, Floor) == 0x000664, "Member 'UElevatorButtonComponent::Floor' has a wrong offset!");

// Class ReadyOrNot.EnvQueryContext_GasSafePoints
// 0x0000 (0x0028 - 0x0028)
class UEnvQueryContext_GasSafePoints final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryContext_GasSafePoints">();
	}
	static class UEnvQueryContext_GasSafePoints* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryContext_GasSafePoints>();
	}
};
static_assert(alignof(UEnvQueryContext_GasSafePoints) == 0x000008, "Wrong alignment on UEnvQueryContext_GasSafePoints");
static_assert(sizeof(UEnvQueryContext_GasSafePoints) == 0x000028, "Wrong size on UEnvQueryContext_GasSafePoints");

// Class ReadyOrNot.NavQuery_SwatDelta
// 0x0000 (0x0048 - 0x0048)
class UNavQuery_SwatDelta final : public UNavQuery_Swat
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavQuery_SwatDelta">();
	}
	static class UNavQuery_SwatDelta* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavQuery_SwatDelta>();
	}
};
static_assert(alignof(UNavQuery_SwatDelta) == 0x000008, "Wrong alignment on UNavQuery_SwatDelta");
static_assert(sizeof(UNavQuery_SwatDelta) == 0x000048, "Wrong size on UNavQuery_SwatDelta");

// Class ReadyOrNot.EnvQueryContext_NavProjectedQuerier
// 0x0000 (0x0028 - 0x0028)
class UEnvQueryContext_NavProjectedQuerier final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryContext_NavProjectedQuerier">();
	}
	static class UEnvQueryContext_NavProjectedQuerier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryContext_NavProjectedQuerier>();
	}
};
static_assert(alignof(UEnvQueryContext_NavProjectedQuerier) == 0x000008, "Wrong alignment on UEnvQueryContext_NavProjectedQuerier");
static_assert(sizeof(UEnvQueryContext_NavProjectedQuerier) == 0x000028, "Wrong size on UEnvQueryContext_NavProjectedQuerier");

// Class ReadyOrNot.EnvQueryTest_GasPath
// 0x0070 (0x02F0 - 0x0280)
class UEnvQueryTest_GasPath final : public UEnvQueryTest_Pathfinding
{
public:
	struct FAIDataProviderBoolValue               CalculatePathLengthToAllContexts;                  // 0x0280(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              SafePointsBufferDistance;                          // 0x02B8(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_GasPath">();
	}
	static class UEnvQueryTest_GasPath* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_GasPath>();
	}
};
static_assert(alignof(UEnvQueryTest_GasPath) == 0x000008, "Wrong alignment on UEnvQueryTest_GasPath");
static_assert(sizeof(UEnvQueryTest_GasPath) == 0x0002F0, "Wrong size on UEnvQueryTest_GasPath");
static_assert(offsetof(UEnvQueryTest_GasPath, CalculatePathLengthToAllContexts) == 0x000280, "Member 'UEnvQueryTest_GasPath::CalculatePathLengthToAllContexts' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_GasPath, SafePointsBufferDistance) == 0x0002B8, "Member 'UEnvQueryTest_GasPath::SafePointsBufferDistance' has a wrong offset!");

// Class ReadyOrNot.NavQuery_Suspect
// 0x0000 (0x0048 - 0x0048)
class UNavQuery_Suspect : public UNavigationQueryFilter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavQuery_Suspect">();
	}
	static class UNavQuery_Suspect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavQuery_Suspect>();
	}
};
static_assert(alignof(UNavQuery_Suspect) == 0x000008, "Wrong alignment on UNavQuery_Suspect");
static_assert(sizeof(UNavQuery_Suspect) == 0x000048, "Wrong size on UNavQuery_Suspect");

// Class ReadyOrNot.NavQuery_RepositioningSuspect
// 0x0000 (0x0048 - 0x0048)
class UNavQuery_RepositioningSuspect final : public UNavQuery_Suspect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavQuery_RepositioningSuspect">();
	}
	static class UNavQuery_RepositioningSuspect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavQuery_RepositioningSuspect>();
	}
};
static_assert(alignof(UNavQuery_RepositioningSuspect) == 0x000008, "Wrong alignment on UNavQuery_RepositioningSuspect");
static_assert(sizeof(UNavQuery_RepositioningSuspect) == 0x000048, "Wrong size on UNavQuery_RepositioningSuspect");

// Class ReadyOrNot.EOSMultiplayerStatics
// 0x0000 (0x0028 - 0x0028)
class UEOSMultiplayerStatics final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EOSMultiplayerStatics">();
	}
	static class UEOSMultiplayerStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEOSMultiplayerStatics>();
	}
};
static_assert(alignof(UEOSMultiplayerStatics) == 0x000008, "Wrong alignment on UEOSMultiplayerStatics");
static_assert(sizeof(UEOSMultiplayerStatics) == 0x000028, "Wrong size on UEOSMultiplayerStatics");

// Class ReadyOrNot.NavQuery_NoCSGas
// 0x0000 (0x0048 - 0x0048)
class UNavQuery_NoCSGas final : public UNavigationQueryFilter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavQuery_NoCSGas">();
	}
	static class UNavQuery_NoCSGas* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavQuery_NoCSGas>();
	}
};
static_assert(alignof(UNavQuery_NoCSGas) == 0x000008, "Wrong alignment on UNavQuery_NoCSGas");
static_assert(sizeof(UNavQuery_NoCSGas) == 0x000048, "Wrong size on UNavQuery_NoCSGas");

// Class ReadyOrNot.ReadyOrNotEvidenceSettings
// 0x0028 (0x0060 - 0x0038)
class UReadyOrNotEvidenceSettings final : public UDeveloperSettings
{
public:
	TSoftClassPtr<class UClass>                   DefaultCollectedEvidenceActor;                     // 0x0038(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotEvidenceSettings">();
	}
	static class UReadyOrNotEvidenceSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotEvidenceSettings>();
	}
};
static_assert(alignof(UReadyOrNotEvidenceSettings) == 0x000008, "Wrong alignment on UReadyOrNotEvidenceSettings");
static_assert(sizeof(UReadyOrNotEvidenceSettings) == 0x000060, "Wrong size on UReadyOrNotEvidenceSettings");
static_assert(offsetof(UReadyOrNotEvidenceSettings, DefaultCollectedEvidenceActor) == 0x000038, "Member 'UReadyOrNotEvidenceSettings::DefaultCollectedEvidenceActor' has a wrong offset!");

// Class ReadyOrNot.ReadyOrNotCoverData
// 0x00F8 (0x0128 - 0x0030)
class UReadyOrNotCoverData final : public UDataAsset
{
public:
	struct FCoverDataMain                         CoverData;                                         // 0x0030(0x00F8)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotCoverData">();
	}
	static class UReadyOrNotCoverData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotCoverData>();
	}
};
static_assert(alignof(UReadyOrNotCoverData) == 0x000008, "Wrong alignment on UReadyOrNotCoverData");
static_assert(sizeof(UReadyOrNotCoverData) == 0x000128, "Wrong size on UReadyOrNotCoverData");
static_assert(offsetof(UReadyOrNotCoverData, CoverData) == 0x000030, "Member 'UReadyOrNotCoverData::CoverData' has a wrong offset!");

// Class ReadyOrNot.EvidenceSpawnPoint
// 0x0018 (0x02C8 - 0x02B0)
class AEvidenceSpawnPoint final : public AActorSpawnPoint
{
public:
	TSubclassOf<class AEvidenceActor>             EvidenceActorClass;                                // 0x02B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASplineTrigger_Incrimination*           EvidenceSearchArea;                                // 0x02B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABuildingTrigger_Incrimination*         EvidenceBuilding;                                  // 0x02C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EvidenceSpawnPoint">();
	}
	static class AEvidenceSpawnPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEvidenceSpawnPoint>();
	}
};
static_assert(alignof(AEvidenceSpawnPoint) == 0x000008, "Wrong alignment on AEvidenceSpawnPoint");
static_assert(sizeof(AEvidenceSpawnPoint) == 0x0002C8, "Wrong size on AEvidenceSpawnPoint");
static_assert(offsetof(AEvidenceSpawnPoint, EvidenceActorClass) == 0x0002B0, "Member 'AEvidenceSpawnPoint::EvidenceActorClass' has a wrong offset!");
static_assert(offsetof(AEvidenceSpawnPoint, EvidenceSearchArea) == 0x0002B8, "Member 'AEvidenceSpawnPoint::EvidenceSearchArea' has a wrong offset!");
static_assert(offsetof(AEvidenceSpawnPoint, EvidenceBuilding) == 0x0002C0, "Member 'AEvidenceSpawnPoint::EvidenceBuilding' has a wrong offset!");

// Class ReadyOrNot.ExperienceManager
// 0x0040 (0x00E0 - 0x00A0)
class UExperienceManager final : public UGameStateComponent
{
public:
	class UExperienceDefinition*                  CurrentExperience;                                 // 0x00A0(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A8[0x38];                                      // 0x00A8(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_CurrentExperience();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExperienceManager">();
	}
	static class UExperienceManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExperienceManager>();
	}
};
static_assert(alignof(UExperienceManager) == 0x000008, "Wrong alignment on UExperienceManager");
static_assert(sizeof(UExperienceManager) == 0x0000E0, "Wrong size on UExperienceManager");
static_assert(offsetof(UExperienceManager, CurrentExperience) == 0x0000A0, "Member 'UExperienceManager::CurrentExperience' has a wrong offset!");

// Class ReadyOrNot.ReadyOrNotGameUserSettings
// 0x0210 (0x0358 - 0x0148)
class UReadyOrNotGameUserSettings final : public UGameUserSettings
{
public:
	uint8                                         Pad_148[0x18];                                     // 0x0148(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MasterSoundVolume;                                 // 0x0160(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MusicSoundVolume;                                  // 0x0164(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UISoundVolume;                                     // 0x0168(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SFXSoundVolume;                                    // 0x016C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VOIPVolume;                                        // 0x0170(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVoiceType                                    DefaultVOIPChannel;                                // 0x0174(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHitmarkerSfxEnabled;                              // 0x0175(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_176[0x2];                                      // 0x0176(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MouseSensitivity;                                  // 0x0178(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FreelookSensitivity;                               // 0x017C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamepadLookSensitivityVertical;                    // 0x0180(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamepadLookSensitivityHorizontal;                  // 0x0184(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamepadAimSensitivityVertical;                     // 0x0188(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamepadAimSensitivityHorizontal;                   // 0x018C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamepadLookSensitivitySpeedUp;                     // 0x0190(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamepadMovementInnerDeadzone;                      // 0x0194(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamepadLookInnerDeadzone;                          // 0x0198(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GyroVerticalLookSensitivity;                       // 0x019C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GyroHorizontalLookSensitivity;                     // 0x01A0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GyroVerticalAimSensitivity;                        // 0x01A4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GyroHorizontalAimSensitivity;                      // 0x01A8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AC[0x4];                                      // 0x01AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AimAssistIntensity;                                // 0x01B0(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RadialMenuUseLeftStick;                            // 0x01C0(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RadialMenuRequireShoulderRelease;                  // 0x01C1(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C2[0x6];                                      // 0x01C2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 GyroActiveMode;                                    // 0x01C8(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ForceFeedbackEnabled;                              // 0x01D8(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D9[0x3];                                      // 0x01D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ForceFeedbackIntensity;                            // 0x01DC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TargetLocale;                                      // 0x01E0(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FieldOfView;                                       // 0x01F0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponFieldOfView;                                 // 0x01F4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LadderRollSensitivity;                             // 0x01F8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bToggleADS;                                        // 0x01FC(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHoldCrouch;                                       // 0x01FD(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPS5AdaptiveFireTriggers;                          // 0x01FE(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPS5AdaptiveAimTriggers;                           // 0x01FF(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTogglePS5Gyro;                                    // 0x0200(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvertStickLayout;                                // 0x0201(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvertButtonLayout;                               // 0x0202(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvertTriggersLayout;                             // 0x0203(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvertGyroVertical;                               // 0x0204(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvertGyroHorizontal;                             // 0x0205(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsingAlternateControls;                           // 0x0206(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_207[0x1];                                      // 0x0207(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxShellsInWorld;                                  // 0x0208(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxShellLifeTime;                                  // 0x020C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseMeshPainting;                                  // 0x0210(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_211[0x7];                                      // 0x0211(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LastConnectedServerIP;                             // 0x0218(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IconScale;                                         // 0x0228(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         QuickThrowScale;                                   // 0x022C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWorldDecalsEnabled;                               // 0x0230(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_231[0x3];                                      // 0x0231(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WorldDecalScreenFadeSize;                          // 0x0234(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WorldDecalDensity;                                 // 0x0238(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FireModeDisplayOption;                             // 0x023C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamViewFPS;                                       // 0x0240(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTeamViewFPSEnabled;                               // 0x0244(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowFPS;                                          // 0x0245(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowHUD;                                          // 0x0246(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowCompass;                                      // 0x0247(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowWeaponHUD;                                    // 0x0248(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowMagazineHUD;                                  // 0x0249(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowChat;                                         // 0x024A(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableHUDSwaying;                                 // 0x024B(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowHotkeyHints;                                  // 0x024C(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowHealthIcons;                                  // 0x024D(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowCommandContextHint;                           // 0x024E(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bZoomADS;                                          // 0x024F(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSendMapStatistics;                                // 0x0250(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EScoreReadoutMode                             ScoreReadoutMode;                                  // 0x0251(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESwatCommand                                  DefaultCommand;                                    // 0x0252(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESwatCommand                                  DefaultDoorUnknownCommand;                         // 0x0253(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESwatCommand                                  DefaultDoorOpenCommand;                            // 0x0254(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESwatCommand                                  DefaultDoorLockedCommand;                          // 0x0255(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESwatCommand                                  DefaultDoorUnlockedCommand;                        // 0x0256(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_257[0x1];                                      // 0x0257(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DefaultCommandOption;                              // 0x0258(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ViewDistanceQuality;                               // 0x025C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AntiAliasingQuality;                               // 0x0260(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ShadowQuality;                                     // 0x0264(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PostProcessQuality;                                // 0x0268(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TextureQuality;                                    // 0x026C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EffectsQuality;                                    // 0x0270(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GlobalIlluminationQuality;                         // 0x0274(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReflectionQuality;                                 // 0x0278(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnablePerObjectShadows;                           // 0x027C(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27D[0x3];                                      // 0x027D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DefaultDoorUnknownCommandOption;                   // 0x0280(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultDoorOpenCommandOption;                      // 0x0284(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultDoorLockedCommandOption;                    // 0x0288(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultDoorUnlockedCommandOption;                  // 0x028C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCurvedHUD;                                        // 0x0290(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          b2DReloadIcons;                                    // 0x0291(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowPlayerNamePlates;                             // 0x0292(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowPlayerIcon;                                   // 0x0293(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowTeamStatus;                                   // 0x0294(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMirrorReflectionEnabled;                          // 0x0295(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMirrorInLobbyOnly;                                // 0x0296(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_297[0x1];                                      // 0x0297(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MirrorFPS;                                         // 0x0298(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PiPFPS;                                            // 0x029C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPiPFPSEnabled;                                    // 0x02A0(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDepthOfField;                                     // 0x02A1(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMotionBlur;                                       // 0x02A2(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A3[0x1];                                      // 0x02A3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MotionBlurStrength;                                // 0x02A4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PiPResolutionScale;                                // 0x02A8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SafeZoneX;                                         // 0x02AC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SafeZoneY;                                         // 0x02B0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GraphicsPresetIndex;                               // 0x02B4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowButtonPrompts;                                // 0x02B8(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvertMousePitch;                                 // 0x02B9(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvertMouseYaw;                                   // 0x02BA(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvertGamepadHorizontal;                          // 0x02BB(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvertGamepadVertical;                            // 0x02BC(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExperimentalFeatures;                             // 0x02BD(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowControlsOnScreen;                             // 0x02BE(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowHesitationBar;                                // 0x02BF(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRayTracingEnabled;                                // 0x02C0(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRayTracingReflectionsEnabled;                     // 0x02C1(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRayTracingShadowsEnabled;                         // 0x02C2(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRayTracingAmbientOcclusionEnabled;                // 0x02C3(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C4[0x4];                                      // 0x02C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DlssQualitySetting;                                // 0x02C8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FrameGenerationSetting;                            // 0x02CC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FSRQualitySetting;                                 // 0x02D0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MicInputGain;                                      // 0x02D4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InputAudioDevice;                                  // 0x02D8(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFrameLimitEnabled;                                // 0x02E8(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemSelectionInterfaceType                   ItemSelectionInterface;                            // 0x02E9(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGrenadeThrowSettingType                      GrenadeThrowType;                                  // 0x02EA(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EShotgunReloadType                            ShotgunLoadType;                                   // 0x02EB(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEmptyMagReloadType                           EmptyMagReloadType;                                // 0x02EC(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOptiwandViewMode                             OptiwandViewMode;                                  // 0x02ED(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EE[0x2];                                      // 0x02EE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DMOAddress;                                        // 0x02F0(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DMOGameMode;                                       // 0x0300(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETeamType                                     DMOTeamType;                                       // 0x0310(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_311[0x3];                                      // 0x0311(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMirrorReflectionSettings              MirrorReflectionSettings;                          // 0x0314(0x0008)(Config, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUseHighReadyStyle;                                // 0x031C(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBounceLightEnabled;                               // 0x031D(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFlashlightShadowsEnabled;                         // 0x031E(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bServerSideChecksum;                               // 0x031F(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ReflexMode;                                        // 0x0320(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReflexGameToRenderLatencyInMSEnabled;             // 0x0321(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReflexGameLatencyInMSEnabled;                     // 0x0322(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReflexRenderLatencyInMSEnabled;                   // 0x0323(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReflexFlashIndicatorEnabled;                      // 0x0324(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EColorVisionDeficiency                        ColorVisionDeficiency;                             // 0x0325(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_326[0x2];                                      // 0x0326(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ColorVisionDeficiencyStrength;                     // 0x0328(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHighlightWeapons;                                 // 0x032C(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWorldSpaceActionPrompts;                          // 0x032D(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32E[0x2];                                      // 0x032E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InterfaceAspectRatio;                              // 0x0330(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableSubtitles;                                  // 0x0334(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESubtitlesSize                                SubtitlesSize;                                     // 0x0335(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_336[0x2];                                      // 0x0336(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SubtitlesLocale;                                   // 0x0338(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SubtitlesBackgroundOpacity;                        // 0x0348(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SubtitlesSpeed;                                    // 0x034C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReplayEnabled;                                    // 0x0350(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_351[0x3];                                      // 0x0351(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UserInterfaceScale;                                // 0x0354(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static void ResetKeybinds();

	void ResetAccessibilityOptions();
	void ResetAudioOptions();
	void ResetGamepadControlsSettings();
	void ResetGamepadRadialMenuSettings();
	void ResetGamepadSchemeSettings();
	void ResetGameplayOptions();
	void ResetGraphicsOptions();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotGameUserSettings">();
	}
	static class UReadyOrNotGameUserSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotGameUserSettings>();
	}
};
static_assert(alignof(UReadyOrNotGameUserSettings) == 0x000008, "Wrong alignment on UReadyOrNotGameUserSettings");
static_assert(sizeof(UReadyOrNotGameUserSettings) == 0x000358, "Wrong size on UReadyOrNotGameUserSettings");
static_assert(offsetof(UReadyOrNotGameUserSettings, MasterSoundVolume) == 0x000160, "Member 'UReadyOrNotGameUserSettings::MasterSoundVolume' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, MusicSoundVolume) == 0x000164, "Member 'UReadyOrNotGameUserSettings::MusicSoundVolume' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, UISoundVolume) == 0x000168, "Member 'UReadyOrNotGameUserSettings::UISoundVolume' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, SFXSoundVolume) == 0x00016C, "Member 'UReadyOrNotGameUserSettings::SFXSoundVolume' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, VOIPVolume) == 0x000170, "Member 'UReadyOrNotGameUserSettings::VOIPVolume' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, DefaultVOIPChannel) == 0x000174, "Member 'UReadyOrNotGameUserSettings::DefaultVOIPChannel' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bHitmarkerSfxEnabled) == 0x000175, "Member 'UReadyOrNotGameUserSettings::bHitmarkerSfxEnabled' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, MouseSensitivity) == 0x000178, "Member 'UReadyOrNotGameUserSettings::MouseSensitivity' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, FreelookSensitivity) == 0x00017C, "Member 'UReadyOrNotGameUserSettings::FreelookSensitivity' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, GamepadLookSensitivityVertical) == 0x000180, "Member 'UReadyOrNotGameUserSettings::GamepadLookSensitivityVertical' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, GamepadLookSensitivityHorizontal) == 0x000184, "Member 'UReadyOrNotGameUserSettings::GamepadLookSensitivityHorizontal' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, GamepadAimSensitivityVertical) == 0x000188, "Member 'UReadyOrNotGameUserSettings::GamepadAimSensitivityVertical' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, GamepadAimSensitivityHorizontal) == 0x00018C, "Member 'UReadyOrNotGameUserSettings::GamepadAimSensitivityHorizontal' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, GamepadLookSensitivitySpeedUp) == 0x000190, "Member 'UReadyOrNotGameUserSettings::GamepadLookSensitivitySpeedUp' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, GamepadMovementInnerDeadzone) == 0x000194, "Member 'UReadyOrNotGameUserSettings::GamepadMovementInnerDeadzone' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, GamepadLookInnerDeadzone) == 0x000198, "Member 'UReadyOrNotGameUserSettings::GamepadLookInnerDeadzone' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, GyroVerticalLookSensitivity) == 0x00019C, "Member 'UReadyOrNotGameUserSettings::GyroVerticalLookSensitivity' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, GyroHorizontalLookSensitivity) == 0x0001A0, "Member 'UReadyOrNotGameUserSettings::GyroHorizontalLookSensitivity' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, GyroVerticalAimSensitivity) == 0x0001A4, "Member 'UReadyOrNotGameUserSettings::GyroVerticalAimSensitivity' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, GyroHorizontalAimSensitivity) == 0x0001A8, "Member 'UReadyOrNotGameUserSettings::GyroHorizontalAimSensitivity' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, AimAssistIntensity) == 0x0001B0, "Member 'UReadyOrNotGameUserSettings::AimAssistIntensity' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, RadialMenuUseLeftStick) == 0x0001C0, "Member 'UReadyOrNotGameUserSettings::RadialMenuUseLeftStick' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, RadialMenuRequireShoulderRelease) == 0x0001C1, "Member 'UReadyOrNotGameUserSettings::RadialMenuRequireShoulderRelease' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, GyroActiveMode) == 0x0001C8, "Member 'UReadyOrNotGameUserSettings::GyroActiveMode' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, ForceFeedbackEnabled) == 0x0001D8, "Member 'UReadyOrNotGameUserSettings::ForceFeedbackEnabled' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, ForceFeedbackIntensity) == 0x0001DC, "Member 'UReadyOrNotGameUserSettings::ForceFeedbackIntensity' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, TargetLocale) == 0x0001E0, "Member 'UReadyOrNotGameUserSettings::TargetLocale' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, FieldOfView) == 0x0001F0, "Member 'UReadyOrNotGameUserSettings::FieldOfView' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, WeaponFieldOfView) == 0x0001F4, "Member 'UReadyOrNotGameUserSettings::WeaponFieldOfView' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, LadderRollSensitivity) == 0x0001F8, "Member 'UReadyOrNotGameUserSettings::LadderRollSensitivity' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bToggleADS) == 0x0001FC, "Member 'UReadyOrNotGameUserSettings::bToggleADS' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bHoldCrouch) == 0x0001FD, "Member 'UReadyOrNotGameUserSettings::bHoldCrouch' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bPS5AdaptiveFireTriggers) == 0x0001FE, "Member 'UReadyOrNotGameUserSettings::bPS5AdaptiveFireTriggers' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bPS5AdaptiveAimTriggers) == 0x0001FF, "Member 'UReadyOrNotGameUserSettings::bPS5AdaptiveAimTriggers' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bTogglePS5Gyro) == 0x000200, "Member 'UReadyOrNotGameUserSettings::bTogglePS5Gyro' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bInvertStickLayout) == 0x000201, "Member 'UReadyOrNotGameUserSettings::bInvertStickLayout' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bInvertButtonLayout) == 0x000202, "Member 'UReadyOrNotGameUserSettings::bInvertButtonLayout' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bInvertTriggersLayout) == 0x000203, "Member 'UReadyOrNotGameUserSettings::bInvertTriggersLayout' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bInvertGyroVertical) == 0x000204, "Member 'UReadyOrNotGameUserSettings::bInvertGyroVertical' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bInvertGyroHorizontal) == 0x000205, "Member 'UReadyOrNotGameUserSettings::bInvertGyroHorizontal' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bUsingAlternateControls) == 0x000206, "Member 'UReadyOrNotGameUserSettings::bUsingAlternateControls' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, MaxShellsInWorld) == 0x000208, "Member 'UReadyOrNotGameUserSettings::MaxShellsInWorld' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, MaxShellLifeTime) == 0x00020C, "Member 'UReadyOrNotGameUserSettings::MaxShellLifeTime' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bUseMeshPainting) == 0x000210, "Member 'UReadyOrNotGameUserSettings::bUseMeshPainting' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, LastConnectedServerIP) == 0x000218, "Member 'UReadyOrNotGameUserSettings::LastConnectedServerIP' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, IconScale) == 0x000228, "Member 'UReadyOrNotGameUserSettings::IconScale' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, QuickThrowScale) == 0x00022C, "Member 'UReadyOrNotGameUserSettings::QuickThrowScale' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bWorldDecalsEnabled) == 0x000230, "Member 'UReadyOrNotGameUserSettings::bWorldDecalsEnabled' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, WorldDecalScreenFadeSize) == 0x000234, "Member 'UReadyOrNotGameUserSettings::WorldDecalScreenFadeSize' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, WorldDecalDensity) == 0x000238, "Member 'UReadyOrNotGameUserSettings::WorldDecalDensity' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, FireModeDisplayOption) == 0x00023C, "Member 'UReadyOrNotGameUserSettings::FireModeDisplayOption' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, TeamViewFPS) == 0x000240, "Member 'UReadyOrNotGameUserSettings::TeamViewFPS' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bTeamViewFPSEnabled) == 0x000244, "Member 'UReadyOrNotGameUserSettings::bTeamViewFPSEnabled' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bShowFPS) == 0x000245, "Member 'UReadyOrNotGameUserSettings::bShowFPS' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bShowHUD) == 0x000246, "Member 'UReadyOrNotGameUserSettings::bShowHUD' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bShowCompass) == 0x000247, "Member 'UReadyOrNotGameUserSettings::bShowCompass' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bShowWeaponHUD) == 0x000248, "Member 'UReadyOrNotGameUserSettings::bShowWeaponHUD' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bShowMagazineHUD) == 0x000249, "Member 'UReadyOrNotGameUserSettings::bShowMagazineHUD' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bShowChat) == 0x00024A, "Member 'UReadyOrNotGameUserSettings::bShowChat' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bEnableHUDSwaying) == 0x00024B, "Member 'UReadyOrNotGameUserSettings::bEnableHUDSwaying' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bShowHotkeyHints) == 0x00024C, "Member 'UReadyOrNotGameUserSettings::bShowHotkeyHints' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bShowHealthIcons) == 0x00024D, "Member 'UReadyOrNotGameUserSettings::bShowHealthIcons' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bShowCommandContextHint) == 0x00024E, "Member 'UReadyOrNotGameUserSettings::bShowCommandContextHint' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bZoomADS) == 0x00024F, "Member 'UReadyOrNotGameUserSettings::bZoomADS' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bSendMapStatistics) == 0x000250, "Member 'UReadyOrNotGameUserSettings::bSendMapStatistics' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, ScoreReadoutMode) == 0x000251, "Member 'UReadyOrNotGameUserSettings::ScoreReadoutMode' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, DefaultCommand) == 0x000252, "Member 'UReadyOrNotGameUserSettings::DefaultCommand' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, DefaultDoorUnknownCommand) == 0x000253, "Member 'UReadyOrNotGameUserSettings::DefaultDoorUnknownCommand' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, DefaultDoorOpenCommand) == 0x000254, "Member 'UReadyOrNotGameUserSettings::DefaultDoorOpenCommand' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, DefaultDoorLockedCommand) == 0x000255, "Member 'UReadyOrNotGameUserSettings::DefaultDoorLockedCommand' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, DefaultDoorUnlockedCommand) == 0x000256, "Member 'UReadyOrNotGameUserSettings::DefaultDoorUnlockedCommand' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, DefaultCommandOption) == 0x000258, "Member 'UReadyOrNotGameUserSettings::DefaultCommandOption' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, ViewDistanceQuality) == 0x00025C, "Member 'UReadyOrNotGameUserSettings::ViewDistanceQuality' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, AntiAliasingQuality) == 0x000260, "Member 'UReadyOrNotGameUserSettings::AntiAliasingQuality' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, ShadowQuality) == 0x000264, "Member 'UReadyOrNotGameUserSettings::ShadowQuality' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, PostProcessQuality) == 0x000268, "Member 'UReadyOrNotGameUserSettings::PostProcessQuality' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, TextureQuality) == 0x00026C, "Member 'UReadyOrNotGameUserSettings::TextureQuality' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, EffectsQuality) == 0x000270, "Member 'UReadyOrNotGameUserSettings::EffectsQuality' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, GlobalIlluminationQuality) == 0x000274, "Member 'UReadyOrNotGameUserSettings::GlobalIlluminationQuality' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, ReflectionQuality) == 0x000278, "Member 'UReadyOrNotGameUserSettings::ReflectionQuality' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bEnablePerObjectShadows) == 0x00027C, "Member 'UReadyOrNotGameUserSettings::bEnablePerObjectShadows' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, DefaultDoorUnknownCommandOption) == 0x000280, "Member 'UReadyOrNotGameUserSettings::DefaultDoorUnknownCommandOption' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, DefaultDoorOpenCommandOption) == 0x000284, "Member 'UReadyOrNotGameUserSettings::DefaultDoorOpenCommandOption' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, DefaultDoorLockedCommandOption) == 0x000288, "Member 'UReadyOrNotGameUserSettings::DefaultDoorLockedCommandOption' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, DefaultDoorUnlockedCommandOption) == 0x00028C, "Member 'UReadyOrNotGameUserSettings::DefaultDoorUnlockedCommandOption' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bCurvedHUD) == 0x000290, "Member 'UReadyOrNotGameUserSettings::bCurvedHUD' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, b2DReloadIcons) == 0x000291, "Member 'UReadyOrNotGameUserSettings::b2DReloadIcons' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bShowPlayerNamePlates) == 0x000292, "Member 'UReadyOrNotGameUserSettings::bShowPlayerNamePlates' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bShowPlayerIcon) == 0x000293, "Member 'UReadyOrNotGameUserSettings::bShowPlayerIcon' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bShowTeamStatus) == 0x000294, "Member 'UReadyOrNotGameUserSettings::bShowTeamStatus' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bMirrorReflectionEnabled) == 0x000295, "Member 'UReadyOrNotGameUserSettings::bMirrorReflectionEnabled' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bMirrorInLobbyOnly) == 0x000296, "Member 'UReadyOrNotGameUserSettings::bMirrorInLobbyOnly' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, MirrorFPS) == 0x000298, "Member 'UReadyOrNotGameUserSettings::MirrorFPS' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, PiPFPS) == 0x00029C, "Member 'UReadyOrNotGameUserSettings::PiPFPS' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bPiPFPSEnabled) == 0x0002A0, "Member 'UReadyOrNotGameUserSettings::bPiPFPSEnabled' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bDepthOfField) == 0x0002A1, "Member 'UReadyOrNotGameUserSettings::bDepthOfField' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bMotionBlur) == 0x0002A2, "Member 'UReadyOrNotGameUserSettings::bMotionBlur' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, MotionBlurStrength) == 0x0002A4, "Member 'UReadyOrNotGameUserSettings::MotionBlurStrength' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, PiPResolutionScale) == 0x0002A8, "Member 'UReadyOrNotGameUserSettings::PiPResolutionScale' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, SafeZoneX) == 0x0002AC, "Member 'UReadyOrNotGameUserSettings::SafeZoneX' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, SafeZoneY) == 0x0002B0, "Member 'UReadyOrNotGameUserSettings::SafeZoneY' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, GraphicsPresetIndex) == 0x0002B4, "Member 'UReadyOrNotGameUserSettings::GraphicsPresetIndex' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bShowButtonPrompts) == 0x0002B8, "Member 'UReadyOrNotGameUserSettings::bShowButtonPrompts' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bInvertMousePitch) == 0x0002B9, "Member 'UReadyOrNotGameUserSettings::bInvertMousePitch' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bInvertMouseYaw) == 0x0002BA, "Member 'UReadyOrNotGameUserSettings::bInvertMouseYaw' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bInvertGamepadHorizontal) == 0x0002BB, "Member 'UReadyOrNotGameUserSettings::bInvertGamepadHorizontal' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bInvertGamepadVertical) == 0x0002BC, "Member 'UReadyOrNotGameUserSettings::bInvertGamepadVertical' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bExperimentalFeatures) == 0x0002BD, "Member 'UReadyOrNotGameUserSettings::bExperimentalFeatures' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bShowControlsOnScreen) == 0x0002BE, "Member 'UReadyOrNotGameUserSettings::bShowControlsOnScreen' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bShowHesitationBar) == 0x0002BF, "Member 'UReadyOrNotGameUserSettings::bShowHesitationBar' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bRayTracingEnabled) == 0x0002C0, "Member 'UReadyOrNotGameUserSettings::bRayTracingEnabled' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bRayTracingReflectionsEnabled) == 0x0002C1, "Member 'UReadyOrNotGameUserSettings::bRayTracingReflectionsEnabled' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bRayTracingShadowsEnabled) == 0x0002C2, "Member 'UReadyOrNotGameUserSettings::bRayTracingShadowsEnabled' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bRayTracingAmbientOcclusionEnabled) == 0x0002C3, "Member 'UReadyOrNotGameUserSettings::bRayTracingAmbientOcclusionEnabled' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, DlssQualitySetting) == 0x0002C8, "Member 'UReadyOrNotGameUserSettings::DlssQualitySetting' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, FrameGenerationSetting) == 0x0002CC, "Member 'UReadyOrNotGameUserSettings::FrameGenerationSetting' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, FSRQualitySetting) == 0x0002D0, "Member 'UReadyOrNotGameUserSettings::FSRQualitySetting' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, MicInputGain) == 0x0002D4, "Member 'UReadyOrNotGameUserSettings::MicInputGain' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, InputAudioDevice) == 0x0002D8, "Member 'UReadyOrNotGameUserSettings::InputAudioDevice' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bFrameLimitEnabled) == 0x0002E8, "Member 'UReadyOrNotGameUserSettings::bFrameLimitEnabled' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, ItemSelectionInterface) == 0x0002E9, "Member 'UReadyOrNotGameUserSettings::ItemSelectionInterface' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, GrenadeThrowType) == 0x0002EA, "Member 'UReadyOrNotGameUserSettings::GrenadeThrowType' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, ShotgunLoadType) == 0x0002EB, "Member 'UReadyOrNotGameUserSettings::ShotgunLoadType' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, EmptyMagReloadType) == 0x0002EC, "Member 'UReadyOrNotGameUserSettings::EmptyMagReloadType' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, OptiwandViewMode) == 0x0002ED, "Member 'UReadyOrNotGameUserSettings::OptiwandViewMode' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, DMOAddress) == 0x0002F0, "Member 'UReadyOrNotGameUserSettings::DMOAddress' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, DMOGameMode) == 0x000300, "Member 'UReadyOrNotGameUserSettings::DMOGameMode' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, DMOTeamType) == 0x000310, "Member 'UReadyOrNotGameUserSettings::DMOTeamType' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, MirrorReflectionSettings) == 0x000314, "Member 'UReadyOrNotGameUserSettings::MirrorReflectionSettings' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bUseHighReadyStyle) == 0x00031C, "Member 'UReadyOrNotGameUserSettings::bUseHighReadyStyle' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bBounceLightEnabled) == 0x00031D, "Member 'UReadyOrNotGameUserSettings::bBounceLightEnabled' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bFlashlightShadowsEnabled) == 0x00031E, "Member 'UReadyOrNotGameUserSettings::bFlashlightShadowsEnabled' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bServerSideChecksum) == 0x00031F, "Member 'UReadyOrNotGameUserSettings::bServerSideChecksum' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, ReflexMode) == 0x000320, "Member 'UReadyOrNotGameUserSettings::ReflexMode' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bReflexGameToRenderLatencyInMSEnabled) == 0x000321, "Member 'UReadyOrNotGameUserSettings::bReflexGameToRenderLatencyInMSEnabled' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bReflexGameLatencyInMSEnabled) == 0x000322, "Member 'UReadyOrNotGameUserSettings::bReflexGameLatencyInMSEnabled' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bReflexRenderLatencyInMSEnabled) == 0x000323, "Member 'UReadyOrNotGameUserSettings::bReflexRenderLatencyInMSEnabled' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bReflexFlashIndicatorEnabled) == 0x000324, "Member 'UReadyOrNotGameUserSettings::bReflexFlashIndicatorEnabled' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, ColorVisionDeficiency) == 0x000325, "Member 'UReadyOrNotGameUserSettings::ColorVisionDeficiency' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, ColorVisionDeficiencyStrength) == 0x000328, "Member 'UReadyOrNotGameUserSettings::ColorVisionDeficiencyStrength' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bHighlightWeapons) == 0x00032C, "Member 'UReadyOrNotGameUserSettings::bHighlightWeapons' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bWorldSpaceActionPrompts) == 0x00032D, "Member 'UReadyOrNotGameUserSettings::bWorldSpaceActionPrompts' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, InterfaceAspectRatio) == 0x000330, "Member 'UReadyOrNotGameUserSettings::InterfaceAspectRatio' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bEnableSubtitles) == 0x000334, "Member 'UReadyOrNotGameUserSettings::bEnableSubtitles' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, SubtitlesSize) == 0x000335, "Member 'UReadyOrNotGameUserSettings::SubtitlesSize' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, SubtitlesLocale) == 0x000338, "Member 'UReadyOrNotGameUserSettings::SubtitlesLocale' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, SubtitlesBackgroundOpacity) == 0x000348, "Member 'UReadyOrNotGameUserSettings::SubtitlesBackgroundOpacity' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, SubtitlesSpeed) == 0x00034C, "Member 'UReadyOrNotGameUserSettings::SubtitlesSpeed' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, bReplayEnabled) == 0x000350, "Member 'UReadyOrNotGameUserSettings::bReplayEnabled' has a wrong offset!");
static_assert(offsetof(UReadyOrNotGameUserSettings, UserInterfaceScale) == 0x000354, "Member 'UReadyOrNotGameUserSettings::UserInterfaceScale' has a wrong offset!");

// Class ReadyOrNot.ExplosiveContainer
// 0x0058 (0x02F0 - 0x0298)
class AExplosiveContainer final : public AActor
{
public:
	class UStaticMeshComponent*                   BaseMesh;                                          // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystemComponent*               FireEffectParticle;                                // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystemComponent*               ExplosionEffectParticle;                           // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODAudioComponent*                    FMODFireAudioComponent;                            // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B8[0x2];                                      // 0x02B8(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bHideMeshAfterDetonation;                          // 0x02BA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BB[0x5];                                      // 0x02BB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     ScorchDecal;                                       // 0x02C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             FMODExplosionAudio;                                // 0x02C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UStunDamage>                StunDamageType;                                    // 0x02D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ULegacyCameraShake>         ExplosionScreenShake;                              // 0x02D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            ExplosionInstigator;                               // 0x02E0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimerUntilExplosionOnceTriggered;                  // 0x02E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDamageToTrigger;                                // 0x02EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void Multicast_PlayExplosionEffects();
	void Multicast_TriggerExplosive();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExplosiveContainer">();
	}
	static class AExplosiveContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AExplosiveContainer>();
	}
};
static_assert(alignof(AExplosiveContainer) == 0x000008, "Wrong alignment on AExplosiveContainer");
static_assert(sizeof(AExplosiveContainer) == 0x0002F0, "Wrong size on AExplosiveContainer");
static_assert(offsetof(AExplosiveContainer, BaseMesh) == 0x000298, "Member 'AExplosiveContainer::BaseMesh' has a wrong offset!");
static_assert(offsetof(AExplosiveContainer, FireEffectParticle) == 0x0002A0, "Member 'AExplosiveContainer::FireEffectParticle' has a wrong offset!");
static_assert(offsetof(AExplosiveContainer, ExplosionEffectParticle) == 0x0002A8, "Member 'AExplosiveContainer::ExplosionEffectParticle' has a wrong offset!");
static_assert(offsetof(AExplosiveContainer, FMODFireAudioComponent) == 0x0002B0, "Member 'AExplosiveContainer::FMODFireAudioComponent' has a wrong offset!");
static_assert(offsetof(AExplosiveContainer, bHideMeshAfterDetonation) == 0x0002BA, "Member 'AExplosiveContainer::bHideMeshAfterDetonation' has a wrong offset!");
static_assert(offsetof(AExplosiveContainer, ScorchDecal) == 0x0002C0, "Member 'AExplosiveContainer::ScorchDecal' has a wrong offset!");
static_assert(offsetof(AExplosiveContainer, FMODExplosionAudio) == 0x0002C8, "Member 'AExplosiveContainer::FMODExplosionAudio' has a wrong offset!");
static_assert(offsetof(AExplosiveContainer, StunDamageType) == 0x0002D0, "Member 'AExplosiveContainer::StunDamageType' has a wrong offset!");
static_assert(offsetof(AExplosiveContainer, ExplosionScreenShake) == 0x0002D8, "Member 'AExplosiveContainer::ExplosionScreenShake' has a wrong offset!");
static_assert(offsetof(AExplosiveContainer, ExplosionInstigator) == 0x0002E0, "Member 'AExplosiveContainer::ExplosionInstigator' has a wrong offset!");
static_assert(offsetof(AExplosiveContainer, TimerUntilExplosionOnceTriggered) == 0x0002E8, "Member 'AExplosiveContainer::TimerUntilExplosionOnceTriggered' has a wrong offset!");
static_assert(offsetof(AExplosiveContainer, MinDamageToTrigger) == 0x0002EC, "Member 'AExplosiveContainer::MinDamageToTrigger' has a wrong offset!");

// Class ReadyOrNot.ExplosiveVest
// 0x0080 (0x0D30 - 0x0CB0)
class AExplosiveVest : public ASuspectArmour
{
public:
	uint8                                         Pad_CB0[0x10];                                     // 0x0CB0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bShouldExplodeOnHit;                               // 0x0CC0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldExplodeOnDeath;                             // 0x0CC1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisarmed;                                         // 0x0CC2(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CC3[0x5];                                      // 0x0CC3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UDamageType>                ExplosionDamageType;                               // 0x0CC8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDamageOnDetonation;                             // 0x0CD0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDamageOnDetonation;                             // 0x0CD4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageInnerRadius;                                 // 0x0CD8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageOuterRadius;                                 // 0x0CDC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplosionEffectDelay;                              // 0x0CE0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplosionEffectRandomDelay;                        // 0x0CE4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplosionDamageDelay;                              // 0x0CE8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CEC[0x4];                                      // 0x0CEC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DetonationMontage;                                 // 0x0CF0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ExplosiveVestSocket;                               // 0x0D00(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        ExplosionParticle;                                 // 0x0D08(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             ExplosionEvent;                                    // 0x0D10(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             DetonationEvent;                                   // 0x0D18(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ULegacyCameraShake>         ExplosionScreenShake;                              // 0x0D20(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplosionScreenShakeRadius;                        // 0x0D28(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D2C[0x4];                                      // 0x0D2C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Disarm();
	void ExplodeVest();
	void Multicast_PlayExplosionEffects();
	void Multicast_PlayPreExplosionEffects();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExplosiveVest">();
	}
	static class AExplosiveVest* GetDefaultObj()
	{
		return GetDefaultObjImpl<AExplosiveVest>();
	}
};
static_assert(alignof(AExplosiveVest) == 0x000010, "Wrong alignment on AExplosiveVest");
static_assert(sizeof(AExplosiveVest) == 0x000D30, "Wrong size on AExplosiveVest");
static_assert(offsetof(AExplosiveVest, bShouldExplodeOnHit) == 0x000CC0, "Member 'AExplosiveVest::bShouldExplodeOnHit' has a wrong offset!");
static_assert(offsetof(AExplosiveVest, bShouldExplodeOnDeath) == 0x000CC1, "Member 'AExplosiveVest::bShouldExplodeOnDeath' has a wrong offset!");
static_assert(offsetof(AExplosiveVest, bDisarmed) == 0x000CC2, "Member 'AExplosiveVest::bDisarmed' has a wrong offset!");
static_assert(offsetof(AExplosiveVest, ExplosionDamageType) == 0x000CC8, "Member 'AExplosiveVest::ExplosionDamageType' has a wrong offset!");
static_assert(offsetof(AExplosiveVest, MaxDamageOnDetonation) == 0x000CD0, "Member 'AExplosiveVest::MaxDamageOnDetonation' has a wrong offset!");
static_assert(offsetof(AExplosiveVest, MinDamageOnDetonation) == 0x000CD4, "Member 'AExplosiveVest::MinDamageOnDetonation' has a wrong offset!");
static_assert(offsetof(AExplosiveVest, DamageInnerRadius) == 0x000CD8, "Member 'AExplosiveVest::DamageInnerRadius' has a wrong offset!");
static_assert(offsetof(AExplosiveVest, DamageOuterRadius) == 0x000CDC, "Member 'AExplosiveVest::DamageOuterRadius' has a wrong offset!");
static_assert(offsetof(AExplosiveVest, ExplosionEffectDelay) == 0x000CE0, "Member 'AExplosiveVest::ExplosionEffectDelay' has a wrong offset!");
static_assert(offsetof(AExplosiveVest, ExplosionEffectRandomDelay) == 0x000CE4, "Member 'AExplosiveVest::ExplosionEffectRandomDelay' has a wrong offset!");
static_assert(offsetof(AExplosiveVest, ExplosionDamageDelay) == 0x000CE8, "Member 'AExplosiveVest::ExplosionDamageDelay' has a wrong offset!");
static_assert(offsetof(AExplosiveVest, DetonationMontage) == 0x000CF0, "Member 'AExplosiveVest::DetonationMontage' has a wrong offset!");
static_assert(offsetof(AExplosiveVest, ExplosiveVestSocket) == 0x000D00, "Member 'AExplosiveVest::ExplosiveVestSocket' has a wrong offset!");
static_assert(offsetof(AExplosiveVest, ExplosionParticle) == 0x000D08, "Member 'AExplosiveVest::ExplosionParticle' has a wrong offset!");
static_assert(offsetof(AExplosiveVest, ExplosionEvent) == 0x000D10, "Member 'AExplosiveVest::ExplosionEvent' has a wrong offset!");
static_assert(offsetof(AExplosiveVest, DetonationEvent) == 0x000D18, "Member 'AExplosiveVest::DetonationEvent' has a wrong offset!");
static_assert(offsetof(AExplosiveVest, ExplosionScreenShake) == 0x000D20, "Member 'AExplosiveVest::ExplosionScreenShake' has a wrong offset!");
static_assert(offsetof(AExplosiveVest, ExplosionScreenShakeRadius) == 0x000D28, "Member 'AExplosiveVest::ExplosionScreenShakeRadius' has a wrong offset!");

// Class ReadyOrNot.FlankingAvoidanceVolume
// 0x0010 (0x02A8 - 0x0298)
class AFlankingAvoidanceVolume final : public AActor
{
public:
	class UBoxComponent*                          Bounds;                                            // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNavModifierComponent*                  NavModifierComponent;                              // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlankingAvoidanceVolume">();
	}
	static class AFlankingAvoidanceVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFlankingAvoidanceVolume>();
	}
};
static_assert(alignof(AFlankingAvoidanceVolume) == 0x000008, "Wrong alignment on AFlankingAvoidanceVolume");
static_assert(sizeof(AFlankingAvoidanceVolume) == 0x0002A8, "Wrong size on AFlankingAvoidanceVolume");
static_assert(offsetof(AFlankingAvoidanceVolume, Bounds) == 0x000298, "Member 'AFlankingAvoidanceVolume::Bounds' has a wrong offset!");
static_assert(offsetof(AFlankingAvoidanceVolume, NavModifierComponent) == 0x0002A0, "Member 'AFlankingAvoidanceVolume::NavModifierComponent' has a wrong offset!");

// Class ReadyOrNot.ReplayCameraPawn
// 0x0E38 (0x1180 - 0x0348)
class AReplayCameraPawn : public ASpectatorPawn
{
public:
	class UCameraComponent*                       PawnCamera;                                        // 0x0348(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReplaySpringArm*                       SpringArm;                                         // 0x0350(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFloatingPawnMovement*                  FloatingPawnMovement;                              // 0x0358(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPostProcessSettings                   PostProcessSettings;                               // 0x0360(0x06E0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FPostProcessSettings                   DefaultPostProcessSettings;                        // 0x0A40(0x06E0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         Sensitivity;                                       // 0x1120(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RollAmount;                                        // 0x1124(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1128[0x4];                                     // 0x1128(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InitialMaxSpeed;                                   // 0x112C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialAcceleration;                               // 0x1130(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialDeceleration;                               // 0x1134(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1138[0x48];                                    // 0x1138(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReplayCameraPawn">();
	}
	static class AReplayCameraPawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<AReplayCameraPawn>();
	}
};
static_assert(alignof(AReplayCameraPawn) == 0x000010, "Wrong alignment on AReplayCameraPawn");
static_assert(sizeof(AReplayCameraPawn) == 0x001180, "Wrong size on AReplayCameraPawn");
static_assert(offsetof(AReplayCameraPawn, PawnCamera) == 0x000348, "Member 'AReplayCameraPawn::PawnCamera' has a wrong offset!");
static_assert(offsetof(AReplayCameraPawn, SpringArm) == 0x000350, "Member 'AReplayCameraPawn::SpringArm' has a wrong offset!");
static_assert(offsetof(AReplayCameraPawn, FloatingPawnMovement) == 0x000358, "Member 'AReplayCameraPawn::FloatingPawnMovement' has a wrong offset!");
static_assert(offsetof(AReplayCameraPawn, PostProcessSettings) == 0x000360, "Member 'AReplayCameraPawn::PostProcessSettings' has a wrong offset!");
static_assert(offsetof(AReplayCameraPawn, DefaultPostProcessSettings) == 0x000A40, "Member 'AReplayCameraPawn::DefaultPostProcessSettings' has a wrong offset!");
static_assert(offsetof(AReplayCameraPawn, Sensitivity) == 0x001120, "Member 'AReplayCameraPawn::Sensitivity' has a wrong offset!");
static_assert(offsetof(AReplayCameraPawn, RollAmount) == 0x001124, "Member 'AReplayCameraPawn::RollAmount' has a wrong offset!");
static_assert(offsetof(AReplayCameraPawn, InitialMaxSpeed) == 0x00112C, "Member 'AReplayCameraPawn::InitialMaxSpeed' has a wrong offset!");
static_assert(offsetof(AReplayCameraPawn, InitialAcceleration) == 0x001130, "Member 'AReplayCameraPawn::InitialAcceleration' has a wrong offset!");
static_assert(offsetof(AReplayCameraPawn, InitialDeceleration) == 0x001134, "Member 'AReplayCameraPawn::InitialDeceleration' has a wrong offset!");

// Class ReadyOrNot.FlashbangDamageType
// 0x0000 (0x07B0 - 0x07B0)
class UFlashbangDamageType : public UStunDamage
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlashbangDamageType">();
	}
	static class UFlashbangDamageType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlashbangDamageType>();
	}
};
static_assert(alignof(UFlashbangDamageType) == 0x000010, "Wrong alignment on UFlashbangDamageType");
static_assert(sizeof(UFlashbangDamageType) == 0x0007B0, "Wrong size on UFlashbangDamageType");

// Class ReadyOrNot.FleeingCombatMove
// 0x0048 (0x0278 - 0x0230)
class UFleeingCombatMove final : public UBaseCombatMoveActivity
{
public:
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AThreatAwarenessActor*>          UsedFleePoints;                                    // 0x0238(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<class AThreatAwarenessActor*>          LastExitPoints;                                    // 0x0248(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class AThreatAwarenessActor*                  LastFleePoint;                                     // 0x0258(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_260[0x18];                                     // 0x0260(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	EFleeType GetFleeType();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FleeingCombatMove">();
	}
	static class UFleeingCombatMove* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFleeingCombatMove>();
	}
};
static_assert(alignof(UFleeingCombatMove) == 0x000008, "Wrong alignment on UFleeingCombatMove");
static_assert(sizeof(UFleeingCombatMove) == 0x000278, "Wrong size on UFleeingCombatMove");
static_assert(offsetof(UFleeingCombatMove, UsedFleePoints) == 0x000238, "Member 'UFleeingCombatMove::UsedFleePoints' has a wrong offset!");
static_assert(offsetof(UFleeingCombatMove, LastExitPoints) == 0x000248, "Member 'UFleeingCombatMove::LastExitPoints' has a wrong offset!");
static_assert(offsetof(UFleeingCombatMove, LastFleePoint) == 0x000258, "Member 'UFleeingCombatMove::LastFleePoint' has a wrong offset!");

// Class ReadyOrNot.FootstepImpactEffectsPool
// 0x0000 (0x00D0 - 0x00D0)
class UFootstepImpactEffectsPool : public UObjectPoolBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FootstepImpactEffectsPool">();
	}
	static class UFootstepImpactEffectsPool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFootstepImpactEffectsPool>();
	}
};
static_assert(alignof(UFootstepImpactEffectsPool) == 0x000008, "Wrong alignment on UFootstepImpactEffectsPool");
static_assert(sizeof(UFootstepImpactEffectsPool) == 0x0000D0, "Wrong size on UFootstepImpactEffectsPool");

// Class ReadyOrNot.ReportTargetActivity
// 0x0010 (0x0200 - 0x01F0)
class UReportTargetActivity final : public UBaseActivity
{
public:
	TScriptInterface<class IReportable>           ReportTarget;                                      // 0x01F0(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReportTargetActivity">();
	}
	static class UReportTargetActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReportTargetActivity>();
	}
};
static_assert(alignof(UReportTargetActivity) == 0x000008, "Wrong alignment on UReportTargetActivity");
static_assert(sizeof(UReportTargetActivity) == 0x000200, "Wrong size on UReportTargetActivity");
static_assert(offsetof(UReportTargetActivity, ReportTarget) == 0x0001F0, "Member 'UReportTargetActivity::ReportTarget' has a wrong offset!");

// Class ReadyOrNot.ForceLowReadyVolume
// 0x0008 (0x02D8 - 0x02D0)
class AForceLowReadyVolume final : public AVolume
{
public:
	bool                                          bForceLowReadyWhileAimingAt;                       // 0x02D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceLowReadyWhileInside;                         // 0x02D1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D2[0x6];                                      // 0x02D2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ForceLowReadyVolume">();
	}
	static class AForceLowReadyVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AForceLowReadyVolume>();
	}
};
static_assert(alignof(AForceLowReadyVolume) == 0x000008, "Wrong alignment on AForceLowReadyVolume");
static_assert(sizeof(AForceLowReadyVolume) == 0x0002D8, "Wrong size on AForceLowReadyVolume");
static_assert(offsetof(AForceLowReadyVolume, bForceLowReadyWhileAimingAt) == 0x0002D0, "Member 'AForceLowReadyVolume::bForceLowReadyWhileAimingAt' has a wrong offset!");
static_assert(offsetof(AForceLowReadyVolume, bForceLowReadyWhileInside) == 0x0002D1, "Member 'AForceLowReadyVolume::bForceLowReadyWhileInside' has a wrong offset!");

// Class ReadyOrNot.FriendsList
// 0x00A8 (0x04B8 - 0x0410)
class UFriendsList : public UCommonActivatableWidget
{
public:
	uint8                                         Pad_410[0x28];                                     // 0x0410(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnSuccess;                                         // 0x0438(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnFailure;                                         // 0x0448(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FFriend>                        FriendsList;                                       // 0x0458(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_468[0x50];                                     // 0x0468(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FBPUniqueNetId CreateUniqueNetIdFromString(const class FString& PlatformId);

	void GetFriendsList();
	void JoinFriend(const struct FFriend& Friend);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FriendsList">();
	}
	static class UFriendsList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFriendsList>();
	}
};
static_assert(alignof(UFriendsList) == 0x000008, "Wrong alignment on UFriendsList");
static_assert(sizeof(UFriendsList) == 0x0004B8, "Wrong size on UFriendsList");
static_assert(offsetof(UFriendsList, OnSuccess) == 0x000438, "Member 'UFriendsList::OnSuccess' has a wrong offset!");
static_assert(offsetof(UFriendsList, OnFailure) == 0x000448, "Member 'UFriendsList::OnFailure' has a wrong offset!");
static_assert(offsetof(UFriendsList, FriendsList) == 0x000458, "Member 'UFriendsList::FriendsList' has a wrong offset!");

// Class ReadyOrNot.GamepadControlScheme
// 0x02A0 (0x06B0 - 0x0410)
class UGamepadControlScheme : public UCommonActivatableWidget
{
public:
	class UWidgetSwitcher*                        WidgetSwitcher;                                    // 0x0410(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         LastUsedControllerIndex;                           // 0x0418(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_41C[0x4];                                      // 0x041C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextBlock*                             txt_XBOX_LT_1;                                     // 0x0420(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_XBOX_LT_2;                                     // 0x0428(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_XBOX_RT_1;                                     // 0x0430(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_XBOX_RT_2;                                     // 0x0438(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_XBox_LB_1;                                     // 0x0440(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_XBox_LB_2;                                     // 0x0448(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_XBox_LeftStick_1;                              // 0x0450(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_XBox_LeftStick_2;                              // 0x0458(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_XBox_Dpad_Left_1;                              // 0x0460(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_XBox_Dpad_Left_2;                              // 0x0468(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_XBox_Dpad_Right_1;                             // 0x0470(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_XBox_Dpad_Right_2;                             // 0x0478(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_XBox_Dpad_Right_3;                             // 0x0480(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_XBox_Dpad_Up_1;                                // 0x0488(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_XBox_Dpad_Up_2;                                // 0x0490(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_XBox_Dpad_Down_1;                              // 0x0498(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_XBox_Dpad_Down_2;                              // 0x04A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_XBox_RB_1;                                     // 0x04A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_XBox_RB_2;                                     // 0x04B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_XBox_Y_1;                                      // 0x04B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_XBox_Y_2;                                      // 0x04C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_XBox_B_1;                                      // 0x04C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_XBox_B_2;                                      // 0x04D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_XBox_B_3;                                      // 0x04D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_XBox_A_1;                                      // 0x04E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_XBox_A_2;                                      // 0x04E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_XBox_X_1;                                      // 0x04F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_XBox_X_2;                                      // 0x04F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_XBox_RightStick_1;                             // 0x0500(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_XBox_RightStick_2;                             // 0x0508(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_PS5_L2_1;                                      // 0x0510(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_PS5_L2_2;                                      // 0x0518(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_PS5_R2_1;                                      // 0x0520(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_PS5_R2_2;                                      // 0x0528(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_PS5_L1_1;                                      // 0x0530(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_PS5_L1_2;                                      // 0x0538(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_PS5_LeftStick_1;                               // 0x0540(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_PS5_LeftStick_2;                               // 0x0548(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_PS5_DirCross_Left_1;                           // 0x0550(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_PS5_DirCross_Left_2;                           // 0x0558(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_PS5_DirCross_Right_1;                          // 0x0560(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_PS5_DirCross_Right_2;                          // 0x0568(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_PS5_DirCross_Right_3;                          // 0x0570(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_PS5_DirCross_Up_1;                             // 0x0578(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_PS5_DirCross_Up_2;                             // 0x0580(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_PS5_DirCross_Down_1;                           // 0x0588(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_PS5_DirCross_Down_2;                           // 0x0590(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_PS5_R1_1;                                      // 0x0598(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_PS5_R1_2;                                      // 0x05A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_PS5_Triangle_1;                                // 0x05A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_PS5_Triangle_2;                                // 0x05B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_PS5_Circle_1;                                  // 0x05B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_PS5_Circle_2;                                  // 0x05C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_PS5_Circle_3;                                  // 0x05C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_PS5_Cross_1;                                   // 0x05D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_PS5_Cross_2;                                   // 0x05D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_PS5_Square_1;                                  // 0x05E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_PS5_Square_2;                                  // 0x05E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_PS5_RightStick_1;                              // 0x05F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_PS5_RightStick_2;                              // 0x05F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_600[0xB0];                                     // 0x0600(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GamepadControlScheme">();
	}
	static class UGamepadControlScheme* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGamepadControlScheme>();
	}
};
static_assert(alignof(UGamepadControlScheme) == 0x000008, "Wrong alignment on UGamepadControlScheme");
static_assert(sizeof(UGamepadControlScheme) == 0x0006B0, "Wrong size on UGamepadControlScheme");
static_assert(offsetof(UGamepadControlScheme, WidgetSwitcher) == 0x000410, "Member 'UGamepadControlScheme::WidgetSwitcher' has a wrong offset!");
static_assert(offsetof(UGamepadControlScheme, LastUsedControllerIndex) == 0x000418, "Member 'UGamepadControlScheme::LastUsedControllerIndex' has a wrong offset!");
static_assert(offsetof(UGamepadControlScheme, txt_XBOX_LT_1) == 0x000420, "Member 'UGamepadControlScheme::txt_XBOX_LT_1' has a wrong offset!");
static_assert(offsetof(UGamepadControlScheme, txt_XBOX_LT_2) == 0x000428, "Member 'UGamepadControlScheme::txt_XBOX_LT_2' has a wrong offset!");
static_assert(offsetof(UGamepadControlScheme, txt_XBOX_RT_1) == 0x000430, "Member 'UGamepadControlScheme::txt_XBOX_RT_1' has a wrong offset!");
static_assert(offsetof(UGamepadControlScheme, txt_XBOX_RT_2) == 0x000438, "Member 'UGamepadControlScheme::txt_XBOX_RT_2' has a wrong offset!");
static_assert(offsetof(UGamepadControlScheme, txt_XBox_LB_1) == 0x000440, "Member 'UGamepadControlScheme::txt_XBox_LB_1' has a wrong offset!");
static_assert(offsetof(UGamepadControlScheme, txt_XBox_LB_2) == 0x000448, "Member 'UGamepadControlScheme::txt_XBox_LB_2' has a wrong offset!");
static_assert(offsetof(UGamepadControlScheme, txt_XBox_LeftStick_1) == 0x000450, "Member 'UGamepadControlScheme::txt_XBox_LeftStick_1' has a wrong offset!");
static_assert(offsetof(UGamepadControlScheme, txt_XBox_LeftStick_2) == 0x000458, "Member 'UGamepadControlScheme::txt_XBox_LeftStick_2' has a wrong offset!");
static_assert(offsetof(UGamepadControlScheme, txt_XBox_Dpad_Left_1) == 0x000460, "Member 'UGamepadControlScheme::txt_XBox_Dpad_Left_1' has a wrong offset!");
static_assert(offsetof(UGamepadControlScheme, txt_XBox_Dpad_Left_2) == 0x000468, "Member 'UGamepadControlScheme::txt_XBox_Dpad_Left_2' has a wrong offset!");
static_assert(offsetof(UGamepadControlScheme, txt_XBox_Dpad_Right_1) == 0x000470, "Member 'UGamepadControlScheme::txt_XBox_Dpad_Right_1' has a wrong offset!");
static_assert(offsetof(UGamepadControlScheme, txt_XBox_Dpad_Right_2) == 0x000478, "Member 'UGamepadControlScheme::txt_XBox_Dpad_Right_2' has a wrong offset!");
static_assert(offsetof(UGamepadControlScheme, txt_XBox_Dpad_Right_3) == 0x000480, "Member 'UGamepadControlScheme::txt_XBox_Dpad_Right_3' has a wrong offset!");
static_assert(offsetof(UGamepadControlScheme, txt_XBox_Dpad_Up_1) == 0x000488, "Member 'UGamepadControlScheme::txt_XBox_Dpad_Up_1' has a wrong offset!");
static_assert(offsetof(UGamepadControlScheme, txt_XBox_Dpad_Up_2) == 0x000490, "Member 'UGamepadControlScheme::txt_XBox_Dpad_Up_2' has a wrong offset!");
static_assert(offsetof(UGamepadControlScheme, txt_XBox_Dpad_Down_1) == 0x000498, "Member 'UGamepadControlScheme::txt_XBox_Dpad_Down_1' has a wrong offset!");
static_assert(offsetof(UGamepadControlScheme, txt_XBox_Dpad_Down_2) == 0x0004A0, "Member 'UGamepadControlScheme::txt_XBox_Dpad_Down_2' has a wrong offset!");
static_assert(offsetof(UGamepadControlScheme, txt_XBox_RB_1) == 0x0004A8, "Member 'UGamepadControlScheme::txt_XBox_RB_1' has a wrong offset!");
static_assert(offsetof(UGamepadControlScheme, txt_XBox_RB_2) == 0x0004B0, "Member 'UGamepadControlScheme::txt_XBox_RB_2' has a wrong offset!");
static_assert(offsetof(UGamepadControlScheme, txt_XBox_Y_1) == 0x0004B8, "Member 'UGamepadControlScheme::txt_XBox_Y_1' has a wrong offset!");
static_assert(offsetof(UGamepadControlScheme, txt_XBox_Y_2) == 0x0004C0, "Member 'UGamepadControlScheme::txt_XBox_Y_2' has a wrong offset!");
static_assert(offsetof(UGamepadControlScheme, txt_XBox_B_1) == 0x0004C8, "Member 'UGamepadControlScheme::txt_XBox_B_1' has a wrong offset!");
static_assert(offsetof(UGamepadControlScheme, txt_XBox_B_2) == 0x0004D0, "Member 'UGamepadControlScheme::txt_XBox_B_2' has a wrong offset!");
static_assert(offsetof(UGamepadControlScheme, txt_XBox_B_3) == 0x0004D8, "Member 'UGamepadControlScheme::txt_XBox_B_3' has a wrong offset!");
static_assert(offsetof(UGamepadControlScheme, txt_XBox_A_1) == 0x0004E0, "Member 'UGamepadControlScheme::txt_XBox_A_1' has a wrong offset!");
static_assert(offsetof(UGamepadControlScheme, txt_XBox_A_2) == 0x0004E8, "Member 'UGamepadControlScheme::txt_XBox_A_2' has a wrong offset!");
static_assert(offsetof(UGamepadControlScheme, txt_XBox_X_1) == 0x0004F0, "Member 'UGamepadControlScheme::txt_XBox_X_1' has a wrong offset!");
static_assert(offsetof(UGamepadControlScheme, txt_XBox_X_2) == 0x0004F8, "Member 'UGamepadControlScheme::txt_XBox_X_2' has a wrong offset!");
static_assert(offsetof(UGamepadControlScheme, txt_XBox_RightStick_1) == 0x000500, "Member 'UGamepadControlScheme::txt_XBox_RightStick_1' has a wrong offset!");
static_assert(offsetof(UGamepadControlScheme, txt_XBox_RightStick_2) == 0x000508, "Member 'UGamepadControlScheme::txt_XBox_RightStick_2' has a wrong offset!");
static_assert(offsetof(UGamepadControlScheme, txt_PS5_L2_1) == 0x000510, "Member 'UGamepadControlScheme::txt_PS5_L2_1' has a wrong offset!");
static_assert(offsetof(UGamepadControlScheme, txt_PS5_L2_2) == 0x000518, "Member 'UGamepadControlScheme::txt_PS5_L2_2' has a wrong offset!");
static_assert(offsetof(UGamepadControlScheme, txt_PS5_R2_1) == 0x000520, "Member 'UGamepadControlScheme::txt_PS5_R2_1' has a wrong offset!");
static_assert(offsetof(UGamepadControlScheme, txt_PS5_R2_2) == 0x000528, "Member 'UGamepadControlScheme::txt_PS5_R2_2' has a wrong offset!");
static_assert(offsetof(UGamepadControlScheme, txt_PS5_L1_1) == 0x000530, "Member 'UGamepadControlScheme::txt_PS5_L1_1' has a wrong offset!");
static_assert(offsetof(UGamepadControlScheme, txt_PS5_L1_2) == 0x000538, "Member 'UGamepadControlScheme::txt_PS5_L1_2' has a wrong offset!");
static_assert(offsetof(UGamepadControlScheme, txt_PS5_LeftStick_1) == 0x000540, "Member 'UGamepadControlScheme::txt_PS5_LeftStick_1' has a wrong offset!");
static_assert(offsetof(UGamepadControlScheme, txt_PS5_LeftStick_2) == 0x000548, "Member 'UGamepadControlScheme::txt_PS5_LeftStick_2' has a wrong offset!");
static_assert(offsetof(UGamepadControlScheme, txt_PS5_DirCross_Left_1) == 0x000550, "Member 'UGamepadControlScheme::txt_PS5_DirCross_Left_1' has a wrong offset!");
static_assert(offsetof(UGamepadControlScheme, txt_PS5_DirCross_Left_2) == 0x000558, "Member 'UGamepadControlScheme::txt_PS5_DirCross_Left_2' has a wrong offset!");
static_assert(offsetof(UGamepadControlScheme, txt_PS5_DirCross_Right_1) == 0x000560, "Member 'UGamepadControlScheme::txt_PS5_DirCross_Right_1' has a wrong offset!");
static_assert(offsetof(UGamepadControlScheme, txt_PS5_DirCross_Right_2) == 0x000568, "Member 'UGamepadControlScheme::txt_PS5_DirCross_Right_2' has a wrong offset!");
static_assert(offsetof(UGamepadControlScheme, txt_PS5_DirCross_Right_3) == 0x000570, "Member 'UGamepadControlScheme::txt_PS5_DirCross_Right_3' has a wrong offset!");
static_assert(offsetof(UGamepadControlScheme, txt_PS5_DirCross_Up_1) == 0x000578, "Member 'UGamepadControlScheme::txt_PS5_DirCross_Up_1' has a wrong offset!");
static_assert(offsetof(UGamepadControlScheme, txt_PS5_DirCross_Up_2) == 0x000580, "Member 'UGamepadControlScheme::txt_PS5_DirCross_Up_2' has a wrong offset!");
static_assert(offsetof(UGamepadControlScheme, txt_PS5_DirCross_Down_1) == 0x000588, "Member 'UGamepadControlScheme::txt_PS5_DirCross_Down_1' has a wrong offset!");
static_assert(offsetof(UGamepadControlScheme, txt_PS5_DirCross_Down_2) == 0x000590, "Member 'UGamepadControlScheme::txt_PS5_DirCross_Down_2' has a wrong offset!");
static_assert(offsetof(UGamepadControlScheme, txt_PS5_R1_1) == 0x000598, "Member 'UGamepadControlScheme::txt_PS5_R1_1' has a wrong offset!");
static_assert(offsetof(UGamepadControlScheme, txt_PS5_R1_2) == 0x0005A0, "Member 'UGamepadControlScheme::txt_PS5_R1_2' has a wrong offset!");
static_assert(offsetof(UGamepadControlScheme, txt_PS5_Triangle_1) == 0x0005A8, "Member 'UGamepadControlScheme::txt_PS5_Triangle_1' has a wrong offset!");
static_assert(offsetof(UGamepadControlScheme, txt_PS5_Triangle_2) == 0x0005B0, "Member 'UGamepadControlScheme::txt_PS5_Triangle_2' has a wrong offset!");
static_assert(offsetof(UGamepadControlScheme, txt_PS5_Circle_1) == 0x0005B8, "Member 'UGamepadControlScheme::txt_PS5_Circle_1' has a wrong offset!");
static_assert(offsetof(UGamepadControlScheme, txt_PS5_Circle_2) == 0x0005C0, "Member 'UGamepadControlScheme::txt_PS5_Circle_2' has a wrong offset!");
static_assert(offsetof(UGamepadControlScheme, txt_PS5_Circle_3) == 0x0005C8, "Member 'UGamepadControlScheme::txt_PS5_Circle_3' has a wrong offset!");
static_assert(offsetof(UGamepadControlScheme, txt_PS5_Cross_1) == 0x0005D0, "Member 'UGamepadControlScheme::txt_PS5_Cross_1' has a wrong offset!");
static_assert(offsetof(UGamepadControlScheme, txt_PS5_Cross_2) == 0x0005D8, "Member 'UGamepadControlScheme::txt_PS5_Cross_2' has a wrong offset!");
static_assert(offsetof(UGamepadControlScheme, txt_PS5_Square_1) == 0x0005E0, "Member 'UGamepadControlScheme::txt_PS5_Square_1' has a wrong offset!");
static_assert(offsetof(UGamepadControlScheme, txt_PS5_Square_2) == 0x0005E8, "Member 'UGamepadControlScheme::txt_PS5_Square_2' has a wrong offset!");
static_assert(offsetof(UGamepadControlScheme, txt_PS5_RightStick_1) == 0x0005F0, "Member 'UGamepadControlScheme::txt_PS5_RightStick_1' has a wrong offset!");
static_assert(offsetof(UGamepadControlScheme, txt_PS5_RightStick_2) == 0x0005F8, "Member 'UGamepadControlScheme::txt_PS5_RightStick_2' has a wrong offset!");

// Class ReadyOrNot.SquadActionGate
// 0x0000 (0x0028 - 0x0028)
class USquadActionGate : public UObject
{
public:
	bool CanOpen(const struct FSquadActionDecisionContext& Context) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SquadActionGate">();
	}
	static class USquadActionGate* GetDefaultObj()
	{
		return GetDefaultObjImpl<USquadActionGate>();
	}
};
static_assert(alignof(USquadActionGate) == 0x000008, "Wrong alignment on USquadActionGate");
static_assert(sizeof(USquadActionGate) == 0x000028, "Wrong size on USquadActionGate");

// Class ReadyOrNot.SAGNumberOfSquadMembersAlive
// 0x0008 (0x0030 - 0x0028)
class USAGNumberOfSquadMembersAlive final : public USquadActionGate
{
public:
	int32                                         NumberAlive;                                       // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SAGNumberOfSquadMembersAlive">();
	}
	static class USAGNumberOfSquadMembersAlive* GetDefaultObj()
	{
		return GetDefaultObjImpl<USAGNumberOfSquadMembersAlive>();
	}
};
static_assert(alignof(USAGNumberOfSquadMembersAlive) == 0x000008, "Wrong alignment on USAGNumberOfSquadMembersAlive");
static_assert(sizeof(USAGNumberOfSquadMembersAlive) == 0x000030, "Wrong size on USAGNumberOfSquadMembersAlive");
static_assert(offsetof(USAGNumberOfSquadMembersAlive, NumberAlive) == 0x000028, "Member 'USAGNumberOfSquadMembersAlive::NumberAlive' has a wrong offset!");

// Class ReadyOrNot.GamepadItemWheelControlScheme
// 0x0200 (0x0610 - 0x0410)
class UGamepadItemWheelControlScheme : public UCommonActivatableWidget
{
public:
	class UWidgetSwitcher*                        WidgetSwitcher;                                    // 0x0410(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         LastUsedControllerIndex;                           // 0x0418(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_41C[0x4];                                      // 0x041C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextBlock*                             txt_XBox_LeftStick;                                // 0x0420(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_XBox_LeftStickPress;                           // 0x0428(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 LinesXBox_LeftStick;                               // 0x0430(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ButtonXBox_LeftStick;                              // 0x0438(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ButtonXBox_LeftStickPress;                         // 0x0440(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_XBox_LB;                                       // 0x0448(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_XBox_LB_Confirm;                               // 0x0450(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_XBox_Dpad_Down;                                // 0x0458(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 LinesXBox_RB;                                      // 0x0460(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ButtonXBox_RB;                                     // 0x0468(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 LinesXBox_Dpad_Single;                             // 0x0470(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ButtonXbox_Dpad_Down;                              // 0x0478(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_XBox_RightStick;                               // 0x0480(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_XBox_RightStickPress;                          // 0x0488(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 LinesXBox_RightStick;                              // 0x0490(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ButtonXBox_RightStick;                             // 0x0498(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ButtonXBox_RightStickPress;                        // 0x04A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_XBox_RB;                                       // 0x04A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_XBox_RB_Confirm;                               // 0x04B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_XBox_A;                                        // 0x04B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 LinesXBox_LB;                                      // 0x04C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ButtonXBox_LB;                                     // 0x04C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 LinesXBox_FaceButtons_Single;                      // 0x04D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ButtonXbox_A;                                      // 0x04D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_PS5_RightStick;                                // 0x04E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_PS5_R3;                                        // 0x04E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ButtonPS5_RightStick;                              // 0x04F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ButtonPS5_R3;                                      // 0x04F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_PS5_R1;                                        // 0x0500(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_PS5_R1_Confirm;                                // 0x0508(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_PS5_DirCross_Down;                             // 0x0510(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 LinesPS5_R1;                                       // 0x0518(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ButtonPS5_R1;                                      // 0x0520(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 LinesPS5_DirCross;                                 // 0x0528(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ButtonPS5_DirCross_Down;                           // 0x0530(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_PS5_LeftStick;                                 // 0x0538(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_PS5_L3;                                        // 0x0540(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 LinesPS5_LeftStick;                                // 0x0548(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ButtonPS5_LeftStick;                               // 0x0550(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ButtonPS5_L3;                                      // 0x0558(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 LinesPS5_RightStick;                               // 0x0560(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_PS5_L1;                                        // 0x0568(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_PS5_L1_Confirm;                                // 0x0570(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_PS5_Cross;                                     // 0x0578(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                LinesPS5_L1;                                       // 0x0580(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ButtonPS5_L1;                                      // 0x0588(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 LinesPS5_FaceButtons;                              // 0x0590(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ButtonPS5_Cross;                                   // 0x0598(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5A0[0x70];                                     // 0x05A0(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GamepadItemWheelControlScheme">();
	}
	static class UGamepadItemWheelControlScheme* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGamepadItemWheelControlScheme>();
	}
};
static_assert(alignof(UGamepadItemWheelControlScheme) == 0x000008, "Wrong alignment on UGamepadItemWheelControlScheme");
static_assert(sizeof(UGamepadItemWheelControlScheme) == 0x000610, "Wrong size on UGamepadItemWheelControlScheme");
static_assert(offsetof(UGamepadItemWheelControlScheme, WidgetSwitcher) == 0x000410, "Member 'UGamepadItemWheelControlScheme::WidgetSwitcher' has a wrong offset!");
static_assert(offsetof(UGamepadItemWheelControlScheme, LastUsedControllerIndex) == 0x000418, "Member 'UGamepadItemWheelControlScheme::LastUsedControllerIndex' has a wrong offset!");
static_assert(offsetof(UGamepadItemWheelControlScheme, txt_XBox_LeftStick) == 0x000420, "Member 'UGamepadItemWheelControlScheme::txt_XBox_LeftStick' has a wrong offset!");
static_assert(offsetof(UGamepadItemWheelControlScheme, txt_XBox_LeftStickPress) == 0x000428, "Member 'UGamepadItemWheelControlScheme::txt_XBox_LeftStickPress' has a wrong offset!");
static_assert(offsetof(UGamepadItemWheelControlScheme, LinesXBox_LeftStick) == 0x000430, "Member 'UGamepadItemWheelControlScheme::LinesXBox_LeftStick' has a wrong offset!");
static_assert(offsetof(UGamepadItemWheelControlScheme, ButtonXBox_LeftStick) == 0x000438, "Member 'UGamepadItemWheelControlScheme::ButtonXBox_LeftStick' has a wrong offset!");
static_assert(offsetof(UGamepadItemWheelControlScheme, ButtonXBox_LeftStickPress) == 0x000440, "Member 'UGamepadItemWheelControlScheme::ButtonXBox_LeftStickPress' has a wrong offset!");
static_assert(offsetof(UGamepadItemWheelControlScheme, txt_XBox_LB) == 0x000448, "Member 'UGamepadItemWheelControlScheme::txt_XBox_LB' has a wrong offset!");
static_assert(offsetof(UGamepadItemWheelControlScheme, txt_XBox_LB_Confirm) == 0x000450, "Member 'UGamepadItemWheelControlScheme::txt_XBox_LB_Confirm' has a wrong offset!");
static_assert(offsetof(UGamepadItemWheelControlScheme, txt_XBox_Dpad_Down) == 0x000458, "Member 'UGamepadItemWheelControlScheme::txt_XBox_Dpad_Down' has a wrong offset!");
static_assert(offsetof(UGamepadItemWheelControlScheme, LinesXBox_RB) == 0x000460, "Member 'UGamepadItemWheelControlScheme::LinesXBox_RB' has a wrong offset!");
static_assert(offsetof(UGamepadItemWheelControlScheme, ButtonXBox_RB) == 0x000468, "Member 'UGamepadItemWheelControlScheme::ButtonXBox_RB' has a wrong offset!");
static_assert(offsetof(UGamepadItemWheelControlScheme, LinesXBox_Dpad_Single) == 0x000470, "Member 'UGamepadItemWheelControlScheme::LinesXBox_Dpad_Single' has a wrong offset!");
static_assert(offsetof(UGamepadItemWheelControlScheme, ButtonXbox_Dpad_Down) == 0x000478, "Member 'UGamepadItemWheelControlScheme::ButtonXbox_Dpad_Down' has a wrong offset!");
static_assert(offsetof(UGamepadItemWheelControlScheme, txt_XBox_RightStick) == 0x000480, "Member 'UGamepadItemWheelControlScheme::txt_XBox_RightStick' has a wrong offset!");
static_assert(offsetof(UGamepadItemWheelControlScheme, txt_XBox_RightStickPress) == 0x000488, "Member 'UGamepadItemWheelControlScheme::txt_XBox_RightStickPress' has a wrong offset!");
static_assert(offsetof(UGamepadItemWheelControlScheme, LinesXBox_RightStick) == 0x000490, "Member 'UGamepadItemWheelControlScheme::LinesXBox_RightStick' has a wrong offset!");
static_assert(offsetof(UGamepadItemWheelControlScheme, ButtonXBox_RightStick) == 0x000498, "Member 'UGamepadItemWheelControlScheme::ButtonXBox_RightStick' has a wrong offset!");
static_assert(offsetof(UGamepadItemWheelControlScheme, ButtonXBox_RightStickPress) == 0x0004A0, "Member 'UGamepadItemWheelControlScheme::ButtonXBox_RightStickPress' has a wrong offset!");
static_assert(offsetof(UGamepadItemWheelControlScheme, txt_XBox_RB) == 0x0004A8, "Member 'UGamepadItemWheelControlScheme::txt_XBox_RB' has a wrong offset!");
static_assert(offsetof(UGamepadItemWheelControlScheme, txt_XBox_RB_Confirm) == 0x0004B0, "Member 'UGamepadItemWheelControlScheme::txt_XBox_RB_Confirm' has a wrong offset!");
static_assert(offsetof(UGamepadItemWheelControlScheme, txt_XBox_A) == 0x0004B8, "Member 'UGamepadItemWheelControlScheme::txt_XBox_A' has a wrong offset!");
static_assert(offsetof(UGamepadItemWheelControlScheme, LinesXBox_LB) == 0x0004C0, "Member 'UGamepadItemWheelControlScheme::LinesXBox_LB' has a wrong offset!");
static_assert(offsetof(UGamepadItemWheelControlScheme, ButtonXBox_LB) == 0x0004C8, "Member 'UGamepadItemWheelControlScheme::ButtonXBox_LB' has a wrong offset!");
static_assert(offsetof(UGamepadItemWheelControlScheme, LinesXBox_FaceButtons_Single) == 0x0004D0, "Member 'UGamepadItemWheelControlScheme::LinesXBox_FaceButtons_Single' has a wrong offset!");
static_assert(offsetof(UGamepadItemWheelControlScheme, ButtonXbox_A) == 0x0004D8, "Member 'UGamepadItemWheelControlScheme::ButtonXbox_A' has a wrong offset!");
static_assert(offsetof(UGamepadItemWheelControlScheme, txt_PS5_RightStick) == 0x0004E0, "Member 'UGamepadItemWheelControlScheme::txt_PS5_RightStick' has a wrong offset!");
static_assert(offsetof(UGamepadItemWheelControlScheme, txt_PS5_R3) == 0x0004E8, "Member 'UGamepadItemWheelControlScheme::txt_PS5_R3' has a wrong offset!");
static_assert(offsetof(UGamepadItemWheelControlScheme, ButtonPS5_RightStick) == 0x0004F0, "Member 'UGamepadItemWheelControlScheme::ButtonPS5_RightStick' has a wrong offset!");
static_assert(offsetof(UGamepadItemWheelControlScheme, ButtonPS5_R3) == 0x0004F8, "Member 'UGamepadItemWheelControlScheme::ButtonPS5_R3' has a wrong offset!");
static_assert(offsetof(UGamepadItemWheelControlScheme, txt_PS5_R1) == 0x000500, "Member 'UGamepadItemWheelControlScheme::txt_PS5_R1' has a wrong offset!");
static_assert(offsetof(UGamepadItemWheelControlScheme, txt_PS5_R1_Confirm) == 0x000508, "Member 'UGamepadItemWheelControlScheme::txt_PS5_R1_Confirm' has a wrong offset!");
static_assert(offsetof(UGamepadItemWheelControlScheme, txt_PS5_DirCross_Down) == 0x000510, "Member 'UGamepadItemWheelControlScheme::txt_PS5_DirCross_Down' has a wrong offset!");
static_assert(offsetof(UGamepadItemWheelControlScheme, LinesPS5_R1) == 0x000518, "Member 'UGamepadItemWheelControlScheme::LinesPS5_R1' has a wrong offset!");
static_assert(offsetof(UGamepadItemWheelControlScheme, ButtonPS5_R1) == 0x000520, "Member 'UGamepadItemWheelControlScheme::ButtonPS5_R1' has a wrong offset!");
static_assert(offsetof(UGamepadItemWheelControlScheme, LinesPS5_DirCross) == 0x000528, "Member 'UGamepadItemWheelControlScheme::LinesPS5_DirCross' has a wrong offset!");
static_assert(offsetof(UGamepadItemWheelControlScheme, ButtonPS5_DirCross_Down) == 0x000530, "Member 'UGamepadItemWheelControlScheme::ButtonPS5_DirCross_Down' has a wrong offset!");
static_assert(offsetof(UGamepadItemWheelControlScheme, txt_PS5_LeftStick) == 0x000538, "Member 'UGamepadItemWheelControlScheme::txt_PS5_LeftStick' has a wrong offset!");
static_assert(offsetof(UGamepadItemWheelControlScheme, txt_PS5_L3) == 0x000540, "Member 'UGamepadItemWheelControlScheme::txt_PS5_L3' has a wrong offset!");
static_assert(offsetof(UGamepadItemWheelControlScheme, LinesPS5_LeftStick) == 0x000548, "Member 'UGamepadItemWheelControlScheme::LinesPS5_LeftStick' has a wrong offset!");
static_assert(offsetof(UGamepadItemWheelControlScheme, ButtonPS5_LeftStick) == 0x000550, "Member 'UGamepadItemWheelControlScheme::ButtonPS5_LeftStick' has a wrong offset!");
static_assert(offsetof(UGamepadItemWheelControlScheme, ButtonPS5_L3) == 0x000558, "Member 'UGamepadItemWheelControlScheme::ButtonPS5_L3' has a wrong offset!");
static_assert(offsetof(UGamepadItemWheelControlScheme, LinesPS5_RightStick) == 0x000560, "Member 'UGamepadItemWheelControlScheme::LinesPS5_RightStick' has a wrong offset!");
static_assert(offsetof(UGamepadItemWheelControlScheme, txt_PS5_L1) == 0x000568, "Member 'UGamepadItemWheelControlScheme::txt_PS5_L1' has a wrong offset!");
static_assert(offsetof(UGamepadItemWheelControlScheme, txt_PS5_L1_Confirm) == 0x000570, "Member 'UGamepadItemWheelControlScheme::txt_PS5_L1_Confirm' has a wrong offset!");
static_assert(offsetof(UGamepadItemWheelControlScheme, txt_PS5_Cross) == 0x000578, "Member 'UGamepadItemWheelControlScheme::txt_PS5_Cross' has a wrong offset!");
static_assert(offsetof(UGamepadItemWheelControlScheme, LinesPS5_L1) == 0x000580, "Member 'UGamepadItemWheelControlScheme::LinesPS5_L1' has a wrong offset!");
static_assert(offsetof(UGamepadItemWheelControlScheme, ButtonPS5_L1) == 0x000588, "Member 'UGamepadItemWheelControlScheme::ButtonPS5_L1' has a wrong offset!");
static_assert(offsetof(UGamepadItemWheelControlScheme, LinesPS5_FaceButtons) == 0x000590, "Member 'UGamepadItemWheelControlScheme::LinesPS5_FaceButtons' has a wrong offset!");
static_assert(offsetof(UGamepadItemWheelControlScheme, ButtonPS5_Cross) == 0x000598, "Member 'UGamepadItemWheelControlScheme::ButtonPS5_Cross' has a wrong offset!");

// Class ReadyOrNot.GamepadStatics
// 0x0000 (0x0028 - 0x0028)
class UGamepadStatics final : public UBlueprintFunctionLibrary
{
public:
	static void DisableTriggerEffects(class ULocalPlayer* LocalPlayer);
	static void EnableLightBar();
	static void EnableTriggerEffects(class ULocalPlayer* LocalPlayer);
	static bool GetAimTriggerEffectsEnabled(class ULocalPlayer* LocalPlayer);
	static bool GetFireTriggerEffectsEnabled(class ULocalPlayer* LocalPlayer);
	static bool GetIsTriggered(class ULocalPlayer* LocalPlayer, int32 ControllerId, bool RightTrigger);
	static bool GetIsTriggerStarted(class ULocalPlayer* LocalPlayer, int32 ControllerId, bool RightTrigger);
	static bool IsAnalogValueOutsideDeadZone(const float Magnitude);
	static bool IsUsingPlaystationController(class ULocalPlayer* LocalPlayer);
	static void ResetControllerOrientation(int32 ControllerId);
	static void ResetLightBar();
	static void SetLightBarColor(const struct FColor& Color);
	static bool ShouldUseAdaptiveAimTrigger(class ULocalPlayer* LocalPlayer);
	static bool ShouldUseAdaptiveWeaponTrigger(class ULocalPlayer* LocalPlayer);
	static void ToggleThumbstickUiNavigation(bool bEnableThumbstickNavigation);
	static void UpdateTriggerEffects(class ULocalPlayer* LocalPlayer, uint8 Start, uint8 End, uint8 Strength);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GamepadStatics">();
	}
	static class UGamepadStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGamepadStatics>();
	}
};
static_assert(alignof(UGamepadStatics) == 0x000008, "Wrong alignment on UGamepadStatics");
static_assert(sizeof(UGamepadStatics) == 0x000028, "Wrong size on UGamepadStatics");

// Class ReadyOrNot.SquadRulesData
// 0x0060 (0x0090 - 0x0030)
class USquadRulesData final : public UDataAsset
{
public:
	TMap<EAIAwarenessState, EAIAwarenessState>    AwarenessStateShareMap;                            // 0x0030(0x0050)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FSquadActivityRules>            SquadActivityData;                                 // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SquadRulesData">();
	}
	static class USquadRulesData* GetDefaultObj()
	{
		return GetDefaultObjImpl<USquadRulesData>();
	}
};
static_assert(alignof(USquadRulesData) == 0x000008, "Wrong alignment on USquadRulesData");
static_assert(sizeof(USquadRulesData) == 0x000090, "Wrong size on USquadRulesData");
static_assert(offsetof(USquadRulesData, AwarenessStateShareMap) == 0x000030, "Member 'USquadRulesData::AwarenessStateShareMap' has a wrong offset!");
static_assert(offsetof(USquadRulesData, SquadActivityData) == 0x000080, "Member 'USquadRulesData::SquadActivityData' has a wrong offset!");

// Class ReadyOrNot.GasNavLinkGenerator
// 0x0008 (0x02A0 - 0x0298)
class AGasNavLinkGenerator final : public AActor
{
public:
	class UBillboardComponent*                    BillboardComponent;                                // 0x0298(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void GenerateNavLinks();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GasNavLinkGenerator">();
	}
	static class AGasNavLinkGenerator* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGasNavLinkGenerator>();
	}
};
static_assert(alignof(AGasNavLinkGenerator) == 0x000008, "Wrong alignment on AGasNavLinkGenerator");
static_assert(sizeof(AGasNavLinkGenerator) == 0x0002A0, "Wrong size on AGasNavLinkGenerator");
static_assert(offsetof(AGasNavLinkGenerator, BillboardComponent) == 0x000298, "Member 'AGasNavLinkGenerator::BillboardComponent' has a wrong offset!");

// Class ReadyOrNot.GasVolumeComponent
// 0x0020 (0x05D0 - 0x05B0)
class UGasVolumeComponent final : public UBoxComponent
{
public:
	uint8                                         Pad_5B0[0x20];                                     // 0x05B0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GasVolumeComponent">();
	}
	static class UGasVolumeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGasVolumeComponent>();
	}
};
static_assert(alignof(UGasVolumeComponent) == 0x000010, "Wrong alignment on UGasVolumeComponent");
static_assert(sizeof(UGasVolumeComponent) == 0x0005D0, "Wrong size on UGasVolumeComponent");

// Class ReadyOrNot.StingerDamageType
// 0x0000 (0x07B0 - 0x07B0)
class UStingerDamageType : public UStunDamage
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StingerDamageType">();
	}
	static class UStingerDamageType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStingerDamageType>();
	}
};
static_assert(alignof(UStingerDamageType) == 0x000010, "Wrong alignment on UStingerDamageType");
static_assert(sizeof(UStingerDamageType) == 0x0007B0, "Wrong size on UStingerDamageType");

// Class ReadyOrNot.GetFriendlyName
// 0x0000 (0x0000 - 0x0000)
class IGetFriendlyName final
{
public:
	class UTexture2D* GetFriendlyIcon();
	class FString GetFriendlyName();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GetFriendlyName">();
	}
	static class IGetFriendlyName* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGetFriendlyName>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IGetFriendlyName) == 0x000001, "Wrong alignment on IGetFriendlyName");
static_assert(sizeof(IGetFriendlyName) == 0x000001, "Wrong size on IGetFriendlyName");

// Class ReadyOrNot.GlassActor
// 0x0030 (0x02C8 - 0x0298)
class AGlassActor final : public AActor
{
public:
	TArray<class UMaterialInstance*>              RandomGlassMaterial;                               // 0x0298(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UMaterialInstance*>              RandomShatteredGlassMaterial;                      // 0x02A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(float DamageAmount, const struct FVector& HitLocation, const struct FVector& ImpulseDir, float ImpulseStrength)> OnApplyDamageToWindow; // 0x02B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	class UMaterialInterface* GetRandomGlassMaterial();
	class UMaterialInterface* GetRandomShatteredGlassMaterial();
	void Multicast_ApplyDamageToWindow(float DamageAmount, const struct FVector& HitLocation, const struct FVector& ImpulseDir, float ImpulseStrength);
	void Multicast_TakeDamage(float DamageAmount, const struct FDamageEvent& DamageEvent, class AController* EventInstigator, class AActor* DamageCauser);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GlassActor">();
	}
	static class AGlassActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGlassActor>();
	}
};
static_assert(alignof(AGlassActor) == 0x000008, "Wrong alignment on AGlassActor");
static_assert(sizeof(AGlassActor) == 0x0002C8, "Wrong size on AGlassActor");
static_assert(offsetof(AGlassActor, RandomGlassMaterial) == 0x000298, "Member 'AGlassActor::RandomGlassMaterial' has a wrong offset!");
static_assert(offsetof(AGlassActor, RandomShatteredGlassMaterial) == 0x0002A8, "Member 'AGlassActor::RandomShatteredGlassMaterial' has a wrong offset!");
static_assert(offsetof(AGlassActor, OnApplyDamageToWindow) == 0x0002B8, "Member 'AGlassActor::OnApplyDamageToWindow' has a wrong offset!");

// Class ReadyOrNot.SubtitlesStatics
// 0x0000 (0x0028 - 0x0028)
class USubtitlesStatics final : public UBlueprintFunctionLibrary
{
public:
	static const TMap<class FString, class FText> GetAvailableLocales();
	static void PlaySubtitles(class UObject* WorldContextObject, const class FString& Speaker, const class FString& VoiceLine, float Length, class FName SpeakerTag, const class FString& NameLookupOverride);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SubtitlesStatics">();
	}
	static class USubtitlesStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<USubtitlesStatics>();
	}
};
static_assert(alignof(USubtitlesStatics) == 0x000008, "Wrong alignment on USubtitlesStatics");
static_assert(sizeof(USubtitlesStatics) == 0x000028, "Wrong size on USubtitlesStatics");

// Class ReadyOrNot.GrenadeProjectile
// 0x00B0 (0x04D8 - 0x0428)
class AGrenadeProjectile : public ABulletProjectile
{
public:
	class URadialForceComponent*                  DetonationRadialForce;                             // 0x0428(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AGrenadeProjectile* Projectile)> OnGrenadeDetonated;         // 0x0430(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_440[0x8];                                      // 0x0440(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantize                    ProjectileLocation;                                // 0x0448(0x0018)(Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DetonationTime;                                    // 0x0460(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DetonationBetweenTime;                             // 0x0464(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ElapsedTime;                                       // 0x0468(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DetonationCount;                                   // 0x046C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DetonationMax;                                     // 0x0470(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_474[0x4];                                      // 0x0474(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGrenadeDamage>                 GrenadeDamage;                                     // 0x0478(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIncreaseRadiusOverTime;                           // 0x0488(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_489[0x7];                                      // 0x0489(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             DetonationSound;                                   // 0x0490(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bPlayDetonationSoundOnce : 1;                      // 0x0498(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_499[0x7];                                      // 0x0499(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        BounceLocations;                                   // 0x04A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bDetonateOnValidation;                             // 0x04B0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4B1[0x3];                                      // 0x04B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LocationRecordingRate;                             // 0x04B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecordDistanceThreshold;                           // 0x04B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4BC[0x4];                                      // 0x04BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        PastLocations;                                     // 0x04C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D0[0x8];                                      // 0x04D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDetonate();
	void OnDetonate_Blueprint();
	void OnDetonationComplete_Blueprint();
	void RecordLocation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GrenadeProjectile">();
	}
	static class AGrenadeProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGrenadeProjectile>();
	}
};
static_assert(alignof(AGrenadeProjectile) == 0x000008, "Wrong alignment on AGrenadeProjectile");
static_assert(sizeof(AGrenadeProjectile) == 0x0004D8, "Wrong size on AGrenadeProjectile");
static_assert(offsetof(AGrenadeProjectile, DetonationRadialForce) == 0x000428, "Member 'AGrenadeProjectile::DetonationRadialForce' has a wrong offset!");
static_assert(offsetof(AGrenadeProjectile, OnGrenadeDetonated) == 0x000430, "Member 'AGrenadeProjectile::OnGrenadeDetonated' has a wrong offset!");
static_assert(offsetof(AGrenadeProjectile, ProjectileLocation) == 0x000448, "Member 'AGrenadeProjectile::ProjectileLocation' has a wrong offset!");
static_assert(offsetof(AGrenadeProjectile, DetonationTime) == 0x000460, "Member 'AGrenadeProjectile::DetonationTime' has a wrong offset!");
static_assert(offsetof(AGrenadeProjectile, DetonationBetweenTime) == 0x000464, "Member 'AGrenadeProjectile::DetonationBetweenTime' has a wrong offset!");
static_assert(offsetof(AGrenadeProjectile, ElapsedTime) == 0x000468, "Member 'AGrenadeProjectile::ElapsedTime' has a wrong offset!");
static_assert(offsetof(AGrenadeProjectile, DetonationCount) == 0x00046C, "Member 'AGrenadeProjectile::DetonationCount' has a wrong offset!");
static_assert(offsetof(AGrenadeProjectile, DetonationMax) == 0x000470, "Member 'AGrenadeProjectile::DetonationMax' has a wrong offset!");
static_assert(offsetof(AGrenadeProjectile, GrenadeDamage) == 0x000478, "Member 'AGrenadeProjectile::GrenadeDamage' has a wrong offset!");
static_assert(offsetof(AGrenadeProjectile, bIncreaseRadiusOverTime) == 0x000488, "Member 'AGrenadeProjectile::bIncreaseRadiusOverTime' has a wrong offset!");
static_assert(offsetof(AGrenadeProjectile, DetonationSound) == 0x000490, "Member 'AGrenadeProjectile::DetonationSound' has a wrong offset!");
static_assert(offsetof(AGrenadeProjectile, BounceLocations) == 0x0004A0, "Member 'AGrenadeProjectile::BounceLocations' has a wrong offset!");
static_assert(offsetof(AGrenadeProjectile, bDetonateOnValidation) == 0x0004B0, "Member 'AGrenadeProjectile::bDetonateOnValidation' has a wrong offset!");
static_assert(offsetof(AGrenadeProjectile, LocationRecordingRate) == 0x0004B4, "Member 'AGrenadeProjectile::LocationRecordingRate' has a wrong offset!");
static_assert(offsetof(AGrenadeProjectile, RecordDistanceThreshold) == 0x0004B8, "Member 'AGrenadeProjectile::RecordDistanceThreshold' has a wrong offset!");
static_assert(offsetof(AGrenadeProjectile, PastLocations) == 0x0004C0, "Member 'AGrenadeProjectile::PastLocations' has a wrong offset!");

// Class ReadyOrNot.GunGameGS
// 0x0000 (0x08F8 - 0x08F8)
class AGunGameGS final : public AReadyOrNotGameState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GunGameGS">();
	}
	static class AGunGameGS* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGunGameGS>();
	}
};
static_assert(alignof(AGunGameGS) == 0x000008, "Wrong alignment on AGunGameGS");
static_assert(sizeof(AGunGameGS) == 0x0008F8, "Wrong size on AGunGameGS");

// Class ReadyOrNot.RosterPortal
// 0x0018 (0x02B0 - 0x0298)
class ARosterPortal final : public AActor
{
public:
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	ERosterPortalType                             PortalType;                                        // 0x02A0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A1[0x7];                                      // 0x02A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractableComponent*                 InteractableComponent;                             // 0x02A8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RosterPortal">();
	}
	static class ARosterPortal* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARosterPortal>();
	}
};
static_assert(alignof(ARosterPortal) == 0x000008, "Wrong alignment on ARosterPortal");
static_assert(sizeof(ARosterPortal) == 0x0002B0, "Wrong size on ARosterPortal");
static_assert(offsetof(ARosterPortal, PortalType) == 0x0002A0, "Member 'ARosterPortal::PortalType' has a wrong offset!");
static_assert(offsetof(ARosterPortal, InteractableComponent) == 0x0002A8, "Member 'ARosterPortal::InteractableComponent' has a wrong offset!");

// Class ReadyOrNot.HardcoreMoneyGS
// 0x0000 (0x0A08 - 0x0A08)
class AHardcoreMoneyGS final : public ACoopGS
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HardcoreMoneyGS">();
	}
	static class AHardcoreMoneyGS* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHardcoreMoneyGS>();
	}
};
static_assert(alignof(AHardcoreMoneyGS) == 0x000008, "Wrong alignment on AHardcoreMoneyGS");
static_assert(sizeof(AHardcoreMoneyGS) == 0x000A08, "Wrong size on AHardcoreMoneyGS");

// Class ReadyOrNot.Headwear
// 0x0EB0 (0x1AD0 - 0x0C20)
#pragma pack(push, 0x1)
class alignas(0x10) AHeadwear : public ABaseArmour
{
public:
	bool                                          bHasHelmet;                                        // 0x0C20(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasHeadset;                                       // 0x0C21(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C22[0x2];                                      // 0x0C22(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CustomizationHelmetTag;                            // 0x0C24(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C2C[0x4];                                      // 0x0C2C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UCustomizationHelmet>    DefaultCustomizationHelmet;                        // 0x0C30(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HelmetTag;                                         // 0x0C58(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckForCompatibility;                            // 0x0C60(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C61[0x7];                                      // 0x0C61(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           HelmetCompatibilityTags;                           // 0x0C68(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Durability;                                        // 0x0C78(0x0004)(Edit, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageReduction;                                   // 0x0C7C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RicochetChance;                                    // 0x0C80(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C84[0x4];                                      // 0x0C84(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             RicochetEvent;                                     // 0x0C88(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bProtectsAgainstInstantKnockout;                   // 0x0C90(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseMaskVoiceFilter;                               // 0x0C91(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C92[0x6];                                      // 0x0C92(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             PaperdollTexture_WithHelmet;                       // 0x0C98(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             PaperdollTexture_WithHelmet_Crouch;                // 0x0CA0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             PaperdollTexture_NoHelmet;                         // 0x0CA8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             PaperdollTexture_NoHelmet_Crouch;                  // 0x0CB0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             VoiceLineEventOverrideSpatalized;                  // 0x0CB8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODEvent*                             VoiceLineEventOverrideLocal;                       // 0x0CC0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUserWidget>                MaskOverlay;                                       // 0x0CC8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnablePostProcess;                                // 0x0CD0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CD1[0xF];                                      // 0x0CD1(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPostProcessSettings                   MaskPostProcess;                                   // 0x0CE0(0x06E0)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FPostProcessSettings                   MaskSupressionPostProcess;                         // 0x13C0(0x06E0)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bOverrideBreathingSound;                           // 0x1AA0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1AA1[0x7];                                     // 0x1AA1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class USoundCue*>                      OverriddenBreathingSounds;                         // 0x1AA8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	float                                         GapBetweenBreaths;                                 // 0x1AB8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSpawnedOverlay;                                   // 0x1ABC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1ABD[0x3];                                     // 0x1ABD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserWidget*                            SpawnedMaskOverlay;                                // 0x1AC0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Headwear">();
	}
	static class AHeadwear* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHeadwear>();
	}
};
#pragma pack(pop)
static_assert(alignof(AHeadwear) == 0x000010, "Wrong alignment on AHeadwear");
static_assert(sizeof(AHeadwear) == 0x001AD0, "Wrong size on AHeadwear");
static_assert(offsetof(AHeadwear, bHasHelmet) == 0x000C20, "Member 'AHeadwear::bHasHelmet' has a wrong offset!");
static_assert(offsetof(AHeadwear, bHasHeadset) == 0x000C21, "Member 'AHeadwear::bHasHeadset' has a wrong offset!");
static_assert(offsetof(AHeadwear, CustomizationHelmetTag) == 0x000C24, "Member 'AHeadwear::CustomizationHelmetTag' has a wrong offset!");
static_assert(offsetof(AHeadwear, DefaultCustomizationHelmet) == 0x000C30, "Member 'AHeadwear::DefaultCustomizationHelmet' has a wrong offset!");
static_assert(offsetof(AHeadwear, HelmetTag) == 0x000C58, "Member 'AHeadwear::HelmetTag' has a wrong offset!");
static_assert(offsetof(AHeadwear, bCheckForCompatibility) == 0x000C60, "Member 'AHeadwear::bCheckForCompatibility' has a wrong offset!");
static_assert(offsetof(AHeadwear, HelmetCompatibilityTags) == 0x000C68, "Member 'AHeadwear::HelmetCompatibilityTags' has a wrong offset!");
static_assert(offsetof(AHeadwear, Durability) == 0x000C78, "Member 'AHeadwear::Durability' has a wrong offset!");
static_assert(offsetof(AHeadwear, DamageReduction) == 0x000C7C, "Member 'AHeadwear::DamageReduction' has a wrong offset!");
static_assert(offsetof(AHeadwear, RicochetChance) == 0x000C80, "Member 'AHeadwear::RicochetChance' has a wrong offset!");
static_assert(offsetof(AHeadwear, RicochetEvent) == 0x000C88, "Member 'AHeadwear::RicochetEvent' has a wrong offset!");
static_assert(offsetof(AHeadwear, bProtectsAgainstInstantKnockout) == 0x000C90, "Member 'AHeadwear::bProtectsAgainstInstantKnockout' has a wrong offset!");
static_assert(offsetof(AHeadwear, bUseMaskVoiceFilter) == 0x000C91, "Member 'AHeadwear::bUseMaskVoiceFilter' has a wrong offset!");
static_assert(offsetof(AHeadwear, PaperdollTexture_WithHelmet) == 0x000C98, "Member 'AHeadwear::PaperdollTexture_WithHelmet' has a wrong offset!");
static_assert(offsetof(AHeadwear, PaperdollTexture_WithHelmet_Crouch) == 0x000CA0, "Member 'AHeadwear::PaperdollTexture_WithHelmet_Crouch' has a wrong offset!");
static_assert(offsetof(AHeadwear, PaperdollTexture_NoHelmet) == 0x000CA8, "Member 'AHeadwear::PaperdollTexture_NoHelmet' has a wrong offset!");
static_assert(offsetof(AHeadwear, PaperdollTexture_NoHelmet_Crouch) == 0x000CB0, "Member 'AHeadwear::PaperdollTexture_NoHelmet_Crouch' has a wrong offset!");
static_assert(offsetof(AHeadwear, VoiceLineEventOverrideSpatalized) == 0x000CB8, "Member 'AHeadwear::VoiceLineEventOverrideSpatalized' has a wrong offset!");
static_assert(offsetof(AHeadwear, VoiceLineEventOverrideLocal) == 0x000CC0, "Member 'AHeadwear::VoiceLineEventOverrideLocal' has a wrong offset!");
static_assert(offsetof(AHeadwear, MaskOverlay) == 0x000CC8, "Member 'AHeadwear::MaskOverlay' has a wrong offset!");
static_assert(offsetof(AHeadwear, bEnablePostProcess) == 0x000CD0, "Member 'AHeadwear::bEnablePostProcess' has a wrong offset!");
static_assert(offsetof(AHeadwear, MaskPostProcess) == 0x000CE0, "Member 'AHeadwear::MaskPostProcess' has a wrong offset!");
static_assert(offsetof(AHeadwear, MaskSupressionPostProcess) == 0x0013C0, "Member 'AHeadwear::MaskSupressionPostProcess' has a wrong offset!");
static_assert(offsetof(AHeadwear, bOverrideBreathingSound) == 0x001AA0, "Member 'AHeadwear::bOverrideBreathingSound' has a wrong offset!");
static_assert(offsetof(AHeadwear, OverriddenBreathingSounds) == 0x001AA8, "Member 'AHeadwear::OverriddenBreathingSounds' has a wrong offset!");
static_assert(offsetof(AHeadwear, GapBetweenBreaths) == 0x001AB8, "Member 'AHeadwear::GapBetweenBreaths' has a wrong offset!");
static_assert(offsetof(AHeadwear, bSpawnedOverlay) == 0x001ABC, "Member 'AHeadwear::bSpawnedOverlay' has a wrong offset!");
static_assert(offsetof(AHeadwear, SpawnedMaskOverlay) == 0x001AC0, "Member 'AHeadwear::SpawnedMaskOverlay' has a wrong offset!");

// Class ReadyOrNot.RoundEndWidget_PVP
// 0x0008 (0x02F0 - 0x02E8)
class URoundEndWidget_PVP : public UBaseWidget
{
public:
	class UWidgetAnimation*                       Anim_FadeIn;                                       // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnGameModeRoundEnded();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RoundEndWidget_PVP">();
	}
	static class URoundEndWidget_PVP* GetDefaultObj()
	{
		return GetDefaultObjImpl<URoundEndWidget_PVP>();
	}
};
static_assert(alignof(URoundEndWidget_PVP) == 0x000008, "Wrong alignment on URoundEndWidget_PVP");
static_assert(sizeof(URoundEndWidget_PVP) == 0x0002F0, "Wrong size on URoundEndWidget_PVP");
static_assert(offsetof(URoundEndWidget_PVP, Anim_FadeIn) == 0x0002E8, "Member 'URoundEndWidget_PVP::Anim_FadeIn' has a wrong offset!");

// Class ReadyOrNot.Helicopter
// 0x0128 (0x03C0 - 0x0298)
class AHelicopter final : public AActor
{
public:
	class USkeletalMeshComponent*                 Mesh;                                              // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      CapsuleComponent;                                  // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URadialTrackingComponent*               RadialTrackingComponent;                           // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTrackingSpotlightComponent*            TrackingSpotlightComponent;                        // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTrackingCameraComponent*               TrackingCameraComponent;                           // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDiegeticSoundComponent*                CoreSoundLoopComponent;                            // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScoringComponent*                      ScoringComponent;                                  // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxFriendlyFireEvents;                             // 0x02D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FriendlyFireCooldown;                              // 0x02D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AHelicopterPath*                        DefaultPath;                                       // 0x02D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DefaultSpeed;                                      // 0x02E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DefaultRotationRate;                               // 0x02E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VelocitySmoothingRate;                             // 0x02E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2EC[0x4];                                      // 0x02EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LastDirection;                                     // 0x02F0(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                LastVelocity;                                      // 0x0308(0x0018)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                SmoothedVelocity;                                  // 0x0320(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TargetAudioCooldown;                               // 0x0338(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NetworkMovementSmoothingRate;                      // 0x033C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AHelicopterPath*                        CurrentPath;                                       // 0x0340(0x0008)(Net, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EHelicopterState                              CurrentState;                                      // 0x0348(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_349[0x7];                                      // 0x0349(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ServerLocation;                                    // 0x0350(0x0018)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRotator                               ServerRotation;                                    // 0x0368(0x0018)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_380[0x40];                                     // 0x0380(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AllowFriendlyFire();
	void AllowTargetAudio();
	void DisableFeatures();
	void EnableFeatures(const struct FRadialTrackingInitStruct& trackingInitData, const struct FTrackingCameraInitStruct& cameraInitStruct, const struct FTrackingSpotlightInitStruct& spotlightInitStruct);
	void MulticastDisableFeatures();
	void MulticastEnableCamera(const struct FTrackingCameraInitStruct& cameraInitStruct);
	void MulticastEnableSpotLight(const struct FTrackingSpotlightInitStruct& spotlightInitStruct);
	void MulticastFriendlyFire();
	void OnSceneCaptureVisibilityChange(bool bVisible);
	void OnTargetFound(class ACyberneticCharacter* Target);
	void OnTargetLost(ETrackingTargetLoseReason LoseReason);
	void StartPath(class AHelicopterPath* Path, EPathTransitionType TransitionType);

	class UTrackingCameraComponent* GetTrackingCameraComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Helicopter">();
	}
	static class AHelicopter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHelicopter>();
	}
};
static_assert(alignof(AHelicopter) == 0x000008, "Wrong alignment on AHelicopter");
static_assert(sizeof(AHelicopter) == 0x0003C0, "Wrong size on AHelicopter");
static_assert(offsetof(AHelicopter, Mesh) == 0x000298, "Member 'AHelicopter::Mesh' has a wrong offset!");
static_assert(offsetof(AHelicopter, CapsuleComponent) == 0x0002A0, "Member 'AHelicopter::CapsuleComponent' has a wrong offset!");
static_assert(offsetof(AHelicopter, RadialTrackingComponent) == 0x0002A8, "Member 'AHelicopter::RadialTrackingComponent' has a wrong offset!");
static_assert(offsetof(AHelicopter, TrackingSpotlightComponent) == 0x0002B0, "Member 'AHelicopter::TrackingSpotlightComponent' has a wrong offset!");
static_assert(offsetof(AHelicopter, TrackingCameraComponent) == 0x0002B8, "Member 'AHelicopter::TrackingCameraComponent' has a wrong offset!");
static_assert(offsetof(AHelicopter, CoreSoundLoopComponent) == 0x0002C0, "Member 'AHelicopter::CoreSoundLoopComponent' has a wrong offset!");
static_assert(offsetof(AHelicopter, ScoringComponent) == 0x0002C8, "Member 'AHelicopter::ScoringComponent' has a wrong offset!");
static_assert(offsetof(AHelicopter, MaxFriendlyFireEvents) == 0x0002D0, "Member 'AHelicopter::MaxFriendlyFireEvents' has a wrong offset!");
static_assert(offsetof(AHelicopter, FriendlyFireCooldown) == 0x0002D4, "Member 'AHelicopter::FriendlyFireCooldown' has a wrong offset!");
static_assert(offsetof(AHelicopter, DefaultPath) == 0x0002D8, "Member 'AHelicopter::DefaultPath' has a wrong offset!");
static_assert(offsetof(AHelicopter, DefaultSpeed) == 0x0002E0, "Member 'AHelicopter::DefaultSpeed' has a wrong offset!");
static_assert(offsetof(AHelicopter, DefaultRotationRate) == 0x0002E4, "Member 'AHelicopter::DefaultRotationRate' has a wrong offset!");
static_assert(offsetof(AHelicopter, VelocitySmoothingRate) == 0x0002E8, "Member 'AHelicopter::VelocitySmoothingRate' has a wrong offset!");
static_assert(offsetof(AHelicopter, LastDirection) == 0x0002F0, "Member 'AHelicopter::LastDirection' has a wrong offset!");
static_assert(offsetof(AHelicopter, LastVelocity) == 0x000308, "Member 'AHelicopter::LastVelocity' has a wrong offset!");
static_assert(offsetof(AHelicopter, SmoothedVelocity) == 0x000320, "Member 'AHelicopter::SmoothedVelocity' has a wrong offset!");
static_assert(offsetof(AHelicopter, TargetAudioCooldown) == 0x000338, "Member 'AHelicopter::TargetAudioCooldown' has a wrong offset!");
static_assert(offsetof(AHelicopter, NetworkMovementSmoothingRate) == 0x00033C, "Member 'AHelicopter::NetworkMovementSmoothingRate' has a wrong offset!");
static_assert(offsetof(AHelicopter, CurrentPath) == 0x000340, "Member 'AHelicopter::CurrentPath' has a wrong offset!");
static_assert(offsetof(AHelicopter, CurrentState) == 0x000348, "Member 'AHelicopter::CurrentState' has a wrong offset!");
static_assert(offsetof(AHelicopter, ServerLocation) == 0x000350, "Member 'AHelicopter::ServerLocation' has a wrong offset!");
static_assert(offsetof(AHelicopter, ServerRotation) == 0x000368, "Member 'AHelicopter::ServerRotation' has a wrong offset!");

// Class ReadyOrNot.HelicopterFeatureZoneComponent
// 0x0030 (0x00D8 - 0x00A8)
class UHelicopterFeatureZoneComponent final : public UHelicopterTriggerComponent
{
public:
	class AHelicopter*                            Helicopter;                                        // 0x00A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRadialTrackingInitStruct              TrackingInitStruct;                                // 0x00B0(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FTrackingCameraInitStruct              cameraInitStruct;                                  // 0x00C8(0x000C)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FTrackingSpotlightInitStruct           spotlightInitStruct;                               // 0x00D4(0x0002)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_D6[0x2];                                       // 0x00D6(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HelicopterFeatureZoneComponent">();
	}
	static class UHelicopterFeatureZoneComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHelicopterFeatureZoneComponent>();
	}
};
static_assert(alignof(UHelicopterFeatureZoneComponent) == 0x000008, "Wrong alignment on UHelicopterFeatureZoneComponent");
static_assert(sizeof(UHelicopterFeatureZoneComponent) == 0x0000D8, "Wrong size on UHelicopterFeatureZoneComponent");
static_assert(offsetof(UHelicopterFeatureZoneComponent, Helicopter) == 0x0000A8, "Member 'UHelicopterFeatureZoneComponent::Helicopter' has a wrong offset!");
static_assert(offsetof(UHelicopterFeatureZoneComponent, TrackingInitStruct) == 0x0000B0, "Member 'UHelicopterFeatureZoneComponent::TrackingInitStruct' has a wrong offset!");
static_assert(offsetof(UHelicopterFeatureZoneComponent, cameraInitStruct) == 0x0000C8, "Member 'UHelicopterFeatureZoneComponent::cameraInitStruct' has a wrong offset!");
static_assert(offsetof(UHelicopterFeatureZoneComponent, spotlightInitStruct) == 0x0000D4, "Member 'UHelicopterFeatureZoneComponent::spotlightInitStruct' has a wrong offset!");

// Class ReadyOrNot.Pouch
// 0x0038 (0x0350 - 0x0318)
class APouch final : public ASkeletalMeshActor
{
public:
	class USkeletalMeshComponent*                 MagazineComponent;                                 // 0x0318(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        AttachToComp;                                      // 0x0320(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   AttachToSocket;                                    // 0x0328(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bShowMagazine;                                     // 0x0330(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_331[0x3];                                      // 0x0331(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MagazineSocket;                                    // 0x0334(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_33C[0x4];                                      // 0x033C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          OpenPouch;                                         // 0x0340(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ClosePouch;                                        // 0x0348(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnRep_Attach();
	void OnRep_UpdateVisibility();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Pouch">();
	}
	static class APouch* GetDefaultObj()
	{
		return GetDefaultObjImpl<APouch>();
	}
};
static_assert(alignof(APouch) == 0x000008, "Wrong alignment on APouch");
static_assert(sizeof(APouch) == 0x000350, "Wrong size on APouch");
static_assert(offsetof(APouch, MagazineComponent) == 0x000318, "Member 'APouch::MagazineComponent' has a wrong offset!");
static_assert(offsetof(APouch, AttachToComp) == 0x000320, "Member 'APouch::AttachToComp' has a wrong offset!");
static_assert(offsetof(APouch, AttachToSocket) == 0x000328, "Member 'APouch::AttachToSocket' has a wrong offset!");
static_assert(offsetof(APouch, bShowMagazine) == 0x000330, "Member 'APouch::bShowMagazine' has a wrong offset!");
static_assert(offsetof(APouch, MagazineSocket) == 0x000334, "Member 'APouch::MagazineSocket' has a wrong offset!");
static_assert(offsetof(APouch, OpenPouch) == 0x000340, "Member 'APouch::OpenPouch' has a wrong offset!");
static_assert(offsetof(APouch, ClosePouch) == 0x000348, "Member 'APouch::ClosePouch' has a wrong offset!");

// Class ReadyOrNot.HelicopterOverlayWidget
// 0x0030 (0x02F0 - 0x02C0)
class UHelicopterOverlayWidget : public UUserWidget
{
public:
	class AHelicopter*                            Helicopter;                                        // 0x02C0(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMissionInformationSubsystem*           MissionInformation;                                // 0x02C8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D0[0x20];                                     // 0x02D0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetAltitudeInFeet();
	float GetCameraHeadingInDegrees();
	float GetCameraPitchInDegrees();
	float GetCameraRelativeHeadingInDegrees();
	float GetHelicopterHeadingInDegrees();
	void GetLatitude(float* Degrees, float* Minutes, float* Seconds, float* DecimalSeconds, bool* IsNorthing);
	struct FDateTime GetLocalDateTime();
	void GetLongitude(float* Degrees, float* Minutes, float* Seconds, float* DecimalSeconds, bool* IsEasting);
	float GetSpeedInKnots();
	struct FDateTime GetZuluDateTime();
	bool IsCameraEnabled();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HelicopterOverlayWidget">();
	}
	static class UHelicopterOverlayWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHelicopterOverlayWidget>();
	}
};
static_assert(alignof(UHelicopterOverlayWidget) == 0x000008, "Wrong alignment on UHelicopterOverlayWidget");
static_assert(sizeof(UHelicopterOverlayWidget) == 0x0002F0, "Wrong size on UHelicopterOverlayWidget");
static_assert(offsetof(UHelicopterOverlayWidget, Helicopter) == 0x0002C0, "Member 'UHelicopterOverlayWidget::Helicopter' has a wrong offset!");
static_assert(offsetof(UHelicopterOverlayWidget, MissionInformation) == 0x0002C8, "Member 'UHelicopterOverlayWidget::MissionInformation' has a wrong offset!");

// Class ReadyOrNot.ScoringComponent
// 0x00A0 (0x0140 - 0x00A0)
class UScoringComponent final : public UActorComponent
{
public:
	uint8                                         bEnabled : 1;                                      // 0x00A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScoreData                             ScoringData;                                       // 0x00A8(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    ScoreGroup;                                        // 0x00D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   ScoreGroupName;                                    // 0x00E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EObjectiveLevel                               ObjectiveLevel;                                    // 0x00F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bAutoAddToScorePool : 1;                           // 0x00F1(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bShowPopupOnTakeAllScoresWithNoChange;             // 0x00F2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F3[0x45];                                      // 0x00F3(0x0045)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             ScoreGroupDataTable;                               // 0x0138(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	int32 GetScore(const class FText& ScoreName) const;
	int32 GetTotalScore(bool bOnlyEnabled, const bool bOnlyGiven) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScoringComponent">();
	}
	static class UScoringComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScoringComponent>();
	}
};
static_assert(alignof(UScoringComponent) == 0x000008, "Wrong alignment on UScoringComponent");
static_assert(sizeof(UScoringComponent) == 0x000140, "Wrong size on UScoringComponent");
static_assert(offsetof(UScoringComponent, ScoringData) == 0x0000A8, "Member 'UScoringComponent::ScoringData' has a wrong offset!");
static_assert(offsetof(UScoringComponent, ScoreGroup) == 0x0000D8, "Member 'UScoringComponent::ScoreGroup' has a wrong offset!");
static_assert(offsetof(UScoringComponent, ScoreGroupName) == 0x0000E8, "Member 'UScoringComponent::ScoreGroupName' has a wrong offset!");
static_assert(offsetof(UScoringComponent, ObjectiveLevel) == 0x0000F0, "Member 'UScoringComponent::ObjectiveLevel' has a wrong offset!");
static_assert(offsetof(UScoringComponent, bShowPopupOnTakeAllScoresWithNoChange) == 0x0000F2, "Member 'UScoringComponent::bShowPopupOnTakeAllScoresWithNoChange' has a wrong offset!");
static_assert(offsetof(UScoringComponent, ScoreGroupDataTable) == 0x000138, "Member 'UScoringComponent::ScoreGroupDataTable' has a wrong offset!");

// Class ReadyOrNot.HelicopterPath
// 0x0038 (0x02D0 - 0x0298)
class alignas(0x10) AHelicopterPath final : public AActor
{
public:
	TArray<class AHelicopterPathNode*>            PathNodes;                                         // 0x0298(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bLoop;                                             // 0x02A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInterruptOnTargetFound;                           // 0x02A9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AA[0x16];                                     // 0x02AA(0x0016)(Fixing Size After Last Property [ Dumper-7 ])
	class AHelicopterPathNode*                    CurrentNode;                                       // 0x02C0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C8[0x8];                                      // 0x02C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class AHelicopterPathNode* GetCurrentNode();
	void NextNode();
	void ResetPath(bool bMoveToNearest, const struct FVector& helicopterLocation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HelicopterPath">();
	}
	static class AHelicopterPath* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHelicopterPath>();
	}
};
static_assert(alignof(AHelicopterPath) == 0x000010, "Wrong alignment on AHelicopterPath");
static_assert(sizeof(AHelicopterPath) == 0x0002D0, "Wrong size on AHelicopterPath");
static_assert(offsetof(AHelicopterPath, PathNodes) == 0x000298, "Member 'AHelicopterPath::PathNodes' has a wrong offset!");
static_assert(offsetof(AHelicopterPath, bLoop) == 0x0002A8, "Member 'AHelicopterPath::bLoop' has a wrong offset!");
static_assert(offsetof(AHelicopterPath, bInterruptOnTargetFound) == 0x0002A9, "Member 'AHelicopterPath::bInterruptOnTargetFound' has a wrong offset!");
static_assert(offsetof(AHelicopterPath, CurrentNode) == 0x0002C0, "Member 'AHelicopterPath::CurrentNode' has a wrong offset!");

// Class ReadyOrNot.HelicopterPathNode
// 0x0030 (0x02C8 - 0x0298)
class AHelicopterPathNode final : public AActor
{
public:
	ENodeBehavior                                 NodeBehavior;                                      // 0x0298(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_299[0x3];                                      // 0x0299(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WaitTime;                                          // 0x029C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRotateToNodeRotation;                             // 0x02A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A1[0x3];                                      // 0x02A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RotateToNodeThreshold;                             // 0x02A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EEasingFunc                                   RotateToNodeEase;                                  // 0x02A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRotateToForward;                                  // 0x02A9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2AA[0x2];                                      // 0x02AA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ArrivalThreshold;                                  // 0x02AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpeedOverride;                                     // 0x02B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RotationRateOverride;                              // 0x02B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHelicopterVOLine                             OnArriveSound;                                     // 0x02B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHelicopterVOLine                             OnDepartSound;                                     // 0x02B9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2BA[0xE];                                      // 0x02BA(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FinishWait();
	void MulticastPlayArriveSound();
	void MulticastPlayDepartSound();
	void OnArriveAtNode(class AHelicopter* Helicopter);
	void OnDepartNode(class AHelicopter* Helicopter);
	void ResetNode();
	void UnlockNode();

	EEasingFunc GetRotateToNodeEase() const;
	float GetRotateToNodeThreshold() const;
	float GetRotationRateOverride() const;
	float GetSpeedOverride() const;
	bool IsAtNode(const struct FVector& Position) const;
	bool IsLocked() const;
	bool ShouldRotateToForward() const;
	bool ShouldRotateToNode() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HelicopterPathNode">();
	}
	static class AHelicopterPathNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHelicopterPathNode>();
	}
};
static_assert(alignof(AHelicopterPathNode) == 0x000008, "Wrong alignment on AHelicopterPathNode");
static_assert(sizeof(AHelicopterPathNode) == 0x0002C8, "Wrong size on AHelicopterPathNode");
static_assert(offsetof(AHelicopterPathNode, NodeBehavior) == 0x000298, "Member 'AHelicopterPathNode::NodeBehavior' has a wrong offset!");
static_assert(offsetof(AHelicopterPathNode, WaitTime) == 0x00029C, "Member 'AHelicopterPathNode::WaitTime' has a wrong offset!");
static_assert(offsetof(AHelicopterPathNode, bRotateToNodeRotation) == 0x0002A0, "Member 'AHelicopterPathNode::bRotateToNodeRotation' has a wrong offset!");
static_assert(offsetof(AHelicopterPathNode, RotateToNodeThreshold) == 0x0002A4, "Member 'AHelicopterPathNode::RotateToNodeThreshold' has a wrong offset!");
static_assert(offsetof(AHelicopterPathNode, RotateToNodeEase) == 0x0002A8, "Member 'AHelicopterPathNode::RotateToNodeEase' has a wrong offset!");
static_assert(offsetof(AHelicopterPathNode, bRotateToForward) == 0x0002A9, "Member 'AHelicopterPathNode::bRotateToForward' has a wrong offset!");
static_assert(offsetof(AHelicopterPathNode, ArrivalThreshold) == 0x0002AC, "Member 'AHelicopterPathNode::ArrivalThreshold' has a wrong offset!");
static_assert(offsetof(AHelicopterPathNode, SpeedOverride) == 0x0002B0, "Member 'AHelicopterPathNode::SpeedOverride' has a wrong offset!");
static_assert(offsetof(AHelicopterPathNode, RotationRateOverride) == 0x0002B4, "Member 'AHelicopterPathNode::RotationRateOverride' has a wrong offset!");
static_assert(offsetof(AHelicopterPathNode, OnArriveSound) == 0x0002B8, "Member 'AHelicopterPathNode::OnArriveSound' has a wrong offset!");
static_assert(offsetof(AHelicopterPathNode, OnDepartSound) == 0x0002B9, "Member 'AHelicopterPathNode::OnDepartSound' has a wrong offset!");

// Class ReadyOrNot.ScriptedDialogue
// 0x0060 (0x0090 - 0x0030)
class UScriptedDialogue final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void()>              DialogueFinished;                                  // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UObject*                                WorldContextObject;                                // 0x0040(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AReadyOrNotCharacter*                   Character;                                         // 0x0048(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundSource*                           VoiceSoundSource;                                  // 0x0050(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_58[0x38];                                      // 0x0058(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UScriptedDialogue* Start2DScriptedDialogue(class UObject* WorldContextObject_0, class UFMODEvent* Event, const class FString& Speaker, const class FString& VoiceLine, class FName SpeakerTag);
	static class UScriptedDialogue* StartCharacterScriptedDialogue(class AReadyOrNotCharacter* Character_0, const class FString& VoiceLine);

	void HandleDialogueFinished();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScriptedDialogue">();
	}
	static class UScriptedDialogue* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScriptedDialogue>();
	}
};
static_assert(alignof(UScriptedDialogue) == 0x000008, "Wrong alignment on UScriptedDialogue");
static_assert(sizeof(UScriptedDialogue) == 0x000090, "Wrong size on UScriptedDialogue");
static_assert(offsetof(UScriptedDialogue, DialogueFinished) == 0x000030, "Member 'UScriptedDialogue::DialogueFinished' has a wrong offset!");
static_assert(offsetof(UScriptedDialogue, WorldContextObject) == 0x000040, "Member 'UScriptedDialogue::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UScriptedDialogue, Character) == 0x000048, "Member 'UScriptedDialogue::Character' has a wrong offset!");
static_assert(offsetof(UScriptedDialogue, VoiceSoundSource) == 0x000050, "Member 'UScriptedDialogue::VoiceSoundSource' has a wrong offset!");

// Class ReadyOrNot.HelicopterSetPathComponent
// 0x0018 (0x00C0 - 0x00A8)
class UHelicopterSetPathComponent final : public UHelicopterTriggerComponent
{
public:
	class AHelicopter*                            Helicopter;                                        // 0x00A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AHelicopterPath*                        Path;                                              // 0x00B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPathTransitionType                           TransitionType;                                    // 0x00B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HelicopterSetPathComponent">();
	}
	static class UHelicopterSetPathComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHelicopterSetPathComponent>();
	}
};
static_assert(alignof(UHelicopterSetPathComponent) == 0x000008, "Wrong alignment on UHelicopterSetPathComponent");
static_assert(sizeof(UHelicopterSetPathComponent) == 0x0000C0, "Wrong size on UHelicopterSetPathComponent");
static_assert(offsetof(UHelicopterSetPathComponent, Helicopter) == 0x0000A8, "Member 'UHelicopterSetPathComponent::Helicopter' has a wrong offset!");
static_assert(offsetof(UHelicopterSetPathComponent, Path) == 0x0000B0, "Member 'UHelicopterSetPathComponent::Path' has a wrong offset!");
static_assert(offsetof(UHelicopterSetPathComponent, TransitionType) == 0x0000B8, "Member 'UHelicopterSetPathComponent::TransitionType' has a wrong offset!");

// Class ReadyOrNot.HelicopterUnlockPathNodeComponent
// 0x0008 (0x00B0 - 0x00A8)
class UHelicopterUnlockPathNodeComponent final : public UHelicopterTriggerComponent
{
public:
	class AHelicopterPathNode*                    Node;                                              // 0x00A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HelicopterUnlockPathNodeComponent">();
	}
	static class UHelicopterUnlockPathNodeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHelicopterUnlockPathNodeComponent>();
	}
};
static_assert(alignof(UHelicopterUnlockPathNodeComponent) == 0x000008, "Wrong alignment on UHelicopterUnlockPathNodeComponent");
static_assert(sizeof(UHelicopterUnlockPathNodeComponent) == 0x0000B0, "Wrong size on UHelicopterUnlockPathNodeComponent");
static_assert(offsetof(UHelicopterUnlockPathNodeComponent, Node) == 0x0000A8, "Member 'UHelicopterUnlockPathNodeComponent::Node' has a wrong offset!");

// Class ReadyOrNot.HelicopterViewWidget
// 0x0008 (0x0418 - 0x0410)
class UHelicopterViewWidget : public UCommonActivatableWidget
{
public:
	class AHelicopter*                            Helicopter;                                        // 0x0410(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void HandleVisibilityChange(bool bVisible);
	bool IsHelicopterAvailable();
	void OnRenderTargetSet(class UTextureRenderTarget2D* InRenderTarget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HelicopterViewWidget">();
	}
	static class UHelicopterViewWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHelicopterViewWidget>();
	}
};
static_assert(alignof(UHelicopterViewWidget) == 0x000008, "Wrong alignment on UHelicopterViewWidget");
static_assert(sizeof(UHelicopterViewWidget) == 0x000418, "Wrong size on UHelicopterViewWidget");
static_assert(offsetof(UHelicopterViewWidget, Helicopter) == 0x000410, "Member 'UHelicopterViewWidget::Helicopter' has a wrong offset!");

// Class ReadyOrNot.ReadyOrNotPathFollowingComp
// 0x0058 (0x0320 - 0x02C8)
class UReadyOrNotPathFollowingComp final : public UPathFollowingComponent
{
public:
	float                                         HoleTraversalCooldown;                             // 0x02C8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CC[0x24];                                     // 0x02CC(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	class ADoor*                                  LastUsedDoorLink;                                  // 0x02F0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AWallHoleTraversal*                     LastUsedWallHole;                                  // 0x02F8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNavLinkCustomComponent*                LastUsedDoorLinkComp;                              // 0x0300(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_308[0x8];                                      // 0x0308(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ADoor*                                  PendingDoor;                                       // 0x0310(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPendingDoorReason                            PendingDoorReason;                                 // 0x0318(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_319[0x7];                                      // 0x0319(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHoleTraversalFinished(class UBaseActivity* Activity, class ACyberneticController* Controller);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotPathFollowingComp">();
	}
	static class UReadyOrNotPathFollowingComp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotPathFollowingComp>();
	}
};
static_assert(alignof(UReadyOrNotPathFollowingComp) == 0x000008, "Wrong alignment on UReadyOrNotPathFollowingComp");
static_assert(sizeof(UReadyOrNotPathFollowingComp) == 0x000320, "Wrong size on UReadyOrNotPathFollowingComp");
static_assert(offsetof(UReadyOrNotPathFollowingComp, HoleTraversalCooldown) == 0x0002C8, "Member 'UReadyOrNotPathFollowingComp::HoleTraversalCooldown' has a wrong offset!");
static_assert(offsetof(UReadyOrNotPathFollowingComp, LastUsedDoorLink) == 0x0002F0, "Member 'UReadyOrNotPathFollowingComp::LastUsedDoorLink' has a wrong offset!");
static_assert(offsetof(UReadyOrNotPathFollowingComp, LastUsedWallHole) == 0x0002F8, "Member 'UReadyOrNotPathFollowingComp::LastUsedWallHole' has a wrong offset!");
static_assert(offsetof(UReadyOrNotPathFollowingComp, LastUsedDoorLinkComp) == 0x000300, "Member 'UReadyOrNotPathFollowingComp::LastUsedDoorLinkComp' has a wrong offset!");
static_assert(offsetof(UReadyOrNotPathFollowingComp, PendingDoor) == 0x000310, "Member 'UReadyOrNotPathFollowingComp::PendingDoor' has a wrong offset!");
static_assert(offsetof(UReadyOrNotPathFollowingComp, PendingDoorReason) == 0x000318, "Member 'UReadyOrNotPathFollowingComp::PendingDoorReason' has a wrong offset!");

// Class ReadyOrNot.HighgroundVolume
// 0x0070 (0x0308 - 0x0298)
class AHighgroundVolume final : public AActor
{
public:
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AudioDebounce;                                     // 0x02A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A4[0x4];                                      // 0x02A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          Bounds;                                            // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAudioComponent*                        AudioComp;                                         // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWatching;                                         // 0x02B8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B9[0x3];                                      // 0x02B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SierraDesignation;                                 // 0x02BC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   VolumeLabel;                                       // 0x02C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USoundBase*>                     ContactEnteredVolumeAudio;                         // 0x02C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class USoundBase*>                     ContactExitedVolumeAudio;                          // 0x02D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class USoundBase*>                     SwatEnteredVolumeAudio;                            // 0x02E8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class USoundBase*>                     SwatExitedVolumeAudio;                             // 0x02F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	void OnAudioFinished();
	void OnOverlapBegin(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnOverlapEnd(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HighgroundVolume">();
	}
	static class AHighgroundVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHighgroundVolume>();
	}
};
static_assert(alignof(AHighgroundVolume) == 0x000008, "Wrong alignment on AHighgroundVolume");
static_assert(sizeof(AHighgroundVolume) == 0x000308, "Wrong size on AHighgroundVolume");
static_assert(offsetof(AHighgroundVolume, AudioDebounce) == 0x0002A0, "Member 'AHighgroundVolume::AudioDebounce' has a wrong offset!");
static_assert(offsetof(AHighgroundVolume, Bounds) == 0x0002A8, "Member 'AHighgroundVolume::Bounds' has a wrong offset!");
static_assert(offsetof(AHighgroundVolume, AudioComp) == 0x0002B0, "Member 'AHighgroundVolume::AudioComp' has a wrong offset!");
static_assert(offsetof(AHighgroundVolume, bWatching) == 0x0002B8, "Member 'AHighgroundVolume::bWatching' has a wrong offset!");
static_assert(offsetof(AHighgroundVolume, SierraDesignation) == 0x0002BC, "Member 'AHighgroundVolume::SierraDesignation' has a wrong offset!");
static_assert(offsetof(AHighgroundVolume, VolumeLabel) == 0x0002C0, "Member 'AHighgroundVolume::VolumeLabel' has a wrong offset!");
static_assert(offsetof(AHighgroundVolume, ContactEnteredVolumeAudio) == 0x0002C8, "Member 'AHighgroundVolume::ContactEnteredVolumeAudio' has a wrong offset!");
static_assert(offsetof(AHighgroundVolume, ContactExitedVolumeAudio) == 0x0002D8, "Member 'AHighgroundVolume::ContactExitedVolumeAudio' has a wrong offset!");
static_assert(offsetof(AHighgroundVolume, SwatEnteredVolumeAudio) == 0x0002E8, "Member 'AHighgroundVolume::SwatEnteredVolumeAudio' has a wrong offset!");
static_assert(offsetof(AHighgroundVolume, SwatExitedVolumeAudio) == 0x0002F8, "Member 'AHighgroundVolume::SwatExitedVolumeAudio' has a wrong offset!");

// Class ReadyOrNot.ReadyOrNotRecastNavMesh
// 0x0008 (0x06A8 - 0x06A0)
class AReadyOrNotRecastNavMesh final : public ANotifyingRecastNavMesh
{
public:
	bool                                          bDrawStairPoints;                                  // 0x06A0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6A1[0x7];                                      // 0x06A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotRecastNavMesh">();
	}
	static class AReadyOrNotRecastNavMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<AReadyOrNotRecastNavMesh>();
	}
};
static_assert(alignof(AReadyOrNotRecastNavMesh) == 0x000008, "Wrong alignment on AReadyOrNotRecastNavMesh");
static_assert(sizeof(AReadyOrNotRecastNavMesh) == 0x0006A8, "Wrong size on AReadyOrNotRecastNavMesh");
static_assert(offsetof(AReadyOrNotRecastNavMesh, bDrawStairPoints) == 0x0006A0, "Member 'AReadyOrNotRecastNavMesh::bDrawStairPoints' has a wrong offset!");

// Class ReadyOrNot.HostMigrationManager
// 0x0100 (0x0128 - 0x0028)
class UHostMigrationManager final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHm_PlayerInformation>          PlayerInformations;                                // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FHm_CyberneticsInformation>     CyberneticsInformations;                           // 0x0048(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FHm_DoorInformation>            DoorInformations;                                  // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FHm_BombInformation>            BombInformations;                                  // 0x0068(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FHm_BaggedEvidence>             BaggedEvidenceInformations;                        // 0x0078(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FHm_DroppedEvidence>            DroppedEvidenceInformations;                       // 0x0088(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FHm_Objectives>                 ObjectiveInformations;                             // 0x0098(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class FString>                         ActiveEvidence;                                    // 0x00A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerState*                           NextHost;                                          // 0x00C8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 MigrationGUID;                                     // 0x00D0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E0[0x8];                                       // 0x00E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 MapName;                                           // 0x00E8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 ModeName;                                          // 0x00F8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_108[0x8];                                      // 0x0108(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 NextHostName;                                      // 0x0110(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExpectedPlayerCount;                               // 0x0120(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_124[0x4];                                      // 0x0124(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CreateMigrationSession();
	void FindMigrationSession();
	void OnLobbySuccess();
	void OnMigrationSessionFoundFailed(const TArray<struct FBlueprintSessionResult>& Results);
	void OnMigrationSessionFoundSuccess(const TArray<struct FBlueprintSessionResult>& Results);
	void ReturnToMainMenu();
	void SaveState();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HostMigrationManager">();
	}
	static class UHostMigrationManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHostMigrationManager>();
	}
};
static_assert(alignof(UHostMigrationManager) == 0x000008, "Wrong alignment on UHostMigrationManager");
static_assert(sizeof(UHostMigrationManager) == 0x000128, "Wrong size on UHostMigrationManager");
static_assert(offsetof(UHostMigrationManager, PlayerInformations) == 0x000038, "Member 'UHostMigrationManager::PlayerInformations' has a wrong offset!");
static_assert(offsetof(UHostMigrationManager, CyberneticsInformations) == 0x000048, "Member 'UHostMigrationManager::CyberneticsInformations' has a wrong offset!");
static_assert(offsetof(UHostMigrationManager, DoorInformations) == 0x000058, "Member 'UHostMigrationManager::DoorInformations' has a wrong offset!");
static_assert(offsetof(UHostMigrationManager, BombInformations) == 0x000068, "Member 'UHostMigrationManager::BombInformations' has a wrong offset!");
static_assert(offsetof(UHostMigrationManager, BaggedEvidenceInformations) == 0x000078, "Member 'UHostMigrationManager::BaggedEvidenceInformations' has a wrong offset!");
static_assert(offsetof(UHostMigrationManager, DroppedEvidenceInformations) == 0x000088, "Member 'UHostMigrationManager::DroppedEvidenceInformations' has a wrong offset!");
static_assert(offsetof(UHostMigrationManager, ObjectiveInformations) == 0x000098, "Member 'UHostMigrationManager::ObjectiveInformations' has a wrong offset!");
static_assert(offsetof(UHostMigrationManager, ActiveEvidence) == 0x0000A8, "Member 'UHostMigrationManager::ActiveEvidence' has a wrong offset!");
static_assert(offsetof(UHostMigrationManager, NextHost) == 0x0000C8, "Member 'UHostMigrationManager::NextHost' has a wrong offset!");
static_assert(offsetof(UHostMigrationManager, MigrationGUID) == 0x0000D0, "Member 'UHostMigrationManager::MigrationGUID' has a wrong offset!");
static_assert(offsetof(UHostMigrationManager, MapName) == 0x0000E8, "Member 'UHostMigrationManager::MapName' has a wrong offset!");
static_assert(offsetof(UHostMigrationManager, ModeName) == 0x0000F8, "Member 'UHostMigrationManager::ModeName' has a wrong offset!");
static_assert(offsetof(UHostMigrationManager, NextHostName) == 0x000110, "Member 'UHostMigrationManager::NextHostName' has a wrong offset!");
static_assert(offsetof(UHostMigrationManager, ExpectedPlayerCount) == 0x000120, "Member 'UHostMigrationManager::ExpectedPlayerCount' has a wrong offset!");

// Class ReadyOrNot.HotkeyWidget
// 0x0120 (0x03E0 - 0x02C0)
class UHotkeyWidget : public UUserWidget
{
public:
	class UTextBlock*                             Hotkey_Text;                                       // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Hotkey_Image;                                      // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 HotkeyDivider_Image;                               // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             RemainingUses_Text;                                // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       Anim_Pressed;                                      // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       Anim_Released;                                     // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   InputName;                                         // 0x02F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F8[0x8];                                      // 0x02F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            Icon;                                              // 0x0300(0x00D0)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	uint8                                         bCustomAnimation : 1;                              // 0x03D0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bShowRemainingUses : 1;                            // 0x03D0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_3D1[0xF];                                      // 0x03D1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PlayPressedAnimation();
	void PlayReleasedAnimation();
	void RefreshHotkey();
	void SetHotkeyImage(const struct FSlateBrush& Brush);
	void SetHotkeyRemainingUses(int32 InRemainingUses);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HotkeyWidget">();
	}
	static class UHotkeyWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHotkeyWidget>();
	}
};
static_assert(alignof(UHotkeyWidget) == 0x000010, "Wrong alignment on UHotkeyWidget");
static_assert(sizeof(UHotkeyWidget) == 0x0003E0, "Wrong size on UHotkeyWidget");
static_assert(offsetof(UHotkeyWidget, Hotkey_Text) == 0x0002C0, "Member 'UHotkeyWidget::Hotkey_Text' has a wrong offset!");
static_assert(offsetof(UHotkeyWidget, Hotkey_Image) == 0x0002C8, "Member 'UHotkeyWidget::Hotkey_Image' has a wrong offset!");
static_assert(offsetof(UHotkeyWidget, HotkeyDivider_Image) == 0x0002D0, "Member 'UHotkeyWidget::HotkeyDivider_Image' has a wrong offset!");
static_assert(offsetof(UHotkeyWidget, RemainingUses_Text) == 0x0002D8, "Member 'UHotkeyWidget::RemainingUses_Text' has a wrong offset!");
static_assert(offsetof(UHotkeyWidget, Anim_Pressed) == 0x0002E0, "Member 'UHotkeyWidget::Anim_Pressed' has a wrong offset!");
static_assert(offsetof(UHotkeyWidget, Anim_Released) == 0x0002E8, "Member 'UHotkeyWidget::Anim_Released' has a wrong offset!");
static_assert(offsetof(UHotkeyWidget, InputName) == 0x0002F0, "Member 'UHotkeyWidget::InputName' has a wrong offset!");
static_assert(offsetof(UHotkeyWidget, Icon) == 0x000300, "Member 'UHotkeyWidget::Icon' has a wrong offset!");

// Class ReadyOrNot.ReadyOrNotVoiceConfig
// 0x00B0 (0x00D8 - 0x0028)
class UReadyOrNotVoiceConfig final : public UGameplayConfig
{
public:
	TMap<class FString, struct FSequencedVOLookup> SequencedLookup;                                  // 0x0028(0x0050)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_78[0x60];                                      // 0x0078(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UReadyOrNotVoiceConfig* Get();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotVoiceConfig">();
	}
	static class UReadyOrNotVoiceConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotVoiceConfig>();
	}
};
static_assert(alignof(UReadyOrNotVoiceConfig) == 0x000008, "Wrong alignment on UReadyOrNotVoiceConfig");
static_assert(sizeof(UReadyOrNotVoiceConfig) == 0x0000D8, "Wrong size on UReadyOrNotVoiceConfig");
static_assert(offsetof(UReadyOrNotVoiceConfig, SequencedLookup) == 0x000028, "Member 'UReadyOrNotVoiceConfig::SequencedLookup' has a wrong offset!");

// Class ReadyOrNot.IconWidget
// 0x0010 (0x02D0 - 0x02C0)
class UIconWidget final : public UUserWidget
{
public:
	class UImage*                                 MainImage;                                         // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractableComponent*                 ParentComponent;                                   // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class UTexture2D* GetAttachedObjectIcon() const;
	class FString GetAttachedObjectName() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IconWidget">();
	}
	static class UIconWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIconWidget>();
	}
};
static_assert(alignof(UIconWidget) == 0x000008, "Wrong alignment on UIconWidget");
static_assert(sizeof(UIconWidget) == 0x0002D0, "Wrong size on UIconWidget");
static_assert(offsetof(UIconWidget, MainImage) == 0x0002C0, "Member 'UIconWidget::MainImage' has a wrong offset!");
static_assert(offsetof(UIconWidget, ParentComponent) == 0x0002C8, "Member 'UIconWidget::ParentComponent' has a wrong offset!");

// Class ReadyOrNot.IllegalUnbindModal
// 0x0000 (0x04B8 - 0x04B8)
class UIllegalUnbindModal : public UStandardModal
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IllegalUnbindModal">();
	}
	static class UIllegalUnbindModal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIllegalUnbindModal>();
	}
};
static_assert(alignof(UIllegalUnbindModal) == 0x000008, "Wrong alignment on UIllegalUnbindModal");
static_assert(sizeof(UIllegalUnbindModal) == 0x0004B8, "Wrong size on UIllegalUnbindModal");

// Class ReadyOrNot.ReflectionProbe
// 0x0028 (0x02C0 - 0x0298)
class AReflectionProbe final : public AActor
{
public:
	class UFMODAudioComponent*                    AudioComponent;                                    // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RoomSize;                                          // 0x02A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Volume;                                            // 0x02A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AReflectionProbe*>               SiblingProbes;                                     // 0x02A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bDeleteOnRegeneration;                             // 0x02B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B9[0x7];                                      // 0x02B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReflectionProbe">();
	}
	static class AReflectionProbe* GetDefaultObj()
	{
		return GetDefaultObjImpl<AReflectionProbe>();
	}
};
static_assert(alignof(AReflectionProbe) == 0x000008, "Wrong alignment on AReflectionProbe");
static_assert(sizeof(AReflectionProbe) == 0x0002C0, "Wrong size on AReflectionProbe");
static_assert(offsetof(AReflectionProbe, AudioComponent) == 0x000298, "Member 'AReflectionProbe::AudioComponent' has a wrong offset!");
static_assert(offsetof(AReflectionProbe, RoomSize) == 0x0002A0, "Member 'AReflectionProbe::RoomSize' has a wrong offset!");
static_assert(offsetof(AReflectionProbe, Volume) == 0x0002A4, "Member 'AReflectionProbe::Volume' has a wrong offset!");
static_assert(offsetof(AReflectionProbe, SiblingProbes) == 0x0002A8, "Member 'AReflectionProbe::SiblingProbes' has a wrong offset!");
static_assert(offsetof(AReflectionProbe, bDeleteOnRegeneration) == 0x0002B8, "Member 'AReflectionProbe::bDeleteOnRegeneration' has a wrong offset!");

// Class ReadyOrNot.IncapacitatedHuman
// 0x00D0 (0x0368 - 0x0298)
class AIncapacitatedHuman final : public AActor
{
public:
	uint8                                         Pad_298[0x28];                                     // 0x0298(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AIncapacitatedHuman* ReportedIncapacitatedHuman, class AReadyOrNotCharacter* Reporter)> OnReported; // 0x02C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class USceneComponent*                        DefaultScene;                                      // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 HumanMesh;                                         // 0x02D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 HumanMeshFace;                                     // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      CapsuleComponent;                                  // 0x02E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractableComponent*                 ReportInteractableComponent;                       // 0x02F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScoringComponent*                      ScoringComponent;                                  // 0x02F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODAudioComponent*                    IncapacitatedAudioComponent;                       // 0x0300(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAIPerceptionStimuliSourceComponent*    PerceptionStimuliComp;                             // 0x0308(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPhysicsAsset*                          RagdollPhysicsAsset;                               // 0x0310(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           DyingMontage;                                      // 0x0318(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODEvent*                             FMODEventLoop;                                     // 0x0320(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        ShotParticleEffect;                                // 0x0328(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsChild;                                          // 0x0330(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStartDead;                                        // 0x0331(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanEverDieByTime;                                 // 0x0332(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_333[0x1];                                      // 0x0333(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeRemainingUntilDead;                            // 0x0334(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsInGroup;                                        // 0x0338(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsMasterOfGroup;                                  // 0x0339(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_33A[0x6];                                      // 0x033A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AIncapacitatedHuman*>            IncapacitatedHumansInGroup;                        // 0x0340(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class AIncapacitatedHuman*                    MasterHumanInGroup;                                // 0x0350(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAttachReportInteractableToMesh;                   // 0x0358(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_359[0x3];                                      // 0x0359(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SocketToAttach;                                    // 0x035C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETeamType                                     Team;                                              // 0x0364(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsDead;                                           // 0x0365(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasBeenReported;                                  // 0x0366(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_367[0x1];                                      // 0x0367(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MakeMasterInGroup();
	void SelectAllInGroup();

	bool HasBeenReported() const;
	bool IsChild() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IncapacitatedHuman">();
	}
	static class AIncapacitatedHuman* GetDefaultObj()
	{
		return GetDefaultObjImpl<AIncapacitatedHuman>();
	}
};
static_assert(alignof(AIncapacitatedHuman) == 0x000008, "Wrong alignment on AIncapacitatedHuman");
static_assert(sizeof(AIncapacitatedHuman) == 0x000368, "Wrong size on AIncapacitatedHuman");
static_assert(offsetof(AIncapacitatedHuman, OnReported) == 0x0002C0, "Member 'AIncapacitatedHuman::OnReported' has a wrong offset!");
static_assert(offsetof(AIncapacitatedHuman, DefaultScene) == 0x0002D0, "Member 'AIncapacitatedHuman::DefaultScene' has a wrong offset!");
static_assert(offsetof(AIncapacitatedHuman, HumanMesh) == 0x0002D8, "Member 'AIncapacitatedHuman::HumanMesh' has a wrong offset!");
static_assert(offsetof(AIncapacitatedHuman, HumanMeshFace) == 0x0002E0, "Member 'AIncapacitatedHuman::HumanMeshFace' has a wrong offset!");
static_assert(offsetof(AIncapacitatedHuman, CapsuleComponent) == 0x0002E8, "Member 'AIncapacitatedHuman::CapsuleComponent' has a wrong offset!");
static_assert(offsetof(AIncapacitatedHuman, ReportInteractableComponent) == 0x0002F0, "Member 'AIncapacitatedHuman::ReportInteractableComponent' has a wrong offset!");
static_assert(offsetof(AIncapacitatedHuman, ScoringComponent) == 0x0002F8, "Member 'AIncapacitatedHuman::ScoringComponent' has a wrong offset!");
static_assert(offsetof(AIncapacitatedHuman, IncapacitatedAudioComponent) == 0x000300, "Member 'AIncapacitatedHuman::IncapacitatedAudioComponent' has a wrong offset!");
static_assert(offsetof(AIncapacitatedHuman, PerceptionStimuliComp) == 0x000308, "Member 'AIncapacitatedHuman::PerceptionStimuliComp' has a wrong offset!");
static_assert(offsetof(AIncapacitatedHuman, RagdollPhysicsAsset) == 0x000310, "Member 'AIncapacitatedHuman::RagdollPhysicsAsset' has a wrong offset!");
static_assert(offsetof(AIncapacitatedHuman, DyingMontage) == 0x000318, "Member 'AIncapacitatedHuman::DyingMontage' has a wrong offset!");
static_assert(offsetof(AIncapacitatedHuman, FMODEventLoop) == 0x000320, "Member 'AIncapacitatedHuman::FMODEventLoop' has a wrong offset!");
static_assert(offsetof(AIncapacitatedHuman, ShotParticleEffect) == 0x000328, "Member 'AIncapacitatedHuman::ShotParticleEffect' has a wrong offset!");
static_assert(offsetof(AIncapacitatedHuman, bIsChild) == 0x000330, "Member 'AIncapacitatedHuman::bIsChild' has a wrong offset!");
static_assert(offsetof(AIncapacitatedHuman, bStartDead) == 0x000331, "Member 'AIncapacitatedHuman::bStartDead' has a wrong offset!");
static_assert(offsetof(AIncapacitatedHuman, bCanEverDieByTime) == 0x000332, "Member 'AIncapacitatedHuman::bCanEverDieByTime' has a wrong offset!");
static_assert(offsetof(AIncapacitatedHuman, TimeRemainingUntilDead) == 0x000334, "Member 'AIncapacitatedHuman::TimeRemainingUntilDead' has a wrong offset!");
static_assert(offsetof(AIncapacitatedHuman, bIsInGroup) == 0x000338, "Member 'AIncapacitatedHuman::bIsInGroup' has a wrong offset!");
static_assert(offsetof(AIncapacitatedHuman, bIsMasterOfGroup) == 0x000339, "Member 'AIncapacitatedHuman::bIsMasterOfGroup' has a wrong offset!");
static_assert(offsetof(AIncapacitatedHuman, IncapacitatedHumansInGroup) == 0x000340, "Member 'AIncapacitatedHuman::IncapacitatedHumansInGroup' has a wrong offset!");
static_assert(offsetof(AIncapacitatedHuman, MasterHumanInGroup) == 0x000350, "Member 'AIncapacitatedHuman::MasterHumanInGroup' has a wrong offset!");
static_assert(offsetof(AIncapacitatedHuman, bAttachReportInteractableToMesh) == 0x000358, "Member 'AIncapacitatedHuman::bAttachReportInteractableToMesh' has a wrong offset!");
static_assert(offsetof(AIncapacitatedHuman, SocketToAttach) == 0x00035C, "Member 'AIncapacitatedHuman::SocketToAttach' has a wrong offset!");
static_assert(offsetof(AIncapacitatedHuman, Team) == 0x000364, "Member 'AIncapacitatedHuman::Team' has a wrong offset!");
static_assert(offsetof(AIncapacitatedHuman, bIsDead) == 0x000365, "Member 'AIncapacitatedHuman::bIsDead' has a wrong offset!");
static_assert(offsetof(AIncapacitatedHuman, bHasBeenReported) == 0x000366, "Member 'AIncapacitatedHuman::bHasBeenReported' has a wrong offset!");

// Class ReadyOrNot.IncriminationClueSpawnPoint
// 0x0058 (0x0308 - 0x02B0)
class AIncriminationClueSpawnPoint final : public AActorSpawnPoint
{
public:
	TSubclassOf<class AIncriminationClue>         IncriminationClueClass;                            // 0x02B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     ClueFlareClass;                                    // 0x02B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ClueNumber;                                        // 0x02C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C1[0x3];                                      // 0x02C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ShowObjectiveMarkerIn;                             // 0x02C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ClueName;                                          // 0x02C8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   ClueFoundMessage;                                  // 0x02E0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F8[0x10];                                     // 0x02F8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IncriminationClueSpawnPoint">();
	}
	static class AIncriminationClueSpawnPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AIncriminationClueSpawnPoint>();
	}
};
static_assert(alignof(AIncriminationClueSpawnPoint) == 0x000008, "Wrong alignment on AIncriminationClueSpawnPoint");
static_assert(sizeof(AIncriminationClueSpawnPoint) == 0x000308, "Wrong size on AIncriminationClueSpawnPoint");
static_assert(offsetof(AIncriminationClueSpawnPoint, IncriminationClueClass) == 0x0002B0, "Member 'AIncriminationClueSpawnPoint::IncriminationClueClass' has a wrong offset!");
static_assert(offsetof(AIncriminationClueSpawnPoint, ClueFlareClass) == 0x0002B8, "Member 'AIncriminationClueSpawnPoint::ClueFlareClass' has a wrong offset!");
static_assert(offsetof(AIncriminationClueSpawnPoint, ClueNumber) == 0x0002C0, "Member 'AIncriminationClueSpawnPoint::ClueNumber' has a wrong offset!");
static_assert(offsetof(AIncriminationClueSpawnPoint, ShowObjectiveMarkerIn) == 0x0002C4, "Member 'AIncriminationClueSpawnPoint::ShowObjectiveMarkerIn' has a wrong offset!");
static_assert(offsetof(AIncriminationClueSpawnPoint, ClueName) == 0x0002C8, "Member 'AIncriminationClueSpawnPoint::ClueName' has a wrong offset!");
static_assert(offsetof(AIncriminationClueSpawnPoint, ClueFoundMessage) == 0x0002E0, "Member 'AIncriminationClueSpawnPoint::ClueFoundMessage' has a wrong offset!");

// Class ReadyOrNot.SoundData
// 0x0000 (0x0030 - 0x0030)
class USoundData final : public UDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundData">();
	}
	static class USoundData* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundData>();
	}
};
static_assert(alignof(USoundData) == 0x000008, "Wrong alignment on USoundData");
static_assert(sizeof(USoundData) == 0x000030, "Wrong size on USoundData");

// Class ReadyOrNot.IncriminationGS
// 0x00D8 (0x09D0 - 0x08F8)
class AIncriminationGS final : public AReadyOrNotGameState
{
public:
	TMulticastInlineDelegate<void(class AEvidenceActor* EvidenceActor, EEvidenceActorState NewEvidenceState, bool bExtracted)> OnIntelStateChanged; // 0x08F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ASplineTrigger_Incrimination* EvidenceSearchArea)> OnIntelSearchAreaChosen; // 0x0908(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ABuildingTrigger_Incrimination* EvidenceSearchArea)> OnIntelBuildingChosen; // 0x0918(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AIncriminationClue* ActiveClue)> OnActiveClueChanged;        // 0x0928(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AIncriminationClue* ActiveClue)> OnPreviousActiveClueChanged; // 0x0938(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const TArray<class AIncriminationClue*>& Clues)> OnCluesChanged;   // 0x0948(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AEvidenceSpawnPoint*                    ChosenEvidenceSpawn;                               // 0x0958(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AEvidenceActor*                         ChosenEvidenceActor;                               // 0x0960(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AEvidenceExtractionDevice_Incrim*       ChosenExtractionDevice;                            // 0x0968(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AIncriminationClue*>             Clues;                                             // 0x0970(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class AIncriminationClueSpawnPoint*>   ClueSpawnPoints;                                   // 0x0980(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class AIncriminationClue*                     ActiveClue;                                        // 0x0990(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AIncriminationClue*                     PreviousActiveClue;                                // 0x0998(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASplineTrigger_Incrimination*           ChosenEvidenceSearchArea;                          // 0x09A0(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABuildingTrigger_Incrimination*         ChosenEvidenceBuilding;                            // 0x09A8(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ASplineTrigger_Incrimination*>   NonMainIntelSearchZones;                           // 0x09B0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class AEvidenceExtractionDevice*              CurrentExtractionDevice;                           // 0x09C0(0x0008)(BlueprintVisible, Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETeamType                                     PickupTeam;                                        // 0x09C8(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEvidenceActorState                           IntelState;                                        // 0x09C9(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIntelExtracted;                                   // 0x09CA(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9CB[0x5];                                      // 0x09CB(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AnyHigherCluesFound(int32 ClueNumber);
	bool AnyLowerCluesFound(int32 ClueNumber);
	bool DoesPlayerPossessAnyClue(class APlayerCharacter* PlayerCharacter);
	TArray<class AIncriminationClue*> GetAllCluesOfNumber(int32 ClueNumber);
	class AIncriminationClue* GetClue(int32 ClueNumber, bool* bSuccess, bool bMustBeFound);
	void OnRep_OnActiveClueChanged();
	void OnRep_OnCluesChanged();
	void OnRep_OnIntelBuildingChosen();
	void OnRep_OnIntelSearchAreaChosen();
	void OnRep_OnIntelStateChanged();
	void OnRep_OnPreviousActiveClueChanged();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IncriminationGS">();
	}
	static class AIncriminationGS* GetDefaultObj()
	{
		return GetDefaultObjImpl<AIncriminationGS>();
	}
};
static_assert(alignof(AIncriminationGS) == 0x000008, "Wrong alignment on AIncriminationGS");
static_assert(sizeof(AIncriminationGS) == 0x0009D0, "Wrong size on AIncriminationGS");
static_assert(offsetof(AIncriminationGS, OnIntelStateChanged) == 0x0008F8, "Member 'AIncriminationGS::OnIntelStateChanged' has a wrong offset!");
static_assert(offsetof(AIncriminationGS, OnIntelSearchAreaChosen) == 0x000908, "Member 'AIncriminationGS::OnIntelSearchAreaChosen' has a wrong offset!");
static_assert(offsetof(AIncriminationGS, OnIntelBuildingChosen) == 0x000918, "Member 'AIncriminationGS::OnIntelBuildingChosen' has a wrong offset!");
static_assert(offsetof(AIncriminationGS, OnActiveClueChanged) == 0x000928, "Member 'AIncriminationGS::OnActiveClueChanged' has a wrong offset!");
static_assert(offsetof(AIncriminationGS, OnPreviousActiveClueChanged) == 0x000938, "Member 'AIncriminationGS::OnPreviousActiveClueChanged' has a wrong offset!");
static_assert(offsetof(AIncriminationGS, OnCluesChanged) == 0x000948, "Member 'AIncriminationGS::OnCluesChanged' has a wrong offset!");
static_assert(offsetof(AIncriminationGS, ChosenEvidenceSpawn) == 0x000958, "Member 'AIncriminationGS::ChosenEvidenceSpawn' has a wrong offset!");
static_assert(offsetof(AIncriminationGS, ChosenEvidenceActor) == 0x000960, "Member 'AIncriminationGS::ChosenEvidenceActor' has a wrong offset!");
static_assert(offsetof(AIncriminationGS, ChosenExtractionDevice) == 0x000968, "Member 'AIncriminationGS::ChosenExtractionDevice' has a wrong offset!");
static_assert(offsetof(AIncriminationGS, Clues) == 0x000970, "Member 'AIncriminationGS::Clues' has a wrong offset!");
static_assert(offsetof(AIncriminationGS, ClueSpawnPoints) == 0x000980, "Member 'AIncriminationGS::ClueSpawnPoints' has a wrong offset!");
static_assert(offsetof(AIncriminationGS, ActiveClue) == 0x000990, "Member 'AIncriminationGS::ActiveClue' has a wrong offset!");
static_assert(offsetof(AIncriminationGS, PreviousActiveClue) == 0x000998, "Member 'AIncriminationGS::PreviousActiveClue' has a wrong offset!");
static_assert(offsetof(AIncriminationGS, ChosenEvidenceSearchArea) == 0x0009A0, "Member 'AIncriminationGS::ChosenEvidenceSearchArea' has a wrong offset!");
static_assert(offsetof(AIncriminationGS, ChosenEvidenceBuilding) == 0x0009A8, "Member 'AIncriminationGS::ChosenEvidenceBuilding' has a wrong offset!");
static_assert(offsetof(AIncriminationGS, NonMainIntelSearchZones) == 0x0009B0, "Member 'AIncriminationGS::NonMainIntelSearchZones' has a wrong offset!");
static_assert(offsetof(AIncriminationGS, CurrentExtractionDevice) == 0x0009C0, "Member 'AIncriminationGS::CurrentExtractionDevice' has a wrong offset!");
static_assert(offsetof(AIncriminationGS, PickupTeam) == 0x0009C8, "Member 'AIncriminationGS::PickupTeam' has a wrong offset!");
static_assert(offsetof(AIncriminationGS, IntelState) == 0x0009C9, "Member 'AIncriminationGS::IntelState' has a wrong offset!");
static_assert(offsetof(AIncriminationGS, bIntelExtracted) == 0x0009CA, "Member 'AIncriminationGS::bIntelExtracted' has a wrong offset!");

// Class ReadyOrNot.IncriminationTriggerBox
// 0x0000 (0x0308 - 0x0308)
class AIncriminationTriggerBox final : public APVPTriggerBox
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IncriminationTriggerBox">();
	}
	static class AIncriminationTriggerBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<AIncriminationTriggerBox>();
	}
};
static_assert(alignof(AIncriminationTriggerBox) == 0x000008, "Wrong alignment on AIncriminationTriggerBox");
static_assert(sizeof(AIncriminationTriggerBox) == 0x000308, "Wrong size on AIncriminationTriggerBox");

// Class ReadyOrNot.SoundPropagator
// 0x0078 (0x0310 - 0x0298)
class ASoundPropagator final : public AActor
{
public:
	TMap<class APropagationPoint*, float>         PropagationPoints;                                 // 0x0298(0x0050)(Edit, BlueprintVisible, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	uint8                                         bStopPropagationIfClosestToSound : 1;              // 0x02E8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2E9[0x3];                                      // 0x02E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PathTracerRefreshRate;                             // 0x02EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NavCheckRefreshRate;                               // 0x02F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bEnableDebugSpheres : 1;                           // 0x02F4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableDebugPathPoints : 1;                        // 0x02F4(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2F5[0x3];                                      // 0x02F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        SceneComponent;                                    // 0x02F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          PropagationSwitchEnter;                            // 0x0300(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          PropagationSwitchExit;                             // 0x0308(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnPropagationEnterOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnPropagationExitOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundPropagator">();
	}
	static class ASoundPropagator* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASoundPropagator>();
	}
};
static_assert(alignof(ASoundPropagator) == 0x000008, "Wrong alignment on ASoundPropagator");
static_assert(sizeof(ASoundPropagator) == 0x000310, "Wrong size on ASoundPropagator");
static_assert(offsetof(ASoundPropagator, PropagationPoints) == 0x000298, "Member 'ASoundPropagator::PropagationPoints' has a wrong offset!");
static_assert(offsetof(ASoundPropagator, PathTracerRefreshRate) == 0x0002EC, "Member 'ASoundPropagator::PathTracerRefreshRate' has a wrong offset!");
static_assert(offsetof(ASoundPropagator, NavCheckRefreshRate) == 0x0002F0, "Member 'ASoundPropagator::NavCheckRefreshRate' has a wrong offset!");
static_assert(offsetof(ASoundPropagator, SceneComponent) == 0x0002F8, "Member 'ASoundPropagator::SceneComponent' has a wrong offset!");
static_assert(offsetof(ASoundPropagator, PropagationSwitchEnter) == 0x000300, "Member 'ASoundPropagator::PropagationSwitchEnter' has a wrong offset!");
static_assert(offsetof(ASoundPropagator, PropagationSwitchExit) == 0x000308, "Member 'ASoundPropagator::PropagationSwitchExit' has a wrong offset!");

// Class ReadyOrNot.InteractableComponent
// 0x04A0 (0x0B90 - 0x06F0)
class UInteractableComponent final : public UWidgetComponent
{
public:
	uint8                                         bEnabled : 1;                                      // 0x06E8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_6E9[0x3];                                      // 0x06E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AnimatedIconName;                                  // 0x06EC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowActionPromptInWorld;                          // 0x06F4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableActionPromptBackground;                     // 0x06F5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideActionPromptUserSettings;                 // 0x06F6(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bShowIconWhenActionsLocked : 1;                    // 0x06F7(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	struct FPlayerActionPromptSlot                ActionSlot1;                                       // 0x06F8(0x0090)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FPlayerActionPromptSlot                ActionSlot2;                                       // 0x0788(0x0090)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FPlayerActionPromptSlot                ActionSlot3;                                       // 0x0818(0x0090)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FPlayerActionPromptSlot                ActionSlot4;                                       // 0x08A8(0x0090)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bDistanceChecksEnabled;                            // 0x0938(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_939[0x3];                                      // 0x0939(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinShowPromptAtDistance;                           // 0x093C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShowPromptAtDistance;                              // 0x0940(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bMustBeLookingAt : 1;                              // 0x0944(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_945[0x3];                                      // 0x0945(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RequiredLookAtPercentage;                          // 0x0948(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMustBeOverlapping;                                // 0x094C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94D[0x3];                                      // 0x094D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InteractCircleSize;                                // 0x0950(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InteractIconSize;                                  // 0x0954(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bDistanceFadeIcon : 1;                             // 0x0958(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bHideUponInteraction : 1;                          // 0x0958(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bHideUponPlayerMovement : 1;                       // 0x0958(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bImprintIconOnHUDUponInteraction : 1;              // 0x0958(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_959[0x7];                                      // 0x0959(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class APlayerController*>              DisallowedPlayerControllers;                       // 0x0960(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, EditConst, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         IgnoreInteractionBlockingActors;                   // 0x0970(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         CurrentProgress;                                   // 0x0980(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_984[0x4];                                      // 0x0984(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnimatedIcon                          AnimatedIcon;                                      // 0x0988(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class AActor*                                 UseActor;                                          // 0x09A0(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClientInteract;                                   // 0x09A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExecuteOnServer;                                  // 0x09A9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9AA[0x6];                                      // 0x09AA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class APlayerCharacter*>               PlayersFocusing;                                   // 0x09B0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUserWidget>                CachedWidgetClass;                                 // 0x09C0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimatedIconWidgetWithActionPrompt*    IconWidget;                                        // 0x09C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUserWidget>                ImprintIconWidgetClass;                            // 0x09D0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimatedIconWidget_Imprint*            IconWidget_Imprint;                                // 0x09D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class FName, struct FAnimatedIcon>       AnimatedIconMap;                                   // 0x09E0(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_A30[0x160];                                    // 0x0A30(0x0160)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DisableInteractable();
	void DisableInteractionFor(class APlayerCharacter* InCharacter);
	void EnableInteractable();
	void EnableInteractionFor(class APlayerCharacter* InCharacter);
	bool InputActionNameMatchesAnySlot(class FName InInputActionName);
	bool InputActionNameMatchesAnyValidSlot(class FName InInputActionName);
	bool IsBeingLookedAt(class APlayerController* InPlayerController, float MaxRange, float LookatThreshold, bool bUseActorLocation);
	bool IsInteractionEnabledFor(class APlayerCharacter* InCharacter);
	void OnInteract(class APlayerCharacter* InteractInstigator);
	void ResetToOriginalLocation();
	void SetAnimatedIconName(const class FName& NewIconName);
	void SetInteractionIconSize(float InInteractCircleSize, float InInteractIconSize);
	void SetInteractionIconState(bool bValid);

	bool AnyActionSlotValid() const;
	bool CanInteract(bool bLog) const;
	float GetDistanceFromPlayer() const;
	class FName GetOriginalIconName() const;
	struct FVector GetOriginalLocation() const;
	struct FVector GetOriginalLocation_Relative() const;
	TArray<class APlayerCharacter*> GetPlayersFocusing() const;
	class AActor* GetUseActor() const;
	bool IsFocused() const;
	bool IsIconVisible() const;
	bool IsInteractionEnabledForController(class APlayerController* InController) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractableComponent">();
	}
	static class UInteractableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractableComponent>();
	}
};
static_assert(alignof(UInteractableComponent) == 0x000010, "Wrong alignment on UInteractableComponent");
static_assert(sizeof(UInteractableComponent) == 0x000B90, "Wrong size on UInteractableComponent");
static_assert(offsetof(UInteractableComponent, AnimatedIconName) == 0x0006EC, "Member 'UInteractableComponent::AnimatedIconName' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, bShowActionPromptInWorld) == 0x0006F4, "Member 'UInteractableComponent::bShowActionPromptInWorld' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, bEnableActionPromptBackground) == 0x0006F5, "Member 'UInteractableComponent::bEnableActionPromptBackground' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, bOverrideActionPromptUserSettings) == 0x0006F6, "Member 'UInteractableComponent::bOverrideActionPromptUserSettings' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, ActionSlot1) == 0x0006F8, "Member 'UInteractableComponent::ActionSlot1' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, ActionSlot2) == 0x000788, "Member 'UInteractableComponent::ActionSlot2' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, ActionSlot3) == 0x000818, "Member 'UInteractableComponent::ActionSlot3' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, ActionSlot4) == 0x0008A8, "Member 'UInteractableComponent::ActionSlot4' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, bDistanceChecksEnabled) == 0x000938, "Member 'UInteractableComponent::bDistanceChecksEnabled' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, MinShowPromptAtDistance) == 0x00093C, "Member 'UInteractableComponent::MinShowPromptAtDistance' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, ShowPromptAtDistance) == 0x000940, "Member 'UInteractableComponent::ShowPromptAtDistance' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, RequiredLookAtPercentage) == 0x000948, "Member 'UInteractableComponent::RequiredLookAtPercentage' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, bMustBeOverlapping) == 0x00094C, "Member 'UInteractableComponent::bMustBeOverlapping' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, InteractCircleSize) == 0x000950, "Member 'UInteractableComponent::InteractCircleSize' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, InteractIconSize) == 0x000954, "Member 'UInteractableComponent::InteractIconSize' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, DisallowedPlayerControllers) == 0x000960, "Member 'UInteractableComponent::DisallowedPlayerControllers' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, IgnoreInteractionBlockingActors) == 0x000970, "Member 'UInteractableComponent::IgnoreInteractionBlockingActors' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, CurrentProgress) == 0x000980, "Member 'UInteractableComponent::CurrentProgress' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, AnimatedIcon) == 0x000988, "Member 'UInteractableComponent::AnimatedIcon' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, UseActor) == 0x0009A0, "Member 'UInteractableComponent::UseActor' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, bClientInteract) == 0x0009A8, "Member 'UInteractableComponent::bClientInteract' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, bExecuteOnServer) == 0x0009A9, "Member 'UInteractableComponent::bExecuteOnServer' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, PlayersFocusing) == 0x0009B0, "Member 'UInteractableComponent::PlayersFocusing' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, CachedWidgetClass) == 0x0009C0, "Member 'UInteractableComponent::CachedWidgetClass' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, IconWidget) == 0x0009C8, "Member 'UInteractableComponent::IconWidget' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, ImprintIconWidgetClass) == 0x0009D0, "Member 'UInteractableComponent::ImprintIconWidgetClass' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, IconWidget_Imprint) == 0x0009D8, "Member 'UInteractableComponent::IconWidget_Imprint' has a wrong offset!");
static_assert(offsetof(UInteractableComponent, AnimatedIconMap) == 0x0009E0, "Member 'UInteractableComponent::AnimatedIconMap' has a wrong offset!");

// Class ReadyOrNot.InteractWithDoorObjective
// 0x0020 (0x0340 - 0x0320)
class AInteractWithDoorObjective final : public AObjective
{
public:
	TArray<class ADoor*>                          Doors;                                             // 0x0320(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	class FName                                   DoorTag;                                           // 0x0330(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EObjectiveDoorInteractions                    DoorInteractionType;                               // 0x0338(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_339[0x7];                                      // 0x0339(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDoorKicked(class ADoor* Door, class AReadyOrNotCharacter* InstigatorCharacter, bool bSuccess);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractWithDoorObjective">();
	}
	static class AInteractWithDoorObjective* GetDefaultObj()
	{
		return GetDefaultObjImpl<AInteractWithDoorObjective>();
	}
};
static_assert(alignof(AInteractWithDoorObjective) == 0x000008, "Wrong alignment on AInteractWithDoorObjective");
static_assert(sizeof(AInteractWithDoorObjective) == 0x000340, "Wrong size on AInteractWithDoorObjective");
static_assert(offsetof(AInteractWithDoorObjective, Doors) == 0x000320, "Member 'AInteractWithDoorObjective::Doors' has a wrong offset!");
static_assert(offsetof(AInteractWithDoorObjective, DoorTag) == 0x000330, "Member 'AInteractWithDoorObjective::DoorTag' has a wrong offset!");
static_assert(offsetof(AInteractWithDoorObjective, DoorInteractionType) == 0x000338, "Member 'AInteractWithDoorObjective::DoorInteractionType' has a wrong offset!");

// Class ReadyOrNot.SpawnSkeletalMeshAnimNotifyState
// 0x00A0 (0x00D0 - 0x0030)
class USpawnSkeletalMeshAnimNotifyState final : public UAnimNotifyState
{
public:
	class USkeletalMesh*                          SkeletalMeshToSpawn;                               // 0x0030(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimationAsset*                        PlayAnimation;                                     // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             MeshTransform;                                     // 0x0040(0x0060)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableWeaponFOVShader;                            // 0x00A0(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyOwnerSee;                                     // 0x00A1(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOwnerNoSee;                                       // 0x00A2(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A3[0x1];                                       // 0x00A3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BoneToSpawnOn;                                     // 0x00A4(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDestroyAtEnd;                                     // 0x00AC(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSimulatePhysicsAtEnd;                             // 0x00AD(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AE[0x2];                                       // 0x00AE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ForceVector;                                       // 0x00B0(0x0018)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnSkeletalMeshAnimNotifyState">();
	}
	static class USpawnSkeletalMeshAnimNotifyState* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpawnSkeletalMeshAnimNotifyState>();
	}
};
static_assert(alignof(USpawnSkeletalMeshAnimNotifyState) == 0x000010, "Wrong alignment on USpawnSkeletalMeshAnimNotifyState");
static_assert(sizeof(USpawnSkeletalMeshAnimNotifyState) == 0x0000D0, "Wrong size on USpawnSkeletalMeshAnimNotifyState");
static_assert(offsetof(USpawnSkeletalMeshAnimNotifyState, SkeletalMeshToSpawn) == 0x000030, "Member 'USpawnSkeletalMeshAnimNotifyState::SkeletalMeshToSpawn' has a wrong offset!");
static_assert(offsetof(USpawnSkeletalMeshAnimNotifyState, PlayAnimation) == 0x000038, "Member 'USpawnSkeletalMeshAnimNotifyState::PlayAnimation' has a wrong offset!");
static_assert(offsetof(USpawnSkeletalMeshAnimNotifyState, MeshTransform) == 0x000040, "Member 'USpawnSkeletalMeshAnimNotifyState::MeshTransform' has a wrong offset!");
static_assert(offsetof(USpawnSkeletalMeshAnimNotifyState, bEnableWeaponFOVShader) == 0x0000A0, "Member 'USpawnSkeletalMeshAnimNotifyState::bEnableWeaponFOVShader' has a wrong offset!");
static_assert(offsetof(USpawnSkeletalMeshAnimNotifyState, bOnlyOwnerSee) == 0x0000A1, "Member 'USpawnSkeletalMeshAnimNotifyState::bOnlyOwnerSee' has a wrong offset!");
static_assert(offsetof(USpawnSkeletalMeshAnimNotifyState, bOwnerNoSee) == 0x0000A2, "Member 'USpawnSkeletalMeshAnimNotifyState::bOwnerNoSee' has a wrong offset!");
static_assert(offsetof(USpawnSkeletalMeshAnimNotifyState, BoneToSpawnOn) == 0x0000A4, "Member 'USpawnSkeletalMeshAnimNotifyState::BoneToSpawnOn' has a wrong offset!");
static_assert(offsetof(USpawnSkeletalMeshAnimNotifyState, bDestroyAtEnd) == 0x0000AC, "Member 'USpawnSkeletalMeshAnimNotifyState::bDestroyAtEnd' has a wrong offset!");
static_assert(offsetof(USpawnSkeletalMeshAnimNotifyState, bSimulatePhysicsAtEnd) == 0x0000AD, "Member 'USpawnSkeletalMeshAnimNotifyState::bSimulatePhysicsAtEnd' has a wrong offset!");
static_assert(offsetof(USpawnSkeletalMeshAnimNotifyState, ForceVector) == 0x0000B0, "Member 'USpawnSkeletalMeshAnimNotifyState::ForceVector' has a wrong offset!");

// Class ReadyOrNot.IntimidateNearbyCivilianActivity
// 0x0018 (0x0208 - 0x01F0)
class UIntimidateNearbyCivilianActivity final : public UBaseActivity
{
public:
	class ACyberneticCharacter*                   TargetCivilian;                                    // 0x01F0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F8[0x10];                                     // 0x01F8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IntimidateNearbyCivilianActivity">();
	}
	static class UIntimidateNearbyCivilianActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIntimidateNearbyCivilianActivity>();
	}
};
static_assert(alignof(UIntimidateNearbyCivilianActivity) == 0x000008, "Wrong alignment on UIntimidateNearbyCivilianActivity");
static_assert(sizeof(UIntimidateNearbyCivilianActivity) == 0x000208, "Wrong size on UIntimidateNearbyCivilianActivity");
static_assert(offsetof(UIntimidateNearbyCivilianActivity, TargetCivilian) == 0x0001F0, "Member 'UIntimidateNearbyCivilianActivity::TargetCivilian' has a wrong offset!");

// Class ReadyOrNot.SpinTestHeatmapVolume
// 0x0000 (0x02D0 - 0x02D0)
class ASpinTestHeatmapVolume final : public AVolume
{
public:
	void FlushVisualization();
	void VisualizeHeatMapIfExists();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpinTestHeatmapVolume">();
	}
	static class ASpinTestHeatmapVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASpinTestHeatmapVolume>();
	}
};
static_assert(alignof(ASpinTestHeatmapVolume) == 0x000008, "Wrong alignment on ASpinTestHeatmapVolume");
static_assert(sizeof(ASpinTestHeatmapVolume) == 0x0002D0, "Wrong size on ASpinTestHeatmapVolume");

// Class ReadyOrNot.InvestigateStimulusActivity
// 0x0088 (0x0278 - 0x01F0)
class UInvestigateStimulusActivity final : public UBaseActivity
{
public:
	struct FAIStimulus                            Stimulus;                                          // 0x01F0(0x0058)(BlueprintVisible, BlueprintReadOnly, NoDestructor, ExposeOnSpawn, NativeAccessSpecifierPublic)
	class AReadyOrNotCharacter*                   Instigator;                                        // 0x0248(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_250[0x28];                                     // 0x0250(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InvestigateStimulusActivity">();
	}
	static class UInvestigateStimulusActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInvestigateStimulusActivity>();
	}
};
static_assert(alignof(UInvestigateStimulusActivity) == 0x000008, "Wrong alignment on UInvestigateStimulusActivity");
static_assert(sizeof(UInvestigateStimulusActivity) == 0x000278, "Wrong size on UInvestigateStimulusActivity");
static_assert(offsetof(UInvestigateStimulusActivity, Stimulus) == 0x0001F0, "Member 'UInvestigateStimulusActivity::Stimulus' has a wrong offset!");
static_assert(offsetof(UInvestigateStimulusActivity, Instigator) == 0x000248, "Member 'UInvestigateStimulusActivity::Instigator' has a wrong offset!");

// Class ReadyOrNot.AmmoCacheResourceComponent
// 0x0000 (0x0100 - 0x0100)
class UAmmoCacheResourceComponent final : public UCacheResourceComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AmmoCacheResourceComponent">();
	}
	static class UAmmoCacheResourceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAmmoCacheResourceComponent>();
	}
};
static_assert(alignof(UAmmoCacheResourceComponent) == 0x000008, "Wrong alignment on UAmmoCacheResourceComponent");
static_assert(sizeof(UAmmoCacheResourceComponent) == 0x000100, "Wrong size on UAmmoCacheResourceComponent");

// Class ReadyOrNot.PlacedZipcuffs
// 0x0008 (0x02A0 - 0x0298)
class APlacedZipcuffs : public AActor
{
public:
	class USkeletalMeshComponent*                 ZipcuffMesh;                                       // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlacedZipcuffs">();
	}
	static class APlacedZipcuffs* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlacedZipcuffs>();
	}
};
static_assert(alignof(APlacedZipcuffs) == 0x000008, "Wrong alignment on APlacedZipcuffs");
static_assert(sizeof(APlacedZipcuffs) == 0x0002A0, "Wrong size on APlacedZipcuffs");
static_assert(offsetof(APlacedZipcuffs, ZipcuffMesh) == 0x000298, "Member 'APlacedZipcuffs::ZipcuffMesh' has a wrong offset!");

// Class ReadyOrNot.WeaponCacheResourceComponent
// 0x0010 (0x0110 - 0x0100)
class UWeaponCacheResourceComponent final : public UCacheResourceComponent
{
public:
	TArray<TSubclassOf<class ABaseMagazineWeapon>> AvailableWeapons;                                 // 0x0100(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponCacheResourceComponent">();
	}
	static class UWeaponCacheResourceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponCacheResourceComponent>();
	}
};
static_assert(alignof(UWeaponCacheResourceComponent) == 0x000008, "Wrong alignment on UWeaponCacheResourceComponent");
static_assert(sizeof(UWeaponCacheResourceComponent) == 0x000110, "Wrong size on UWeaponCacheResourceComponent");
static_assert(offsetof(UWeaponCacheResourceComponent, AvailableWeapons) == 0x000100, "Member 'UWeaponCacheResourceComponent::AvailableWeapons' has a wrong offset!");

// Class ReadyOrNot.ItemCacheActor
// 0x0070 (0x0308 - 0x0298)
class AItemCacheActor final : public AActor
{
public:
	uint8                                         Pad_298[0x20];                                     // 0x0298(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   Mesh;                                              // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractableComponent*                 InteractableComponent;                             // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UScoringComponent*                      ScoringComponent;                                  // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEvidenceComponent*                     EvidenceComponent;                                 // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x02D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowSecuring;                                    // 0x02D9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DA[0x6];                                      // 0x02DA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ReportVoiceLine;                                   // 0x02E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ACyberneticCharacter* InteractingCharacter, class UCacheResourceComponent* AffectedResourceComponent)> OnCacheInteraction; // 0x02F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bIsSecured;                                        // 0x0300(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_301[0x7];                                      // 0x0301(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GiveItemTo(class ACyberneticCharacter* Character);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemCacheActor">();
	}
	static class AItemCacheActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItemCacheActor>();
	}
};
static_assert(alignof(AItemCacheActor) == 0x000008, "Wrong alignment on AItemCacheActor");
static_assert(sizeof(AItemCacheActor) == 0x000308, "Wrong size on AItemCacheActor");
static_assert(offsetof(AItemCacheActor, Mesh) == 0x0002B8, "Member 'AItemCacheActor::Mesh' has a wrong offset!");
static_assert(offsetof(AItemCacheActor, InteractableComponent) == 0x0002C0, "Member 'AItemCacheActor::InteractableComponent' has a wrong offset!");
static_assert(offsetof(AItemCacheActor, ScoringComponent) == 0x0002C8, "Member 'AItemCacheActor::ScoringComponent' has a wrong offset!");
static_assert(offsetof(AItemCacheActor, EvidenceComponent) == 0x0002D0, "Member 'AItemCacheActor::EvidenceComponent' has a wrong offset!");
static_assert(offsetof(AItemCacheActor, bEnabled) == 0x0002D8, "Member 'AItemCacheActor::bEnabled' has a wrong offset!");
static_assert(offsetof(AItemCacheActor, bAllowSecuring) == 0x0002D9, "Member 'AItemCacheActor::bAllowSecuring' has a wrong offset!");
static_assert(offsetof(AItemCacheActor, ReportVoiceLine) == 0x0002E0, "Member 'AItemCacheActor::ReportVoiceLine' has a wrong offset!");
static_assert(offsetof(AItemCacheActor, OnCacheInteraction) == 0x0002F0, "Member 'AItemCacheActor::OnCacheInteraction' has a wrong offset!");
static_assert(offsetof(AItemCacheActor, bIsSecured) == 0x000300, "Member 'AItemCacheActor::bIsSecured' has a wrong offset!");

// Class ReadyOrNot.PlayDeadActivity
// 0x0020 (0x0210 - 0x01F0)
class UPlayDeadActivity final : public UBaseActivity
{
public:
	uint8                                         Pad_1F0[0x20];                                     // 0x01F0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDamaged(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* DamagedCharacter, class AActor* DamageCauser, float Damage, float HealthRemaining);
	void OnHeardYell(class AReadyOrNotCharacter* Shouter, bool bLOS);
	void OnStunned(class AReadyOrNotCharacter* StunnedCharacter, float Duration, EStunType StunType, class AActor* DamageCauser);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayDeadActivity">();
	}
	static class UPlayDeadActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayDeadActivity>();
	}
};
static_assert(alignof(UPlayDeadActivity) == 0x000008, "Wrong alignment on UPlayDeadActivity");
static_assert(sizeof(UPlayDeadActivity) == 0x000210, "Wrong size on UPlayDeadActivity");

// Class ReadyOrNot.ItemSlotTactical_V2
// 0x0068 (0x0350 - 0x02E8)
class UItemSlotTactical_V2 : public UCommonUserWidget
{
public:
	ELoadoutTacticalSlotType                      SlotType;                                          // 0x02E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E9[0x7];                                      // 0x02E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ABaseItem>                  SlotItem;                                          // 0x02F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SlotAmmunitionName;                                // 0x02F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   SlotName;                                          // 0x0300(0x0018)(Edit, NativeAccessSpecifierPublic)
	TDelegate<void(EUINavigation Navigation)>     NavigationDelegate;                                // 0x0318(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             ItemName;                                          // 0x0328(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ItemType;                                          // 0x0330(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ItemCount;                                         // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                LeftArrow;                                         // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                RightArrow;                                        // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class FText GetItemDescription();
	class FText GetItemName();
	class UWidget* OnNavigateLeft(EUINavigation NavigationRule);
	class UWidget* OnNavigateRight(EUINavigation NavigationRule);
	void OnSlotsUpdated();
	void Refresh();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemSlotTactical_V2">();
	}
	static class UItemSlotTactical_V2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemSlotTactical_V2>();
	}
};
static_assert(alignof(UItemSlotTactical_V2) == 0x000008, "Wrong alignment on UItemSlotTactical_V2");
static_assert(sizeof(UItemSlotTactical_V2) == 0x000350, "Wrong size on UItemSlotTactical_V2");
static_assert(offsetof(UItemSlotTactical_V2, SlotType) == 0x0002E8, "Member 'UItemSlotTactical_V2::SlotType' has a wrong offset!");
static_assert(offsetof(UItemSlotTactical_V2, SlotItem) == 0x0002F0, "Member 'UItemSlotTactical_V2::SlotItem' has a wrong offset!");
static_assert(offsetof(UItemSlotTactical_V2, SlotAmmunitionName) == 0x0002F8, "Member 'UItemSlotTactical_V2::SlotAmmunitionName' has a wrong offset!");
static_assert(offsetof(UItemSlotTactical_V2, SlotName) == 0x000300, "Member 'UItemSlotTactical_V2::SlotName' has a wrong offset!");
static_assert(offsetof(UItemSlotTactical_V2, NavigationDelegate) == 0x000318, "Member 'UItemSlotTactical_V2::NavigationDelegate' has a wrong offset!");
static_assert(offsetof(UItemSlotTactical_V2, ItemName) == 0x000328, "Member 'UItemSlotTactical_V2::ItemName' has a wrong offset!");
static_assert(offsetof(UItemSlotTactical_V2, ItemType) == 0x000330, "Member 'UItemSlotTactical_V2::ItemType' has a wrong offset!");
static_assert(offsetof(UItemSlotTactical_V2, ItemCount) == 0x000338, "Member 'UItemSlotTactical_V2::ItemCount' has a wrong offset!");
static_assert(offsetof(UItemSlotTactical_V2, LeftArrow) == 0x000340, "Member 'UItemSlotTactical_V2::LeftArrow' has a wrong offset!");
static_assert(offsetof(UItemSlotTactical_V2, RightArrow) == 0x000348, "Member 'UItemSlotTactical_V2::RightArrow' has a wrong offset!");

// Class ReadyOrNot.ItemVisualizationComponent
// 0x0040 (0x0FE0 - 0x0FA0)
class UItemVisualizationComponent final : public USkeletalMeshComponent
{
public:
	EItemVisualizationType                        VisualizationType;                                 // 0x0FA0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FA1[0x7];                                      // 0x0FA1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ABaseItem*                              BasedOfItem;                                       // 0x0FA8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   MagazineComp;                                      // 0x0FB0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 ScopeAttachment;                                   // 0x0FB8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 MuzzleAttachment;                                  // 0x0FC0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 UnderbarrelAttachment;                             // 0x0FC8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 OverbarrelAttachment;                              // 0x0FD0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FD8[0x8];                                      // 0x0FD8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemVisualizationComponent">();
	}
	static class UItemVisualizationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemVisualizationComponent>();
	}
};
static_assert(alignof(UItemVisualizationComponent) == 0x000010, "Wrong alignment on UItemVisualizationComponent");
static_assert(sizeof(UItemVisualizationComponent) == 0x000FE0, "Wrong size on UItemVisualizationComponent");
static_assert(offsetof(UItemVisualizationComponent, VisualizationType) == 0x000FA0, "Member 'UItemVisualizationComponent::VisualizationType' has a wrong offset!");
static_assert(offsetof(UItemVisualizationComponent, BasedOfItem) == 0x000FA8, "Member 'UItemVisualizationComponent::BasedOfItem' has a wrong offset!");
static_assert(offsetof(UItemVisualizationComponent, MagazineComp) == 0x000FB0, "Member 'UItemVisualizationComponent::MagazineComp' has a wrong offset!");
static_assert(offsetof(UItemVisualizationComponent, ScopeAttachment) == 0x000FB8, "Member 'UItemVisualizationComponent::ScopeAttachment' has a wrong offset!");
static_assert(offsetof(UItemVisualizationComponent, MuzzleAttachment) == 0x000FC0, "Member 'UItemVisualizationComponent::MuzzleAttachment' has a wrong offset!");
static_assert(offsetof(UItemVisualizationComponent, UnderbarrelAttachment) == 0x000FC8, "Member 'UItemVisualizationComponent::UnderbarrelAttachment' has a wrong offset!");
static_assert(offsetof(UItemVisualizationComponent, OverbarrelAttachment) == 0x000FD0, "Member 'UItemVisualizationComponent::OverbarrelAttachment' has a wrong offset!");

// Class ReadyOrNot.PlayerEffect_ModifyRecoil
// 0x00B0 (0x0110 - 0x0060)
class UPlayerEffect_ModifyRecoil : public UBasePlayerEffect
{
public:
	ERecoilModifierOption                         ModificationOption;                                // 0x0060(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EItemClass>                            WeaponFilter;                                      // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         RecoilFireStrength;                                // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RecoilFireStrengthFirst;                           // 0x007C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RecoilDampStrength;                                // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RecoilAngleStrength;                               // 0x0084(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RecoilRandomness;                                  // 0x0088(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RecoilFireADSModifier;                             // 0x008C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RecoilBuildupADSModifier;                          // 0x0090(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RecoilAngleADSModifier;                            // 0x0094(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RecoilBuildupDampStrength;                         // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bApplySpecific : 1;                                // 0x009C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_9D[0x3];                                       // 0x009D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSpecificWeaponRecoilMod>       SpecificWeaponRecoilMods;                          // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<class ABaseMagazineWeapon*, struct FSpecificWeaponRecoilMod> OriginalRecoilValues;          // 0x00B0(0x0050)(NativeAccessSpecifierPrivate)
	TArray<class ABaseMagazineWeapon*>            AffectedWeapons;                                   // 0x0100(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerEffect_ModifyRecoil">();
	}
	static class UPlayerEffect_ModifyRecoil* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerEffect_ModifyRecoil>();
	}
};
static_assert(alignof(UPlayerEffect_ModifyRecoil) == 0x000008, "Wrong alignment on UPlayerEffect_ModifyRecoil");
static_assert(sizeof(UPlayerEffect_ModifyRecoil) == 0x000110, "Wrong size on UPlayerEffect_ModifyRecoil");
static_assert(offsetof(UPlayerEffect_ModifyRecoil, ModificationOption) == 0x000060, "Member 'UPlayerEffect_ModifyRecoil::ModificationOption' has a wrong offset!");
static_assert(offsetof(UPlayerEffect_ModifyRecoil, WeaponFilter) == 0x000068, "Member 'UPlayerEffect_ModifyRecoil::WeaponFilter' has a wrong offset!");
static_assert(offsetof(UPlayerEffect_ModifyRecoil, RecoilFireStrength) == 0x000078, "Member 'UPlayerEffect_ModifyRecoil::RecoilFireStrength' has a wrong offset!");
static_assert(offsetof(UPlayerEffect_ModifyRecoil, RecoilFireStrengthFirst) == 0x00007C, "Member 'UPlayerEffect_ModifyRecoil::RecoilFireStrengthFirst' has a wrong offset!");
static_assert(offsetof(UPlayerEffect_ModifyRecoil, RecoilDampStrength) == 0x000080, "Member 'UPlayerEffect_ModifyRecoil::RecoilDampStrength' has a wrong offset!");
static_assert(offsetof(UPlayerEffect_ModifyRecoil, RecoilAngleStrength) == 0x000084, "Member 'UPlayerEffect_ModifyRecoil::RecoilAngleStrength' has a wrong offset!");
static_assert(offsetof(UPlayerEffect_ModifyRecoil, RecoilRandomness) == 0x000088, "Member 'UPlayerEffect_ModifyRecoil::RecoilRandomness' has a wrong offset!");
static_assert(offsetof(UPlayerEffect_ModifyRecoil, RecoilFireADSModifier) == 0x00008C, "Member 'UPlayerEffect_ModifyRecoil::RecoilFireADSModifier' has a wrong offset!");
static_assert(offsetof(UPlayerEffect_ModifyRecoil, RecoilBuildupADSModifier) == 0x000090, "Member 'UPlayerEffect_ModifyRecoil::RecoilBuildupADSModifier' has a wrong offset!");
static_assert(offsetof(UPlayerEffect_ModifyRecoil, RecoilAngleADSModifier) == 0x000094, "Member 'UPlayerEffect_ModifyRecoil::RecoilAngleADSModifier' has a wrong offset!");
static_assert(offsetof(UPlayerEffect_ModifyRecoil, RecoilBuildupDampStrength) == 0x000098, "Member 'UPlayerEffect_ModifyRecoil::RecoilBuildupDampStrength' has a wrong offset!");
static_assert(offsetof(UPlayerEffect_ModifyRecoil, SpecificWeaponRecoilMods) == 0x0000A0, "Member 'UPlayerEffect_ModifyRecoil::SpecificWeaponRecoilMods' has a wrong offset!");
static_assert(offsetof(UPlayerEffect_ModifyRecoil, OriginalRecoilValues) == 0x0000B0, "Member 'UPlayerEffect_ModifyRecoil::OriginalRecoilValues' has a wrong offset!");
static_assert(offsetof(UPlayerEffect_ModifyRecoil, AffectedWeapons) == 0x000100, "Member 'UPlayerEffect_ModifyRecoil::AffectedWeapons' has a wrong offset!");

// Class ReadyOrNot.KillHostageChanceAnimNotify
// 0x0000 (0x0038 - 0x0038)
class UKillHostageChanceAnimNotify final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillHostageChanceAnimNotify">();
	}
	static class UKillHostageChanceAnimNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillHostageChanceAnimNotify>();
	}
};
static_assert(alignof(UKillHostageChanceAnimNotify) == 0x000008, "Wrong alignment on UKillHostageChanceAnimNotify");
static_assert(sizeof(UKillHostageChanceAnimNotify) == 0x000038, "Wrong size on UKillHostageChanceAnimNotify");

// Class ReadyOrNot.PlayerPostProcessing
// 0x0800 (0x11A0 - 0x09A0)
class UPlayerPostProcessing final : public UPostProcessComponent
{
public:
	TArray<class UPostProcessEffectData*>         DebugPPEffects;                                    // 0x09A0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<class UMaterialInstanceDynamic*>       DebugPPEffects_MIDs;                               // 0x09B0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_9C0[0x38];                                     // 0x09C0(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPostProcessEffect>             PostProcessEffects;                                // 0x09F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_A08[0x28];                                     // 0x0A08(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMaterialInterface*>             DevPostProcessMaterials;                           // 0x0A30(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	struct FNVGPostProcessSettings                NVG_Settings;                                      // 0x0A40(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_A98[0x6E8];                                    // 0x0A98(0x06E8)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerCharacter*                       OwningCharacter;                                   // 0x1180(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 RecentDamageCauser;                                // 0x1188(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1190[0x10];                                    // 0x1190(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FadeToGrey();
	bool FulfillsAllRequirements(const TArray<TSubclassOf<class UPostProcessRequirement>>& InRequirementClasses, class AActor* InDamageCauser, bool bForceFulfillment);
	int32 GetPostProcessFromFloatParam(const struct FPostProcessEffect& InPostProcessEffect, const class FName& InParameterName, int32 Instance);
	int32 InitializePostProcessFloatParam(const struct FPostProcessEffect& InPostProcessEffect, const class FName& InParameterName, float Value, int32 Instance, int32 CurveKey);
	void OnBulletImpact(float DirectionForward, float DirectionRight);
	void OnDamageTaken(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* DamagedCharacter, class AActor* DamageCauser, float Damage, float HealthRemaining);
	void OnDamageTakenDetails(bool bWasHeadshot, float DamageTaken, float HealthRemaining, bool bBlockedByArmour, bool bBlockedByHelmet);
	void OnFire();
	void OnItemEquipped(class ABaseItem* Item);
	void OnItemHolstered(class ABaseItem* Item);
	void OnPlayerKilled(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter);
	void OnPlayerPepperSprayed(class AActor* DamageCauser);
	void OnPlayerStunned(class AReadyOrNotCharacter* Character, float Duration, EStunType StunType, class AActor* DamageCauser);
	void OnSupression(float Strength);
	void PlayPostProcessEffect_Name(class FName EffectName, class AActor* DamageCauser);
	void ProcessPostProcessEffect(struct FPostProcessEffect* InPostProcessEffect, float DeltaTime);
	void ResetInjuryRadialBlur(float DeltaTime);
	void StartBleedingEffect();
	void StartDeathEffect(class AActor* DamageCauser);
	void StartFlashbangEffect(class AActor* DamageCauser);
	void StartGasEffect(class AActor* DamageCauser);
	void StartHealingEffect();
	void StartHeartbeatEffect();
	void StartInjuryEffects(class AActor* DamageCauser);
	void StartPeppersprayEffect(class AActor* DamageCauser);
	void StartPostProcessEffect(struct FPostProcessEffect* InPostProcessEffect, class AActor* DamageCauser);
	void StartPostProcessEffect_FromDataAsset(class UPostProcessEffectData* InPostProcessEffectData, class AActor* DamageCauser);
	void StartPostProcessEffect_Specific(struct FPostProcessEffectPlayer* InPostProcessSetting, class AActor* DamageCauser);
	void StartStingerEffect(class AActor* DamageCauser);
	void StartSuppressionEffects(class AActor* DamageCauser);
	void StartTaserEffect(class AActor* DamageCauser);
	void StopBleedingEffect();
	void StopDeathEffect();
	void StopFlashbangEffect();
	void StopGasEffect();
	void StopHealingEffect();
	void StopHeartbeatEffect();
	void StopInjuryEffects();
	void StopPeppersprayEffect();
	void StopPostProcessEffect(struct FPostProcessEffect* InPostProcessEffect);
	void StopPostProcessEffect_FromDataAsset(class UPostProcessEffectData* InPostProcessEffectData);
	void StopPostProcessEffect_Name(class FName EffectName);
	void StopStingerEffect();
	void StopSuppressionEffects();
	void StopTaserEffect();
	void UpdateWeaponHighlightVisibility();

	bool IsPostProcessEffectPlaying(class UPostProcessEffectData* InPostProcessEffectData) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerPostProcessing">();
	}
	static class UPlayerPostProcessing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerPostProcessing>();
	}
};
static_assert(alignof(UPlayerPostProcessing) == 0x000010, "Wrong alignment on UPlayerPostProcessing");
static_assert(sizeof(UPlayerPostProcessing) == 0x0011A0, "Wrong size on UPlayerPostProcessing");
static_assert(offsetof(UPlayerPostProcessing, DebugPPEffects) == 0x0009A0, "Member 'UPlayerPostProcessing::DebugPPEffects' has a wrong offset!");
static_assert(offsetof(UPlayerPostProcessing, DebugPPEffects_MIDs) == 0x0009B0, "Member 'UPlayerPostProcessing::DebugPPEffects_MIDs' has a wrong offset!");
static_assert(offsetof(UPlayerPostProcessing, PostProcessEffects) == 0x0009F8, "Member 'UPlayerPostProcessing::PostProcessEffects' has a wrong offset!");
static_assert(offsetof(UPlayerPostProcessing, DevPostProcessMaterials) == 0x000A30, "Member 'UPlayerPostProcessing::DevPostProcessMaterials' has a wrong offset!");
static_assert(offsetof(UPlayerPostProcessing, NVG_Settings) == 0x000A40, "Member 'UPlayerPostProcessing::NVG_Settings' has a wrong offset!");
static_assert(offsetof(UPlayerPostProcessing, OwningCharacter) == 0x001180, "Member 'UPlayerPostProcessing::OwningCharacter' has a wrong offset!");
static_assert(offsetof(UPlayerPostProcessing, RecentDamageCauser) == 0x001188, "Member 'UPlayerPostProcessing::RecentDamageCauser' has a wrong offset!");

// Class ReadyOrNot.KingOfTheHillGS
// 0x0008 (0x0900 - 0x08F8)
class AKingOfTheHillGS final : public AReadyOrNotGameState
{
public:
	class ATugOfWarMover*                         Mover;                                             // 0x08F8(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KingOfTheHillGS">();
	}
	static class AKingOfTheHillGS* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKingOfTheHillGS>();
	}
};
static_assert(alignof(AKingOfTheHillGS) == 0x000008, "Wrong alignment on AKingOfTheHillGS");
static_assert(sizeof(AKingOfTheHillGS) == 0x000900, "Wrong size on AKingOfTheHillGS");
static_assert(offsetof(AKingOfTheHillGS, Mover) == 0x0008F8, "Member 'AKingOfTheHillGS::Mover' has a wrong offset!");

// Class ReadyOrNot.KingOfTheHostageGS
// 0x0008 (0x0900 - 0x08F8)
class AKingOfTheHostageGS final : public AReadyOrNotGameState
{
public:
	float                                         RedTeam_RoundTimeRemaining;                        // 0x08F8(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlueTeam_RoundTimeRemaining;                       // 0x08FC(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KingOfTheHostageGS">();
	}
	static class AKingOfTheHostageGS* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKingOfTheHostageGS>();
	}
};
static_assert(alignof(AKingOfTheHostageGS) == 0x000008, "Wrong alignment on AKingOfTheHostageGS");
static_assert(sizeof(AKingOfTheHostageGS) == 0x000900, "Wrong size on AKingOfTheHostageGS");
static_assert(offsetof(AKingOfTheHostageGS, RedTeam_RoundTimeRemaining) == 0x0008F8, "Member 'AKingOfTheHostageGS::RedTeam_RoundTimeRemaining' has a wrong offset!");
static_assert(offsetof(AKingOfTheHostageGS, BlueTeam_RoundTimeRemaining) == 0x0008FC, "Member 'AKingOfTheHostageGS::BlueTeam_RoundTimeRemaining' has a wrong offset!");

// Class ReadyOrNot.ReadyOrNotLoadoutHelper
// 0x0000 (0x0028 - 0x0028)
class UReadyOrNotLoadoutHelper final : public UBlueprintFunctionLibrary
{
public:
	static struct FRosterLoadout GetRosterCharacterLoadout(class UWorld* WorldContext, class URosterCharacter* Character);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotLoadoutHelper">();
	}
	static class UReadyOrNotLoadoutHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotLoadoutHelper>();
	}
};
static_assert(alignof(UReadyOrNotLoadoutHelper) == 0x000008, "Wrong alignment on UReadyOrNotLoadoutHelper");
static_assert(sizeof(UReadyOrNotLoadoutHelper) == 0x000028, "Wrong size on UReadyOrNotLoadoutHelper");

// Class ReadyOrNot.LadderSnapZone
// 0x0048 (0x02E0 - 0x0298)
class ALadderSnapZone : public AActor
{
public:
	class UBoxComponent*                          SelectionZone;                                     // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 GhostLadder;                                       // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          Collision;                                         // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        SceneRoot;                                         // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterial*                              ValidPlacementMaterial;                            // 0x02B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterial*                              InvalidPlacementMaterial;                          // 0x02C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRetractedRungCount;                             // 0x02C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHorizontal;                                       // 0x02CC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CD[0x3];                                      // 0x02CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class ATelescopicLadder*                      AttachedLadder;                                    // 0x02D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUnableToPlace;                                    // 0x02D8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D9[0x3];                                      // 0x02D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumberOverlappers;                                 // 0x02DC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void DisableCollision();
	void EnableCollision();
	void Multicast_StartShowingGhostMesh(bool bAbleToPlace);
	void Multicast_StopShowingGhostMesh();
	void OnCollisionOverlapBegin(class UPrimitiveComponent* Comp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnCollisionOverlapEnd(class UPrimitiveComponent* Comp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LadderSnapZone">();
	}
	static class ALadderSnapZone* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALadderSnapZone>();
	}
};
static_assert(alignof(ALadderSnapZone) == 0x000008, "Wrong alignment on ALadderSnapZone");
static_assert(sizeof(ALadderSnapZone) == 0x0002E0, "Wrong size on ALadderSnapZone");
static_assert(offsetof(ALadderSnapZone, SelectionZone) == 0x000298, "Member 'ALadderSnapZone::SelectionZone' has a wrong offset!");
static_assert(offsetof(ALadderSnapZone, GhostLadder) == 0x0002A0, "Member 'ALadderSnapZone::GhostLadder' has a wrong offset!");
static_assert(offsetof(ALadderSnapZone, Collision) == 0x0002A8, "Member 'ALadderSnapZone::Collision' has a wrong offset!");
static_assert(offsetof(ALadderSnapZone, SceneRoot) == 0x0002B0, "Member 'ALadderSnapZone::SceneRoot' has a wrong offset!");
static_assert(offsetof(ALadderSnapZone, ValidPlacementMaterial) == 0x0002B8, "Member 'ALadderSnapZone::ValidPlacementMaterial' has a wrong offset!");
static_assert(offsetof(ALadderSnapZone, InvalidPlacementMaterial) == 0x0002C0, "Member 'ALadderSnapZone::InvalidPlacementMaterial' has a wrong offset!");
static_assert(offsetof(ALadderSnapZone, MaxRetractedRungCount) == 0x0002C8, "Member 'ALadderSnapZone::MaxRetractedRungCount' has a wrong offset!");
static_assert(offsetof(ALadderSnapZone, bHorizontal) == 0x0002CC, "Member 'ALadderSnapZone::bHorizontal' has a wrong offset!");
static_assert(offsetof(ALadderSnapZone, AttachedLadder) == 0x0002D0, "Member 'ALadderSnapZone::AttachedLadder' has a wrong offset!");
static_assert(offsetof(ALadderSnapZone, bUnableToPlace) == 0x0002D8, "Member 'ALadderSnapZone::bUnableToPlace' has a wrong offset!");
static_assert(offsetof(ALadderSnapZone, NumberOverlappers) == 0x0002DC, "Member 'ALadderSnapZone::NumberOverlappers' has a wrong offset!");

// Class ReadyOrNot.LaserAttachment
// 0x0040 (0x1110 - 0x10D0)
class ULaserAttachment : public UWeaponAttachment
{
public:
	bool                                          bRequireNVG;                                       // 0x10D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10D1[0x7];                                     // 0x10D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystemComponent*               LaserParticleComponent;                            // 0x10D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystemComponent*               LaserBeamEndComponent;                             // 0x10E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        LaserParticle;                                     // 0x10E8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        LaserBeamEnd;                                      // 0x10F0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRepOn;                                            // 0x10F8(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10F9[0x7];                                     // 0x10F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ALensFlare>                 LensFlareClass;                                    // 0x1100(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ALensFlare*                             SpawnedLensFlare;                                  // 0x1108(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnRep_On();
	void ToggleLaser(bool bOn);

	bool IsLaserOn() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LaserAttachment">();
	}
	static class ULaserAttachment* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULaserAttachment>();
	}
};
static_assert(alignof(ULaserAttachment) == 0x000010, "Wrong alignment on ULaserAttachment");
static_assert(sizeof(ULaserAttachment) == 0x001110, "Wrong size on ULaserAttachment");
static_assert(offsetof(ULaserAttachment, bRequireNVG) == 0x0010D0, "Member 'ULaserAttachment::bRequireNVG' has a wrong offset!");
static_assert(offsetof(ULaserAttachment, LaserParticleComponent) == 0x0010D8, "Member 'ULaserAttachment::LaserParticleComponent' has a wrong offset!");
static_assert(offsetof(ULaserAttachment, LaserBeamEndComponent) == 0x0010E0, "Member 'ULaserAttachment::LaserBeamEndComponent' has a wrong offset!");
static_assert(offsetof(ULaserAttachment, LaserParticle) == 0x0010E8, "Member 'ULaserAttachment::LaserParticle' has a wrong offset!");
static_assert(offsetof(ULaserAttachment, LaserBeamEnd) == 0x0010F0, "Member 'ULaserAttachment::LaserBeamEnd' has a wrong offset!");
static_assert(offsetof(ULaserAttachment, bRepOn) == 0x0010F8, "Member 'ULaserAttachment::bRepOn' has a wrong offset!");
static_assert(offsetof(ULaserAttachment, LensFlareClass) == 0x001100, "Member 'ULaserAttachment::LensFlareClass' has a wrong offset!");
static_assert(offsetof(ULaserAttachment, SpawnedLensFlare) == 0x001108, "Member 'ULaserAttachment::SpawnedLensFlare' has a wrong offset!");

// Class ReadyOrNot.NavArea_RepositionBlockingArea
// 0x0000 (0x0048 - 0x0048)
class UNavArea_RepositionBlockingArea final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_RepositionBlockingArea">();
	}
	static class UNavArea_RepositionBlockingArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_RepositionBlockingArea>();
	}
};
static_assert(alignof(UNavArea_RepositionBlockingArea) == 0x000008, "Wrong alignment on UNavArea_RepositionBlockingArea");
static_assert(sizeof(UNavArea_RepositionBlockingArea) == 0x000048, "Wrong size on UNavArea_RepositionBlockingArea");

// Class ReadyOrNot.LevelData
// 0x0828 (0x0858 - 0x0030)
class ULevelData final : public UPrimaryDataAsset
{
public:
	class FString                                 LevelName;                                         // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLevelDataLookupTable                  Data;                                              // 0x0040(0x0818)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelData">();
	}
	static class ULevelData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelData>();
	}
};
static_assert(alignof(ULevelData) == 0x000008, "Wrong alignment on ULevelData");
static_assert(sizeof(ULevelData) == 0x000858, "Wrong size on ULevelData");
static_assert(offsetof(ULevelData, LevelName) == 0x000030, "Member 'ULevelData::LevelName' has a wrong offset!");
static_assert(offsetof(ULevelData, Data) == 0x000040, "Member 'ULevelData::Data' has a wrong offset!");

// Class ReadyOrNot.LicenseSave
// 0x0008 (0x0030 - 0x0028)
class ULicenseSave final : public USaveGame
{
public:
	bool                                          bAcceptedAlphaNonDisclosureAgreement;              // 0x0028(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AcceptAlphaNDA();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LicenseSave">();
	}
	static class ULicenseSave* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULicenseSave>();
	}
};
static_assert(alignof(ULicenseSave) == 0x000008, "Wrong alignment on ULicenseSave");
static_assert(sizeof(ULicenseSave) == 0x000030, "Wrong size on ULicenseSave");
static_assert(offsetof(ULicenseSave, bAcceptedAlphaNonDisclosureAgreement) == 0x000028, "Member 'ULicenseSave::bAcceptedAlphaNonDisclosureAgreement' has a wrong offset!");

// Class ReadyOrNot.NavArea_TrappedDoor
// 0x0000 (0x0048 - 0x0048)
class UNavArea_TrappedDoor final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_TrappedDoor">();
	}
	static class UNavArea_TrappedDoor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_TrappedDoor>();
	}
};
static_assert(alignof(UNavArea_TrappedDoor) == 0x000008, "Wrong alignment on UNavArea_TrappedDoor");
static_assert(sizeof(UNavArea_TrappedDoor) == 0x000048, "Wrong size on UNavArea_TrappedDoor");

// Class ReadyOrNot.LightAttachmentPointLight
// 0x0000 (0x0420 - 0x0420)
class ULightAttachmentPointLight : public UPointLightComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LightAttachmentPointLight">();
	}
	static class ULightAttachmentPointLight* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULightAttachmentPointLight>();
	}
};
static_assert(alignof(ULightAttachmentPointLight) == 0x000010, "Wrong alignment on ULightAttachmentPointLight");
static_assert(sizeof(ULightAttachmentPointLight) == 0x000420, "Wrong size on ULightAttachmentPointLight");

// Class ReadyOrNot.LightningGenerator
// 0x00A8 (0x0340 - 0x0298)
class ALightningGenerator final : public AActor
{
public:
	uint8                                         Pad_298[0x10];                                     // 0x0298(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        SceneRoot;                                         // 0x02A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAudioComponent*                        Thunder;                                           // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystemComponent*               ParticleComponent;                                 // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParticleSpawnChance;                               // 0x02C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C4[0x4];                                      // 0x02C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UParticleSystem*>                ParticleTemplates;                                 // 0x02C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class USoundBase*>                     ThunderSounds;                                     // 0x02D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class UDirectionalLightComponent*             Lightning;                                         // 0x02E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThunderDelayMin;                                   // 0x02F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThunderDelayMax;                                   // 0x02F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           LightningColorMin;                                 // 0x02F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           LightningColorMax;                                 // 0x0308(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightningDelayMin;                                 // 0x0318(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightningDelayMax;                                 // 0x031C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightningIntensityMin;                             // 0x0320(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightningIntensityMax;                             // 0x0324(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightningIntensityDecay;                           // 0x0328(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightningIntensityJitterMin;                       // 0x032C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightningIntensityJitterMax;                       // 0x0330(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightningIntensityJitterTimeMin;                   // 0x0334(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightningIntensityJitterTimeMax;                   // 0x0338(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightningJitterTimeRemaining;                      // 0x033C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void PlayLightning();
	void PlayThunder();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LightningGenerator">();
	}
	static class ALightningGenerator* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALightningGenerator>();
	}
};
static_assert(alignof(ALightningGenerator) == 0x000008, "Wrong alignment on ALightningGenerator");
static_assert(sizeof(ALightningGenerator) == 0x000340, "Wrong size on ALightningGenerator");
static_assert(offsetof(ALightningGenerator, SceneRoot) == 0x0002A8, "Member 'ALightningGenerator::SceneRoot' has a wrong offset!");
static_assert(offsetof(ALightningGenerator, Thunder) == 0x0002B0, "Member 'ALightningGenerator::Thunder' has a wrong offset!");
static_assert(offsetof(ALightningGenerator, ParticleComponent) == 0x0002B8, "Member 'ALightningGenerator::ParticleComponent' has a wrong offset!");
static_assert(offsetof(ALightningGenerator, ParticleSpawnChance) == 0x0002C0, "Member 'ALightningGenerator::ParticleSpawnChance' has a wrong offset!");
static_assert(offsetof(ALightningGenerator, ParticleTemplates) == 0x0002C8, "Member 'ALightningGenerator::ParticleTemplates' has a wrong offset!");
static_assert(offsetof(ALightningGenerator, ThunderSounds) == 0x0002D8, "Member 'ALightningGenerator::ThunderSounds' has a wrong offset!");
static_assert(offsetof(ALightningGenerator, Lightning) == 0x0002E8, "Member 'ALightningGenerator::Lightning' has a wrong offset!");
static_assert(offsetof(ALightningGenerator, ThunderDelayMin) == 0x0002F0, "Member 'ALightningGenerator::ThunderDelayMin' has a wrong offset!");
static_assert(offsetof(ALightningGenerator, ThunderDelayMax) == 0x0002F4, "Member 'ALightningGenerator::ThunderDelayMax' has a wrong offset!");
static_assert(offsetof(ALightningGenerator, LightningColorMin) == 0x0002F8, "Member 'ALightningGenerator::LightningColorMin' has a wrong offset!");
static_assert(offsetof(ALightningGenerator, LightningColorMax) == 0x000308, "Member 'ALightningGenerator::LightningColorMax' has a wrong offset!");
static_assert(offsetof(ALightningGenerator, LightningDelayMin) == 0x000318, "Member 'ALightningGenerator::LightningDelayMin' has a wrong offset!");
static_assert(offsetof(ALightningGenerator, LightningDelayMax) == 0x00031C, "Member 'ALightningGenerator::LightningDelayMax' has a wrong offset!");
static_assert(offsetof(ALightningGenerator, LightningIntensityMin) == 0x000320, "Member 'ALightningGenerator::LightningIntensityMin' has a wrong offset!");
static_assert(offsetof(ALightningGenerator, LightningIntensityMax) == 0x000324, "Member 'ALightningGenerator::LightningIntensityMax' has a wrong offset!");
static_assert(offsetof(ALightningGenerator, LightningIntensityDecay) == 0x000328, "Member 'ALightningGenerator::LightningIntensityDecay' has a wrong offset!");
static_assert(offsetof(ALightningGenerator, LightningIntensityJitterMin) == 0x00032C, "Member 'ALightningGenerator::LightningIntensityJitterMin' has a wrong offset!");
static_assert(offsetof(ALightningGenerator, LightningIntensityJitterMax) == 0x000330, "Member 'ALightningGenerator::LightningIntensityJitterMax' has a wrong offset!");
static_assert(offsetof(ALightningGenerator, LightningIntensityJitterTimeMin) == 0x000334, "Member 'ALightningGenerator::LightningIntensityJitterTimeMin' has a wrong offset!");
static_assert(offsetof(ALightningGenerator, LightningIntensityJitterTimeMax) == 0x000338, "Member 'ALightningGenerator::LightningIntensityJitterTimeMax' has a wrong offset!");
static_assert(offsetof(ALightningGenerator, LightningJitterTimeRemaining) == 0x00033C, "Member 'ALightningGenerator::LightningJitterTimeRemaining' has a wrong offset!");

// Class ReadyOrNot.NavArea_SwatAlpha
// 0x0000 (0x0048 - 0x0048)
class UNavArea_SwatAlpha final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_SwatAlpha">();
	}
	static class UNavArea_SwatAlpha* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_SwatAlpha>();
	}
};
static_assert(alignof(UNavArea_SwatAlpha) == 0x000008, "Wrong alignment on UNavArea_SwatAlpha");
static_assert(sizeof(UNavArea_SwatAlpha) == 0x000048, "Wrong size on UNavArea_SwatAlpha");

// Class ReadyOrNot.ListenForDeath
// 0x0000 (0x0000 - 0x0000)
class IListenForDeath final
{
public:
	void OnCharacterDied(class AReadyOrNotCharacter* Victim, class AReadyOrNotCharacter* Killer, class AActor* Inflictor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ListenForDeath">();
	}
	static class IListenForDeath* GetDefaultObj()
	{
		return GetDefaultObjImpl<IListenForDeath>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IListenForDeath) == 0x000001, "Wrong alignment on IListenForDeath");
static_assert(sizeof(IListenForDeath) == 0x000001, "Wrong size on IListenForDeath");

// Class ReadyOrNot.ListenForGameStart
// 0x0000 (0x0000 - 0x0000)
class IListenForGameStart final
{
public:
	void OnGameStarted();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ListenForGameStart">();
	}
	static class IListenForGameStart* GetDefaultObj()
	{
		return GetDefaultObjImpl<IListenForGameStart>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IListenForGameStart) == 0x000001, "Wrong alignment on IListenForGameStart");
static_assert(sizeof(IListenForGameStart) == 0x000001, "Wrong size on IListenForGameStart");

// Class ReadyOrNot.PropagationPoint
// 0x0000 (0x0298 - 0x0298)
class APropagationPoint final : public ATargetPoint
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PropagationPoint">();
	}
	static class APropagationPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<APropagationPoint>();
	}
};
static_assert(alignof(APropagationPoint) == 0x000008, "Wrong alignment on APropagationPoint");
static_assert(sizeof(APropagationPoint) == 0x000298, "Wrong size on APropagationPoint");

// Class ReadyOrNot.LoadoutInformationTableWidget
// 0x0050 (0x0310 - 0x02C0)
class ULoadoutInformationTableWidget final : public UUserWidget
{
public:
	TMulticastInlineDelegate<void(class ABaseItem* ItemToModify)> OnModifyWeaponButtonClicked;       // 0x02C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnInfoPanelRemoved;                                // 0x02D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnCancelRefresh;                                   // 0x02E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(EWeaponAttachmentType WeaponSlot, class UWeaponAttachment* AttachmentData)> OnInfoPanelAttachmentClicked; // 0x02F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(EWeaponAttachmentType WeaponSlot)> OnInfoPanelRemoveAttachmentClicked; // 0x0300(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void RefreshPanelAmmoInfo(const struct FAmmoTypeData& AmmoType, TSubclassOf<class ABaseItem> ItemClass);
	void RefreshPanelArmourMaterial(class UArmourMaterial* ArmourMaterial);
	void RefreshPanelItemInfo(const struct FSavedLoadout& ActiveLoadout, TSubclassOf<class ABaseItem> ItemClass, EItemCategory LoadoutSlot, bool bRestricted);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadoutInformationTableWidget">();
	}
	static class ULoadoutInformationTableWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadoutInformationTableWidget>();
	}
};
static_assert(alignof(ULoadoutInformationTableWidget) == 0x000008, "Wrong alignment on ULoadoutInformationTableWidget");
static_assert(sizeof(ULoadoutInformationTableWidget) == 0x000310, "Wrong size on ULoadoutInformationTableWidget");
static_assert(offsetof(ULoadoutInformationTableWidget, OnModifyWeaponButtonClicked) == 0x0002C0, "Member 'ULoadoutInformationTableWidget::OnModifyWeaponButtonClicked' has a wrong offset!");
static_assert(offsetof(ULoadoutInformationTableWidget, OnInfoPanelRemoved) == 0x0002D0, "Member 'ULoadoutInformationTableWidget::OnInfoPanelRemoved' has a wrong offset!");
static_assert(offsetof(ULoadoutInformationTableWidget, OnCancelRefresh) == 0x0002E0, "Member 'ULoadoutInformationTableWidget::OnCancelRefresh' has a wrong offset!");
static_assert(offsetof(ULoadoutInformationTableWidget, OnInfoPanelAttachmentClicked) == 0x0002F0, "Member 'ULoadoutInformationTableWidget::OnInfoPanelAttachmentClicked' has a wrong offset!");
static_assert(offsetof(ULoadoutInformationTableWidget, OnInfoPanelRemoveAttachmentClicked) == 0x000300, "Member 'ULoadoutInformationTableWidget::OnInfoPanelRemoveAttachmentClicked' has a wrong offset!");

// Class ReadyOrNot.SearchAndSecureActivity
// 0x0080 (0x0270 - 0x01F0)
class USearchAndSecureActivity final : public UBaseActivity
{
public:
	TMulticastInlineDelegate<void(class USearchAndSecureActivity* Activity, class ADoor* BreachedDoor)> OnSearchComplete; // 0x01F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_200[0x20];                                     // 0x0200(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class ADoor*                                  BreachDoor;                                        // 0x0220(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_228[0x30];                                     // 0x0228(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         AllSecurables;                                     // 0x0258(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class AActor*                                 ClosestSecurable;                                  // 0x0268(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SearchAndSecureActivity">();
	}
	static class USearchAndSecureActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<USearchAndSecureActivity>();
	}
};
static_assert(alignof(USearchAndSecureActivity) == 0x000008, "Wrong alignment on USearchAndSecureActivity");
static_assert(sizeof(USearchAndSecureActivity) == 0x000270, "Wrong size on USearchAndSecureActivity");
static_assert(offsetof(USearchAndSecureActivity, OnSearchComplete) == 0x0001F0, "Member 'USearchAndSecureActivity::OnSearchComplete' has a wrong offset!");
static_assert(offsetof(USearchAndSecureActivity, BreachDoor) == 0x000220, "Member 'USearchAndSecureActivity::BreachDoor' has a wrong offset!");
static_assert(offsetof(USearchAndSecureActivity, AllSecurables) == 0x000258, "Member 'USearchAndSecureActivity::AllSecurables' has a wrong offset!");
static_assert(offsetof(USearchAndSecureActivity, ClosestSecurable) == 0x000268, "Member 'USearchAndSecureActivity::ClosestSecurable' has a wrong offset!");

// Class ReadyOrNot.LoadoutManager
// 0x0100 (0x0128 - 0x0028)
class ULoadoutManager final : public UObject
{
public:
	TArray<class ABaseItem*>                      AllItems;                                          // 0x0028(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class ABaseItem*>                      PrimaryWeapons;                                    // 0x0038(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class ABaseItem*>                      SecondaryWeapons;                                  // 0x0048(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class ABaseItem*>                      LongTacticalItems;                                 // 0x0058(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class ABaseItem*>                      TacticalItems;                                     // 0x0068(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class ABaseItem*>                      BodyArmors;                                        // 0x0078(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class ABaseItem*>                      Helmets;                                           // 0x0088(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class ABaseItem*>                      HelmetMounts;                                      // 0x0098(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class ABaseItem*>                      Facewears;                                         // 0x00A8(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UArmourMaterial*>                ArmorMaterials;                                    // 0x00B8(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UCustomizationDataBase*>         CustomizationAssets;                               // 0x00C8(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<class FName, class ABaseItem*>           ItemLookupMap;                                     // 0x00D8(0x0050)(UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	static class ULoadoutManager* Get(const class UObject* WorldContextObject);
	static TArray<TSubclassOf<class ABaseItem>> GetAllItems(class UObject* WorldContextObject);
	static TArray<TSubclassOf<class ABaseItem>> GetAllItemsInCategory(class UObject* WorldContextObject, EItemCategory InItemCategory);
	static TSubclassOf<class ABaseItem> GetItemByLookupIdx(const class UObject* WorldContextObject, class FName LookupIdx);

	const TArray<class ABaseItem*> GetBodyArmors();
	const TArray<class ABaseItem*> GetFacewears();
	const TArray<class ABaseItem*> GetHelmetMounts();
	const TArray<class ABaseItem*> GetHelmets();
	const TArray<class ABaseItem*> GetLongTacticalItems();
	const TArray<class ABaseItem*> GetPrimaryWeapons();
	const TArray<class ABaseItem*> GetSecondaryWeapons();
	const TArray<class ABaseItem*> GetTacticalItems();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadoutManager">();
	}
	static class ULoadoutManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadoutManager>();
	}
};
static_assert(alignof(ULoadoutManager) == 0x000008, "Wrong alignment on ULoadoutManager");
static_assert(sizeof(ULoadoutManager) == 0x000128, "Wrong size on ULoadoutManager");
static_assert(offsetof(ULoadoutManager, AllItems) == 0x000028, "Member 'ULoadoutManager::AllItems' has a wrong offset!");
static_assert(offsetof(ULoadoutManager, PrimaryWeapons) == 0x000038, "Member 'ULoadoutManager::PrimaryWeapons' has a wrong offset!");
static_assert(offsetof(ULoadoutManager, SecondaryWeapons) == 0x000048, "Member 'ULoadoutManager::SecondaryWeapons' has a wrong offset!");
static_assert(offsetof(ULoadoutManager, LongTacticalItems) == 0x000058, "Member 'ULoadoutManager::LongTacticalItems' has a wrong offset!");
static_assert(offsetof(ULoadoutManager, TacticalItems) == 0x000068, "Member 'ULoadoutManager::TacticalItems' has a wrong offset!");
static_assert(offsetof(ULoadoutManager, BodyArmors) == 0x000078, "Member 'ULoadoutManager::BodyArmors' has a wrong offset!");
static_assert(offsetof(ULoadoutManager, Helmets) == 0x000088, "Member 'ULoadoutManager::Helmets' has a wrong offset!");
static_assert(offsetof(ULoadoutManager, HelmetMounts) == 0x000098, "Member 'ULoadoutManager::HelmetMounts' has a wrong offset!");
static_assert(offsetof(ULoadoutManager, Facewears) == 0x0000A8, "Member 'ULoadoutManager::Facewears' has a wrong offset!");
static_assert(offsetof(ULoadoutManager, ArmorMaterials) == 0x0000B8, "Member 'ULoadoutManager::ArmorMaterials' has a wrong offset!");
static_assert(offsetof(ULoadoutManager, CustomizationAssets) == 0x0000C8, "Member 'ULoadoutManager::CustomizationAssets' has a wrong offset!");
static_assert(offsetof(ULoadoutManager, ItemLookupMap) == 0x0000D8, "Member 'ULoadoutManager::ItemLookupMap' has a wrong offset!");

// Class ReadyOrNot.LoadoutOverviewWidget
// 0x0060 (0x0320 - 0x02C0)
class ULoadoutOverviewWidget final : public UUserWidget
{
public:
	TMulticastInlineDelegate<void(class ULoadoutSlotWidget* TriggeringSlot)> OnOverviewItemClicked;  // 0x02C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ULoadoutSlotWidget* TriggeringSlot)> OnOverviewItemHovered;  // 0x02D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ULoadoutSlotWidget* TriggeringSlot)> OnOverviewItemUnhovered; // 0x02E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ULoadoutSlotAttachmentWidget* AttachmentSlot)> OnAttachmentSlotClicked; // 0x02F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ULoadoutSlotAttachmentWidget* AttachmentSlot)> OnAttachmentSlotHovered; // 0x0300(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ULoadoutSlotAttachmentWidget* AttachmentSlot)> OnAttachmentSlotUnhovered; // 0x0310(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void InitializeOverviewList(bool bRemotePlayer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadoutOverviewWidget">();
	}
	static class ULoadoutOverviewWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadoutOverviewWidget>();
	}
};
static_assert(alignof(ULoadoutOverviewWidget) == 0x000008, "Wrong alignment on ULoadoutOverviewWidget");
static_assert(sizeof(ULoadoutOverviewWidget) == 0x000320, "Wrong size on ULoadoutOverviewWidget");
static_assert(offsetof(ULoadoutOverviewWidget, OnOverviewItemClicked) == 0x0002C0, "Member 'ULoadoutOverviewWidget::OnOverviewItemClicked' has a wrong offset!");
static_assert(offsetof(ULoadoutOverviewWidget, OnOverviewItemHovered) == 0x0002D0, "Member 'ULoadoutOverviewWidget::OnOverviewItemHovered' has a wrong offset!");
static_assert(offsetof(ULoadoutOverviewWidget, OnOverviewItemUnhovered) == 0x0002E0, "Member 'ULoadoutOverviewWidget::OnOverviewItemUnhovered' has a wrong offset!");
static_assert(offsetof(ULoadoutOverviewWidget, OnAttachmentSlotClicked) == 0x0002F0, "Member 'ULoadoutOverviewWidget::OnAttachmentSlotClicked' has a wrong offset!");
static_assert(offsetof(ULoadoutOverviewWidget, OnAttachmentSlotHovered) == 0x000300, "Member 'ULoadoutOverviewWidget::OnAttachmentSlotHovered' has a wrong offset!");
static_assert(offsetof(ULoadoutOverviewWidget, OnAttachmentSlotUnhovered) == 0x000310, "Member 'ULoadoutOverviewWidget::OnAttachmentSlotUnhovered' has a wrong offset!");

// Class ReadyOrNot.PS5ActivitiesSubsystem
// 0x0028 (0x0058 - 0x0030)
class UPS5ActivitiesSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x28];                                      // 0x0030(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PS5ActivitiesSubsystem">();
	}
	static class UPS5ActivitiesSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPS5ActivitiesSubsystem>();
	}
};
static_assert(alignof(UPS5ActivitiesSubsystem) == 0x000008, "Wrong alignment on UPS5ActivitiesSubsystem");
static_assert(sizeof(UPS5ActivitiesSubsystem) == 0x000058, "Wrong size on UPS5ActivitiesSubsystem");

// Class ReadyOrNot.LoadoutSlotAttachmentWidget
// 0x0000 (0x02C0 - 0x02C0)
class ULoadoutSlotAttachmentWidget final : public UUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadoutSlotAttachmentWidget">();
	}
	static class ULoadoutSlotAttachmentWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadoutSlotAttachmentWidget>();
	}
};
static_assert(alignof(ULoadoutSlotAttachmentWidget) == 0x000008, "Wrong alignment on ULoadoutSlotAttachmentWidget");
static_assert(sizeof(ULoadoutSlotAttachmentWidget) == 0x0002C0, "Wrong size on ULoadoutSlotAttachmentWidget");

// Class ReadyOrNot.ServerList
// 0x0020 (0x0430 - 0x0410)
class UServerList : public UCommonActivatableWidget
{
public:
	class UCommonListView*                        ServerListView;                                    // 0x0410(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UServerListData*>                ServerList;                                        // 0x0418(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UUserWidget>                ListEntryWidgetClass;                              // 0x0428(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void PopulateServerList(const TArray<struct FBlueprintSessionResult>& SessionResults);
	void TempPopulateServerList();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ServerList">();
	}
	static class UServerList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UServerList>();
	}
};
static_assert(alignof(UServerList) == 0x000008, "Wrong alignment on UServerList");
static_assert(sizeof(UServerList) == 0x000430, "Wrong size on UServerList");
static_assert(offsetof(UServerList, ServerListView) == 0x000410, "Member 'UServerList::ServerListView' has a wrong offset!");
static_assert(offsetof(UServerList, ServerList) == 0x000418, "Member 'UServerList::ServerList' has a wrong offset!");
static_assert(offsetof(UServerList, ListEntryWidgetClass) == 0x000428, "Member 'UServerList::ListEntryWidgetClass' has a wrong offset!");

// Class ReadyOrNot.LoadoutSlotWidget
// 0x01B0 (0x0498 - 0x02E8)
class ULoadoutSlotWidget : public UCommonUserWidget
{
public:
	bool                                          IsActive;                                          // 0x02E8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemCategory                                 LoadoutSlot;                                       // 0x02E9(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EA[0x6];                                      // 0x02EA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ABaseItem>                  ItemData;                                          // 0x02F0(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPrimary;                                        // 0x02F8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAmmunition;                                     // 0x02F9(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FA[0x6];                                      // 0x02FA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAmmoTypeData                          AmmoType;                                          // 0x0300(0x0170)(BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bIsArmourMaterial;                                 // 0x0470(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_471[0x7];                                      // 0x0471(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UArmourMaterial*                        ArmourMaterialData;                                // 0x0478(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeaponAttachmentType                         AttachmentSlot;                                    // 0x0480(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_481[0x7];                                      // 0x0481(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct ReadyOrNot::FLoadoutCategory>   GearCategoryClasses;                               // 0x0488(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void SetActive(bool IsActive_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadoutSlotWidget">();
	}
	static class ULoadoutSlotWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadoutSlotWidget>();
	}
};
static_assert(alignof(ULoadoutSlotWidget) == 0x000008, "Wrong alignment on ULoadoutSlotWidget");
static_assert(sizeof(ULoadoutSlotWidget) == 0x000498, "Wrong size on ULoadoutSlotWidget");
static_assert(offsetof(ULoadoutSlotWidget, IsActive) == 0x0002E8, "Member 'ULoadoutSlotWidget::IsActive' has a wrong offset!");
static_assert(offsetof(ULoadoutSlotWidget, LoadoutSlot) == 0x0002E9, "Member 'ULoadoutSlotWidget::LoadoutSlot' has a wrong offset!");
static_assert(offsetof(ULoadoutSlotWidget, ItemData) == 0x0002F0, "Member 'ULoadoutSlotWidget::ItemData' has a wrong offset!");
static_assert(offsetof(ULoadoutSlotWidget, bIsPrimary) == 0x0002F8, "Member 'ULoadoutSlotWidget::bIsPrimary' has a wrong offset!");
static_assert(offsetof(ULoadoutSlotWidget, bIsAmmunition) == 0x0002F9, "Member 'ULoadoutSlotWidget::bIsAmmunition' has a wrong offset!");
static_assert(offsetof(ULoadoutSlotWidget, AmmoType) == 0x000300, "Member 'ULoadoutSlotWidget::AmmoType' has a wrong offset!");
static_assert(offsetof(ULoadoutSlotWidget, bIsArmourMaterial) == 0x000470, "Member 'ULoadoutSlotWidget::bIsArmourMaterial' has a wrong offset!");
static_assert(offsetof(ULoadoutSlotWidget, ArmourMaterialData) == 0x000478, "Member 'ULoadoutSlotWidget::ArmourMaterialData' has a wrong offset!");
static_assert(offsetof(ULoadoutSlotWidget, AttachmentSlot) == 0x000480, "Member 'ULoadoutSlotWidget::AttachmentSlot' has a wrong offset!");
static_assert(offsetof(ULoadoutSlotWidget, GearCategoryClasses) == 0x000488, "Member 'ULoadoutSlotWidget::GearCategoryClasses' has a wrong offset!");

// Class ReadyOrNot.LoadoutSlot_V2
// 0x00B8 (0x03A0 - 0x02E8)
class ULoadoutSlot_V2 : public UCommonUserWidget
{
public:
	class ABaseItem*                              BaseItem;                                          // 0x02E8(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ABaseItem>                  BaseItemClass;                                     // 0x02F0(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABaseWeapon*                            BaseWeapon;                                        // 0x02F8(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABaseArmour*                            BaseArmor;                                         // 0x0300(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UArmourMaterial*                        ArmorMaterial;                                     // 0x0308(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   AmmunitionName;                                    // 0x0310(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             ItemImage;                                         // 0x0318(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             EmptyImage;                                        // 0x0320(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   ItemName;                                          // 0x0328(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   ItemType;                                          // 0x0340(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   ItemSubtext;                                       // 0x0358(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	int32                                         SlotCount;                                         // 0x0370(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EWeaponAttachmentType                         AttachmentType;                                    // 0x0374(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_375[0x3];                                      // 0x0375(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UWeaponAttachment*                      Attachment;                                        // 0x0378(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELoadoutMunitionSlotType                      MunitionType;                                      // 0x0380(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHovered;                                          // 0x0381(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPressed;                                          // 0x0382(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseGamepad;                                       // 0x0383(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAttachment;                                       // 0x0384(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_385[0x3];                                      // 0x0385(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class AReadyOrNotGameState*                   gs;                                                // 0x0388(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UReadyOrNotLoadoutManager*              LoadoutFunctionLibrary;                            // 0x0390(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bEquipped;                                         // 0x0398(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_399[0x7];                                      // 0x0399(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DecrementSlots();
	TSubclassOf<class UWeaponAttachment> GetAttachmentClass();
	bool GetEquipped();
	void IncrementSlots();
	void OnEquipped();
	void OnSlotsUpdated();
	void RefreshAttachmentImage();
	void RefreshInfo();
	void RefreshItemImage();
	void SetAmmoMunition(class FName AmmoName, bool Secondary);
	void SetArmorMaterial(class UArmourMaterial* Item);
	void SetAttachment(class UWeaponAttachment* WeaponAttachment);
	void SetEquipped(bool IsEquipped);
	void SetItem(class ABaseItem* Item);
	void SetStyle(bool UseGamepad);
	void SetTacticalMunition(ELoadoutMunitionSlotType Munition, class ABaseItem* TacticalItem);
	void SetVisualState(bool Hovered, bool Pressed, bool Equipped);
	void ShowSubtext(const class FText& Text, bool Show);
	void UpdateSlotCount();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadoutSlot_V2">();
	}
	static class ULoadoutSlot_V2* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadoutSlot_V2>();
	}
};
static_assert(alignof(ULoadoutSlot_V2) == 0x000008, "Wrong alignment on ULoadoutSlot_V2");
static_assert(sizeof(ULoadoutSlot_V2) == 0x0003A0, "Wrong size on ULoadoutSlot_V2");
static_assert(offsetof(ULoadoutSlot_V2, BaseItem) == 0x0002E8, "Member 'ULoadoutSlot_V2::BaseItem' has a wrong offset!");
static_assert(offsetof(ULoadoutSlot_V2, BaseItemClass) == 0x0002F0, "Member 'ULoadoutSlot_V2::BaseItemClass' has a wrong offset!");
static_assert(offsetof(ULoadoutSlot_V2, BaseWeapon) == 0x0002F8, "Member 'ULoadoutSlot_V2::BaseWeapon' has a wrong offset!");
static_assert(offsetof(ULoadoutSlot_V2, BaseArmor) == 0x000300, "Member 'ULoadoutSlot_V2::BaseArmor' has a wrong offset!");
static_assert(offsetof(ULoadoutSlot_V2, ArmorMaterial) == 0x000308, "Member 'ULoadoutSlot_V2::ArmorMaterial' has a wrong offset!");
static_assert(offsetof(ULoadoutSlot_V2, AmmunitionName) == 0x000310, "Member 'ULoadoutSlot_V2::AmmunitionName' has a wrong offset!");
static_assert(offsetof(ULoadoutSlot_V2, ItemImage) == 0x000318, "Member 'ULoadoutSlot_V2::ItemImage' has a wrong offset!");
static_assert(offsetof(ULoadoutSlot_V2, EmptyImage) == 0x000320, "Member 'ULoadoutSlot_V2::EmptyImage' has a wrong offset!");
static_assert(offsetof(ULoadoutSlot_V2, ItemName) == 0x000328, "Member 'ULoadoutSlot_V2::ItemName' has a wrong offset!");
static_assert(offsetof(ULoadoutSlot_V2, ItemType) == 0x000340, "Member 'ULoadoutSlot_V2::ItemType' has a wrong offset!");
static_assert(offsetof(ULoadoutSlot_V2, ItemSubtext) == 0x000358, "Member 'ULoadoutSlot_V2::ItemSubtext' has a wrong offset!");
static_assert(offsetof(ULoadoutSlot_V2, SlotCount) == 0x000370, "Member 'ULoadoutSlot_V2::SlotCount' has a wrong offset!");
static_assert(offsetof(ULoadoutSlot_V2, AttachmentType) == 0x000374, "Member 'ULoadoutSlot_V2::AttachmentType' has a wrong offset!");
static_assert(offsetof(ULoadoutSlot_V2, Attachment) == 0x000378, "Member 'ULoadoutSlot_V2::Attachment' has a wrong offset!");
static_assert(offsetof(ULoadoutSlot_V2, MunitionType) == 0x000380, "Member 'ULoadoutSlot_V2::MunitionType' has a wrong offset!");
static_assert(offsetof(ULoadoutSlot_V2, bHovered) == 0x000381, "Member 'ULoadoutSlot_V2::bHovered' has a wrong offset!");
static_assert(offsetof(ULoadoutSlot_V2, bPressed) == 0x000382, "Member 'ULoadoutSlot_V2::bPressed' has a wrong offset!");
static_assert(offsetof(ULoadoutSlot_V2, bUseGamepad) == 0x000383, "Member 'ULoadoutSlot_V2::bUseGamepad' has a wrong offset!");
static_assert(offsetof(ULoadoutSlot_V2, bAttachment) == 0x000384, "Member 'ULoadoutSlot_V2::bAttachment' has a wrong offset!");
static_assert(offsetof(ULoadoutSlot_V2, gs) == 0x000388, "Member 'ULoadoutSlot_V2::gs' has a wrong offset!");
static_assert(offsetof(ULoadoutSlot_V2, LoadoutFunctionLibrary) == 0x000390, "Member 'ULoadoutSlot_V2::LoadoutFunctionLibrary' has a wrong offset!");
static_assert(offsetof(ULoadoutSlot_V2, bEquipped) == 0x000398, "Member 'ULoadoutSlot_V2::bEquipped' has a wrong offset!");

// Class ReadyOrNot.LoadoutUnitSelectWidget
// 0x0000 (0x02C0 - 0x02C0)
class ULoadoutUnitSelectWidget final : public UUserWidget
{
public:
	void Init();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadoutUnitSelectWidget">();
	}
	static class ULoadoutUnitSelectWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadoutUnitSelectWidget>();
	}
};
static_assert(alignof(ULoadoutUnitSelectWidget) == 0x000008, "Wrong alignment on ULoadoutUnitSelectWidget");
static_assert(sizeof(ULoadoutUnitSelectWidget) == 0x0002C0, "Wrong size on ULoadoutUnitSelectWidget");

// Class ReadyOrNot.QuadrotorPawn
// 0x0140 (0x0460 - 0x0320)
class AQuadrotorPawn final : public APawn
{
public:
	class UBoxComponent*                          FlightBox;                                         // 0x0320(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 DroneMesh;                                         // 0x0328(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCameraComponent*                       FirstPersonCamera;                                 // 0x0330(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RPM;                                               // 0x0338(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RPMThrottleMultiplier;                             // 0x033C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyingInput;                                    // 0x0340(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_341[0x3];                                      // 0x0341(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxRPM;                                            // 0x0344(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleRPM;                                           // 0x0348(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RPMForceScale;                                     // 0x034C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaximumTilt;                                       // 0x0350(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxVelocity;                                       // 0x0354(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEngineOn;                                         // 0x0358(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_359[0x7];                                      // 0x0359(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               RotorRotation;                                     // 0x0360(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_378[0x8];                                      // 0x0378(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             DroneTransform;                                    // 0x0380(0x0060)(BlueprintVisible, BlueprintReadOnly, Net, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               TargetRotation;                                    // 0x03E0(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F8[0x68];                                     // 0x03F8(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_DroneMovement();
	void Server_UpdateDroneTransform(const struct FTransform& NewTransform);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuadrotorPawn">();
	}
	static class AQuadrotorPawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<AQuadrotorPawn>();
	}
};
static_assert(alignof(AQuadrotorPawn) == 0x000010, "Wrong alignment on AQuadrotorPawn");
static_assert(sizeof(AQuadrotorPawn) == 0x000460, "Wrong size on AQuadrotorPawn");
static_assert(offsetof(AQuadrotorPawn, FlightBox) == 0x000320, "Member 'AQuadrotorPawn::FlightBox' has a wrong offset!");
static_assert(offsetof(AQuadrotorPawn, DroneMesh) == 0x000328, "Member 'AQuadrotorPawn::DroneMesh' has a wrong offset!");
static_assert(offsetof(AQuadrotorPawn, FirstPersonCamera) == 0x000330, "Member 'AQuadrotorPawn::FirstPersonCamera' has a wrong offset!");
static_assert(offsetof(AQuadrotorPawn, RPM) == 0x000338, "Member 'AQuadrotorPawn::RPM' has a wrong offset!");
static_assert(offsetof(AQuadrotorPawn, RPMThrottleMultiplier) == 0x00033C, "Member 'AQuadrotorPawn::RPMThrottleMultiplier' has a wrong offset!");
static_assert(offsetof(AQuadrotorPawn, bApplyingInput) == 0x000340, "Member 'AQuadrotorPawn::bApplyingInput' has a wrong offset!");
static_assert(offsetof(AQuadrotorPawn, MaxRPM) == 0x000344, "Member 'AQuadrotorPawn::MaxRPM' has a wrong offset!");
static_assert(offsetof(AQuadrotorPawn, IdleRPM) == 0x000348, "Member 'AQuadrotorPawn::IdleRPM' has a wrong offset!");
static_assert(offsetof(AQuadrotorPawn, RPMForceScale) == 0x00034C, "Member 'AQuadrotorPawn::RPMForceScale' has a wrong offset!");
static_assert(offsetof(AQuadrotorPawn, MaximumTilt) == 0x000350, "Member 'AQuadrotorPawn::MaximumTilt' has a wrong offset!");
static_assert(offsetof(AQuadrotorPawn, MaxVelocity) == 0x000354, "Member 'AQuadrotorPawn::MaxVelocity' has a wrong offset!");
static_assert(offsetof(AQuadrotorPawn, bEngineOn) == 0x000358, "Member 'AQuadrotorPawn::bEngineOn' has a wrong offset!");
static_assert(offsetof(AQuadrotorPawn, RotorRotation) == 0x000360, "Member 'AQuadrotorPawn::RotorRotation' has a wrong offset!");
static_assert(offsetof(AQuadrotorPawn, DroneTransform) == 0x000380, "Member 'AQuadrotorPawn::DroneTransform' has a wrong offset!");
static_assert(offsetof(AQuadrotorPawn, TargetRotation) == 0x0003E0, "Member 'AQuadrotorPawn::TargetRotation' has a wrong offset!");

// Class ReadyOrNot.LoadoutVerticalItemListWidget
// 0x0040 (0x0450 - 0x0410)
class ULoadoutVerticalItemListWidget : public UCommonActivatableWidget
{
public:
	TMulticastInlineDelegate<void(class ULoadoutSlotWidget* TriggeringSlot)> OnOverviewItemHovered;  // 0x0410(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ULoadoutSlotWidget* TriggeringSlot)> OnOverviewItemUnhovered; // 0x0420(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ULoadoutSlotAttachmentWidget* AttachmentSlot)> OnAttachmentSlotHovered; // 0x0430(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ULoadoutSlotAttachmentWidget* AttachmentSlot)> OnAttachmentSlotUnhovered; // 0x0440(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadoutVerticalItemListWidget">();
	}
	static class ULoadoutVerticalItemListWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadoutVerticalItemListWidget>();
	}
};
static_assert(alignof(ULoadoutVerticalItemListWidget) == 0x000008, "Wrong alignment on ULoadoutVerticalItemListWidget");
static_assert(sizeof(ULoadoutVerticalItemListWidget) == 0x000450, "Wrong size on ULoadoutVerticalItemListWidget");
static_assert(offsetof(ULoadoutVerticalItemListWidget, OnOverviewItemHovered) == 0x000410, "Member 'ULoadoutVerticalItemListWidget::OnOverviewItemHovered' has a wrong offset!");
static_assert(offsetof(ULoadoutVerticalItemListWidget, OnOverviewItemUnhovered) == 0x000420, "Member 'ULoadoutVerticalItemListWidget::OnOverviewItemUnhovered' has a wrong offset!");
static_assert(offsetof(ULoadoutVerticalItemListWidget, OnAttachmentSlotHovered) == 0x000430, "Member 'ULoadoutVerticalItemListWidget::OnAttachmentSlotHovered' has a wrong offset!");
static_assert(offsetof(ULoadoutVerticalItemListWidget, OnAttachmentSlotUnhovered) == 0x000440, "Member 'ULoadoutVerticalItemListWidget::OnAttachmentSlotUnhovered' has a wrong offset!");

// Class ReadyOrNot.LoadoutWidget
// 0x01F0 (0x0D60 - 0x0B70)
class ULoadoutWidget final : public UPremissionPlanning
{
public:
	TSubclassOf<class UUserWidget>                HUDWidgetClass;                                    // 0x0B70(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULoadoutUnitSelectWidget*               WLoadoutCharacterSelect;                           // 0x0B78(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULoadoutOverviewWidget*                 WLoadoutOverview;                                  // 0x0B80(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULoadoutVerticalItemListWidget*         VerticalItemList;                                  // 0x0B88(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULoadoutInformationTableWidget*         InfoPanel;                                         // 0x0B90(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EItemCategory, class FName>              CategoryCameraTags;                                // 0x0B98(0x0050)(Edit, NativeAccessSpecifierPrivate)
	TMap<EItemCategory, class FString>            CategoryPoses;                                     // 0x0BE8(0x0050)(Edit, NativeAccessSpecifierPrivate)
	class FString                                 PrimaryDrawAnim;                                   // 0x0C38(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 SidearmDrawAnim;                                   // 0x0C48(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 PrimaryHolsterAnim;                                // 0x0C58(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 SidearmHolsterAnim;                                // 0x0C68(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFMODEvent*                             WeaponHolsteredSound;                              // 0x0C78(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C80[0xE0];                                     // 0x0C80(0x00E0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class ULoadoutWidget* GetLoadoutWidget();

	void ApplyLoadoutPreset(const struct FLoadoutPreset& LoadoutPreset);
	void AttachmentClicked(class ULoadoutSlotAttachmentWidget* AttachmentSlot);
	void AttachmentHovered(class ULoadoutSlotAttachmentWidget* AttachmentSlot);
	void AttachmentUnhovered(class ULoadoutSlotAttachmentWidget* AttachmentSlot);
	void CheckPreset();
	void CleanCurrentWeapon();
	void ClearPreset();
	void CloseLoadout();
	void DeleteLoadoutPreset(class UUserWidget* TriggeringModal, const class FText& TextEntry);
	void DeselectAttachmentSlot();
	void DeselectLoadoutSlot();
	void DoItemUnhover();
	void EquipArmor(class ABaseItem* ItemData);
	void EquipArmourMaterial(class UArmourMaterial* ArmourMaterial);
	void EquipAttachment(class ABaseItem* AttachingWeapon, class UWeaponAttachment* AttachmentData);
	void EquipGrenades(const TArray<class ABaseItem*>& ItemData);
	void EquipHeadwear(class ABaseItem* ItemData);
	void EquipItem(class ABaseItem* ItemData);
	void EquipLongTactical(class ABaseItem* ItemData);
	void EquipPrimaryAmmo(const TArray<class FName>& PrimaryAmmo);
	void EquipPrimaryAttachments(EWeaponAttachmentType AttachmentType, class UWeaponAttachment* AttachmentData, class ABaseItem* AttachingWeapon);
	void EquipSidearmAmmo(const TArray<class FName>& SidearmAmmo);
	void EquipSidearmAttachments(EWeaponAttachmentType AttachmentType, class UWeaponAttachment* AttachmentData, class ABaseItem* AttachingWeapon);
	void EquipTactical(const TArray<class ABaseItem*>& ItemData);
	void GoBack();
	void HideHUD();
	void HideItemInfoPanel();
	void HideItemList();
	bool HolsterPreviewCharacterWeapon();
	void InitializeAttachmentSelectionPanel(class ULoadoutSlotWidget* TriggeringSlot);
	void InitializeItemSelectionPanel(class ULoadoutSlotWidget* TriggeringSlot);
	void InitializeItemSelectionRemote(class ULoadoutSlotWidget* TriggeringSlot);
	void InitializeOverview();
	void InitializeQuartermaster();
	void InitializeWeaponAttachmentMap();
	bool IsNullAttachment(TSubclassOf<class UWeaponAttachment> Attachment);
	void ItemClicked(class ULoadoutSlotWidget* TriggeringSlot);
	void ItemHovered(class ULoadoutSlotWidget* TriggeringSlot);
	void ItemUnhovered(class ULoadoutSlotWidget* TriggeringSlot);
	void LoadDefaultLoadout();
	void LookAtAttachmentSlot(EWeaponAttachmentType AttachmentSlot);
	void OpenAmmoList(bool bVerticalList, class FName ExcludedAmmoType, TSubclassOf<class ABaseItem> Weapon);
	void OpenArmorQuartermaster(class ABaseItem* ItemToModify);
	void OpenArmourMaterialList(bool bVerticalList);
	void OpenAttachmentList(bool bVerticalList, TSubclassOf<class ABaseItem> ItemData, EWeaponAttachmentType AttachmentType);
	void OpenDeployableList(bool bVerticalList, EItemCategory LoadoutSlot, const TArray<struct ReadyOrNot::FLoadoutCategory>& GearCategoryClasses, const TArray<TSubclassOf<class ABaseItem>>& ExcludedItems);
	void OpenItemList(bool bVerticalList, EItemCategory LoadoutSlot, const TArray<struct ReadyOrNot::FLoadoutCategory>& GearCategoryClasses);
	void OpenLoadoutPresetModal(const class FString& CurrentPreset, bool bDelete);
	void OpenWeaponQuartermaster(class ABaseItem* ItemToModify);
	void PlaySetPreMissionCameraAnimation();
	void PrimaryChanged();
	void RefreshAttachmentInfoPanel(class ULoadoutSlotWidget* LoadoutSlot);
	void RefreshItemInfoPanel(class ULoadoutSlotWidget* LoadoutSlot);
	void SaveActiveLoadoutOld();
	void SaveArmorCoverage(EArmourCoverage ArmourCoverage);
	void SaveGrenadeSlotCount(int32 GrenadeSlotsCount);
	void SaveLoadoutPreset(class UUserWidget* TriggeringModal, const class FText& TextEntry);
	void SavePrimaryAmmoSlotCount(int32 PrimaryAmmoSlotCount);
	void SaveSidearmAmmoSlotCount(int32 SidearmAmmoSlotCount);
	void SaveTacticalSlotcount(int32 TacticalSlotsCount);
	void SaveWeaponPreset(class UUserWidget* TriggeringModal, const class FText& TextEntry);
	void SetActiveLoadout(const class FString& LoadoutName, class AReadyOrNotPlayerState* RoNPlayerState, EEquippingSwat EquippingUnit);
	void SetActiveQuartermasterSlot();
	void SetPreMissionCamera(class FName Tag, const class FString& Animation, float BlendTime);
	void SetPreMissionCameraBySlot(EItemCategory LoadoutSlot, float BlendTime);
	void SetPresetModified(bool bPresetDirty);
	void SetupBindings();
	void SetupWorkbenchCamera();
	void ShowHUD();
	void ShowItemInfoPanel(class ULoadoutSlotWidget* LoadoutSlot);
	void ShowToolTip(const struct FLevelDataLookupTable& MissionDetails);
	void SidearmChanged();
	void UpdateAllPreviewWeaponAttachments(bool bIsWorkbench, TSubclassOf<class ABaseItem> Weapon, bool bIsSidearm);
	void UpdateCurrentItem();
	void UpdateHUDStates();
	void UpdatePreview(EItemCategory Selection);
	void UpdateWorkbenchCameraRotation(float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadoutWidget">();
	}
	static class ULoadoutWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadoutWidget>();
	}
};
static_assert(alignof(ULoadoutWidget) == 0x000008, "Wrong alignment on ULoadoutWidget");
static_assert(sizeof(ULoadoutWidget) == 0x000D60, "Wrong size on ULoadoutWidget");
static_assert(offsetof(ULoadoutWidget, HUDWidgetClass) == 0x000B70, "Member 'ULoadoutWidget::HUDWidgetClass' has a wrong offset!");
static_assert(offsetof(ULoadoutWidget, WLoadoutCharacterSelect) == 0x000B78, "Member 'ULoadoutWidget::WLoadoutCharacterSelect' has a wrong offset!");
static_assert(offsetof(ULoadoutWidget, WLoadoutOverview) == 0x000B80, "Member 'ULoadoutWidget::WLoadoutOverview' has a wrong offset!");
static_assert(offsetof(ULoadoutWidget, VerticalItemList) == 0x000B88, "Member 'ULoadoutWidget::VerticalItemList' has a wrong offset!");
static_assert(offsetof(ULoadoutWidget, InfoPanel) == 0x000B90, "Member 'ULoadoutWidget::InfoPanel' has a wrong offset!");
static_assert(offsetof(ULoadoutWidget, CategoryCameraTags) == 0x000B98, "Member 'ULoadoutWidget::CategoryCameraTags' has a wrong offset!");
static_assert(offsetof(ULoadoutWidget, CategoryPoses) == 0x000BE8, "Member 'ULoadoutWidget::CategoryPoses' has a wrong offset!");
static_assert(offsetof(ULoadoutWidget, PrimaryDrawAnim) == 0x000C38, "Member 'ULoadoutWidget::PrimaryDrawAnim' has a wrong offset!");
static_assert(offsetof(ULoadoutWidget, SidearmDrawAnim) == 0x000C48, "Member 'ULoadoutWidget::SidearmDrawAnim' has a wrong offset!");
static_assert(offsetof(ULoadoutWidget, PrimaryHolsterAnim) == 0x000C58, "Member 'ULoadoutWidget::PrimaryHolsterAnim' has a wrong offset!");
static_assert(offsetof(ULoadoutWidget, SidearmHolsterAnim) == 0x000C68, "Member 'ULoadoutWidget::SidearmHolsterAnim' has a wrong offset!");
static_assert(offsetof(ULoadoutWidget, WeaponHolsteredSound) == 0x000C78, "Member 'ULoadoutWidget::WeaponHolsteredSound' has a wrong offset!");

// Class ReadyOrNot.Loadout_ArmorSelection_V2
// 0x0000 (0x0410 - 0x0410)
class ULoadout_ArmorSelection_V2 final : public UCommonActivatableWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Loadout_ArmorSelection_V2">();
	}
	static class ULoadout_ArmorSelection_V2* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadout_ArmorSelection_V2>();
	}
};
static_assert(alignof(ULoadout_ArmorSelection_V2) == 0x000008, "Wrong alignment on ULoadout_ArmorSelection_V2");
static_assert(sizeof(ULoadout_ArmorSelection_V2) == 0x000410, "Wrong size on ULoadout_ArmorSelection_V2");

// Class ReadyOrNot.Loadout_Carousel_V3
// 0x0008 (0x02C8 - 0x02C0)
class ULoadout_Carousel_V3 final : public UUserWidget
{
public:
	class UTextBlock*                             Text;                                              // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetText(const class FText& inputText);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Loadout_Carousel_V3">();
	}
	static class ULoadout_Carousel_V3* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadout_Carousel_V3>();
	}
};
static_assert(alignof(ULoadout_Carousel_V3) == 0x000008, "Wrong alignment on ULoadout_Carousel_V3");
static_assert(sizeof(ULoadout_Carousel_V3) == 0x0002C8, "Wrong size on ULoadout_Carousel_V3");
static_assert(offsetof(ULoadout_Carousel_V3, Text) == 0x0002C0, "Member 'ULoadout_Carousel_V3::Text' has a wrong offset!");

// Class ReadyOrNot.SmallSlot_V2
// 0x0010 (0x02F8 - 0x02E8)
class USmallSlot_V2 : public UCommonUserWidget
{
public:
	class UTextBlock*                             ItemName;                                          // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          Equipped;                                          // 0x02F0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F1[0x7];                                      // 0x02F1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetEquipped();
	void OnEquipped();
	void SetEquipped(bool IsEquipped);
	void SetText(const class FText& Text);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SmallSlot_V2">();
	}
	static class USmallSlot_V2* GetDefaultObj()
	{
		return GetDefaultObjImpl<USmallSlot_V2>();
	}
};
static_assert(alignof(USmallSlot_V2) == 0x000008, "Wrong alignment on USmallSlot_V2");
static_assert(sizeof(USmallSlot_V2) == 0x0002F8, "Wrong size on USmallSlot_V2");
static_assert(offsetof(USmallSlot_V2, ItemName) == 0x0002E8, "Member 'USmallSlot_V2::ItemName' has a wrong offset!");
static_assert(offsetof(USmallSlot_V2, Equipped) == 0x0002F0, "Member 'USmallSlot_V2::Equipped' has a wrong offset!");

// Class ReadyOrNot.Loadout_InformationBox
// 0x0040 (0x0328 - 0x02E8)
class ULoadout_InformationBox : public UCommonUserWidget
{
public:
	class UTextBlock*                             txt_Category;                                      // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_Class;                                         // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_ItemName;                                      // 0x02F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             txt_Description;                                   // 0x0300(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           VB_Attachments;                                    // 0x0308(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           VB_Effects;                                        // 0x0310(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AReadyOrNotGameState*                   gs;                                                // 0x0318(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UReadyOrNotLoadoutManager*              LoadoutFunctionLibrary;                            // 0x0320(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void CreateAttachmentElement(const TArray<class UWeaponAttachment*>& Attachments, const TArray<EWeaponAttachmentType>& AttachmentTypes);
	void CreateEffectsElement(const TArray<struct FAttachmentEffects>& AttachmentEffects);
	void SetAttachments(TSubclassOf<class ABaseWeapon> BaseWeapon, bool IsSecondary);
	void SetCategory(const class FText& CurrentItemCategory);
	TArray<struct FAttachmentEffects> SetEffects(class UWeaponAttachment* Attachment);
	void UpdateEffectsInfo(class UWeaponAttachment* Attachment, const class FText& CurrentItemCategory);
	void UpdateInfoBox(class ABaseItem* Item, const class FText& CurrentItemCategory, bool IsItemWeapon);
	void UpdateMaterialInfo(class UArmourMaterial* ArmorMaterial, const class FText& CurrentItemCategory);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Loadout_InformationBox">();
	}
	static class ULoadout_InformationBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadout_InformationBox>();
	}
};
static_assert(alignof(ULoadout_InformationBox) == 0x000008, "Wrong alignment on ULoadout_InformationBox");
static_assert(sizeof(ULoadout_InformationBox) == 0x000328, "Wrong size on ULoadout_InformationBox");
static_assert(offsetof(ULoadout_InformationBox, txt_Category) == 0x0002E8, "Member 'ULoadout_InformationBox::txt_Category' has a wrong offset!");
static_assert(offsetof(ULoadout_InformationBox, txt_Class) == 0x0002F0, "Member 'ULoadout_InformationBox::txt_Class' has a wrong offset!");
static_assert(offsetof(ULoadout_InformationBox, txt_ItemName) == 0x0002F8, "Member 'ULoadout_InformationBox::txt_ItemName' has a wrong offset!");
static_assert(offsetof(ULoadout_InformationBox, txt_Description) == 0x000300, "Member 'ULoadout_InformationBox::txt_Description' has a wrong offset!");
static_assert(offsetof(ULoadout_InformationBox, VB_Attachments) == 0x000308, "Member 'ULoadout_InformationBox::VB_Attachments' has a wrong offset!");
static_assert(offsetof(ULoadout_InformationBox, VB_Effects) == 0x000310, "Member 'ULoadout_InformationBox::VB_Effects' has a wrong offset!");
static_assert(offsetof(ULoadout_InformationBox, gs) == 0x000318, "Member 'ULoadout_InformationBox::gs' has a wrong offset!");
static_assert(offsetof(ULoadout_InformationBox, LoadoutFunctionLibrary) == 0x000320, "Member 'ULoadout_InformationBox::LoadoutFunctionLibrary' has a wrong offset!");

// Class ReadyOrNot.Loadout_SubSelection_V2
// 0x0000 (0x02E8 - 0x02E8)
class ULoadout_SubSelection_V2 final : public UCommonUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Loadout_SubSelection_V2">();
	}
	static class ULoadout_SubSelection_V2* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadout_SubSelection_V2>();
	}
};
static_assert(alignof(ULoadout_SubSelection_V2) == 0x000008, "Wrong alignment on ULoadout_SubSelection_V2");
static_assert(sizeof(ULoadout_SubSelection_V2) == 0x0002E8, "Wrong size on ULoadout_SubSelection_V2");

// Class ReadyOrNot.Loadout_TacticalSelection_V2
// 0x0000 (0x0410 - 0x0410)
class ULoadout_TacticalSelection_V2 final : public UCommonActivatableWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Loadout_TacticalSelection_V2">();
	}
	static class ULoadout_TacticalSelection_V2* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadout_TacticalSelection_V2>();
	}
};
static_assert(alignof(ULoadout_TacticalSelection_V2) == 0x000008, "Wrong alignment on ULoadout_TacticalSelection_V2");
static_assert(sizeof(ULoadout_TacticalSelection_V2) == 0x000410, "Wrong size on ULoadout_TacticalSelection_V2");

// Class ReadyOrNot.PenetrationData
// 0x04C8 (0x04F8 - 0x0030)
class UPenetrationData final : public UDataAsset
{
public:
	struct FMaterialPenetration                   DefaultPenetrationData;                            // 0x0030(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Aluminium;                                     // 0x0048(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Asphalt;                                       // 0x0060(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Brick;                                         // 0x0078(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_CarbonFibre;                                   // 0x0090(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Cardboard;                                     // 0x00A8(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Ceramic;                                       // 0x00C0(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_ConcreteSoft;                                  // 0x00D8(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_ConcreteStrong;                                // 0x00F0(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Dirt;                                          // 0x0108(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Drywall;                                       // 0x0120(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Electrical;                                    // 0x0138(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_EnergyShield;                                  // 0x0150(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Fabric_Carpet;                                 // 0x0168(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Fabric_Stuffing;                               // 0x0180(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Fabric_Thin;                                   // 0x0198(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Flesh;                                         // 0x01B0(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Galvanized;                                    // 0x01C8(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Glass_Plate;                                   // 0x01E0(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Glass_Windshield;                              // 0x01F8(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Grass;                                         // 0x0210(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Gravel;                                        // 0x0228(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Ice;                                           // 0x0240(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Lava;                                          // 0x0258(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Lead;                                          // 0x0270(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Leaves;                                        // 0x0288(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Limestone;                                     // 0x02A0(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Mahogany;                                      // 0x02B8(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Marble_Coated;                                 // 0x02D0(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Marble_Thick;                                  // 0x02E8(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Mud;                                           // 0x0300(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Oil;                                           // 0x0318(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Paper;                                         // 0x0330(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Pine;                                          // 0x0348(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Plaster;                                       // 0x0360(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Plastic;                                       // 0x0378(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Plywood;                                       // 0x0390(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Polystyrene;                                   // 0x03A8(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Powder;                                        // 0x03C0(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Rock;                                          // 0x03D8(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Rubber;                                        // 0x03F0(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Sand;                                          // 0x0408(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Snow;                                          // 0x0420(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Soil;                                          // 0x0438(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Steel;                                         // 0x0450(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Tin;                                           // 0x0468(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Treewood;                                      // 0x0480(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Wallpaper;                                     // 0x0498(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Water;                                         // 0x04B0(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Vehicle;                                       // 0x04C8(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMaterialPenetration                   RON_Bulletproof_Glass;                             // 0x04E0(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)

public:
	struct FMaterialPenetration GetPenetrationData(EPhysicalSurface Surface);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PenetrationData">();
	}
	static class UPenetrationData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPenetrationData>();
	}
};
static_assert(alignof(UPenetrationData) == 0x000008, "Wrong alignment on UPenetrationData");
static_assert(sizeof(UPenetrationData) == 0x0004F8, "Wrong size on UPenetrationData");
static_assert(offsetof(UPenetrationData, DefaultPenetrationData) == 0x000030, "Member 'UPenetrationData::DefaultPenetrationData' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Aluminium) == 0x000048, "Member 'UPenetrationData::RON_Aluminium' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Asphalt) == 0x000060, "Member 'UPenetrationData::RON_Asphalt' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Brick) == 0x000078, "Member 'UPenetrationData::RON_Brick' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_CarbonFibre) == 0x000090, "Member 'UPenetrationData::RON_CarbonFibre' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Cardboard) == 0x0000A8, "Member 'UPenetrationData::RON_Cardboard' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Ceramic) == 0x0000C0, "Member 'UPenetrationData::RON_Ceramic' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_ConcreteSoft) == 0x0000D8, "Member 'UPenetrationData::RON_ConcreteSoft' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_ConcreteStrong) == 0x0000F0, "Member 'UPenetrationData::RON_ConcreteStrong' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Dirt) == 0x000108, "Member 'UPenetrationData::RON_Dirt' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Drywall) == 0x000120, "Member 'UPenetrationData::RON_Drywall' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Electrical) == 0x000138, "Member 'UPenetrationData::RON_Electrical' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_EnergyShield) == 0x000150, "Member 'UPenetrationData::RON_EnergyShield' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Fabric_Carpet) == 0x000168, "Member 'UPenetrationData::RON_Fabric_Carpet' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Fabric_Stuffing) == 0x000180, "Member 'UPenetrationData::RON_Fabric_Stuffing' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Fabric_Thin) == 0x000198, "Member 'UPenetrationData::RON_Fabric_Thin' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Flesh) == 0x0001B0, "Member 'UPenetrationData::RON_Flesh' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Galvanized) == 0x0001C8, "Member 'UPenetrationData::RON_Galvanized' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Glass_Plate) == 0x0001E0, "Member 'UPenetrationData::RON_Glass_Plate' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Glass_Windshield) == 0x0001F8, "Member 'UPenetrationData::RON_Glass_Windshield' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Grass) == 0x000210, "Member 'UPenetrationData::RON_Grass' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Gravel) == 0x000228, "Member 'UPenetrationData::RON_Gravel' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Ice) == 0x000240, "Member 'UPenetrationData::RON_Ice' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Lava) == 0x000258, "Member 'UPenetrationData::RON_Lava' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Lead) == 0x000270, "Member 'UPenetrationData::RON_Lead' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Leaves) == 0x000288, "Member 'UPenetrationData::RON_Leaves' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Limestone) == 0x0002A0, "Member 'UPenetrationData::RON_Limestone' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Mahogany) == 0x0002B8, "Member 'UPenetrationData::RON_Mahogany' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Marble_Coated) == 0x0002D0, "Member 'UPenetrationData::RON_Marble_Coated' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Marble_Thick) == 0x0002E8, "Member 'UPenetrationData::RON_Marble_Thick' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Mud) == 0x000300, "Member 'UPenetrationData::RON_Mud' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Oil) == 0x000318, "Member 'UPenetrationData::RON_Oil' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Paper) == 0x000330, "Member 'UPenetrationData::RON_Paper' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Pine) == 0x000348, "Member 'UPenetrationData::RON_Pine' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Plaster) == 0x000360, "Member 'UPenetrationData::RON_Plaster' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Plastic) == 0x000378, "Member 'UPenetrationData::RON_Plastic' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Plywood) == 0x000390, "Member 'UPenetrationData::RON_Plywood' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Polystyrene) == 0x0003A8, "Member 'UPenetrationData::RON_Polystyrene' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Powder) == 0x0003C0, "Member 'UPenetrationData::RON_Powder' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Rock) == 0x0003D8, "Member 'UPenetrationData::RON_Rock' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Rubber) == 0x0003F0, "Member 'UPenetrationData::RON_Rubber' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Sand) == 0x000408, "Member 'UPenetrationData::RON_Sand' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Snow) == 0x000420, "Member 'UPenetrationData::RON_Snow' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Soil) == 0x000438, "Member 'UPenetrationData::RON_Soil' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Steel) == 0x000450, "Member 'UPenetrationData::RON_Steel' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Tin) == 0x000468, "Member 'UPenetrationData::RON_Tin' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Treewood) == 0x000480, "Member 'UPenetrationData::RON_Treewood' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Wallpaper) == 0x000498, "Member 'UPenetrationData::RON_Wallpaper' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Water) == 0x0004B0, "Member 'UPenetrationData::RON_Water' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Vehicle) == 0x0004C8, "Member 'UPenetrationData::RON_Vehicle' has a wrong offset!");
static_assert(offsetof(UPenetrationData, RON_Bulletproof_Glass) == 0x0004E0, "Member 'UPenetrationData::RON_Bulletproof_Glass' has a wrong offset!");

// Class ReadyOrNot.Loadout_V2
// 0x0488 (0x0898 - 0x0410)
class ULoadout_V2 : public UCommonActivatableWidget
{
public:
	class UOverview_V2*                           OverviewWidget;                                    // 0x0410(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCommonActivatableWidgetStack*          WidgetStack;                                       // 0x0418(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AReadyOrNotGameState*                   gs;                                                // 0x0420(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AReadyOrNotPlayerController*            PC;                                                // 0x0428(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AReadyOrNotPlayerState*                 ps;                                                // 0x0430(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_438[0x8];                                      // 0x0438(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AReadyOrNotPlayerState*                 PreviewPlayerState;                                // 0x0440(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class AReadyOrNotCharacter*, class AReadyOrNotPlayerState*> PlayerStatePreviewMap;          // 0x0448(0x0050)(Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   RedTeamClass;                                      // 0x0498(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   BlueTeamClass;                                     // 0x04C0(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   VIPClass;                                          // 0x04E8(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<TSubclassOf<class ABaseItem>, struct FSavedWeaponPreset> WeaponToWeaponPresetsMap;          // 0x0510(0x0050)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class AReadyOrNotPlayerState*                 EquippingPlayerState;                              // 0x0560(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_568[0x8];                                      // 0x0568(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EEquippingSwat, struct FSavedLoadout>    LastSavedLoadout;                                  // 0x0570(0x0050)(Protected, NativeAccessSpecifierProtected)
	TMap<EEquippingSwat, struct FSavedLoadout>    LastEquippedPreviewLoadout;                        // 0x05C0(0x0050)(Protected, NativeAccessSpecifierProtected)
	class FString                                 PrimaryDrawAnim;                                   // 0x0610(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 PrimaryHolsterAnim;                                // 0x0620(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 SidearmDrawAnim;                                   // 0x0630(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 SidearmHolsterAnim;                                // 0x0640(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 CurrentPreviewAnimation;                           // 0x0650(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   CurrentCameraTag;                                  // 0x0660(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HolsterTimeRemaining;                              // 0x0668(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_66C[0x4];                                      // 0x066C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EItemCategory, class FName>              CategoryCameraTags;                                // 0x0670(0x0050)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	TMap<EItemCategory, class FString>            CategoryPoses;                                     // 0x06C0(0x0050)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	bool                                          ApplyingPresets;                                   // 0x0710(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          UsingPreset;                                       // 0x0711(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          PresetDirty;                                       // 0x0712(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          VerticalListOpen;                                  // 0x0713(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ListVisible;                                       // 0x0714(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_715[0x3];                                      // 0x0715(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       AnimExtendListSlide;                               // 0x0718(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FName, class ABaseItem*>           WorkBenchItemPtrMap;                               // 0x0720(0x0050)(BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TMap<TSubclassOf<class ABaseItem>, struct FSavedWeaponAttachmentData> WeaponToAttachmentsMap;    // 0x0770(0x0050)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsCustomizingPrimary;                             // 0x07C0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7C1[0x13];                                     // 0x07C1(0x0013)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ActiveCameraTag;                                   // 0x07D4(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7DC[0x5C];                                     // 0x07DC(0x005C)(Fixing Size After Last Property [ Dumper-7 ])
	class ULoadoutSlotWidget*                     CurrentActiveSlot;                                 // 0x0838(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       FadeOut;                                           // 0x0840(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AReadyOrNotCharacter*                   LoadoutPreviewCharacter;                           // 0x0848(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_850[0x40];                                     // 0x0850(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class UReadyOrNotLoadoutManager*              LoadoutFunctionLibrary;                            // 0x0890(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void ApplyLoadoutPreset(const struct FLoadoutPreset& LoadoutPreset);
	void ExitLoadout();
	class AReadyOrNotCharacter* GetDefaultPreviewCharacter();
	bool GetInputLocked();
	void GrabCharacter();
	void HidePrimary(bool bIsHidden);
	void HidePrimaryAndSecondary();
	void LoadAddAttachment(class ABaseWeapon* BaseWeapon, TSubclassOf<class UWeaponAttachment> Attachment, bool bReplicateAttachment);
	void LoadStoredWeaponAttachments();
	void LoadWeaponPresets();
	void OnLoadoutItemAttachmentsLoaded();
	void OnLoadoutItemAttachmentsSaved();
	void OnLoadoutItemPresetsLoaded();
	void OnLoadoutItemPresetsSaved();
	void OnLoadoutLoaded();
	void OnLoadoutPresetsLoaded();
	void OnLoadoutPresetsSaved();
	void OnLoadoutSaved();
	void OnSwatCharacterChanged();
	void OpenCustomization();
	void PlayAnimationOnPreviewCharacter(const class FString& Animation);
	void ReleaseCharacter();
	void RotateLoadoutCharacter(float InRotation, bool bSetVelocity);
	void SaveStoredWeaponAttachments();
	void SetActiveCameraByTag(class FName Tag, float BlendTime);
	void SetActiveCameraByTagWithFade(class FName Tag, float BlendTime, float FadeTime);
	void SetBodyArmour(TSubclassOf<class ABaseItem> BodyArmour);
	void SetDefaultCamera(float BlendTime);
	void SetFacewear(TSubclassOf<class ABaseItem> Facewear);
	void SetHeadwear(TSubclassOf<class ABaseItem> Headwear);
	void SetHelmetMount(TSubclassOf<class ABaseItem> HelmetMount);
	void SetItem(EItemType ItemType, TSubclassOf<class ABaseItem> ItemClass);
	void SetLockInput(bool bShouldLockInput);
	void SetLongTactical(TSubclassOf<class ABaseItem> LongTactical);
	void SetNvgStyle(ENVGStyle NvgStyle);
	void SetPrimaryWeapon(const struct FWeaponData& WeaponData);
	void SetSecondaryWeapon(const struct FWeaponData& WeaponData);
	void SetWorkbenchItemClass(TSubclassOf<class ABaseItem> Item, class FName Tag, const struct FSavedLoadout& Loadout);
	void UpdateDefaultPreviewCharacter();
	void UpdatePreviewCharacter(class AReadyOrNotPlayerState* InPreviewPlayerState, class FName Tag);
	void UpdatePreviewCharacterArmour();
	void UpdatePreviewCharacterHeadwear();
	void UpdatePreviewCharacterLongTactical();
	void UpdatePreviewCharacterPrimary();
	void UpdatePreviewCharacterSecondary();
	void UpdatePreviewWeaponAttachments(bool IsSecondary, TSubclassOf<class UWeaponAttachment> Attachment);
	void UpdateWorkbenchItemAttachments(const struct FSavedLoadout& Loadout, bool IsSecondary);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Loadout_V2">();
	}
	static class ULoadout_V2* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadout_V2>();
	}
};
static_assert(alignof(ULoadout_V2) == 0x000008, "Wrong alignment on ULoadout_V2");
static_assert(sizeof(ULoadout_V2) == 0x000898, "Wrong size on ULoadout_V2");
static_assert(offsetof(ULoadout_V2, OverviewWidget) == 0x000410, "Member 'ULoadout_V2::OverviewWidget' has a wrong offset!");
static_assert(offsetof(ULoadout_V2, WidgetStack) == 0x000418, "Member 'ULoadout_V2::WidgetStack' has a wrong offset!");
static_assert(offsetof(ULoadout_V2, gs) == 0x000420, "Member 'ULoadout_V2::gs' has a wrong offset!");
static_assert(offsetof(ULoadout_V2, PC) == 0x000428, "Member 'ULoadout_V2::PC' has a wrong offset!");
static_assert(offsetof(ULoadout_V2, ps) == 0x000430, "Member 'ULoadout_V2::ps' has a wrong offset!");
static_assert(offsetof(ULoadout_V2, PreviewPlayerState) == 0x000440, "Member 'ULoadout_V2::PreviewPlayerState' has a wrong offset!");
static_assert(offsetof(ULoadout_V2, PlayerStatePreviewMap) == 0x000448, "Member 'ULoadout_V2::PlayerStatePreviewMap' has a wrong offset!");
static_assert(offsetof(ULoadout_V2, RedTeamClass) == 0x000498, "Member 'ULoadout_V2::RedTeamClass' has a wrong offset!");
static_assert(offsetof(ULoadout_V2, BlueTeamClass) == 0x0004C0, "Member 'ULoadout_V2::BlueTeamClass' has a wrong offset!");
static_assert(offsetof(ULoadout_V2, VIPClass) == 0x0004E8, "Member 'ULoadout_V2::VIPClass' has a wrong offset!");
static_assert(offsetof(ULoadout_V2, WeaponToWeaponPresetsMap) == 0x000510, "Member 'ULoadout_V2::WeaponToWeaponPresetsMap' has a wrong offset!");
static_assert(offsetof(ULoadout_V2, EquippingPlayerState) == 0x000560, "Member 'ULoadout_V2::EquippingPlayerState' has a wrong offset!");
static_assert(offsetof(ULoadout_V2, LastSavedLoadout) == 0x000570, "Member 'ULoadout_V2::LastSavedLoadout' has a wrong offset!");
static_assert(offsetof(ULoadout_V2, LastEquippedPreviewLoadout) == 0x0005C0, "Member 'ULoadout_V2::LastEquippedPreviewLoadout' has a wrong offset!");
static_assert(offsetof(ULoadout_V2, PrimaryDrawAnim) == 0x000610, "Member 'ULoadout_V2::PrimaryDrawAnim' has a wrong offset!");
static_assert(offsetof(ULoadout_V2, PrimaryHolsterAnim) == 0x000620, "Member 'ULoadout_V2::PrimaryHolsterAnim' has a wrong offset!");
static_assert(offsetof(ULoadout_V2, SidearmDrawAnim) == 0x000630, "Member 'ULoadout_V2::SidearmDrawAnim' has a wrong offset!");
static_assert(offsetof(ULoadout_V2, SidearmHolsterAnim) == 0x000640, "Member 'ULoadout_V2::SidearmHolsterAnim' has a wrong offset!");
static_assert(offsetof(ULoadout_V2, CurrentPreviewAnimation) == 0x000650, "Member 'ULoadout_V2::CurrentPreviewAnimation' has a wrong offset!");
static_assert(offsetof(ULoadout_V2, CurrentCameraTag) == 0x000660, "Member 'ULoadout_V2::CurrentCameraTag' has a wrong offset!");
static_assert(offsetof(ULoadout_V2, HolsterTimeRemaining) == 0x000668, "Member 'ULoadout_V2::HolsterTimeRemaining' has a wrong offset!");
static_assert(offsetof(ULoadout_V2, CategoryCameraTags) == 0x000670, "Member 'ULoadout_V2::CategoryCameraTags' has a wrong offset!");
static_assert(offsetof(ULoadout_V2, CategoryPoses) == 0x0006C0, "Member 'ULoadout_V2::CategoryPoses' has a wrong offset!");
static_assert(offsetof(ULoadout_V2, ApplyingPresets) == 0x000710, "Member 'ULoadout_V2::ApplyingPresets' has a wrong offset!");
static_assert(offsetof(ULoadout_V2, UsingPreset) == 0x000711, "Member 'ULoadout_V2::UsingPreset' has a wrong offset!");
static_assert(offsetof(ULoadout_V2, PresetDirty) == 0x000712, "Member 'ULoadout_V2::PresetDirty' has a wrong offset!");
static_assert(offsetof(ULoadout_V2, VerticalListOpen) == 0x000713, "Member 'ULoadout_V2::VerticalListOpen' has a wrong offset!");
static_assert(offsetof(ULoadout_V2, ListVisible) == 0x000714, "Member 'ULoadout_V2::ListVisible' has a wrong offset!");
static_assert(offsetof(ULoadout_V2, AnimExtendListSlide) == 0x000718, "Member 'ULoadout_V2::AnimExtendListSlide' has a wrong offset!");
static_assert(offsetof(ULoadout_V2, WorkBenchItemPtrMap) == 0x000720, "Member 'ULoadout_V2::WorkBenchItemPtrMap' has a wrong offset!");
static_assert(offsetof(ULoadout_V2, WeaponToAttachmentsMap) == 0x000770, "Member 'ULoadout_V2::WeaponToAttachmentsMap' has a wrong offset!");
static_assert(offsetof(ULoadout_V2, bIsCustomizingPrimary) == 0x0007C0, "Member 'ULoadout_V2::bIsCustomizingPrimary' has a wrong offset!");
static_assert(offsetof(ULoadout_V2, ActiveCameraTag) == 0x0007D4, "Member 'ULoadout_V2::ActiveCameraTag' has a wrong offset!");
static_assert(offsetof(ULoadout_V2, CurrentActiveSlot) == 0x000838, "Member 'ULoadout_V2::CurrentActiveSlot' has a wrong offset!");
static_assert(offsetof(ULoadout_V2, FadeOut) == 0x000840, "Member 'ULoadout_V2::FadeOut' has a wrong offset!");
static_assert(offsetof(ULoadout_V2, LoadoutPreviewCharacter) == 0x000848, "Member 'ULoadout_V2::LoadoutPreviewCharacter' has a wrong offset!");
static_assert(offsetof(ULoadout_V2, LoadoutFunctionLibrary) == 0x000890, "Member 'ULoadout_V2::LoadoutFunctionLibrary' has a wrong offset!");

// Class ReadyOrNot.Loadout_WeaponSelection_V2
// 0x0008 (0x0418 - 0x0410)
class ULoadout_WeaponSelection_V2 final : public UCommonActivatableWidget
{
public:
	int32                                         ActiveSwitcherIndex;                               // 0x0410(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ShouldUpdateWorkbench;                             // 0x0414(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_415[0x3];                                      // 0x0415(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetShouldUpdateWorkbench();
	void SetShouldUpdateWorkbench(bool ShouldUpdate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Loadout_WeaponSelection_V2">();
	}
	static class ULoadout_WeaponSelection_V2* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadout_WeaponSelection_V2>();
	}
};
static_assert(alignof(ULoadout_WeaponSelection_V2) == 0x000008, "Wrong alignment on ULoadout_WeaponSelection_V2");
static_assert(sizeof(ULoadout_WeaponSelection_V2) == 0x000418, "Wrong size on ULoadout_WeaponSelection_V2");
static_assert(offsetof(ULoadout_WeaponSelection_V2, ActiveSwitcherIndex) == 0x000410, "Member 'ULoadout_WeaponSelection_V2::ActiveSwitcherIndex' has a wrong offset!");
static_assert(offsetof(ULoadout_WeaponSelection_V2, ShouldUpdateWorkbench) == 0x000414, "Member 'ULoadout_WeaponSelection_V2::ShouldUpdateWorkbench' has a wrong offset!");

// Class ReadyOrNot.ReadyOrNotTriggerVolume
// 0x0028 (0x02C8 - 0x02A0)
class AReadyOrNotTriggerVolume : public ATriggerBox
{
public:
	TArray<TSubclassOf<class AActor>>             OverlappingClasses;                                // 0x02A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         TestActors;                                        // 0x02B0(0x0010)(Edit, ZeroConstructor, EditConst, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C0[0x8];                                      // 0x02C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActorSpawned(class AActor* Actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotTriggerVolume">();
	}
	static class AReadyOrNotTriggerVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AReadyOrNotTriggerVolume>();
	}
};
static_assert(alignof(AReadyOrNotTriggerVolume) == 0x000008, "Wrong alignment on AReadyOrNotTriggerVolume");
static_assert(sizeof(AReadyOrNotTriggerVolume) == 0x0002C8, "Wrong size on AReadyOrNotTriggerVolume");
static_assert(offsetof(AReadyOrNotTriggerVolume, OverlappingClasses) == 0x0002A0, "Member 'AReadyOrNotTriggerVolume::OverlappingClasses' has a wrong offset!");
static_assert(offsetof(AReadyOrNotTriggerVolume, TestActors) == 0x0002B0, "Member 'AReadyOrNotTriggerVolume::TestActors' has a wrong offset!");

// Class ReadyOrNot.LobbyFiringRangeArea
// 0x0000 (0x02C8 - 0x02C8)
class ALobbyFiringRangeArea final : public AReadyOrNotTriggerVolume
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyFiringRangeArea">();
	}
	static class ALobbyFiringRangeArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALobbyFiringRangeArea>();
	}
};
static_assert(alignof(ALobbyFiringRangeArea) == 0x000008, "Wrong alignment on ALobbyFiringRangeArea");
static_assert(sizeof(ALobbyFiringRangeArea) == 0x0002C8, "Wrong size on ALobbyFiringRangeArea");

// Class ReadyOrNot.PepperProjectile
// 0x0008 (0x0430 - 0x0428)
class APepperProjectile : public ABulletProjectile
{
public:
	class UParticleSystem*                        GasEffect;                                         // 0x0428(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PepperProjectile">();
	}
	static class APepperProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<APepperProjectile>();
	}
};
static_assert(alignof(APepperProjectile) == 0x000008, "Wrong alignment on APepperProjectile");
static_assert(sizeof(APepperProjectile) == 0x000430, "Wrong size on APepperProjectile");
static_assert(offsetof(APepperProjectile, GasEffect) == 0x000428, "Member 'APepperProjectile::GasEffect' has a wrong offset!");

// Class ReadyOrNot.LobbyGM
// 0x00D0 (0x0A40 - 0x0970)
class ALobbyGM final : public AReadyOrNotGameMode
{
public:
	uint8                                         Pad_970[0x8];                                      // 0x0970(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AReadyOrNotPlayerController*>    InitalizedPlayerControllers;                       // 0x0978(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_988[0x80];                                     // 0x0988(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	class UCommanderProfile*                      CommanderProfile;                                  // 0x0A08(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URosterManager*                         RosterManager;                                     // 0x0A10(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A18[0x10];                                     // 0x0A18(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UCommonActivatableWidget>> PopupQueue;                                  // 0x0A28(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_A38[0x8];                                      // 0x0A38(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLoadingScreenCleared();
	void OpenMissionSelect();
	void OpenRosterSelection();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyGM">();
	}
	static class ALobbyGM* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALobbyGM>();
	}
};
static_assert(alignof(ALobbyGM) == 0x000010, "Wrong alignment on ALobbyGM");
static_assert(sizeof(ALobbyGM) == 0x000A40, "Wrong size on ALobbyGM");
static_assert(offsetof(ALobbyGM, InitalizedPlayerControllers) == 0x000978, "Member 'ALobbyGM::InitalizedPlayerControllers' has a wrong offset!");
static_assert(offsetof(ALobbyGM, CommanderProfile) == 0x000A08, "Member 'ALobbyGM::CommanderProfile' has a wrong offset!");
static_assert(offsetof(ALobbyGM, RosterManager) == 0x000A10, "Member 'ALobbyGM::RosterManager' has a wrong offset!");
static_assert(offsetof(ALobbyGM, PopupQueue) == 0x000A28, "Member 'ALobbyGM::PopupQueue' has a wrong offset!");

// Class ReadyOrNot.LobbyGS
// 0x0020 (0x0918 - 0x08F8)
class ALobbyGS final : public AReadyOrNotGameState
{
public:
	class UFMODEvent*                             LobbyMusicEvent;                                   // 0x08F8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_900[0x8];                                      // 0x0900(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MissionGradeMusic;                                 // 0x0908(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_90C[0xC];                                      // 0x090C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyGS">();
	}
	static class ALobbyGS* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALobbyGS>();
	}
};
static_assert(alignof(ALobbyGS) == 0x000008, "Wrong alignment on ALobbyGS");
static_assert(sizeof(ALobbyGS) == 0x000918, "Wrong size on ALobbyGS");
static_assert(offsetof(ALobbyGS, LobbyMusicEvent) == 0x0008F8, "Member 'ALobbyGS::LobbyMusicEvent' has a wrong offset!");
static_assert(offsetof(ALobbyGS, MissionGradeMusic) == 0x000908, "Member 'ALobbyGS::MissionGradeMusic' has a wrong offset!");

// Class ReadyOrNot.LockPickDoorActivity
// 0x0000 (0x0258 - 0x0258)
class ULockPickDoorActivity final : public UDoorInteractionActivity
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LockPickDoorActivity">();
	}
	static class ULockPickDoorActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULockPickDoorActivity>();
	}
};
static_assert(alignof(ULockPickDoorActivity) == 0x000008, "Wrong alignment on ULockPickDoorActivity");
static_assert(sizeof(ULockPickDoorActivity) == 0x000258, "Wrong size on ULockPickDoorActivity");

// Class ReadyOrNot.Tool
// 0x0020 (0x0BD0 - 0x0BB0)
#pragma pack(push, 0x1)
class alignas(0x10) ATool : public ABaseItem
{
public:
	float                                         MaxOperatingTime;                                  // 0x0BB0(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentOperatingTime;                              // 0x0BB4(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bOperating : 1;                                    // 0x0BB8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_BB9[0x7];                                      // 0x0BB9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 TargetActor;                                       // 0x0BC0(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Client_FinishedToolUse(class AActor* Target, class APlayerCharacter* PC);
	void Client_StopToolAnimation();
	void Server_StartUsingTool(class AActor* Target);
	void Server_StopUsingTool(class AActor* Target);
	void Server_ToolComplete();
	void StartUsingTool(class AActor* Target);
	void StopUsingTool(class AActor* Target);

	float GetCurrentOperatingTime() const;
	float GetMaxOperatingTime() const;
	bool IsOperating() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Tool">();
	}
	static class ATool* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATool>();
	}
};
#pragma pack(pop)
static_assert(alignof(ATool) == 0x000010, "Wrong alignment on ATool");
static_assert(sizeof(ATool) == 0x000BD0, "Wrong size on ATool");
static_assert(offsetof(ATool, MaxOperatingTime) == 0x000BB0, "Member 'ATool::MaxOperatingTime' has a wrong offset!");
static_assert(offsetof(ATool, CurrentOperatingTime) == 0x000BB4, "Member 'ATool::CurrentOperatingTime' has a wrong offset!");
static_assert(offsetof(ATool, TargetActor) == 0x000BC0, "Member 'ATool::TargetActor' has a wrong offset!");

// Class ReadyOrNot.PickUpCharacterActivity
// 0x0020 (0x0210 - 0x01F0)
class UPickUpCharacterActivity final : public UBaseActivity
{
public:
	class AReadyOrNotCharacter*                   PickUpCharacter;                                   // 0x01F0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F8[0x18];                                     // 0x01F8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnterCompleteStage();
	void EnterMoveToStage();
	void EnterPickUpStage();
	void EnterPlaceDownStage();
	void EnterTransitStage();
	void TickPickUpStage(float DeltaTime, float Uptime);

	bool CanPickUpNow() const;
	bool CanPlaceDownNow() const;
	bool CanTransitNow() const;
	bool IsPlaceDownComplete() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PickUpCharacterActivity">();
	}
	static class UPickUpCharacterActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPickUpCharacterActivity>();
	}
};
static_assert(alignof(UPickUpCharacterActivity) == 0x000008, "Wrong alignment on UPickUpCharacterActivity");
static_assert(sizeof(UPickUpCharacterActivity) == 0x000210, "Wrong size on UPickUpCharacterActivity");
static_assert(offsetof(UPickUpCharacterActivity, PickUpCharacter) == 0x0001F0, "Member 'UPickUpCharacterActivity::PickUpCharacter' has a wrong offset!");

// Class ReadyOrNot.LockpickGun
// 0x0000 (0x0BD0 - 0x0BD0)
class ALockpickGun : public ATool
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LockpickGun">();
	}
	static class ALockpickGun* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALockpickGun>();
	}
};
static_assert(alignof(ALockpickGun) == 0x000010, "Wrong alignment on ALockpickGun");
static_assert(sizeof(ALockpickGun) == 0x000BD0, "Wrong size on ALockpickGun");

// Class ReadyOrNot.LoudnessMeterWidget
// 0x0018 (0x0300 - 0x02E8)
class ULoudnessMeterWidget final : public UBaseWidget
{
public:
	class UWidgetSwitcher*                        MovementSound_WidgetSwitcher;                      // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APlayerCharacter*                       PlayerCharacter;                                   // 0x02F0(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F8[0x8];                                      // 0x02F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoudnessMeterWidget">();
	}
	static class ULoudnessMeterWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoudnessMeterWidget>();
	}
};
static_assert(alignof(ULoudnessMeterWidget) == 0x000008, "Wrong alignment on ULoudnessMeterWidget");
static_assert(sizeof(ULoudnessMeterWidget) == 0x000300, "Wrong size on ULoudnessMeterWidget");
static_assert(offsetof(ULoudnessMeterWidget, MovementSound_WidgetSwitcher) == 0x0002E8, "Member 'ULoudnessMeterWidget::MovementSound_WidgetSwitcher' has a wrong offset!");
static_assert(offsetof(ULoudnessMeterWidget, PlayerCharacter) == 0x0002F0, "Member 'ULoudnessMeterWidget::PlayerCharacter' has a wrong offset!");

// Class ReadyOrNot.MagazineAttachment
// 0x0020 (0x10F0 - 0x10D0)
class UMagazineAttachment : public UWeaponAttachment
{
public:
	class UStaticMesh*                            MagazineStaticMesh;                                // 0x10D0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Socket_01;                                         // 0x10D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Socket_02;                                         // 0x10E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10E8[0x8];                                     // 0x10E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MagazineAttachment">();
	}
	static class UMagazineAttachment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMagazineAttachment>();
	}
};
static_assert(alignof(UMagazineAttachment) == 0x000010, "Wrong alignment on UMagazineAttachment");
static_assert(sizeof(UMagazineAttachment) == 0x0010F0, "Wrong size on UMagazineAttachment");
static_assert(offsetof(UMagazineAttachment, MagazineStaticMesh) == 0x0010D0, "Member 'UMagazineAttachment::MagazineStaticMesh' has a wrong offset!");
static_assert(offsetof(UMagazineAttachment, Socket_01) == 0x0010D8, "Member 'UMagazineAttachment::Socket_01' has a wrong offset!");
static_assert(offsetof(UMagazineAttachment, Socket_02) == 0x0010E0, "Member 'UMagazineAttachment::Socket_02' has a wrong offset!");

// Class ReadyOrNot.MagMaskingAnimNotify
// 0x0008 (0x0040 - 0x0038)
class UMagMaskingAnimNotify final : public UAnimNotify
{
public:
	bool                                          bIsFirstPerson;                                    // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EMaskMag                                      MaskMag;                                           // 0x0039(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EMaskMagState                                 MagState;                                          // 0x003A(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDummyCopyMag02;                                   // 0x003B(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MagMaskingAnimNotify">();
	}
	static class UMagMaskingAnimNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMagMaskingAnimNotify>();
	}
};
static_assert(alignof(UMagMaskingAnimNotify) == 0x000008, "Wrong alignment on UMagMaskingAnimNotify");
static_assert(sizeof(UMagMaskingAnimNotify) == 0x000040, "Wrong size on UMagMaskingAnimNotify");
static_assert(offsetof(UMagMaskingAnimNotify, bIsFirstPerson) == 0x000038, "Member 'UMagMaskingAnimNotify::bIsFirstPerson' has a wrong offset!");
static_assert(offsetof(UMagMaskingAnimNotify, MaskMag) == 0x000039, "Member 'UMagMaskingAnimNotify::MaskMag' has a wrong offset!");
static_assert(offsetof(UMagMaskingAnimNotify, MagState) == 0x00003A, "Member 'UMagMaskingAnimNotify::MagState' has a wrong offset!");
static_assert(offsetof(UMagMaskingAnimNotify, bDummyCopyMag02) == 0x00003B, "Member 'UMagMaskingAnimNotify::bDummyCopyMag02' has a wrong offset!");

// Class ReadyOrNot.PickupWeaponActor
// 0x0030 (0x0330 - 0x0300)
class APickupWeaponActor final : public APickupActor
{
public:
	TSubclassOf<class ABaseWeapon>                Weapon;                                            // 0x0300(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKillOnPickup;                                     // 0x0308(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSecondaryWeapon;                                  // 0x0309(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bModifyLoadout;                                    // 0x030A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30B[0x5];                                      // 0x030B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UWeaponAttachment>          ScopeAttachment;                                   // 0x0310(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWeaponAttachment>          MuzzleAttachment;                                  // 0x0318(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWeaponAttachment>          UnderbarrelAttachment;                             // 0x0320(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWeaponAttachment>          OverbarrelAttachment;                              // 0x0328(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PickupWeaponActor">();
	}
	static class APickupWeaponActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<APickupWeaponActor>();
	}
};
static_assert(alignof(APickupWeaponActor) == 0x000008, "Wrong alignment on APickupWeaponActor");
static_assert(sizeof(APickupWeaponActor) == 0x000330, "Wrong size on APickupWeaponActor");
static_assert(offsetof(APickupWeaponActor, Weapon) == 0x000300, "Member 'APickupWeaponActor::Weapon' has a wrong offset!");
static_assert(offsetof(APickupWeaponActor, bKillOnPickup) == 0x000308, "Member 'APickupWeaponActor::bKillOnPickup' has a wrong offset!");
static_assert(offsetof(APickupWeaponActor, bSecondaryWeapon) == 0x000309, "Member 'APickupWeaponActor::bSecondaryWeapon' has a wrong offset!");
static_assert(offsetof(APickupWeaponActor, bModifyLoadout) == 0x00030A, "Member 'APickupWeaponActor::bModifyLoadout' has a wrong offset!");
static_assert(offsetof(APickupWeaponActor, ScopeAttachment) == 0x000310, "Member 'APickupWeaponActor::ScopeAttachment' has a wrong offset!");
static_assert(offsetof(APickupWeaponActor, MuzzleAttachment) == 0x000318, "Member 'APickupWeaponActor::MuzzleAttachment' has a wrong offset!");
static_assert(offsetof(APickupWeaponActor, UnderbarrelAttachment) == 0x000320, "Member 'APickupWeaponActor::UnderbarrelAttachment' has a wrong offset!");
static_assert(offsetof(APickupWeaponActor, OverbarrelAttachment) == 0x000328, "Member 'APickupWeaponActor::OverbarrelAttachment' has a wrong offset!");

// Class ReadyOrNot.MainMenu
// 0x00E8 (0x04F8 - 0x0410)
class UMainMenu final : public UMenuWidget
{
public:
	TMap<ReadyOrNot::ELoginState, class FText>    BackendConnectionStatus;                           // 0x0410(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TMap<ReadyOrNot::ELoginState, struct FSlateColor> BackendConnectionStatusColor;                  // 0x0460(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           BackgroundCanvas;                                  // 0x04B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidget*                            PlayBtn;                                           // 0x04B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidget*                            FindCOOPSessionBtn;                                // 0x04C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidget*                            FindPVPSessionBtn;                                 // 0x04C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidget*                            PlayPublicLobbyBtn;                                // 0x04D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidget*                            PlayFriendsOnlyBtn;                                // 0x04D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Txt_BackEndConnection;                             // 0x04E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Txt_PublicLobbyCooldown;                           // 0x04E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bEnableFindSessionCOOPButton : 1;                  // 0x04F0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bEnableFindSessionPVPButton : 1;                   // 0x04F0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_4F1[0x7];                                      // 0x04F1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CloseModMenu();
	void OpenModMenu();

	bool CanFindSession(bool bCOOP) const;
	bool CanPlayPublicLobby() const;
	class FText GetBackEndConnectionStatus(ReadyOrNot::ELoginState LoginState) const;
	class FText GetPublicLobbyCooldown() const;
	class FText GetVersion() const;
	bool IsLoggedIn() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MainMenu">();
	}
	static class UMainMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMainMenu>();
	}
};
static_assert(alignof(UMainMenu) == 0x000008, "Wrong alignment on UMainMenu");
static_assert(sizeof(UMainMenu) == 0x0004F8, "Wrong size on UMainMenu");
static_assert(offsetof(UMainMenu, BackendConnectionStatus) == 0x000410, "Member 'UMainMenu::BackendConnectionStatus' has a wrong offset!");
static_assert(offsetof(UMainMenu, BackendConnectionStatusColor) == 0x000460, "Member 'UMainMenu::BackendConnectionStatusColor' has a wrong offset!");
static_assert(offsetof(UMainMenu, BackgroundCanvas) == 0x0004B0, "Member 'UMainMenu::BackgroundCanvas' has a wrong offset!");
static_assert(offsetof(UMainMenu, PlayBtn) == 0x0004B8, "Member 'UMainMenu::PlayBtn' has a wrong offset!");
static_assert(offsetof(UMainMenu, FindCOOPSessionBtn) == 0x0004C0, "Member 'UMainMenu::FindCOOPSessionBtn' has a wrong offset!");
static_assert(offsetof(UMainMenu, FindPVPSessionBtn) == 0x0004C8, "Member 'UMainMenu::FindPVPSessionBtn' has a wrong offset!");
static_assert(offsetof(UMainMenu, PlayPublicLobbyBtn) == 0x0004D0, "Member 'UMainMenu::PlayPublicLobbyBtn' has a wrong offset!");
static_assert(offsetof(UMainMenu, PlayFriendsOnlyBtn) == 0x0004D8, "Member 'UMainMenu::PlayFriendsOnlyBtn' has a wrong offset!");
static_assert(offsetof(UMainMenu, Txt_BackEndConnection) == 0x0004E0, "Member 'UMainMenu::Txt_BackEndConnection' has a wrong offset!");
static_assert(offsetof(UMainMenu, Txt_PublicLobbyCooldown) == 0x0004E8, "Member 'UMainMenu::Txt_PublicLobbyCooldown' has a wrong offset!");

// Class ReadyOrNot.MainMenuGM
// 0x00D0 (0x0408 - 0x0338)
class AMainMenuGM : public AGameModeBase
{
public:
	class UCreateSessionCallbackProxyAdvanced*    CreateSessionCallbackProxyAdvanced;                // 0x0338(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFindSessionsCallbackProxyAdvanced*     FindSessionsCallbackProxyAdvanced;                 // 0x0340(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDestroySessionCallbackProxyAdvanced*   DestroySessionCallbackProxyAdvanced;               // 0x0348(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGetUserPrivilegeCallbackProxy*         GetUserPrivilegeCallbackProxy;                     // 0x0350(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFMODEvent*                             MainMenuMusic;                                     // 0x0358(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             MainMenuAmbience;                                  // 0x0360(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_368[0x40];                                     // 0x0368(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(bool bComplete, class FText OutMessage, const TArray<struct FBlueprintSessionResult>& SessionResult)> OnUpdateSessionSearch; // 0x03A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B8[0x40];                                     // 0x03B8(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserWidget*                            AuthenticationMenu;                                // 0x03F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_400[0x8];                                      // 0x0400(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool HasCompletedTraining();
	static bool HasGameVersionBeenAcknowledged(EGameVersionRestriction GameVersionRestriction);
	static void SetCommanderPopupFlag(bool bPopup);
	static void SetGameVersionAcknowledged(EGameVersionRestriction GameVersionRestriction);
	static void SetQuickPlayPopupFlag(bool bPopup);
	static bool ShouldShowCommanderModePopup();
	static bool ShouldShowQuickPlayPopup();

	void ActuallyFindSessions(const TArray<struct FSessionsSearchSetting>& SearchSettings);
	void CancelSessionSearch();
	bool CanContinueCommanderMode();
	void ContinueCommanderMode();
	void CreateRestartWidget();
	void FindNextSessionList();
	void FindOnlineSession(bool bNewSearch, bool bPVPSession);
	void GoToCommanderMode(int32 ProfileSlot, bool bIronmanMode, bool bTutorialMode);
	void GoToLobby(bool bOnlineMode, bool bFriendsOnly);
	void GoToTraining();
	bool IsSearchingForSession();
	void JoinSession(const struct FBlueprintSessionResult& Session);
	void OnBanStatusChecked(const class FString& SteamId, bool bIsBanned, const class FString& BanReason, bool bIsMySteamId);
	void OnDestroySessionBeforeStartingLobby();
	void OnFindSessionFailed(const TArray<struct FBlueprintSessionResult>& Results);
	void OnFindSessionSuccess(const TArray<struct FBlueprintSessionResult>& Results);
	void OnGetUserPrivilegeFailure();
	void OnGetUserPrivilegeSuccess(EBPUserPrivileges QueriedPrivilege, bool HadPrivilege);
	void OnLobbyFailed();
	void OnLobbySuccess();
	void OnTrainingSuccess();
	void QuickPlayConsole();
	void ShowMainMenuMsg();
	void ShowMessageDisplayBox(const class FString& MessageText, const class FString& ButtonText, const bool QuitOnPress);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MainMenuGM">();
	}
	static class AMainMenuGM* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMainMenuGM>();
	}
};
static_assert(alignof(AMainMenuGM) == 0x000008, "Wrong alignment on AMainMenuGM");
static_assert(sizeof(AMainMenuGM) == 0x000408, "Wrong size on AMainMenuGM");
static_assert(offsetof(AMainMenuGM, CreateSessionCallbackProxyAdvanced) == 0x000338, "Member 'AMainMenuGM::CreateSessionCallbackProxyAdvanced' has a wrong offset!");
static_assert(offsetof(AMainMenuGM, FindSessionsCallbackProxyAdvanced) == 0x000340, "Member 'AMainMenuGM::FindSessionsCallbackProxyAdvanced' has a wrong offset!");
static_assert(offsetof(AMainMenuGM, DestroySessionCallbackProxyAdvanced) == 0x000348, "Member 'AMainMenuGM::DestroySessionCallbackProxyAdvanced' has a wrong offset!");
static_assert(offsetof(AMainMenuGM, GetUserPrivilegeCallbackProxy) == 0x000350, "Member 'AMainMenuGM::GetUserPrivilegeCallbackProxy' has a wrong offset!");
static_assert(offsetof(AMainMenuGM, MainMenuMusic) == 0x000358, "Member 'AMainMenuGM::MainMenuMusic' has a wrong offset!");
static_assert(offsetof(AMainMenuGM, MainMenuAmbience) == 0x000360, "Member 'AMainMenuGM::MainMenuAmbience' has a wrong offset!");
static_assert(offsetof(AMainMenuGM, OnUpdateSessionSearch) == 0x0003A8, "Member 'AMainMenuGM::OnUpdateSessionSearch' has a wrong offset!");
static_assert(offsetof(AMainMenuGM, AuthenticationMenu) == 0x0003F8, "Member 'AMainMenuGM::AuthenticationMenu' has a wrong offset!");

// Class ReadyOrNot.MainMenu_BaseButton
// 0x0040 (0x1600 - 0x15C0)
class UMainMenu_BaseButton : public UCommonButtonFMOD
{
public:
	class FText                                   ButtonText;                                        // 0x15C0(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSlateColor                            NormalTextColor;                                   // 0x15D8(0x0014)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSlateColor                            HoveredTextColor;                                  // 0x15EC(0x0014)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MainMenu_BaseButton">();
	}
	static class UMainMenu_BaseButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMainMenu_BaseButton>();
	}
};
static_assert(alignof(UMainMenu_BaseButton) == 0x000010, "Wrong alignment on UMainMenu_BaseButton");
static_assert(sizeof(UMainMenu_BaseButton) == 0x001600, "Wrong size on UMainMenu_BaseButton");
static_assert(offsetof(UMainMenu_BaseButton, ButtonText) == 0x0015C0, "Member 'UMainMenu_BaseButton::ButtonText' has a wrong offset!");
static_assert(offsetof(UMainMenu_BaseButton, NormalTextColor) == 0x0015D8, "Member 'UMainMenu_BaseButton::NormalTextColor' has a wrong offset!");
static_assert(offsetof(UMainMenu_BaseButton, HoveredTextColor) == 0x0015EC, "Member 'UMainMenu_BaseButton::HoveredTextColor' has a wrong offset!");

// Class ReadyOrNot.MainMenu_V3
// 0x0078 (0x0488 - 0x0410)
class UMainMenu_V3 : public UCommonActivatableWidget
{
public:
	TMap<ReadyOrNot::ELoginState, class FText>    BackendConnectionStatus;                           // 0x0410(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         bEnableFindSessionCOOPButton : 1;                  // 0x0460(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableFindSessionPVPButton : 1;                   // 0x0460(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_461[0x27];                                     // 0x0461(0x0027)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CloseModMenu();
	void DisableMainMenuInputPreprocessor();
	void EnableMainMenuInputPreprocessor();
	void HideModMenu();
	bool IsModUpdating();
	void OnModMenuClosed();
	void OnModMenuClosedDuringUpdate();
	bool OpenModMenu(class APlayerController* PlayerController);
	bool ShouldShowModsButton();
	bool ShouldShowRestartDialog();

	bool CanFindSession(bool bCOOP) const;
	bool CanPlayPublicLobby() const;
	class FText GetBackEndConnectionStatus(ReadyOrNot::ELoginState LoginState) const;
	class FText GetPublicLobbyCooldown() const;
	bool IsLoggedIn() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MainMenu_V3">();
	}
	static class UMainMenu_V3* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMainMenu_V3>();
	}
};
static_assert(alignof(UMainMenu_V3) == 0x000008, "Wrong alignment on UMainMenu_V3");
static_assert(sizeof(UMainMenu_V3) == 0x000488, "Wrong size on UMainMenu_V3");
static_assert(offsetof(UMainMenu_V3, BackendConnectionStatus) == 0x000410, "Member 'UMainMenu_V3::BackendConnectionStatus' has a wrong offset!");

// Class ReadyOrNot.ReadyOrNotCrowdManager
// 0x0000 (0x00F0 - 0x00F0)
class UReadyOrNotCrowdManager final : public UCrowdManager
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotCrowdManager">();
	}
	static class UReadyOrNotCrowdManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotCrowdManager>();
	}
};
static_assert(alignof(UReadyOrNotCrowdManager) == 0x000008, "Wrong alignment on UReadyOrNotCrowdManager");
static_assert(sizeof(UReadyOrNotCrowdManager) == 0x0000F0, "Wrong size on UReadyOrNotCrowdManager");

// Class ReadyOrNot.MainMenu_Wrapper
// 0x0000 (0x0410 - 0x0410)
class UMainMenu_Wrapper final : public UCommonActivatableWidget
{
public:
	void CloseModMenu();
	void OpenModMenu();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MainMenu_Wrapper">();
	}
	static class UMainMenu_Wrapper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMainMenu_Wrapper>();
	}
};
static_assert(alignof(UMainMenu_Wrapper) == 0x000008, "Wrong alignment on UMainMenu_Wrapper");
static_assert(sizeof(UMainMenu_Wrapper) == 0x000410, "Wrong size on UMainMenu_Wrapper");

// Class ReadyOrNot.MapActorComponent
// 0x0140 (0x03E0 - 0x02A0)
class UMapActorComponent final : public USceneComponent
{
public:
	uint8                                         bCondition : 1;                                    // 0x02A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnabled : 1;                                      // 0x02A0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_2A1[0x7];                                      // 0x02A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UMapActorWidget>            MapActorWidgetClass;                               // 0x02A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   IconText;                                          // 0x02B0(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FLinearColor                           IconTextColor;                                     // 0x02C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D8[0x8];                                      // 0x02D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            IconBrush;                                         // 0x02E0(0x00D0)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FLinearColor                           IconColor;                                         // 0x03B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bUseActorRotation : 1;                             // 0x03C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_3C1[0x3];                                      // 0x03C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RotationOffset;                                    // 0x03C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAddedToMap;                                       // 0x03C8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C9[0x7];                                      // 0x03C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMapActorIconWidget*                    MapIconWidget;                                     // 0x03D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D8[0x8];                                      // 0x03D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DisableMapActor();
	void EnableMapActor();
	void SetIconColor(const struct FLinearColor& InIconColor);
	void SetIconText(const class FText& InIconText);
	void SetIconTextColor(const struct FLinearColor& InIconTextColor);

	class FText GetIconText() const;
	bool IsUsingActorRotation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapActorComponent">();
	}
	static class UMapActorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapActorComponent>();
	}
};
static_assert(alignof(UMapActorComponent) == 0x000010, "Wrong alignment on UMapActorComponent");
static_assert(sizeof(UMapActorComponent) == 0x0003E0, "Wrong size on UMapActorComponent");
static_assert(offsetof(UMapActorComponent, MapActorWidgetClass) == 0x0002A8, "Member 'UMapActorComponent::MapActorWidgetClass' has a wrong offset!");
static_assert(offsetof(UMapActorComponent, IconText) == 0x0002B0, "Member 'UMapActorComponent::IconText' has a wrong offset!");
static_assert(offsetof(UMapActorComponent, IconTextColor) == 0x0002C8, "Member 'UMapActorComponent::IconTextColor' has a wrong offset!");
static_assert(offsetof(UMapActorComponent, IconBrush) == 0x0002E0, "Member 'UMapActorComponent::IconBrush' has a wrong offset!");
static_assert(offsetof(UMapActorComponent, IconColor) == 0x0003B0, "Member 'UMapActorComponent::IconColor' has a wrong offset!");
static_assert(offsetof(UMapActorComponent, RotationOffset) == 0x0003C4, "Member 'UMapActorComponent::RotationOffset' has a wrong offset!");
static_assert(offsetof(UMapActorComponent, bAddedToMap) == 0x0003C8, "Member 'UMapActorComponent::bAddedToMap' has a wrong offset!");
static_assert(offsetof(UMapActorComponent, MapIconWidget) == 0x0003D0, "Member 'UMapActorComponent::MapIconWidget' has a wrong offset!");

// Class ReadyOrNot.MapActorWidget
// 0x0050 (0x0338 - 0x02E8)
class UMapActorWidget : public UBaseWidget
{
public:
	class UTextBlock*                             MapActor_Text;                                     // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 ActorToTrack;                                      // 0x02F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseActorRotation;                                 // 0x02F8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseLocation;                                      // 0x02F9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2FA[0x6];                                      // 0x02FA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LocationToTrack;                                   // 0x0300(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RotationOffset;                                    // 0x0318(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MapSize;                                           // 0x031C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MapTextureSize;                                    // 0x0320(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_324[0x4];                                      // 0x0324(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              MapOrigin;                                         // 0x0328(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void InitializeWidget(class AActor* InActorToTrack, bool bInUseActorRotation, bool bInUseLocation, const struct FVector& InLocationToTrack, float InRotationOffset);
	void SetMapActorText(const class FText& InText);
	void SetMapActorTextColor(const struct FLinearColor& InTextColor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapActorWidget">();
	}
	static class UMapActorWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapActorWidget>();
	}
};
static_assert(alignof(UMapActorWidget) == 0x000008, "Wrong alignment on UMapActorWidget");
static_assert(sizeof(UMapActorWidget) == 0x000338, "Wrong size on UMapActorWidget");
static_assert(offsetof(UMapActorWidget, MapActor_Text) == 0x0002E8, "Member 'UMapActorWidget::MapActor_Text' has a wrong offset!");
static_assert(offsetof(UMapActorWidget, ActorToTrack) == 0x0002F0, "Member 'UMapActorWidget::ActorToTrack' has a wrong offset!");
static_assert(offsetof(UMapActorWidget, bUseActorRotation) == 0x0002F8, "Member 'UMapActorWidget::bUseActorRotation' has a wrong offset!");
static_assert(offsetof(UMapActorWidget, bUseLocation) == 0x0002F9, "Member 'UMapActorWidget::bUseLocation' has a wrong offset!");
static_assert(offsetof(UMapActorWidget, LocationToTrack) == 0x000300, "Member 'UMapActorWidget::LocationToTrack' has a wrong offset!");
static_assert(offsetof(UMapActorWidget, RotationOffset) == 0x000318, "Member 'UMapActorWidget::RotationOffset' has a wrong offset!");
static_assert(offsetof(UMapActorWidget, MapSize) == 0x00031C, "Member 'UMapActorWidget::MapSize' has a wrong offset!");
static_assert(offsetof(UMapActorWidget, MapTextureSize) == 0x000320, "Member 'UMapActorWidget::MapTextureSize' has a wrong offset!");
static_assert(offsetof(UMapActorWidget, MapOrigin) == 0x000328, "Member 'UMapActorWidget::MapOrigin' has a wrong offset!");

// Class ReadyOrNot.MapActorIconWidget
// 0x0010 (0x0348 - 0x0338)
class UMapActorIconWidget final : public UMapActorWidget
{
public:
	class UImage*                                 Icon_Image;                                        // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Icon_Image_BG;                                     // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetIconBrushStyle(const struct FSlateBrush& InIconBrush, const struct FLinearColor& InIconColor);
	void SetIconColor(const struct FLinearColor& InIconColor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapActorIconWidget">();
	}
	static class UMapActorIconWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapActorIconWidget>();
	}
};
static_assert(alignof(UMapActorIconWidget) == 0x000008, "Wrong alignment on UMapActorIconWidget");
static_assert(sizeof(UMapActorIconWidget) == 0x000348, "Wrong size on UMapActorIconWidget");
static_assert(offsetof(UMapActorIconWidget, Icon_Image) == 0x000338, "Member 'UMapActorIconWidget::Icon_Image' has a wrong offset!");
static_assert(offsetof(UMapActorIconWidget, Icon_Image_BG) == 0x000340, "Member 'UMapActorIconWidget::Icon_Image_BG' has a wrong offset!");

// Class ReadyOrNot.ReadyOrNotVoipSettings
// 0x0010 (0x0048 - 0x0038)
class UReadyOrNotVoipSettings final : public UDeveloperSettings
{
public:
	int32                                         AudibleDistance;                                   // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ConversationalDistance;                            // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeIntensityByDistance;                           // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FadeModel;                                         // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotVoipSettings">();
	}
	static class UReadyOrNotVoipSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotVoipSettings>();
	}
};
static_assert(alignof(UReadyOrNotVoipSettings) == 0x000008, "Wrong alignment on UReadyOrNotVoipSettings");
static_assert(sizeof(UReadyOrNotVoipSettings) == 0x000048, "Wrong size on UReadyOrNotVoipSettings");
static_assert(offsetof(UReadyOrNotVoipSettings, AudibleDistance) == 0x000038, "Member 'UReadyOrNotVoipSettings::AudibleDistance' has a wrong offset!");
static_assert(offsetof(UReadyOrNotVoipSettings, ConversationalDistance) == 0x00003C, "Member 'UReadyOrNotVoipSettings::ConversationalDistance' has a wrong offset!");
static_assert(offsetof(UReadyOrNotVoipSettings, FadeIntensityByDistance) == 0x000040, "Member 'UReadyOrNotVoipSettings::FadeIntensityByDistance' has a wrong offset!");
static_assert(offsetof(UReadyOrNotVoipSettings, FadeModel) == 0x000044, "Member 'UReadyOrNotVoipSettings::FadeModel' has a wrong offset!");

// Class ReadyOrNot.Referendum
// 0x0088 (0x0320 - 0x0298)
class AReferendum : public AActor
{
public:
	class FText                                   ReferendumName;                                    // 0x0298(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   ReferendumDescription;                             // 0x02B0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         ReferendumTime;                                    // 0x02C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReferendumHoldingTime;                             // 0x02CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         YesVotes;                                          // 0x02D0(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NoVotes;                                           // 0x02D4(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReferendumTimeRemaining;                           // 0x02D8(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReferendumHoldingTimeRemaining;                    // 0x02DC(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReferendumRunning;                                // 0x02E0(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReferendumWaitingToTakeEffect;                    // 0x02E1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E2[0x6];                                      // 0x02E2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class AReadyOrNotPlayerState*                 ReferendumCaller;                                  // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AReadyOrNotPlayerController*>    YesVoters;                                         // 0x02F0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class AReadyOrNotPlayerController*>    NoVoters;                                          // 0x0300(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class AReadyOrNotPlayerController*>    EligibleVoters;                                    // 0x0310(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	void CastedNoVote(class AReadyOrNotPlayerController* Voter);
	void CastedYesVote(class AReadyOrNotPlayerController* Voter);
	class FText GetHudDescription();
	void Multicast_AnnounceNoVote(class AReadyOrNotPlayerState* Voter);
	void Multicast_AnnounceVoteFailed();
	void Multicast_AnnounceVotePassed();
	void Multicast_AnnounceVoteStarted(class AReadyOrNotPlayerState* CallingVoter);
	void Multicast_AnnounceYesVote(class AReadyOrNotPlayerState* Voter);
	void OnAnnounceNoVote(class AReadyOrNotPlayerState* Voter);
	void OnAnnounceVoteFailed();
	void OnAnnounceVotePassed();
	void OnAnnounceVoteStarted(class AReadyOrNotPlayerState* CallingVoter);
	void OnAnnounceYesVote(class AReadyOrNotPlayerState* Voter);
	void OnReferendumPassed();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Referendum">();
	}
	static class AReferendum* GetDefaultObj()
	{
		return GetDefaultObjImpl<AReferendum>();
	}
};
static_assert(alignof(AReferendum) == 0x000008, "Wrong alignment on AReferendum");
static_assert(sizeof(AReferendum) == 0x000320, "Wrong size on AReferendum");
static_assert(offsetof(AReferendum, ReferendumName) == 0x000298, "Member 'AReferendum::ReferendumName' has a wrong offset!");
static_assert(offsetof(AReferendum, ReferendumDescription) == 0x0002B0, "Member 'AReferendum::ReferendumDescription' has a wrong offset!");
static_assert(offsetof(AReferendum, ReferendumTime) == 0x0002C8, "Member 'AReferendum::ReferendumTime' has a wrong offset!");
static_assert(offsetof(AReferendum, ReferendumHoldingTime) == 0x0002CC, "Member 'AReferendum::ReferendumHoldingTime' has a wrong offset!");
static_assert(offsetof(AReferendum, YesVotes) == 0x0002D0, "Member 'AReferendum::YesVotes' has a wrong offset!");
static_assert(offsetof(AReferendum, NoVotes) == 0x0002D4, "Member 'AReferendum::NoVotes' has a wrong offset!");
static_assert(offsetof(AReferendum, ReferendumTimeRemaining) == 0x0002D8, "Member 'AReferendum::ReferendumTimeRemaining' has a wrong offset!");
static_assert(offsetof(AReferendum, ReferendumHoldingTimeRemaining) == 0x0002DC, "Member 'AReferendum::ReferendumHoldingTimeRemaining' has a wrong offset!");
static_assert(offsetof(AReferendum, bReferendumRunning) == 0x0002E0, "Member 'AReferendum::bReferendumRunning' has a wrong offset!");
static_assert(offsetof(AReferendum, bReferendumWaitingToTakeEffect) == 0x0002E1, "Member 'AReferendum::bReferendumWaitingToTakeEffect' has a wrong offset!");
static_assert(offsetof(AReferendum, ReferendumCaller) == 0x0002E8, "Member 'AReferendum::ReferendumCaller' has a wrong offset!");
static_assert(offsetof(AReferendum, YesVoters) == 0x0002F0, "Member 'AReferendum::YesVoters' has a wrong offset!");
static_assert(offsetof(AReferendum, NoVoters) == 0x000300, "Member 'AReferendum::NoVoters' has a wrong offset!");
static_assert(offsetof(AReferendum, EligibleVoters) == 0x000310, "Member 'AReferendum::EligibleVoters' has a wrong offset!");

// Class ReadyOrNot.MapReferendum
// 0x0010 (0x0330 - 0x0320)
class AMapReferendum final : public AReferendum
{
public:
	class FString                                 MapURL;                                            // 0x0320(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapReferendum">();
	}
	static class AMapReferendum* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMapReferendum>();
	}
};
static_assert(alignof(AMapReferendum) == 0x000008, "Wrong alignment on AMapReferendum");
static_assert(sizeof(AMapReferendum) == 0x000330, "Wrong size on AMapReferendum");
static_assert(offsetof(AMapReferendum, MapURL) == 0x000320, "Member 'AMapReferendum::MapURL' has a wrong offset!");

// Class ReadyOrNot.MapStatisticsSystem
// 0x0090 (0x0328 - 0x0298)
class AMapStatisticsSystem final : public AInfo
{
public:
	uint8                                         Pad_298[0xC];                                      // 0x0298(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  GameId;                                            // 0x02A4(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B4[0x14];                                     // 0x02B4(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, uint8>                    ActorIdMap;                                        // 0x02C8(0x0050)(NativeAccessSpecifierPrivate)
	TArray<struct FAnalyticsStatus>               Statuses;                                          // 0x0318(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void EndLevel();
	void StartRecording(const class FString& InLevelName, const class FString& InGameMode);

	struct FGuid GetGameId() const;
	class FString GetRecordingStatus() const;
	bool IsRecording() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapStatisticsSystem">();
	}
	static class AMapStatisticsSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMapStatisticsSystem>();
	}
};
static_assert(alignof(AMapStatisticsSystem) == 0x000008, "Wrong alignment on AMapStatisticsSystem");
static_assert(sizeof(AMapStatisticsSystem) == 0x000328, "Wrong size on AMapStatisticsSystem");
static_assert(offsetof(AMapStatisticsSystem, GameId) == 0x0002A4, "Member 'AMapStatisticsSystem::GameId' has a wrong offset!");
static_assert(offsetof(AMapStatisticsSystem, ActorIdMap) == 0x0002C8, "Member 'AMapStatisticsSystem::ActorIdMap' has a wrong offset!");
static_assert(offsetof(AMapStatisticsSystem, Statuses) == 0x000318, "Member 'AMapStatisticsSystem::Statuses' has a wrong offset!");

// Class ReadyOrNot.MatchStatusCardWidget
// 0x0010 (0x02F8 - 0x02E8)
class UMatchStatusCardWidget final : public UBaseWidget
{
public:
	class UMatchTimeRemainingWidget*              MatchTimeRemaining;                                // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurrentMatchRoundWidget*               CurrentMatchRound;                                 // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchStatusCardWidget">();
	}
	static class UMatchStatusCardWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchStatusCardWidget>();
	}
};
static_assert(alignof(UMatchStatusCardWidget) == 0x000008, "Wrong alignment on UMatchStatusCardWidget");
static_assert(sizeof(UMatchStatusCardWidget) == 0x0002F8, "Wrong size on UMatchStatusCardWidget");
static_assert(offsetof(UMatchStatusCardWidget, MatchTimeRemaining) == 0x0002E8, "Member 'UMatchStatusCardWidget::MatchTimeRemaining' has a wrong offset!");
static_assert(offsetof(UMatchStatusCardWidget, CurrentMatchRound) == 0x0002F0, "Member 'UMatchStatusCardWidget::CurrentMatchRound' has a wrong offset!");

// Class ReadyOrNot.ReadyOrNotGauntletTestController
// 0x0010 (0x0040 - 0x0030)
class UReadyOrNotGauntletTestController final : public UGauntletTestController
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void StartTesting();
	void StopProfiling();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotGauntletTestController">();
	}
	static class UReadyOrNotGauntletTestController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotGauntletTestController>();
	}
};
static_assert(alignof(UReadyOrNotGauntletTestController) == 0x000008, "Wrong alignment on UReadyOrNotGauntletTestController");
static_assert(sizeof(UReadyOrNotGauntletTestController) == 0x000040, "Wrong size on UReadyOrNotGauntletTestController");

// Class ReadyOrNot.MatchTimeRemainingWidget
// 0x0010 (0x02F8 - 0x02E8)
class UMatchTimeRemainingWidget final : public UBaseWidget
{
public:
	class UTextBlock*                             MatchTimeRemaining_Text;                           // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RoundTimeRemaining;                                // 0x02F0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F4[0x4];                                      // 0x02F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchTimeRemainingWidget">();
	}
	static class UMatchTimeRemainingWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchTimeRemainingWidget>();
	}
};
static_assert(alignof(UMatchTimeRemainingWidget) == 0x000008, "Wrong alignment on UMatchTimeRemainingWidget");
static_assert(sizeof(UMatchTimeRemainingWidget) == 0x0002F8, "Wrong size on UMatchTimeRemainingWidget");
static_assert(offsetof(UMatchTimeRemainingWidget, MatchTimeRemaining_Text) == 0x0002E8, "Member 'UMatchTimeRemainingWidget::MatchTimeRemaining_Text' has a wrong offset!");
static_assert(offsetof(UMatchTimeRemainingWidget, RoundTimeRemaining) == 0x0002F0, "Member 'UMatchTimeRemainingWidget::RoundTimeRemaining' has a wrong offset!");

// Class ReadyOrNot.Meleeable
// 0x0000 (0x0000 - 0x0000)
class IMeleeable final
{
public:
	void OnMelee(class AReadyOrNotCharacter* Attacker, const struct FHitResult& Hit);

	class UParticleSystem* GetMeleeImpactParticle() const;
	class UFMODEvent* GetMeleeImpactSound() const;
	bool ShouldPlayMeleeEffectsLocally() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Meleeable">();
	}
	static class IMeleeable* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMeleeable>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IMeleeable) == 0x000001, "Wrong alignment on IMeleeable");
static_assert(sizeof(IMeleeable) == 0x000001, "Wrong size on IMeleeable");

// Class ReadyOrNot.MeleeWeapon
// 0x0010 (0x12C0 - 0x12B0)
class AMeleeWeapon : public ABaseWeapon
{
public:
	class FString                                 MeleeMontage;                                      // 0x12A8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyBleed;                                       // 0x12B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12B9[0x3];                                     // 0x12B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MeleeDamage;                                       // 0x12BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeleeWeapon">();
	}
	static class AMeleeWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMeleeWeapon>();
	}
};
static_assert(alignof(AMeleeWeapon) == 0x000010, "Wrong alignment on AMeleeWeapon");
static_assert(sizeof(AMeleeWeapon) == 0x0012C0, "Wrong size on AMeleeWeapon");
static_assert(offsetof(AMeleeWeapon, MeleeMontage) == 0x0012A8, "Member 'AMeleeWeapon::MeleeMontage' has a wrong offset!");
static_assert(offsetof(AMeleeWeapon, bApplyBleed) == 0x0012B8, "Member 'AMeleeWeapon::bApplyBleed' has a wrong offset!");
static_assert(offsetof(AMeleeWeapon, MeleeDamage) == 0x0012BC, "Member 'AMeleeWeapon::MeleeDamage' has a wrong offset!");

// Class ReadyOrNot.MemorialViewer
// 0x0020 (0x02B8 - 0x0298)
class AMemorialViewer final : public AActor
{
public:
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        RootSceneComponent;                                // 0x02A0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInteractableComponent*                 InteractableComponent;                             // 0x02A8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUserWidget*                            Widget;                                            // 0x02B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MemorialViewer">();
	}
	static class AMemorialViewer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMemorialViewer>();
	}
};
static_assert(alignof(AMemorialViewer) == 0x000008, "Wrong alignment on AMemorialViewer");
static_assert(sizeof(AMemorialViewer) == 0x0002B8, "Wrong size on AMemorialViewer");
static_assert(offsetof(AMemorialViewer, RootSceneComponent) == 0x0002A0, "Member 'AMemorialViewer::RootSceneComponent' has a wrong offset!");
static_assert(offsetof(AMemorialViewer, InteractableComponent) == 0x0002A8, "Member 'AMemorialViewer::InteractableComponent' has a wrong offset!");
static_assert(offsetof(AMemorialViewer, Widget) == 0x0002B0, "Member 'AMemorialViewer::Widget' has a wrong offset!");

// Class ReadyOrNot.ReadyOrNotInputModifierAimInversion
// 0x0000 (0x0028 - 0x0028)
class UReadyOrNotInputModifierAimInversion final : public UInputModifier
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotInputModifierAimInversion">();
	}
	static class UReadyOrNotInputModifierAimInversion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotInputModifierAimInversion>();
	}
};
static_assert(alignof(UReadyOrNotInputModifierAimInversion) == 0x000008, "Wrong alignment on UReadyOrNotInputModifierAimInversion");
static_assert(sizeof(UReadyOrNotInputModifierAimInversion) == 0x000028, "Wrong size on UReadyOrNotInputModifierAimInversion");

// Class ReadyOrNot.MemorialWidget
// 0x0010 (0x0420 - 0x0410)
class UMemorialWidget : public UCommonActivatableWidget
{
public:
	TArray<class URosterCharacter*>               MemorialCharacters;                                // 0x0410(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	void CloseMemorialWidget();
	TArray<class URosterCharacter*> GetMemorialCharacters();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MemorialWidget">();
	}
	static class UMemorialWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMemorialWidget>();
	}
};
static_assert(alignof(UMemorialWidget) == 0x000008, "Wrong alignment on UMemorialWidget");
static_assert(sizeof(UMemorialWidget) == 0x000420, "Wrong size on UMemorialWidget");
static_assert(offsetof(UMemorialWidget, MemorialCharacters) == 0x000410, "Member 'UMemorialWidget::MemorialCharacters' has a wrong offset!");

// Class ReadyOrNot.MessageDisplayBox
// 0x0028 (0x0438 - 0x0410)
class UMessageDisplayBox : public UCommonActivatableWidget
{
public:
	class FString                                 MessageTxt;                                        // 0x0410(0x0010)(BlueprintVisible, ZeroConstructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ButtonTxt;                                         // 0x0420(0x0010)(BlueprintVisible, ZeroConstructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldQuitOnButtonPress;                          // 0x0430(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_431[0x7];                                      // 0x0431(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MessageDisplayBox">();
	}
	static class UMessageDisplayBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMessageDisplayBox>();
	}
};
static_assert(alignof(UMessageDisplayBox) == 0x000008, "Wrong alignment on UMessageDisplayBox");
static_assert(sizeof(UMessageDisplayBox) == 0x000438, "Wrong size on UMessageDisplayBox");
static_assert(offsetof(UMessageDisplayBox, MessageTxt) == 0x000410, "Member 'UMessageDisplayBox::MessageTxt' has a wrong offset!");
static_assert(offsetof(UMessageDisplayBox, ButtonTxt) == 0x000420, "Member 'UMessageDisplayBox::ButtonTxt' has a wrong offset!");
static_assert(offsetof(UMessageDisplayBox, bShouldQuitOnButtonPress) == 0x000430, "Member 'UMessageDisplayBox::bShouldQuitOnButtonPress' has a wrong offset!");

// Class ReadyOrNot.MessagePromptActor
// 0x0050 (0x02E8 - 0x0298)
class AMessagePromptActor final : public AActor
{
public:
	class FString                                 MessageMapID;                                      // 0x0298(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsBigPopUp;                                       // 0x02A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasDisplayedMessage;                              // 0x02A9(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AA[0x6];                                      // 0x02AA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   MessageTitle;                                      // 0x02B0(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<class FText>                           MessageContent;                                    // 0x02C8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FMessagePromptContent>          MessageActions;                                    // 0x02D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void GenerateMessageContent();
	void HideMessagePopUp();
	void ShowMessageThroughPopUp();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MessagePromptActor">();
	}
	static class AMessagePromptActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMessagePromptActor>();
	}
};
static_assert(alignof(AMessagePromptActor) == 0x000008, "Wrong alignment on AMessagePromptActor");
static_assert(sizeof(AMessagePromptActor) == 0x0002E8, "Wrong size on AMessagePromptActor");
static_assert(offsetof(AMessagePromptActor, MessageMapID) == 0x000298, "Member 'AMessagePromptActor::MessageMapID' has a wrong offset!");
static_assert(offsetof(AMessagePromptActor, bIsBigPopUp) == 0x0002A8, "Member 'AMessagePromptActor::bIsBigPopUp' has a wrong offset!");
static_assert(offsetof(AMessagePromptActor, bHasDisplayedMessage) == 0x0002A9, "Member 'AMessagePromptActor::bHasDisplayedMessage' has a wrong offset!");
static_assert(offsetof(AMessagePromptActor, MessageTitle) == 0x0002B0, "Member 'AMessagePromptActor::MessageTitle' has a wrong offset!");
static_assert(offsetof(AMessagePromptActor, MessageContent) == 0x0002C8, "Member 'AMessagePromptActor::MessageContent' has a wrong offset!");
static_assert(offsetof(AMessagePromptActor, MessageActions) == 0x0002D8, "Member 'AMessagePromptActor::MessageActions' has a wrong offset!");

// Class ReadyOrNot.MetaGameProfile
// 0x0108 (0x03C8 - 0x02C0)
class UMetaGameProfile final : public UBaseProfile
{
public:
	int32                                         MetaGameVersion;                                   // 0x02C0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C4[0x4];                                      // 0x02C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LastCampaignSave;                                  // 0x02C8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalLobbyLogins;                                  // 0x02D8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasCompletedTutorial;                             // 0x02DC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasShownQuickPlayPopup;                           // 0x02DD(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasShownCommanderPopup;                           // 0x02DE(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DF[0x1];                                      // 0x02DF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EGameVersionRestriction>               AcknowledgedGameVersions;                          // 0x02E0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         CompletedLevels;                                   // 0x02F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class FString>                         CompletedMultiplayerLevels;                        // 0x0300(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TSet<class FName>                             ProgressionTags;                                   // 0x0310(0x0050)(NativeAccessSpecifierPrivate)
	struct FMetaGameProfileTemporaryData          TemporaryData;                                     // 0x0360(0x0068)(NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MetaGameProfile">();
	}
	static class UMetaGameProfile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMetaGameProfile>();
	}
};
static_assert(alignof(UMetaGameProfile) == 0x000008, "Wrong alignment on UMetaGameProfile");
static_assert(sizeof(UMetaGameProfile) == 0x0003C8, "Wrong size on UMetaGameProfile");
static_assert(offsetof(UMetaGameProfile, MetaGameVersion) == 0x0002C0, "Member 'UMetaGameProfile::MetaGameVersion' has a wrong offset!");
static_assert(offsetof(UMetaGameProfile, LastCampaignSave) == 0x0002C8, "Member 'UMetaGameProfile::LastCampaignSave' has a wrong offset!");
static_assert(offsetof(UMetaGameProfile, TotalLobbyLogins) == 0x0002D8, "Member 'UMetaGameProfile::TotalLobbyLogins' has a wrong offset!");
static_assert(offsetof(UMetaGameProfile, bHasCompletedTutorial) == 0x0002DC, "Member 'UMetaGameProfile::bHasCompletedTutorial' has a wrong offset!");
static_assert(offsetof(UMetaGameProfile, bHasShownQuickPlayPopup) == 0x0002DD, "Member 'UMetaGameProfile::bHasShownQuickPlayPopup' has a wrong offset!");
static_assert(offsetof(UMetaGameProfile, bHasShownCommanderPopup) == 0x0002DE, "Member 'UMetaGameProfile::bHasShownCommanderPopup' has a wrong offset!");
static_assert(offsetof(UMetaGameProfile, AcknowledgedGameVersions) == 0x0002E0, "Member 'UMetaGameProfile::AcknowledgedGameVersions' has a wrong offset!");
static_assert(offsetof(UMetaGameProfile, CompletedLevels) == 0x0002F0, "Member 'UMetaGameProfile::CompletedLevels' has a wrong offset!");
static_assert(offsetof(UMetaGameProfile, CompletedMultiplayerLevels) == 0x000300, "Member 'UMetaGameProfile::CompletedMultiplayerLevels' has a wrong offset!");
static_assert(offsetof(UMetaGameProfile, ProgressionTags) == 0x000310, "Member 'UMetaGameProfile::ProgressionTags' has a wrong offset!");
static_assert(offsetof(UMetaGameProfile, TemporaryData) == 0x000360, "Member 'UMetaGameProfile::TemporaryData' has a wrong offset!");

// Class ReadyOrNot.ReadyOrNotPlayerController
// 0x04D8 (0x0D30 - 0x0858)
class AReadyOrNotPlayerController : public APlayerController
{
public:
	uint8                                         Pad_858[0x8];                                      // 0x0858(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UProgressionComponent*                  ProgressionComp;                                   // 0x0860(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_868[0x4];                                      // 0x0868(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ServerSideChecksum;                                // 0x086C(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_870[0xC];                                      // 0x0870(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bShouldShowMouseCursor;                            // 0x087C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_87D[0x3];                                      // 0x087D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class APawn* PossessedPawn)> OnPawnPossessed;                      // 0x0880(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnExitSettingsMenu;                                // 0x0890(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool bIsOutOfBounds)> OnOutOfBoundsChanged;                        // 0x08A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnPreClientTravel;                                 // 0x08B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C0[0x20];                                     // 0x08C0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RespawnTimeLeft;                                   // 0x08E0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8E4[0x4];                                      // 0x08E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserWidget*                            TabMenuWidget;                                     // 0x08E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UUserWidget>                TabMenuWidgetClass;                                // 0x08F0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUserWidget*                            SubtitlesWidget;                                   // 0x08F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_900[0x8];                                      // 0x0900(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ACameraActor*                           SpectateCamera;                                    // 0x0908(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ULevelStreaming*>                StreamingLevels;                                   // 0x0910(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	class UJoinSessionCallbackProxyAdvanced*      JoinSession;                                       // 0x0920(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 StreamingLevel;                                    // 0x0928(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StreamingOptions;                                  // 0x0938(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_948[0x38];                                     // 0x0948(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         ReplicatedMapList;                                 // 0x0980(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const TArray<class FString>& MapList)> OnMapListReplicated;        // 0x0990(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         VoteAntiSpamDebouncer;                             // 0x09A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9A4[0x4];                                      // 0x09A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVoteData                              MyVoteData;                                        // 0x09A8(0x0030)(BlueprintVisible, BlueprintReadOnly, Net, NativeAccessSpecifierPublic)
	bool                                          bStatsProfiledQueued;                              // 0x09D8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9D9[0x7];                                      // 0x09D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UUserWidget>>        ProtectedWidgetClasses;                            // 0x09E0(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_9F0[0x18];                                     // 0x09F0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bCanOpenOptionsMenu;                               // 0x0A08(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A09[0x7];                                      // 0x0A09(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, class UUserWidget*>       CreatedWidgetMap;                                  // 0x0A10(0x0050)(ExportObject, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	class USpectatorCharacterHUD*                 SpectatorHUDWidget;                                // 0x0A60(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASpectatorPawn*                         NormalSpectatorPawn;                               // 0x0A68(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASpectatePawn*                          DeadSpectatorPawn;                                 // 0x0A70(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A78[0x10];                                     // 0x0A78(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ASwatAutomationManager*                 SwatAutomationManager;                             // 0x0A88(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class AActor*, float>                    DebugActorList;                                    // 0x0A90(0x0050)(NativeAccessSpecifierPublic)
	uint8                                         Pad_AE0[0x30];                                     // 0x0AE0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnHudWidgetsClearedComplete;                       // 0x0B10(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnLoadingScreenCleared;                            // 0x0B20(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          TestCube;                                          // 0x0B30(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     TestMaterial;                                      // 0x0B38(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B40[0x8];                                      // 0x0B40(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bStartedCoopAsSpectator;                           // 0x0B48(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B49[0x7];                                      // 0x0B49(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ACharacter*                             LastKilledCharacter;                               // 0x0B50(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B58[0x8];                                      // 0x0B58(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUASAimAssistConfigDataAsset*           AimAssistConfig_High;                              // 0x0B60(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUASAimAssistConfigDataAsset*           AimAssistConfigADS_High;                           // 0x0B68(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUASAimAssistConfigDataAsset*           AimAssistConfig_Medium;                            // 0x0B70(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUASAimAssistConfigDataAsset*           AimAssistConfigADS_Medium;                         // 0x0B78(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUASAimAssistConfigDataAsset*           AimAssistConfig_Low;                               // 0x0B80(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUASAimAssistConfigDataAsset*           AimAssistConfigADS_Low;                            // 0x0B88(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUASAimAssistConfigDataAsset*           AimAssistConfig_Off;                               // 0x0B90(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUASAimAssistConfigDataAsset*           AimAssistConfigADS_Off;                            // 0x0B98(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsReplaySpectator;                                // 0x0BA0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BA1[0x3F];                                     // 0x0BA1(0x003F)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(bool bRTXOn)>   OnRTXDMOChanged;                                   // 0x0BE0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FRChatMessage>                  ChatMessages;                                      // 0x0BF0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         AimAssistPitch;                                    // 0x0C00(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimAssistYaw;                                      // 0x0C04(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UInputMappingContext>    InputMapping;                                      // 0x0C08(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C30[0x28];                                     // 0x0C30(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, struct FProjectileData>           ActiveProjectiles;                                 // 0x0C58(0x0050)(NativeAccessSpecifierPublic)
	uint8                                         Pad_CA8[0x8];                                      // 0x0CA8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AReadyOrNotPlayerController* PlayerController, bool bReady)> OnPlayerReadyChange; // 0x0CB0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_CC0[0x18];                                     // 0x0CC0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UUASAimAssistConfigDataAsset*           CurrentAimAssistConfig;                            // 0x0CD8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_CE0[0x8];                                      // 0x0CE0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AimAssistIntensity;                                // 0x0CE8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bMotionControlsEnabled;                            // 0x0CF8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_CF9[0xF];                                      // 0x0CF9(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	class UForceFeedbackEffect*                   LightBarDamageTakenEffect;                         // 0x0D08(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPauseMenu_Wrapper*                     PauseMenu;                                         // 0x0D10(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D18[0x18];                                     // 0x0D18(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static float GetRespawnTimeRemaining();

	void AbortCover();
	void AcknowledgeVote(const struct FVoteData& CurrentVoteData);
	void AIEquipPrimary();
	void AIEquipSecondary();
	void AIHide();
	void AIStopHide();
	void ApplyCharacterSkin(const class FString& SkinName);
	void ApplyWeaponSkin(const class FString& SkinName);
	void ArrestAll(ETeamType TargetTeam);
	void ArrestAllButOne(ETeamType TargetTeam);
	void ArrestAllButOneCivilian();
	void ArrestAllButOneSuspect();
	void ArrestAllCivilians();
	void ArrestAllSuspects();
	void ArrestOne();
	void BeginVote(const class FString& Reason, const class FString& Question, bool bCanVoteNo);
	void BP_ClientWasKicked(const class FText& KickReason);
	void BP_HandleMessage(const struct FRChatMessage& ChatMessage);
	void BP_ReturnToMenu(const class FText& ReturnReason);
	bool CanDisableDeployable(int32 DeployableNum);
	bool CanDisablePersonnel(int32 PersonnelNum);
	bool CanEnableDeployable(int32 DeployableNum);
	bool CanEnablePersonnel(int32 PersonnelNum, int32 MapPointNum);
	bool CanSetDepotTo(int32 NewDepot, bool bSameDepot);
	bool CanSetSpawn(ETeamType Team, ESelectedSpawn NewSpawnPoint, bool bSameSpawn);
	void ChangeInputMode(bool bGameMode, bool bMouseCursorEnabled, class UWidget* Widget);
	void Client_ClearHUDWidgets();
	void Client_CreateLoadingScreen(const class FString& Map, const class FString& Mode, const class FString& SessionName, bool bIsSeamlessTravel);
	void Client_CreateSpectatorWidget();
	void Client_CreateWidget(const class FString& WidgetName, bool bForceAddToWidgetStack, bool bIsEscapeKey);
	void Client_DisableUIMouse();
	void Client_GetStats();
	void Client_HideHUDWidgets();
	void Client_LocalReadyStateChanged(bool bReady);
	void Client_OnProjectileValidation(int32 ProjectileSeed, EServerValidationState Validation);
	void Client_PostLogin();
	void Client_RemoveWidget(TSubclassOf<class UUserWidget> Widget);
	void Client_SetControlRotation(const struct FRotator& NewControlRotation);
	void Client_SetViewTargetWithBlend(class APawn* NewViewTarget);
	void Client_UpdateWorldTime(float ServerTime, float SentClientTime);
	void ClientEndOnlineGame();
	void ClientJoinVoice(const class FString& OnlineSessionId, const int32& TeamNum);
	void ClientSetNetSpeed(int32 NewNetSpeed);
	void ClientSetSpectatorCamera(const struct FVector& CameraLocation, const struct FRotator& CameraRotation);
	void ClientSpawned();
	void ClientStartOnlineGame();
	void ConsoleSetMaxPlayers(int32 MaxPlayers);
	class UUserWidget* CreateWidgetForPlayer(const class FString& WidgetName, bool bForceAddToWidgetStack, bool bIsEscapeKey);
	void DebugClientStartHostMigration();
	void DebugMigrateHost();
	void DeleteAnyNonMeshComponents();
	void DestroyAllActorsOfName(const class FString& Name_0);
	void DestroyAllAI();
	void DestroyAllDecals();
	void DestroyAllDynamicLights();
	void DestroyAllExceptClosestCharacter();
	void DestroyAllExceptClosestDoor();
	void DestroyAllItemMeshes();
	void DestroyAllItems();
	void DestroyAllLights();
	void DestroyAllSuspects();
	void DestroyAllWidgets();
	void DestroyAllWorldDynamicItems();
	void DestroyEverything();
	void DestroySwatAnimation();
	void DestroySwatControllers();
	void DestroySwatInventoryItems();
	void DestroySwatTeam();
	void DisableAllItemMaterials();
	void DisableAllItemTicks();
	void DisableAllMaterials();
	void DisableForceShowMouseCursor();
	void DisableSkeletalMeshShadowCasting();
	void DisableWeaponFovShader();
	void DisplayAllPlayingFMODEvents();
	void DownloadBlacklistHashes();
	void DrawBlockingVolumes();
	void DropAllSuspectWeapons();
	void EnableAimAssistConfig();
	void EnablePlayerInput();
	void EnableScopeAlignmentTool();
	void EnableWeaponFovShader();
	void EndVote();
	void Equip(const class FString& ItemName);
	void EquipAndDropEvidence();
	void EscapeMenu();
	void ExecuteLineTracePerfTest();
	void ExecuteSweepTraceMultiPerfTest();
	void ExecuteSweepTraceSinglePerfTest();
	void FlushDeadBodies();
	void FreeVIP();
	void GetNetworkConnectionStatus(float* AvgLag, int32* OutLostPackets, int32* InLostPackets, int32* OutLostPacketPrcnt, int32* InLostPacketPrcnt);
	class FString GetPasswordOnConnection();
	class FString GetPrefferredTeamUniqueNetIdOnConnection();
	TArray<class FString> GetReplicatedMapRotation();
	ETeamType GetTeamType();
	EVoteState GetVote();
	void GibAllComponents();
	void GiveSWATRam();
	void HideAllItemMeshes();
	void HideAllSmallItemMeshes();
	void HideAllWeaponAttachments();
	void HideHUD();
	void InternalSaveStats();
	bool IsCameraFading();
	bool IsConsoleTarget();
	void Kill(float Time);
	void KillAll(ETeamType TargetTeam);
	void KillAllCivilians();
	void KillAllSuspects();
	void KillSWATTeam();
	void KnockoutAllEnemies();
	void LockAchievement(const class FString& AchievementId);
	void LockAllAchievements();
	void MakeCrash();
	void Multicast_ForcePlanningRefresh();
	void Multicast_RemovePersonnelAtPoint(int32 PersonnelNum);
	void Multicast_SetPersonnelAtPoint(int32 PersonnelNum, int32 MapPointNum);
	void NotifyRespawnTime(float RespawnTime);
	void OnLevelOpen();
	void OnLocallyFiredProjectile(class ABulletProjectile* Projectile, int32 ProjectileIdentifier);
	void OnlyCastLocalPlayerDynamicShadow();
	void OnRep_Maplist();
	void OnSaveLoadout();
	void OnSessionJoinFailed();
	void OnSessionJoinSuccess();
	void OnStreamedLevelLoadedComplete();
	void OnStreamedLevelLoadedExecuteOpen();
	void OnStreamedLevelLoadedRemovingLoadingScreen();
	void OptimizeWorld();
	void PassMouseControlToValidWidget();
	void PlayAnimationFromLookupTable(const class FString& AnimationRowName);
	void PlayDamageTakenLightBarEffect();
	void PlayDeadAllEnemies();
	void PresentVoteResult(const struct FVoteData& VoteResult, int32 YesVotes, int32 NoVotes);
	void PrintAllSceneComponentWhoseOriginIsZero();
	void PrintGPUBrand();
	void PS5ActivityEnd(class FString* Activity, int32 Outcome);
	void PS5ActivitySetAvailable(class FString* Activity, bool bAvailable);
	void PS5ActivityStart(class FString* Activity);
	void PS5ResetAllActiveActivities();
	void ReadyUp();
	void ReadyUp_Failsafe();
	void ReleaseVIP();
	void RemoveCharacterSkin();
	void RemoveHUD();
	void RemoveWeaponSkin();
	bool RemoveWidgetFromStack(const class FString& WidgetName);
	void ReplicateMapListIfAdmin();
	void ReportAll(ETeamType Team);
	void ReportAllCivilians();
	void ReportAllInstancedStaticMeshes();
	void ReportAllSuspects();
	void RequestVoteInput(const struct FVoteData& CurrentVoteData);
	void ResetAI(float Range);
	void ResetDoorLockStateKnowledge();
	void ResetKeybinds();
	void RetrieveChatLog(TArray<struct FRChatMessage>* OutMessages);
	void RosterInstantFinishStatus();
	void SaveChatMessage(const struct FRChatMessage& Message);
	bool SaveFileToUserCloud(const class FString& FullPath);
	void SavePerformanceStats();
	void SendChatMessage(const struct FRChatMessage& ChatMessage);
	void Server_AddLine(const struct FPlanningLine& Line);
	void Server_AddMarker(const struct FPlanningMarker& Marker);
	void Server_AdminAddMapToRotation(const class FString& MapURL);
	void Server_AdminAddMapToRotationAtIndex(const class FString& MapURL, int32 Idx);
	void Server_AdminBanPlayer(class APlayerState* BanningPlayerState);
	void Server_AdminKickPlayer(class APlayerState* KickingPlayerState, const class FText& ReasonOveride);
	void Server_AdminNextMap();
	void Server_AdminRemoveMapFromRotation(const class FString& MapURL);
	void Server_AdminRemoveMapFromRotationByIndex(int32 Idx);
	void Server_AdminRestartServer();
	void Server_BecomeVIP();
	void Server_DisableDeployable(int32 DeployableNum);
	void Server_DisablePersonnel(int32 PersonnelNum);
	void Server_EnableDeployable(int32 DeployableNum);
	void Server_EnablePersonnel(int32 PersonnelNum, int32 MapPointNum);
	void Server_Equip(const class FString& ItemName);
	void Server_LoginAsAdmin(const class FString& Password);
	void Server_ReferendumVoteNo();
	void Server_ReferendumVoteYes();
	void Server_ReleaseVIP();
	void Server_RemoveLine(int32 ID);
	void Server_RemoveMarker(int32 ID);
	void Server_RequestLoadoutChange(const struct FSavedLoadout& Loadout);
	void Server_RequestWorldTime(float ClientTime);
	void Server_RespawnAsLobby(TSubclassOf<class ASpectatorPawn> Class_0, const struct FTransform& SpawnTransform);
	void Server_SendChatMessage(const struct FRChatMessage& ChatMessage);
	void Server_SetChecksum(int32 Checksum);
	void Server_SetDeployableDepot(int32 NewDepot);
	void Server_SetHasFinishedLoading();
	void Server_SetReadyState(bool bReady);
	void Server_SetSpawn(ETeamType SpawnTeam, ESelectedSpawn NewSpawnPoint);
	void Server_SetTeamType(ETeamType NewTeam);
	void Server_StartMapReferendum(TSubclassOf<class AMapReferendum> ReferendumClass, const class FString& MapURL);
	void Server_StartPlayerReferendum(TSubclassOf<class APlayerReferendum> ReferendumClass, class AReadyOrNotPlayerState* TargetPlayer);
	void Server_StartReferendum(TSubclassOf<class AReferendum> ReferendumClass);
	void Server_StartSpectating();
	void Server_StatFile(bool bStartStatFile);
	void Server_SwapPlayersTeam(class APlayerState* ps);
	void ServerStatFileStart();
	void ServerStatFileStop();
	void SetAimAssistIntensity(const class FString& NewAimAssistIntensity);
	void SetAllComponentsUseParentsBounds();
	void SetClubMusicMasterVolume(float Volume);
	void SetDualSenseMotionControlsEnabled(bool MotionControlsEnabled);
	void SetForceFeedbackIntensity(float ForceFeedbackIntensity);
	void SetHostMigrationComplete();
	void SetMousePosition(float LocationX, float LocationY);
	void SetPreferredTeamUniqueNetIdOnConnection(const class FString& UniqueID);
	void SetRosterStressValue(float Stress);
	void SetScorelimit(int32 Score);
	void SetServerPasswordOnConnection(const class FString& Password);
	void SetShouldShowMouseCursor(bool bShow);
	void SetTimelimit(float Time);
	void ShowCoopScoreChangeWidget(float ScoreChangeValue);
	void ShowHUD();
	void SkipTutorial();
	void SkipTutorialStep();
	void SoftWinCoop();
	void SpawnAI(const class FString& TableName, int32 Count);
	void SpawnAIAtLocation(const class FString& TableName, const struct FVector& Location, const struct FVector& MoveLocation);
	void SpawnBotsForGame(int32 BotCount);
	void SpawnRandomAI(int32 Count);
	void StartBleeding();
	void StartSpeaking();
	void StartSwatAutomation();
	void StopSpeaking();
	void StopSwatAutomation();
	void StopVoteInput();
	bool StreamInLevel(const class FString& NewLevel, const class FString& Options, class ULevelStreaming** OutStreamedLevel, const struct FLevelStreamOptions& LevelStreamOptions);
	bool StreamInSession(const struct FBlueprintSessionResult& SessionResult, bool bShouldCreateLoadingScreen);
	void SurrenderAll(ETeamType TargetTeam);
	void SurrenderAllCivilians();
	void SurrenderAllSuspects();
	void SwapAllItemSkeletalMeshesToCubes();
	void TakeDamageExec(float DamageAmount);
	void TeleportToNextRemainingAI();
	void TeleportUp();
	void TestMatchmakingServerCreateParty();
	void TestMatchmakingServerRefresh();
	void TestSendCrash();
	void ToggleDeployMenu();
	void ToggleGodModeOnEveryone();
	void ToggleRTXDMO();
	void TryCloseTablet(bool Unequip);
	void UnhideAllItemMeshes();
	void UnhideAllSmallItemMeshes();
	void UnhideAllWeaponAttachments();
	void UnlockAchievement(const class FString& AchievementId);
	void UnlockAllAchievements();
	void UpdateAchievementProgress(const class FString& ID, float Percent);
	void UpdateMouseCursorVisibility();
	void Vote(bool VoteYes);
	void WinCoop();

	bool IsOverlayHudVisible() const;
	void SecureAllEvidence() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotPlayerController">();
	}
	static class AReadyOrNotPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AReadyOrNotPlayerController>();
	}
};
static_assert(alignof(AReadyOrNotPlayerController) == 0x000008, "Wrong alignment on AReadyOrNotPlayerController");
static_assert(sizeof(AReadyOrNotPlayerController) == 0x000D30, "Wrong size on AReadyOrNotPlayerController");
static_assert(offsetof(AReadyOrNotPlayerController, ProgressionComp) == 0x000860, "Member 'AReadyOrNotPlayerController::ProgressionComp' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, ServerSideChecksum) == 0x00086C, "Member 'AReadyOrNotPlayerController::ServerSideChecksum' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, bShouldShowMouseCursor) == 0x00087C, "Member 'AReadyOrNotPlayerController::bShouldShowMouseCursor' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, OnPawnPossessed) == 0x000880, "Member 'AReadyOrNotPlayerController::OnPawnPossessed' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, OnExitSettingsMenu) == 0x000890, "Member 'AReadyOrNotPlayerController::OnExitSettingsMenu' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, OnOutOfBoundsChanged) == 0x0008A0, "Member 'AReadyOrNotPlayerController::OnOutOfBoundsChanged' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, OnPreClientTravel) == 0x0008B0, "Member 'AReadyOrNotPlayerController::OnPreClientTravel' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, RespawnTimeLeft) == 0x0008E0, "Member 'AReadyOrNotPlayerController::RespawnTimeLeft' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, TabMenuWidget) == 0x0008E8, "Member 'AReadyOrNotPlayerController::TabMenuWidget' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, TabMenuWidgetClass) == 0x0008F0, "Member 'AReadyOrNotPlayerController::TabMenuWidgetClass' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, SubtitlesWidget) == 0x0008F8, "Member 'AReadyOrNotPlayerController::SubtitlesWidget' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, SpectateCamera) == 0x000908, "Member 'AReadyOrNotPlayerController::SpectateCamera' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, StreamingLevels) == 0x000910, "Member 'AReadyOrNotPlayerController::StreamingLevels' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, JoinSession) == 0x000920, "Member 'AReadyOrNotPlayerController::JoinSession' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, StreamingLevel) == 0x000928, "Member 'AReadyOrNotPlayerController::StreamingLevel' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, StreamingOptions) == 0x000938, "Member 'AReadyOrNotPlayerController::StreamingOptions' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, ReplicatedMapList) == 0x000980, "Member 'AReadyOrNotPlayerController::ReplicatedMapList' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, OnMapListReplicated) == 0x000990, "Member 'AReadyOrNotPlayerController::OnMapListReplicated' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, VoteAntiSpamDebouncer) == 0x0009A0, "Member 'AReadyOrNotPlayerController::VoteAntiSpamDebouncer' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, MyVoteData) == 0x0009A8, "Member 'AReadyOrNotPlayerController::MyVoteData' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, bStatsProfiledQueued) == 0x0009D8, "Member 'AReadyOrNotPlayerController::bStatsProfiledQueued' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, ProtectedWidgetClasses) == 0x0009E0, "Member 'AReadyOrNotPlayerController::ProtectedWidgetClasses' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, bCanOpenOptionsMenu) == 0x000A08, "Member 'AReadyOrNotPlayerController::bCanOpenOptionsMenu' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, CreatedWidgetMap) == 0x000A10, "Member 'AReadyOrNotPlayerController::CreatedWidgetMap' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, SpectatorHUDWidget) == 0x000A60, "Member 'AReadyOrNotPlayerController::SpectatorHUDWidget' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, NormalSpectatorPawn) == 0x000A68, "Member 'AReadyOrNotPlayerController::NormalSpectatorPawn' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, DeadSpectatorPawn) == 0x000A70, "Member 'AReadyOrNotPlayerController::DeadSpectatorPawn' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, SwatAutomationManager) == 0x000A88, "Member 'AReadyOrNotPlayerController::SwatAutomationManager' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, DebugActorList) == 0x000A90, "Member 'AReadyOrNotPlayerController::DebugActorList' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, OnHudWidgetsClearedComplete) == 0x000B10, "Member 'AReadyOrNotPlayerController::OnHudWidgetsClearedComplete' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, OnLoadingScreenCleared) == 0x000B20, "Member 'AReadyOrNotPlayerController::OnLoadingScreenCleared' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, TestCube) == 0x000B30, "Member 'AReadyOrNotPlayerController::TestCube' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, TestMaterial) == 0x000B38, "Member 'AReadyOrNotPlayerController::TestMaterial' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, bStartedCoopAsSpectator) == 0x000B48, "Member 'AReadyOrNotPlayerController::bStartedCoopAsSpectator' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, LastKilledCharacter) == 0x000B50, "Member 'AReadyOrNotPlayerController::LastKilledCharacter' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, AimAssistConfig_High) == 0x000B60, "Member 'AReadyOrNotPlayerController::AimAssistConfig_High' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, AimAssistConfigADS_High) == 0x000B68, "Member 'AReadyOrNotPlayerController::AimAssistConfigADS_High' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, AimAssistConfig_Medium) == 0x000B70, "Member 'AReadyOrNotPlayerController::AimAssistConfig_Medium' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, AimAssistConfigADS_Medium) == 0x000B78, "Member 'AReadyOrNotPlayerController::AimAssistConfigADS_Medium' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, AimAssistConfig_Low) == 0x000B80, "Member 'AReadyOrNotPlayerController::AimAssistConfig_Low' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, AimAssistConfigADS_Low) == 0x000B88, "Member 'AReadyOrNotPlayerController::AimAssistConfigADS_Low' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, AimAssistConfig_Off) == 0x000B90, "Member 'AReadyOrNotPlayerController::AimAssistConfig_Off' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, AimAssistConfigADS_Off) == 0x000B98, "Member 'AReadyOrNotPlayerController::AimAssistConfigADS_Off' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, bIsReplaySpectator) == 0x000BA0, "Member 'AReadyOrNotPlayerController::bIsReplaySpectator' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, OnRTXDMOChanged) == 0x000BE0, "Member 'AReadyOrNotPlayerController::OnRTXDMOChanged' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, ChatMessages) == 0x000BF0, "Member 'AReadyOrNotPlayerController::ChatMessages' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, AimAssistPitch) == 0x000C00, "Member 'AReadyOrNotPlayerController::AimAssistPitch' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, AimAssistYaw) == 0x000C04, "Member 'AReadyOrNotPlayerController::AimAssistYaw' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, InputMapping) == 0x000C08, "Member 'AReadyOrNotPlayerController::InputMapping' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, ActiveProjectiles) == 0x000C58, "Member 'AReadyOrNotPlayerController::ActiveProjectiles' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, OnPlayerReadyChange) == 0x000CB0, "Member 'AReadyOrNotPlayerController::OnPlayerReadyChange' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, CurrentAimAssistConfig) == 0x000CD8, "Member 'AReadyOrNotPlayerController::CurrentAimAssistConfig' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, AimAssistIntensity) == 0x000CE8, "Member 'AReadyOrNotPlayerController::AimAssistIntensity' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, bMotionControlsEnabled) == 0x000CF8, "Member 'AReadyOrNotPlayerController::bMotionControlsEnabled' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, LightBarDamageTakenEffect) == 0x000D08, "Member 'AReadyOrNotPlayerController::LightBarDamageTakenEffect' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerController, PauseMenu) == 0x000D10, "Member 'AReadyOrNotPlayerController::PauseMenu' has a wrong offset!");

// Class ReadyOrNot.ReplayController
// 0x0108 (0x0E38 - 0x0D30)
class AReplayController : public AReadyOrNotPlayerController
{
public:
	uint8                                         Pad_D30[0x8];                                      // 0x0D30(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AReplaySplineActor*                     ReplaySplineActor;                                 // 0x0D38(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalSplineTime;                                   // 0x0D40(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFollowingSpline;                                // 0x0D44(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D45[0x3];                                      // 0x0D45(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DeltaSplineTime;                                   // 0x0D48(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESplineRotation                               SplineRotationType;                                // 0x0D4C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECameraState                                  CurrentCameraState;                                // 0x0D4D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4E[0x2];                                      // 0x0D4E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         SelectableActors;                                  // 0x0D50(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class AActor*                                 SelectedActor;                                     // 0x0D60(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SelectedActorIndex;                                // 0x0D68(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsReplayMenuOpen;                                 // 0x0D6C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D6D[0x3];                                      // 0x0D6D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UReplayControls*                        ReplayControls;                                    // 0x0D70(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdjustableVerticalOffset;                          // 0x0D78(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMountedTransformLock;                             // 0x0D7C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D7D[0x3];                                      // 0x0D7D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 MountedMesh;                                       // 0x0D80(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MountedBoneName;                                   // 0x0D88(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FReplaySubMesh>                 MountedSubMeshes;                                  // 0x0D98(0x0010)(Edit, BlueprintVisible, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FVector                                MountedLocationOffset;                             // 0x0DA8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               MountedRotationOffset;                             // 0x0DC0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_DD8[0x18];                                     // 0x0DD8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserWidget*                            EscapeWidgetInstance;                              // 0x0DF0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_DF8[0x40];                                     // 0x0DF8(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void ToggleThumbstickNavigation(bool bEnableThumbstickNavigation);

	void AddSplinePoint(const struct FVector& Location, const struct FRotator& Rotation);
	void ApplyCameraState();
	void ApplyNewCameraState();
	void BeginFollowingSpline();
	void ClearSplinePoints();
	void CreateMountData();
	class FString GetActorName(class AActor* Actor);
	TArray<class ACivilianCharacter*> GetAllCivilianAI();
	TArray<class APlayerCharacter*> GetAllPlayers();
	TArray<class ASuspectCharacter*> GetAllSuspectAI();
	TArray<class ASWATCharacter*> GetAllSwatAI();
	TArray<struct FSplinePoint> GetSplinePoints();
	void NextActor();
	void NextSelectableActor();
	void OnChangeSelectedActor();
	void OnDynamicLoad();
	void OnFirstDynamicLoad();
	void OnPauseMenuClosed();
	void OnPauseMenuOpened();
	void OnPlayerChangeCameraState(ECameraState NewState);
	void OnPostDynamicLoad();
	void OnScrubComplete();
	void OnScrubInitiated();
	void PauseReplay();
	void PreviousActor();
	void PreviousSelectableActor();
	void RefreshSelectableActors();
	void RemoveSplinePoint(int32 Index_0);
	void RevertPreviousCameraState();
	void SetCurrentReplayPlayRate(float PlayRate);
	void SetCurrentReplayTimeToSeconds(float Seconds);
	bool SetPaused(bool bDoPause);
	bool SetPausedState(bool bDoPause, bool bMuteAudio);
	void SetViewOverride();
	void SkipReplayBackward();
	void SkipReplayForward();
	void StopFollowingSpline();
	void ToggleHUD();

	float GetCurrentReplayCurrentTimeInSeconds() const;
	float GetCurrentReplayTotalTimeInSeconds() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReplayController">();
	}
	static class AReplayController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AReplayController>();
	}
};
static_assert(alignof(AReplayController) == 0x000008, "Wrong alignment on AReplayController");
static_assert(sizeof(AReplayController) == 0x000E38, "Wrong size on AReplayController");
static_assert(offsetof(AReplayController, ReplaySplineActor) == 0x000D38, "Member 'AReplayController::ReplaySplineActor' has a wrong offset!");
static_assert(offsetof(AReplayController, TotalSplineTime) == 0x000D40, "Member 'AReplayController::TotalSplineTime' has a wrong offset!");
static_assert(offsetof(AReplayController, bIsFollowingSpline) == 0x000D44, "Member 'AReplayController::bIsFollowingSpline' has a wrong offset!");
static_assert(offsetof(AReplayController, DeltaSplineTime) == 0x000D48, "Member 'AReplayController::DeltaSplineTime' has a wrong offset!");
static_assert(offsetof(AReplayController, SplineRotationType) == 0x000D4C, "Member 'AReplayController::SplineRotationType' has a wrong offset!");
static_assert(offsetof(AReplayController, CurrentCameraState) == 0x000D4D, "Member 'AReplayController::CurrentCameraState' has a wrong offset!");
static_assert(offsetof(AReplayController, SelectableActors) == 0x000D50, "Member 'AReplayController::SelectableActors' has a wrong offset!");
static_assert(offsetof(AReplayController, SelectedActor) == 0x000D60, "Member 'AReplayController::SelectedActor' has a wrong offset!");
static_assert(offsetof(AReplayController, SelectedActorIndex) == 0x000D68, "Member 'AReplayController::SelectedActorIndex' has a wrong offset!");
static_assert(offsetof(AReplayController, bIsReplayMenuOpen) == 0x000D6C, "Member 'AReplayController::bIsReplayMenuOpen' has a wrong offset!");
static_assert(offsetof(AReplayController, ReplayControls) == 0x000D70, "Member 'AReplayController::ReplayControls' has a wrong offset!");
static_assert(offsetof(AReplayController, AdjustableVerticalOffset) == 0x000D78, "Member 'AReplayController::AdjustableVerticalOffset' has a wrong offset!");
static_assert(offsetof(AReplayController, bMountedTransformLock) == 0x000D7C, "Member 'AReplayController::bMountedTransformLock' has a wrong offset!");
static_assert(offsetof(AReplayController, MountedMesh) == 0x000D80, "Member 'AReplayController::MountedMesh' has a wrong offset!");
static_assert(offsetof(AReplayController, MountedBoneName) == 0x000D88, "Member 'AReplayController::MountedBoneName' has a wrong offset!");
static_assert(offsetof(AReplayController, MountedSubMeshes) == 0x000D98, "Member 'AReplayController::MountedSubMeshes' has a wrong offset!");
static_assert(offsetof(AReplayController, MountedLocationOffset) == 0x000DA8, "Member 'AReplayController::MountedLocationOffset' has a wrong offset!");
static_assert(offsetof(AReplayController, MountedRotationOffset) == 0x000DC0, "Member 'AReplayController::MountedRotationOffset' has a wrong offset!");
static_assert(offsetof(AReplayController, EscapeWidgetInstance) == 0x000DF0, "Member 'AReplayController::EscapeWidgetInstance' has a wrong offset!");

// Class ReadyOrNot.Mirror
// 0x0088 (0x0320 - 0x0298)
class AMirror final : public AActor
{
public:
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             VisibilityBoundsTransform;                         // 0x02A0(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                VisibilityBoundsExtent;                            // 0x0300(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bDynamicShadowsDisabled : 1;                       // 0x0318(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_319[0x7];                                      // 0x0319(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Mirror">();
	}
	static class AMirror* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMirror>();
	}
};
static_assert(alignof(AMirror) == 0x000010, "Wrong alignment on AMirror");
static_assert(sizeof(AMirror) == 0x000320, "Wrong size on AMirror");
static_assert(offsetof(AMirror, VisibilityBoundsTransform) == 0x0002A0, "Member 'AMirror::VisibilityBoundsTransform' has a wrong offset!");
static_assert(offsetof(AMirror, VisibilityBoundsExtent) == 0x000300, "Member 'AMirror::VisibilityBoundsExtent' has a wrong offset!");

// Class ReadyOrNot.MirrorPortalComponent
// 0x0000 (0x0590 - 0x0590)
class UMirrorPortalComponent final : public UArrowComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MirrorPortalComponent">();
	}
	static class UMirrorPortalComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMirrorPortalComponent>();
	}
};
static_assert(alignof(UMirrorPortalComponent) == 0x000010, "Wrong alignment on UMirrorPortalComponent");
static_assert(sizeof(UMirrorPortalComponent) == 0x000590, "Wrong size on UMirrorPortalComponent");

// Class ReadyOrNot.MirrorUnderDoorActivity
// 0x0028 (0x0280 - 0x0258)
class UMirrorUnderDoorActivity final : public UDoorInteractionActivity
{
public:
	EMirrorContactType                            MirrorContactType;                                 // 0x0258(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_259[0x7];                                      // 0x0259(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ACyberneticCharacter*>           SpottedCharacters;                                 // 0x0260(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_270[0x10];                                     // 0x0270(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MirrorForCustom();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MirrorUnderDoorActivity">();
	}
	static class UMirrorUnderDoorActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMirrorUnderDoorActivity>();
	}
};
static_assert(alignof(UMirrorUnderDoorActivity) == 0x000008, "Wrong alignment on UMirrorUnderDoorActivity");
static_assert(sizeof(UMirrorUnderDoorActivity) == 0x000280, "Wrong size on UMirrorUnderDoorActivity");
static_assert(offsetof(UMirrorUnderDoorActivity, MirrorContactType) == 0x000258, "Member 'UMirrorUnderDoorActivity::MirrorContactType' has a wrong offset!");
static_assert(offsetof(UMirrorUnderDoorActivity, SpottedCharacters) == 0x000260, "Member 'UMirrorUnderDoorActivity::SpottedCharacters' has a wrong offset!");

// Class ReadyOrNot.MissionEnd
// 0x0000 (0x0410 - 0x0410)
class UMissionEnd : public UCommonActivatableWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionEnd">();
	}
	static class UMissionEnd* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionEnd>();
	}
};
static_assert(alignof(UMissionEnd) == 0x000008, "Wrong alignment on UMissionEnd");
static_assert(sizeof(UMissionEnd) == 0x000410, "Wrong size on UMissionEnd");

// Class ReadyOrNot.Reportable
// 0x0000 (0x0000 - 0x0000)
class IReportable final
{
public:
	bool CanReportNow();
	class FString GetSpeechTypeForReport();
	bool GetTocResponseOverride(class FString* OutTocLine);
	void ReportToTOC(class AReadyOrNotCharacter* Reporter, bool bPlayAnimation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Reportable">();
	}
	static class IReportable* GetDefaultObj()
	{
		return GetDefaultObjImpl<IReportable>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IReportable) == 0x000001, "Wrong alignment on IReportable");
static_assert(sizeof(IReportable) == 0x000001, "Wrong size on IReportable");

// Class ReadyOrNot.MissionEventController
// 0x0020 (0x02B8 - 0x0298)
class AMissionEventController final : public AActor
{
public:
	TArray<struct FMissionEventData>              Events;                                            // 0x0298(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FMissionEventData>              Instances;                                         // 0x02A8(0x0010)(Edit, ZeroConstructor, EditConst, ContainsInstancedReference, AdvancedDisplay, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionEventController">();
	}
	static class AMissionEventController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMissionEventController>();
	}
};
static_assert(alignof(AMissionEventController) == 0x000008, "Wrong alignment on AMissionEventController");
static_assert(sizeof(AMissionEventController) == 0x0002B8, "Wrong size on AMissionEventController");
static_assert(offsetof(AMissionEventController, Events) == 0x000298, "Member 'AMissionEventController::Events' has a wrong offset!");
static_assert(offsetof(AMissionEventController, Instances) == 0x0002A8, "Member 'AMissionEventController::Instances' has a wrong offset!");

// Class ReadyOrNot.MissionEventSubsystem
// 0x00C0 (0x00F0 - 0x0030)
class UMissionEventSubsystem final : public UWorldSubsystem
{
public:
	uint8                                         Pad_30[0xC0];                                      // 0x0030(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddEventListener(const struct FGameplayTag& EventTag, TDelegate<void(const struct FGameplayTag& SourceTag)> Delegate);
	void FireEvent(const struct FGameplayTag& EventTag);
	float GetTimeEventFired(const struct FGameplayTag& EventTag);
	bool HasEventFired(const struct FGameplayTag& EventTag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionEventSubsystem">();
	}
	static class UMissionEventSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionEventSubsystem>();
	}
};
static_assert(alignof(UMissionEventSubsystem) == 0x000008, "Wrong alignment on UMissionEventSubsystem");
static_assert(sizeof(UMissionEventSubsystem) == 0x0000F0, "Wrong size on UMissionEventSubsystem");

// Class ReadyOrNot.MissionInformationSubsystem
// 0x0818 (0x0848 - 0x0030)
class UMissionInformationSubsystem final : public UWorldSubsystem
{
public:
	struct FLevelDataLookupTable                  CachedLevelData;                                   // 0x0030(0x0818)(NativeAccessSpecifierPrivate)

public:
	struct FDateTime GetCurrentLocalTime() const;
	struct FDateTime GetCurrentZuluTime() const;
	class FText GetFriendlyLocationName() const;
	class FText GetFriendlyMissionName() const;
	struct FVector2D GetLatitudeAndLongitude() const;
	struct FTimespan GetLocalTimeZoneOffset() const;
	float GetSeaLevelOffsetInCentimeters() const;
	struct FDateTime GetStartingLocalTime() const;
	struct FDateTime GetStartingZuluTime() const;
	float GetTrueNorthAngleInDegrees() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionInformationSubsystem">();
	}
	static class UMissionInformationSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionInformationSubsystem>();
	}
};
static_assert(alignof(UMissionInformationSubsystem) == 0x000008, "Wrong alignment on UMissionInformationSubsystem");
static_assert(sizeof(UMissionInformationSubsystem) == 0x000848, "Wrong size on UMissionInformationSubsystem");
static_assert(offsetof(UMissionInformationSubsystem, CachedLevelData) == 0x000030, "Member 'UMissionInformationSubsystem::CachedLevelData' has a wrong offset!");

// Class ReadyOrNot.MissionPlanManager
// 0x0290 (0x0528 - 0x0298)
class AMissionPlanManager final : public AInfo
{
public:
	struct FPlanningMarkerArray                   MarkerArray;                                       // 0x0298(0x0148)(Net, NativeAccessSpecifierPublic)
	struct FPlanningLineArray                     LineArray;                                         // 0x03E0(0x0148)(Net, NativeAccessSpecifierPublic)

public:
	static class AReadyOrNotPlayerState* GetPlayerStateFromPlanningNumber(const class UObject* WorldContextObject, int32 Number);

	void OnMissionChanged();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionPlanManager">();
	}
	static class AMissionPlanManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMissionPlanManager>();
	}
};
static_assert(alignof(AMissionPlanManager) == 0x000008, "Wrong alignment on AMissionPlanManager");
static_assert(sizeof(AMissionPlanManager) == 0x000528, "Wrong size on AMissionPlanManager");
static_assert(offsetof(AMissionPlanManager, MarkerArray) == 0x000298, "Member 'AMissionPlanManager::MarkerArray' has a wrong offset!");
static_assert(offsetof(AMissionPlanManager, LineArray) == 0x0003E0, "Member 'AMissionPlanManager::LineArray' has a wrong offset!");

// Class ReadyOrNot.RepositionCombatMove
// 0x0008 (0x0238 - 0x0230)
class URepositionCombatMove final : public UBaseCombatMoveActivity
{
public:
	class ADoor*                                  TheDoor;                                           // 0x0230(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RepositionCombatMove">();
	}
	static class URepositionCombatMove* GetDefaultObj()
	{
		return GetDefaultObjImpl<URepositionCombatMove>();
	}
};
static_assert(alignof(URepositionCombatMove) == 0x000008, "Wrong alignment on URepositionCombatMove");
static_assert(sizeof(URepositionCombatMove) == 0x000238, "Wrong size on URepositionCombatMove");
static_assert(offsetof(URepositionCombatMove, TheDoor) == 0x000230, "Member 'URepositionCombatMove::TheDoor' has a wrong offset!");

// Class ReadyOrNot.MissionPlanLinesWidget
// 0x0060 (0x01E0 - 0x0180)
class UMissionPlanLinesWidget final : public UWidget
{
public:
	float                                         LineWidth;                                         // 0x0180(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FirstNodeRadius;                                   // 0x0184(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NodeRadius;                                        // 0x0188(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18C[0x4];                                      // 0x018C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     LineMaterial;                                      // 0x0190(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyDrawPreviewLine;                              // 0x0198(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_199[0x3];                                      // 0x0199(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMissionPlanLineColors                 LineColors;                                        // 0x019C(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1CC[0x14];                                     // 0x01CC(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetCurrentFloor(int32 Floor);
	void SetLineColors(const struct FMissionPlanLineColors& InLineColors);
	void SetPreviewLine(const struct FPlanningLine& Line);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionPlanLinesWidget">();
	}
	static class UMissionPlanLinesWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionPlanLinesWidget>();
	}
};
static_assert(alignof(UMissionPlanLinesWidget) == 0x000008, "Wrong alignment on UMissionPlanLinesWidget");
static_assert(sizeof(UMissionPlanLinesWidget) == 0x0001E0, "Wrong size on UMissionPlanLinesWidget");
static_assert(offsetof(UMissionPlanLinesWidget, LineWidth) == 0x000180, "Member 'UMissionPlanLinesWidget::LineWidth' has a wrong offset!");
static_assert(offsetof(UMissionPlanLinesWidget, FirstNodeRadius) == 0x000184, "Member 'UMissionPlanLinesWidget::FirstNodeRadius' has a wrong offset!");
static_assert(offsetof(UMissionPlanLinesWidget, NodeRadius) == 0x000188, "Member 'UMissionPlanLinesWidget::NodeRadius' has a wrong offset!");
static_assert(offsetof(UMissionPlanLinesWidget, LineMaterial) == 0x000190, "Member 'UMissionPlanLinesWidget::LineMaterial' has a wrong offset!");
static_assert(offsetof(UMissionPlanLinesWidget, bOnlyDrawPreviewLine) == 0x000198, "Member 'UMissionPlanLinesWidget::bOnlyDrawPreviewLine' has a wrong offset!");
static_assert(offsetof(UMissionPlanLinesWidget, LineColors) == 0x00019C, "Member 'UMissionPlanLinesWidget::LineColors' has a wrong offset!");

// Class ReadyOrNot.MissionPlanWidget
// 0x00D0 (0x04E0 - 0x0410)
class UMissionPlanWidget : public UCommonActivatableWidget
{
public:
	uint8                                         Pad_410[0x40];                                     // 0x0410(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class AMissionPlanManager*                    MissionPlanManager;                                // 0x0450(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFMODAudioComponent*                    DrawingAudioComponent;                             // 0x0458(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LineThickness;                                     // 0x0460(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeTime;                                          // 0x0464(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           LineColor;                                         // 0x0468(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ActiveLineColor;                                   // 0x0478(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlanLineWidth;                                     // 0x0488(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FirstNodeRadius;                                   // 0x048C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NodeRadius;                                        // 0x0490(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_494[0x4];                                      // 0x0494(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     PlanLineMaterial;                                  // 0x0498(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             DrawingSoundEvent;                                 // 0x04A0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DrawingFloor;                                      // 0x04A8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4AC[0x4];                                      // 0x04AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidget*                                DrawingTargetWidget;                               // 0x04B0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPlanningLine                          PreviewLine;                                       // 0x04B8(0x0028)(BlueprintVisible, NativeAccessSpecifierPublic)

public:
	void AddLine(const struct FPlanningLine& Line);
	void AddMarker(const struct FPlanningMarker& Marker);
	void OnEntryPointChanged(const struct FEntryPoint& NewEntryPoint);
	void OnLineAdded(int32 ID, const struct FPlanningLine& Line);
	void OnLineRemoved(int32 ID);
	void OnMarkerAdded(int32 ID, const struct FPlanningMarker& Marker);
	void OnMarkerRemoved(int32 ID);
	void OnMissionChanged(const class FString& URL, const struct FLevelDataLookupTable& LevelData);
	void RemoveLine(int32 ID);
	void RemoveMarker(int32 ID);
	void SetEntryPoint(class FName EntryPoint);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionPlanWidget">();
	}
	static class UMissionPlanWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionPlanWidget>();
	}
};
static_assert(alignof(UMissionPlanWidget) == 0x000008, "Wrong alignment on UMissionPlanWidget");
static_assert(sizeof(UMissionPlanWidget) == 0x0004E0, "Wrong size on UMissionPlanWidget");
static_assert(offsetof(UMissionPlanWidget, MissionPlanManager) == 0x000450, "Member 'UMissionPlanWidget::MissionPlanManager' has a wrong offset!");
static_assert(offsetof(UMissionPlanWidget, DrawingAudioComponent) == 0x000458, "Member 'UMissionPlanWidget::DrawingAudioComponent' has a wrong offset!");
static_assert(offsetof(UMissionPlanWidget, LineThickness) == 0x000460, "Member 'UMissionPlanWidget::LineThickness' has a wrong offset!");
static_assert(offsetof(UMissionPlanWidget, FadeTime) == 0x000464, "Member 'UMissionPlanWidget::FadeTime' has a wrong offset!");
static_assert(offsetof(UMissionPlanWidget, LineColor) == 0x000468, "Member 'UMissionPlanWidget::LineColor' has a wrong offset!");
static_assert(offsetof(UMissionPlanWidget, ActiveLineColor) == 0x000478, "Member 'UMissionPlanWidget::ActiveLineColor' has a wrong offset!");
static_assert(offsetof(UMissionPlanWidget, PlanLineWidth) == 0x000488, "Member 'UMissionPlanWidget::PlanLineWidth' has a wrong offset!");
static_assert(offsetof(UMissionPlanWidget, FirstNodeRadius) == 0x00048C, "Member 'UMissionPlanWidget::FirstNodeRadius' has a wrong offset!");
static_assert(offsetof(UMissionPlanWidget, NodeRadius) == 0x000490, "Member 'UMissionPlanWidget::NodeRadius' has a wrong offset!");
static_assert(offsetof(UMissionPlanWidget, PlanLineMaterial) == 0x000498, "Member 'UMissionPlanWidget::PlanLineMaterial' has a wrong offset!");
static_assert(offsetof(UMissionPlanWidget, DrawingSoundEvent) == 0x0004A0, "Member 'UMissionPlanWidget::DrawingSoundEvent' has a wrong offset!");
static_assert(offsetof(UMissionPlanWidget, DrawingFloor) == 0x0004A8, "Member 'UMissionPlanWidget::DrawingFloor' has a wrong offset!");
static_assert(offsetof(UMissionPlanWidget, DrawingTargetWidget) == 0x0004B0, "Member 'UMissionPlanWidget::DrawingTargetWidget' has a wrong offset!");
static_assert(offsetof(UMissionPlanWidget, PreviewLine) == 0x0004B8, "Member 'UMissionPlanWidget::PreviewLine' has a wrong offset!");

// Class ReadyOrNot.MissionPortal
// 0x0120 (0x03E8 - 0x02C8)
class AMissionPortal final : public AReadyOrNotTriggerVolume
{
public:
	uint8                                         Pad_2C8[0x8];                                      // 0x02C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractableComponent*                 InteractableComponent;                             // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class AReadyOrNotGameMode>> SelectableGameModes;                              // 0x02D8(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	class AMissionSelect*                         MissionSelect;                                     // 0x02E8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UReadyOrNotProfile*                     Profile;                                           // 0x02F0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCommanderProfile*                      CommanderProfile;                                  // 0x02F8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMetaGameProfile*                       MetaGameProfile;                                   // 0x0300(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextRenderComponent*                   WhiteboardText;                                    // 0x0308(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_310[0x8];                                      // 0x0310(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnMissionSelected_Delegate;                        // 0x0318(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FString                                 MissionURL;                                        // 0x0328(0x0010)(Net, ZeroConstructor, RepNotify, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ModeURL;                                           // 0x0338(0x0010)(Net, ZeroConstructor, RepNotify, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SelectedEntryPoint;                                // 0x0348(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UStaticMeshComponent*>           CompsToOutline;                                    // 0x0350(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<class ULightComponent*>                LightsToEnable;                                    // 0x0360(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<class UStaticMeshComponent*>           CompsToOutlineMissionSelected;                     // 0x0370(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<class ULightComponent*>                LightsToEnableMissionSelected;                     // 0x0380(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_390[0x18];                                     // 0x0390(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(float Countdown)> OnCountdownStarted;                              // 0x03A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnCountdownCancelled;                              // 0x03B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         NumReadyPlayers;                                   // 0x03C8(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumPlayersInLobby;                                 // 0x03CC(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AReadyOrNotPlayerController*>    ReadiedPlayers;                                    // 0x03D0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E0[0x8];                                      // 0x03E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool DoesLevelExistInBuild(const class FString& InUrl);
	static bool GetPlayersReady(int32* Ready, int32* Total);
	static void GetSelectedMission(class FString* OutMissionURL);
	static bool GetSelectedMode(class FString* OutMode);
	static bool GetSelectedModeName(class FString* OutName);
	static bool IsGameModeSelectable(ECOOPMode InMode);
	static bool IsLevelUnlocked(const class FString& InUrl, bool* OutIsUnlocked, float* OutScoreRequired, class FString* OutLockedUrl);
	static bool IsMissionStarting(bool* bStarting, float* Countdown);
	static void SetSelectedEntryPoint(class FName EntryPoint);
	static void SetSelectedMission(const class FString& InMissionURL);
	static void SetSelectedMode(class FName InMode);

	void Multicast_SetTimer(bool bEnabled, float SetTime);
	void OnMissionSelected();
	void OnPlayerJoinedLobby(class AReadyOrNotPlayerController* PlayerController);
	void OnPlayerReadyChange(class AReadyOrNotPlayerController* ReadyOrNotPlayerController, bool bReady);
	void OnRep_MissionURL();
	void OnRep_PlayersInLobbyChange();
	void OnRep_ReadiedPlayersChange();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionPortal">();
	}
	static class AMissionPortal* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMissionPortal>();
	}
};
static_assert(alignof(AMissionPortal) == 0x000008, "Wrong alignment on AMissionPortal");
static_assert(sizeof(AMissionPortal) == 0x0003E8, "Wrong size on AMissionPortal");
static_assert(offsetof(AMissionPortal, InteractableComponent) == 0x0002D0, "Member 'AMissionPortal::InteractableComponent' has a wrong offset!");
static_assert(offsetof(AMissionPortal, SelectableGameModes) == 0x0002D8, "Member 'AMissionPortal::SelectableGameModes' has a wrong offset!");
static_assert(offsetof(AMissionPortal, MissionSelect) == 0x0002E8, "Member 'AMissionPortal::MissionSelect' has a wrong offset!");
static_assert(offsetof(AMissionPortal, Profile) == 0x0002F0, "Member 'AMissionPortal::Profile' has a wrong offset!");
static_assert(offsetof(AMissionPortal, CommanderProfile) == 0x0002F8, "Member 'AMissionPortal::CommanderProfile' has a wrong offset!");
static_assert(offsetof(AMissionPortal, MetaGameProfile) == 0x000300, "Member 'AMissionPortal::MetaGameProfile' has a wrong offset!");
static_assert(offsetof(AMissionPortal, WhiteboardText) == 0x000308, "Member 'AMissionPortal::WhiteboardText' has a wrong offset!");
static_assert(offsetof(AMissionPortal, OnMissionSelected_Delegate) == 0x000318, "Member 'AMissionPortal::OnMissionSelected_Delegate' has a wrong offset!");
static_assert(offsetof(AMissionPortal, MissionURL) == 0x000328, "Member 'AMissionPortal::MissionURL' has a wrong offset!");
static_assert(offsetof(AMissionPortal, ModeURL) == 0x000338, "Member 'AMissionPortal::ModeURL' has a wrong offset!");
static_assert(offsetof(AMissionPortal, SelectedEntryPoint) == 0x000348, "Member 'AMissionPortal::SelectedEntryPoint' has a wrong offset!");
static_assert(offsetof(AMissionPortal, CompsToOutline) == 0x000350, "Member 'AMissionPortal::CompsToOutline' has a wrong offset!");
static_assert(offsetof(AMissionPortal, LightsToEnable) == 0x000360, "Member 'AMissionPortal::LightsToEnable' has a wrong offset!");
static_assert(offsetof(AMissionPortal, CompsToOutlineMissionSelected) == 0x000370, "Member 'AMissionPortal::CompsToOutlineMissionSelected' has a wrong offset!");
static_assert(offsetof(AMissionPortal, LightsToEnableMissionSelected) == 0x000380, "Member 'AMissionPortal::LightsToEnableMissionSelected' has a wrong offset!");
static_assert(offsetof(AMissionPortal, OnCountdownStarted) == 0x0003A8, "Member 'AMissionPortal::OnCountdownStarted' has a wrong offset!");
static_assert(offsetof(AMissionPortal, OnCountdownCancelled) == 0x0003B8, "Member 'AMissionPortal::OnCountdownCancelled' has a wrong offset!");
static_assert(offsetof(AMissionPortal, NumReadyPlayers) == 0x0003C8, "Member 'AMissionPortal::NumReadyPlayers' has a wrong offset!");
static_assert(offsetof(AMissionPortal, NumPlayersInLobby) == 0x0003CC, "Member 'AMissionPortal::NumPlayersInLobby' has a wrong offset!");
static_assert(offsetof(AMissionPortal, ReadiedPlayers) == 0x0003D0, "Member 'AMissionPortal::ReadiedPlayers' has a wrong offset!");

// Class ReadyOrNot.MissionSelect
// 0x0130 (0x03C8 - 0x0298)
class AMissionSelect final : public AActor
{
public:
	TSoftObjectPtr<class UWorld>                  LosSuenosLevel;                                    // 0x0298(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PersistentLightingLevelName;                       // 0x02C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LevelOffset;                                       // 0x02C8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CameraTag;                                         // 0x02E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EffectsTag;                                        // 0x02E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PreloadTag;                                        // 0x02F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraInterpSpeed;                                 // 0x02F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeOutTime;                                       // 0x02FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeInTime;                                        // 0x0300(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeHoldTime;                                      // 0x0304(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           FadeColor;                                         // 0x0308(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ADirectionalLight*>              HiddenDirectionalLights;                           // 0x0318(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, AdvancedDisplay, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class ASkyLight*>                      HiddenSkyLights;                                   // 0x0328(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, AdvancedDisplay, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class APostProcessVolume*>             HiddenPostProcessVolumes;                          // 0x0338(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, AdvancedDisplay, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class AExponentialHeightFog*>          HiddenExponentialHeightFogs;                       // 0x0348(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, AdvancedDisplay, UObjectWrapper, NativeAccessSpecifierPublic)
	class AActor*                                 ViewTargetActor;                                   // 0x0358(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, AdvancedDisplay, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OriginalCameraPosition;                            // 0x0360(0x0018)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_378[0x18];                                     // 0x0378(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class ULevelStreamingDynamic*                 CurrentLevel;                                      // 0x0390(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULevelStreamingDynamic*                 InFlightLevel;                                     // 0x0398(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULevelStreaming*                        PersistentLightingLevel;                           // 0x03A0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AReadyOrNotPlayerController*            PlayerController;                                  // 0x03A8(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APlayerCameraManager*                   PlayerCameraManager;                               // 0x03B0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACameraActor*                           LoadingCameraActor;                                // 0x03B8(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C0[0x8];                                      // 0x03C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CloseMissionSelect();
	void LoadLevel(TSoftObjectPtr<class UWorld> Level);
	void OnLevelLoaded();
	void OnLevelShown();
	void OpenMissionSelect();
	void PreviewMission(class UMissionSelectLevel* LevelData);
	void SelectMission(class UMissionSelectLevel* LevelData);

	bool IsOpen() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionSelect">();
	}
	static class AMissionSelect* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMissionSelect>();
	}
};
static_assert(alignof(AMissionSelect) == 0x000008, "Wrong alignment on AMissionSelect");
static_assert(sizeof(AMissionSelect) == 0x0003C8, "Wrong size on AMissionSelect");
static_assert(offsetof(AMissionSelect, LosSuenosLevel) == 0x000298, "Member 'AMissionSelect::LosSuenosLevel' has a wrong offset!");
static_assert(offsetof(AMissionSelect, PersistentLightingLevelName) == 0x0002C0, "Member 'AMissionSelect::PersistentLightingLevelName' has a wrong offset!");
static_assert(offsetof(AMissionSelect, LevelOffset) == 0x0002C8, "Member 'AMissionSelect::LevelOffset' has a wrong offset!");
static_assert(offsetof(AMissionSelect, CameraTag) == 0x0002E0, "Member 'AMissionSelect::CameraTag' has a wrong offset!");
static_assert(offsetof(AMissionSelect, EffectsTag) == 0x0002E8, "Member 'AMissionSelect::EffectsTag' has a wrong offset!");
static_assert(offsetof(AMissionSelect, PreloadTag) == 0x0002F0, "Member 'AMissionSelect::PreloadTag' has a wrong offset!");
static_assert(offsetof(AMissionSelect, CameraInterpSpeed) == 0x0002F8, "Member 'AMissionSelect::CameraInterpSpeed' has a wrong offset!");
static_assert(offsetof(AMissionSelect, FadeOutTime) == 0x0002FC, "Member 'AMissionSelect::FadeOutTime' has a wrong offset!");
static_assert(offsetof(AMissionSelect, FadeInTime) == 0x000300, "Member 'AMissionSelect::FadeInTime' has a wrong offset!");
static_assert(offsetof(AMissionSelect, FadeHoldTime) == 0x000304, "Member 'AMissionSelect::FadeHoldTime' has a wrong offset!");
static_assert(offsetof(AMissionSelect, FadeColor) == 0x000308, "Member 'AMissionSelect::FadeColor' has a wrong offset!");
static_assert(offsetof(AMissionSelect, HiddenDirectionalLights) == 0x000318, "Member 'AMissionSelect::HiddenDirectionalLights' has a wrong offset!");
static_assert(offsetof(AMissionSelect, HiddenSkyLights) == 0x000328, "Member 'AMissionSelect::HiddenSkyLights' has a wrong offset!");
static_assert(offsetof(AMissionSelect, HiddenPostProcessVolumes) == 0x000338, "Member 'AMissionSelect::HiddenPostProcessVolumes' has a wrong offset!");
static_assert(offsetof(AMissionSelect, HiddenExponentialHeightFogs) == 0x000348, "Member 'AMissionSelect::HiddenExponentialHeightFogs' has a wrong offset!");
static_assert(offsetof(AMissionSelect, ViewTargetActor) == 0x000358, "Member 'AMissionSelect::ViewTargetActor' has a wrong offset!");
static_assert(offsetof(AMissionSelect, OriginalCameraPosition) == 0x000360, "Member 'AMissionSelect::OriginalCameraPosition' has a wrong offset!");
static_assert(offsetof(AMissionSelect, CurrentLevel) == 0x000390, "Member 'AMissionSelect::CurrentLevel' has a wrong offset!");
static_assert(offsetof(AMissionSelect, InFlightLevel) == 0x000398, "Member 'AMissionSelect::InFlightLevel' has a wrong offset!");
static_assert(offsetof(AMissionSelect, PersistentLightingLevel) == 0x0003A0, "Member 'AMissionSelect::PersistentLightingLevel' has a wrong offset!");
static_assert(offsetof(AMissionSelect, PlayerController) == 0x0003A8, "Member 'AMissionSelect::PlayerController' has a wrong offset!");
static_assert(offsetof(AMissionSelect, PlayerCameraManager) == 0x0003B0, "Member 'AMissionSelect::PlayerCameraManager' has a wrong offset!");
static_assert(offsetof(AMissionSelect, LoadingCameraActor) == 0x0003B8, "Member 'AMissionSelect::LoadingCameraActor' has a wrong offset!");

// Class ReadyOrNot.RoNAnimInstance_HumanBase
// 0x1580 (0x18D0 - 0x0350)
class URoNAnimInstance_HumanBase : public UAnimInstance
{
public:
	class URoNMoveStyleComponent*                 MoveStyleComponent;                                // 0x0348(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_350[0xC];                                      // 0x0350(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsStrafing;                                       // 0x035C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35D[0x3];                                      // 0x035D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRoNStyleSlotData                      Slot0;                                             // 0x0360(0x0258)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FRoNStyleSlotData                      Slot1;                                             // 0x05B8(0x0258)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FRoNStyleSlotData                      Slot2;                                             // 0x0810(0x0258)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FRoNStyleSlotData                      Slot3;                                             // 0x0A68(0x0258)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FRoNStyleSlotData                      Slot4;                                             // 0x0CC0(0x0258)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FRoNStyleSlotData                      Slot5;                                             // 0x0F18(0x0258)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FRoNStyleSlotData                      Slot6;                                             // 0x1170(0x0258)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FRoNStyleIdleData                      IdleData_Default;                                  // 0x13C8(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FRoNStyleTurnData                      TurnData_Default;                                  // 0x13D8(0x0050)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FRoNGaitTransitionData                 TransitionData_Default;                            // 0x1428(0x0120)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FRoNGaitLocomotionData                 LocomotionData_Default;                            // 0x1548(0x00C0)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	class UBlendSpace*                            StrafeBS_Default;                                  // 0x1608(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            NonStrafeBS_Default;                               // 0x1610(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlotBlendTime;                                     // 0x1618(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultSlotBlendTime;                              // 0x161C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimOffsetAlpha;                                    // 0x1620(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StrafeBlendTime;                                   // 0x1624(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlopeWarpingAlpha;                                 // 0x1628(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMoveStyleSlotBActive;                           // 0x162C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_162D[0x3];                                     // 0x162D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SlotIdx;                                           // 0x1630(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1634[0x4];                                     // 0x1634(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                HeadLookLocation;                                  // 0x1638(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeadLookAlpha;                                     // 0x1650(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1654[0x1C];                                    // 0x1654(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Lean;                                              // 0x1670(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeanClamped;                                       // 0x1674(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeanFactor;                                        // 0x1678(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeanInterpSpeed;                                   // 0x167C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdjustedPlayrate;                                  // 0x1680(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedScaling;                                      // 0x1684(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayrateClampMax;                                  // 0x1688(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentIdleIndex;                                  // 0x168C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStrafeDirection                              CurrentStrafeDirection;                            // 0x1690(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1691[0x7];                                     // 0x1691(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StrafeDirectionAngle;                              // 0x1698(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_169C[0x4];                                     // 0x169C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              AimOffsetInterpolated;                             // 0x16A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              AO_2DVector;                                       // 0x16B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInRagdoll;                                        // 0x16C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRecoveringFromRagdoll;                            // 0x16C1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDead;                                           // 0x16C2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPlayingDeathAnim;                               // 0x16C3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16C4[0x4];                                     // 0x16C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FWorldBuildingAnimState                WorldBuildingAnimState;                            // 0x16C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FCarryArrestedAnimState                CarryArrestAnimState;                              // 0x16D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FTakeHostageAnimState                  TakeHostageAnimState;                              // 0x16E0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	EAnimWeaponType                               CurWeaponType;                                     // 0x16F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16F9[0x7];                                     // 0x16F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          IncapacitationLoopAnim;                            // 0x1700(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsArrested;                                       // 0x1708(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsArrestedAsRagdoll;                              // 0x1709(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsBeingArrested;                                  // 0x170A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsBeingArrestedAsRagdoll;                         // 0x170B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSurrendered;                                      // 0x170C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCarried;                                        // 0x170D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsGetUpPlaying;                                   // 0x170E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_170F[0x1];                                     // 0x170F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIncapacitated;                                    // 0x1710(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableIKProcess;                                  // 0x1711(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFemale;                                         // 0x1712(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsUnarmed;                                        // 0x1713(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSWAT;                                           // 0x1714(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCrouching;                                      // 0x1715(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsArrestedAndDead;                                // 0x1716(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1717[0x1];                                     // 0x1717(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCoverAnimStateMachineData             CoverAnimStateMachineData;                         // 0x1718(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FHidingAnimStateMachineData            HidingAnimStateMachineData;                        // 0x1730(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FHoleTraversalAnimStateMachineData     HoleTraversalAnimStateMachineData;                 // 0x1740(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	float                                         LeftArmIKAlpha;                                    // 0x1750(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightArmIKAlpha;                                   // 0x1754(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArmsOnlySlotAlpha;                                 // 0x1758(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftArmOnlySlotAlpha;                              // 0x175C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HandAdditiveLockOverride;                          // 0x1760(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWeaponDown;                                       // 0x1764(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPistolAndWeaponDown;                            // 0x1765(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPistol;                                         // 0x1766(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1767[0x9];                                     // 0x1767(0x0009)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      Calm_Override_Pose;                                // 0x1770(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Aiming_Override_Pose;                              // 0x1778(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Default_Calm_Override_Pose;                        // 0x1780(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Default_Aiming_Override_Pose;                      // 0x1788(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Weapon_Override_Pose_Low;                          // 0x1790(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Weapon_Override_Pose_Up;                           // 0x1798(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Default_Weapon_Override_Pose_Low;                  // 0x17A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Default_Weapon_Override_Pose_Up;                   // 0x17A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponOverridePoseAlpha;                           // 0x17B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsReloading;                                      // 0x17B4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17B5[0x3];                                     // 0x17B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FinalAimOffsetAlpha;                               // 0x17B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableAimOffset;                                  // 0x17BC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnyMontageIsActive;                               // 0x17BD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFullBodyMontagePlaying;                           // 0x17BE(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpperBodyMontagePlaying;                          // 0x17BF(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInteractionMontagePlaying;                        // 0x17C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFullOrInteractionMontagePlaying;                  // 0x17C1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemOverrideRule                             CurOverrideRule;                                   // 0x17C2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLoweredSet;                                     // 0x17C3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowTurnInPlace;                                 // 0x17C4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17C5[0x3];                                     // 0x17C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TurnInPlaceSpeedMultiplier;                        // 0x17C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YawOffsetLimit;                                    // 0x17CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAnimTurnInPlaceAnimSet                TurnInPlaceAnimSet;                                // 0x17D0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FAnimTurnInPlaceState                  TurnInPlaceState;                                  // 0x17E8(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bExitTurnRecoveryIfMoving;                         // 0x1848(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1849[0x3];                                     // 0x1849(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCachedAnimStateData                   TurnAnimStateData;                                 // 0x184C(0x001C)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsTurnInPlaceStateRelevant;                       // 0x1868(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1869[0x3];                                     // 0x1869(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VelocityInterpTime;                                // 0x186C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VelocitySmoothed;                                  // 0x1870(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableAdditiveOverrides;                         // 0x1888(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1889[0x7];                                     // 0x1889(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         AdditiveDisableTagList;                            // 0x1890(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         move_x;                                            // 0x18A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         move_y;                                            // 0x18A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsHostageTaker;                                   // 0x18A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsHostage;                                        // 0x18A9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsHostageOrHostageTaker;                          // 0x18AA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18AB[0x1];                                     // 0x18AB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MoveStyleBlendCoolDown;                            // 0x18AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18B0[0x4];                                     // 0x18B0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bMoveStyleChanging;                                // 0x18B4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseUpperBodyIdleOverride;                         // 0x18B5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTurnOnlyAffectsLowerBody;                         // 0x18B6(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18B7[0x1];                                     // 0x18B7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TurnLowerBodyOnlyWeight;                           // 0x18B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18BC[0x4];                                     // 0x18BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      CurUpperBodyIdleOverride;                          // 0x18C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpperBodyOverrideWeight;                           // 0x18C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18CC[0x4];                                     // 0x18CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetMoveStyleDataFromComp(class URoNMoveStyleComponent* MoveStyleComp);
	void UpdateGaitDataFromComp(class URoNMoveStyleComponent* MoveStyleComp);
	void UpdateMoveStyleDataFromComp(class URoNMoveStyleComponent* MoveStyleComp);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RoNAnimInstance_HumanBase">();
	}
	static class URoNAnimInstance_HumanBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<URoNAnimInstance_HumanBase>();
	}
};
static_assert(alignof(URoNAnimInstance_HumanBase) == 0x000010, "Wrong alignment on URoNAnimInstance_HumanBase");
static_assert(sizeof(URoNAnimInstance_HumanBase) == 0x0018D0, "Wrong size on URoNAnimInstance_HumanBase");
static_assert(offsetof(URoNAnimInstance_HumanBase, MoveStyleComponent) == 0x000348, "Member 'URoNAnimInstance_HumanBase::MoveStyleComponent' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bIsStrafing) == 0x00035C, "Member 'URoNAnimInstance_HumanBase::bIsStrafing' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, Slot0) == 0x000360, "Member 'URoNAnimInstance_HumanBase::Slot0' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, Slot1) == 0x0005B8, "Member 'URoNAnimInstance_HumanBase::Slot1' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, Slot2) == 0x000810, "Member 'URoNAnimInstance_HumanBase::Slot2' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, Slot3) == 0x000A68, "Member 'URoNAnimInstance_HumanBase::Slot3' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, Slot4) == 0x000CC0, "Member 'URoNAnimInstance_HumanBase::Slot4' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, Slot5) == 0x000F18, "Member 'URoNAnimInstance_HumanBase::Slot5' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, Slot6) == 0x001170, "Member 'URoNAnimInstance_HumanBase::Slot6' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, IdleData_Default) == 0x0013C8, "Member 'URoNAnimInstance_HumanBase::IdleData_Default' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, TurnData_Default) == 0x0013D8, "Member 'URoNAnimInstance_HumanBase::TurnData_Default' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, TransitionData_Default) == 0x001428, "Member 'URoNAnimInstance_HumanBase::TransitionData_Default' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, LocomotionData_Default) == 0x001548, "Member 'URoNAnimInstance_HumanBase::LocomotionData_Default' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, StrafeBS_Default) == 0x001608, "Member 'URoNAnimInstance_HumanBase::StrafeBS_Default' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, NonStrafeBS_Default) == 0x001610, "Member 'URoNAnimInstance_HumanBase::NonStrafeBS_Default' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, SlotBlendTime) == 0x001618, "Member 'URoNAnimInstance_HumanBase::SlotBlendTime' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, DefaultSlotBlendTime) == 0x00161C, "Member 'URoNAnimInstance_HumanBase::DefaultSlotBlendTime' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, AimOffsetAlpha) == 0x001620, "Member 'URoNAnimInstance_HumanBase::AimOffsetAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, StrafeBlendTime) == 0x001624, "Member 'URoNAnimInstance_HumanBase::StrafeBlendTime' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, SlopeWarpingAlpha) == 0x001628, "Member 'URoNAnimInstance_HumanBase::SlopeWarpingAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bIsMoveStyleSlotBActive) == 0x00162C, "Member 'URoNAnimInstance_HumanBase::bIsMoveStyleSlotBActive' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, SlotIdx) == 0x001630, "Member 'URoNAnimInstance_HumanBase::SlotIdx' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, HeadLookLocation) == 0x001638, "Member 'URoNAnimInstance_HumanBase::HeadLookLocation' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, HeadLookAlpha) == 0x001650, "Member 'URoNAnimInstance_HumanBase::HeadLookAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, Lean) == 0x001670, "Member 'URoNAnimInstance_HumanBase::Lean' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, LeanClamped) == 0x001674, "Member 'URoNAnimInstance_HumanBase::LeanClamped' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, LeanFactor) == 0x001678, "Member 'URoNAnimInstance_HumanBase::LeanFactor' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, LeanInterpSpeed) == 0x00167C, "Member 'URoNAnimInstance_HumanBase::LeanInterpSpeed' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, AdjustedPlayrate) == 0x001680, "Member 'URoNAnimInstance_HumanBase::AdjustedPlayrate' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, SpeedScaling) == 0x001684, "Member 'URoNAnimInstance_HumanBase::SpeedScaling' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, PlayrateClampMax) == 0x001688, "Member 'URoNAnimInstance_HumanBase::PlayrateClampMax' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, CurrentIdleIndex) == 0x00168C, "Member 'URoNAnimInstance_HumanBase::CurrentIdleIndex' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, CurrentStrafeDirection) == 0x001690, "Member 'URoNAnimInstance_HumanBase::CurrentStrafeDirection' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, StrafeDirectionAngle) == 0x001698, "Member 'URoNAnimInstance_HumanBase::StrafeDirectionAngle' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, AimOffsetInterpolated) == 0x0016A0, "Member 'URoNAnimInstance_HumanBase::AimOffsetInterpolated' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, AO_2DVector) == 0x0016B0, "Member 'URoNAnimInstance_HumanBase::AO_2DVector' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bInRagdoll) == 0x0016C0, "Member 'URoNAnimInstance_HumanBase::bInRagdoll' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bRecoveringFromRagdoll) == 0x0016C1, "Member 'URoNAnimInstance_HumanBase::bRecoveringFromRagdoll' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bIsDead) == 0x0016C2, "Member 'URoNAnimInstance_HumanBase::bIsDead' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bIsPlayingDeathAnim) == 0x0016C3, "Member 'URoNAnimInstance_HumanBase::bIsPlayingDeathAnim' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, WorldBuildingAnimState) == 0x0016C8, "Member 'URoNAnimInstance_HumanBase::WorldBuildingAnimState' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, CarryArrestAnimState) == 0x0016D8, "Member 'URoNAnimInstance_HumanBase::CarryArrestAnimState' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, TakeHostageAnimState) == 0x0016E0, "Member 'URoNAnimInstance_HumanBase::TakeHostageAnimState' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, CurWeaponType) == 0x0016F8, "Member 'URoNAnimInstance_HumanBase::CurWeaponType' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, IncapacitationLoopAnim) == 0x001700, "Member 'URoNAnimInstance_HumanBase::IncapacitationLoopAnim' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bIsArrested) == 0x001708, "Member 'URoNAnimInstance_HumanBase::bIsArrested' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bIsArrestedAsRagdoll) == 0x001709, "Member 'URoNAnimInstance_HumanBase::bIsArrestedAsRagdoll' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bIsBeingArrested) == 0x00170A, "Member 'URoNAnimInstance_HumanBase::bIsBeingArrested' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bIsBeingArrestedAsRagdoll) == 0x00170B, "Member 'URoNAnimInstance_HumanBase::bIsBeingArrestedAsRagdoll' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bSurrendered) == 0x00170C, "Member 'URoNAnimInstance_HumanBase::bSurrendered' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bIsCarried) == 0x00170D, "Member 'URoNAnimInstance_HumanBase::bIsCarried' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bIsGetUpPlaying) == 0x00170E, "Member 'URoNAnimInstance_HumanBase::bIsGetUpPlaying' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bIncapacitated) == 0x001710, "Member 'URoNAnimInstance_HumanBase::bIncapacitated' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bEnableIKProcess) == 0x001711, "Member 'URoNAnimInstance_HumanBase::bEnableIKProcess' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bIsFemale) == 0x001712, "Member 'URoNAnimInstance_HumanBase::bIsFemale' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bIsUnarmed) == 0x001713, "Member 'URoNAnimInstance_HumanBase::bIsUnarmed' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bIsSWAT) == 0x001714, "Member 'URoNAnimInstance_HumanBase::bIsSWAT' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bIsCrouching) == 0x001715, "Member 'URoNAnimInstance_HumanBase::bIsCrouching' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bIsArrestedAndDead) == 0x001716, "Member 'URoNAnimInstance_HumanBase::bIsArrestedAndDead' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, CoverAnimStateMachineData) == 0x001718, "Member 'URoNAnimInstance_HumanBase::CoverAnimStateMachineData' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, HidingAnimStateMachineData) == 0x001730, "Member 'URoNAnimInstance_HumanBase::HidingAnimStateMachineData' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, HoleTraversalAnimStateMachineData) == 0x001740, "Member 'URoNAnimInstance_HumanBase::HoleTraversalAnimStateMachineData' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, LeftArmIKAlpha) == 0x001750, "Member 'URoNAnimInstance_HumanBase::LeftArmIKAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, RightArmIKAlpha) == 0x001754, "Member 'URoNAnimInstance_HumanBase::RightArmIKAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, ArmsOnlySlotAlpha) == 0x001758, "Member 'URoNAnimInstance_HumanBase::ArmsOnlySlotAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, LeftArmOnlySlotAlpha) == 0x00175C, "Member 'URoNAnimInstance_HumanBase::LeftArmOnlySlotAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, HandAdditiveLockOverride) == 0x001760, "Member 'URoNAnimInstance_HumanBase::HandAdditiveLockOverride' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bWeaponDown) == 0x001764, "Member 'URoNAnimInstance_HumanBase::bWeaponDown' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bIsPistolAndWeaponDown) == 0x001765, "Member 'URoNAnimInstance_HumanBase::bIsPistolAndWeaponDown' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bIsPistol) == 0x001766, "Member 'URoNAnimInstance_HumanBase::bIsPistol' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, Calm_Override_Pose) == 0x001770, "Member 'URoNAnimInstance_HumanBase::Calm_Override_Pose' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, Aiming_Override_Pose) == 0x001778, "Member 'URoNAnimInstance_HumanBase::Aiming_Override_Pose' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, Default_Calm_Override_Pose) == 0x001780, "Member 'URoNAnimInstance_HumanBase::Default_Calm_Override_Pose' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, Default_Aiming_Override_Pose) == 0x001788, "Member 'URoNAnimInstance_HumanBase::Default_Aiming_Override_Pose' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, Weapon_Override_Pose_Low) == 0x001790, "Member 'URoNAnimInstance_HumanBase::Weapon_Override_Pose_Low' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, Weapon_Override_Pose_Up) == 0x001798, "Member 'URoNAnimInstance_HumanBase::Weapon_Override_Pose_Up' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, Default_Weapon_Override_Pose_Low) == 0x0017A0, "Member 'URoNAnimInstance_HumanBase::Default_Weapon_Override_Pose_Low' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, Default_Weapon_Override_Pose_Up) == 0x0017A8, "Member 'URoNAnimInstance_HumanBase::Default_Weapon_Override_Pose_Up' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, WeaponOverridePoseAlpha) == 0x0017B0, "Member 'URoNAnimInstance_HumanBase::WeaponOverridePoseAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bIsReloading) == 0x0017B4, "Member 'URoNAnimInstance_HumanBase::bIsReloading' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, FinalAimOffsetAlpha) == 0x0017B8, "Member 'URoNAnimInstance_HumanBase::FinalAimOffsetAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bEnableAimOffset) == 0x0017BC, "Member 'URoNAnimInstance_HumanBase::bEnableAimOffset' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bAnyMontageIsActive) == 0x0017BD, "Member 'URoNAnimInstance_HumanBase::bAnyMontageIsActive' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bFullBodyMontagePlaying) == 0x0017BE, "Member 'URoNAnimInstance_HumanBase::bFullBodyMontagePlaying' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bUpperBodyMontagePlaying) == 0x0017BF, "Member 'URoNAnimInstance_HumanBase::bUpperBodyMontagePlaying' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bInteractionMontagePlaying) == 0x0017C0, "Member 'URoNAnimInstance_HumanBase::bInteractionMontagePlaying' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bFullOrInteractionMontagePlaying) == 0x0017C1, "Member 'URoNAnimInstance_HumanBase::bFullOrInteractionMontagePlaying' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, CurOverrideRule) == 0x0017C2, "Member 'URoNAnimInstance_HumanBase::CurOverrideRule' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bIsLoweredSet) == 0x0017C3, "Member 'URoNAnimInstance_HumanBase::bIsLoweredSet' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bAllowTurnInPlace) == 0x0017C4, "Member 'URoNAnimInstance_HumanBase::bAllowTurnInPlace' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, TurnInPlaceSpeedMultiplier) == 0x0017C8, "Member 'URoNAnimInstance_HumanBase::TurnInPlaceSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, YawOffsetLimit) == 0x0017CC, "Member 'URoNAnimInstance_HumanBase::YawOffsetLimit' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, TurnInPlaceAnimSet) == 0x0017D0, "Member 'URoNAnimInstance_HumanBase::TurnInPlaceAnimSet' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, TurnInPlaceState) == 0x0017E8, "Member 'URoNAnimInstance_HumanBase::TurnInPlaceState' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bExitTurnRecoveryIfMoving) == 0x001848, "Member 'URoNAnimInstance_HumanBase::bExitTurnRecoveryIfMoving' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, TurnAnimStateData) == 0x00184C, "Member 'URoNAnimInstance_HumanBase::TurnAnimStateData' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bIsTurnInPlaceStateRelevant) == 0x001868, "Member 'URoNAnimInstance_HumanBase::bIsTurnInPlaceStateRelevant' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, VelocityInterpTime) == 0x00186C, "Member 'URoNAnimInstance_HumanBase::VelocityInterpTime' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, VelocitySmoothed) == 0x001870, "Member 'URoNAnimInstance_HumanBase::VelocitySmoothed' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bDisableAdditiveOverrides) == 0x001888, "Member 'URoNAnimInstance_HumanBase::bDisableAdditiveOverrides' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, AdditiveDisableTagList) == 0x001890, "Member 'URoNAnimInstance_HumanBase::AdditiveDisableTagList' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, move_x) == 0x0018A0, "Member 'URoNAnimInstance_HumanBase::move_x' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, move_y) == 0x0018A4, "Member 'URoNAnimInstance_HumanBase::move_y' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bIsHostageTaker) == 0x0018A8, "Member 'URoNAnimInstance_HumanBase::bIsHostageTaker' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bIsHostage) == 0x0018A9, "Member 'URoNAnimInstance_HumanBase::bIsHostage' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bIsHostageOrHostageTaker) == 0x0018AA, "Member 'URoNAnimInstance_HumanBase::bIsHostageOrHostageTaker' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, MoveStyleBlendCoolDown) == 0x0018AC, "Member 'URoNAnimInstance_HumanBase::MoveStyleBlendCoolDown' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bMoveStyleChanging) == 0x0018B4, "Member 'URoNAnimInstance_HumanBase::bMoveStyleChanging' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bUseUpperBodyIdleOverride) == 0x0018B5, "Member 'URoNAnimInstance_HumanBase::bUseUpperBodyIdleOverride' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, bTurnOnlyAffectsLowerBody) == 0x0018B6, "Member 'URoNAnimInstance_HumanBase::bTurnOnlyAffectsLowerBody' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, TurnLowerBodyOnlyWeight) == 0x0018B8, "Member 'URoNAnimInstance_HumanBase::TurnLowerBodyOnlyWeight' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, CurUpperBodyIdleOverride) == 0x0018C0, "Member 'URoNAnimInstance_HumanBase::CurUpperBodyIdleOverride' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_HumanBase, UpperBodyOverrideWeight) == 0x0018C8, "Member 'URoNAnimInstance_HumanBase::UpperBodyOverrideWeight' has a wrong offset!");

// Class ReadyOrNot.MissionSelectCampaign
// 0x0050 (0x0078 - 0x0028)
class UMissionSelectCampaign final : public UObject
{
public:
	class FText                                   Name_0;                                            // 0x0028(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<class UMissionSelectLevel*>            Levels;                                            // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bIsLocked;                                         // 0x0050(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECampaignLockReason                           LockReason;                                        // 0x0051(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52[0x6];                                       // 0x0052(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   RequiredCampaign;                                  // 0x0058(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EGameVersionRestriction                       RequiredDlc;                                       // 0x0070(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionSelectCampaign">();
	}
	static class UMissionSelectCampaign* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionSelectCampaign>();
	}
};
static_assert(alignof(UMissionSelectCampaign) == 0x000008, "Wrong alignment on UMissionSelectCampaign");
static_assert(sizeof(UMissionSelectCampaign) == 0x000078, "Wrong size on UMissionSelectCampaign");
static_assert(offsetof(UMissionSelectCampaign, Name_0) == 0x000028, "Member 'UMissionSelectCampaign::Name_0' has a wrong offset!");
static_assert(offsetof(UMissionSelectCampaign, Levels) == 0x000040, "Member 'UMissionSelectCampaign::Levels' has a wrong offset!");
static_assert(offsetof(UMissionSelectCampaign, bIsLocked) == 0x000050, "Member 'UMissionSelectCampaign::bIsLocked' has a wrong offset!");
static_assert(offsetof(UMissionSelectCampaign, LockReason) == 0x000051, "Member 'UMissionSelectCampaign::LockReason' has a wrong offset!");
static_assert(offsetof(UMissionSelectCampaign, RequiredCampaign) == 0x000058, "Member 'UMissionSelectCampaign::RequiredCampaign' has a wrong offset!");
static_assert(offsetof(UMissionSelectCampaign, RequiredDlc) == 0x000070, "Member 'UMissionSelectCampaign::RequiredDlc' has a wrong offset!");

// Class ReadyOrNot.MissionSelectLevel
// 0x00F0 (0x0118 - 0x0028)
class UMissionSelectLevel final : public UObject
{
public:
	TSoftObjectPtr<class UWorld>                  PreviewLevel;                                      // 0x0028(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLocked;                                         // 0x0050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBasicLevelStats                       Stats;                                             // 0x0054(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   Name_0;                                            // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   FriendlyName;                                      // 0x0068(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Nickname;                                          // 0x0080(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Image;                                             // 0x0098(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x00C0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Location;                                          // 0x00D8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   TimeOfDay;                                         // 0x00F0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FEntryPoint>                    EntryPoints;                                       // 0x0108(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionSelectLevel">();
	}
	static class UMissionSelectLevel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionSelectLevel>();
	}
};
static_assert(alignof(UMissionSelectLevel) == 0x000008, "Wrong alignment on UMissionSelectLevel");
static_assert(sizeof(UMissionSelectLevel) == 0x000118, "Wrong size on UMissionSelectLevel");
static_assert(offsetof(UMissionSelectLevel, PreviewLevel) == 0x000028, "Member 'UMissionSelectLevel::PreviewLevel' has a wrong offset!");
static_assert(offsetof(UMissionSelectLevel, bIsLocked) == 0x000050, "Member 'UMissionSelectLevel::bIsLocked' has a wrong offset!");
static_assert(offsetof(UMissionSelectLevel, Stats) == 0x000054, "Member 'UMissionSelectLevel::Stats' has a wrong offset!");
static_assert(offsetof(UMissionSelectLevel, Name_0) == 0x000060, "Member 'UMissionSelectLevel::Name_0' has a wrong offset!");
static_assert(offsetof(UMissionSelectLevel, FriendlyName) == 0x000068, "Member 'UMissionSelectLevel::FriendlyName' has a wrong offset!");
static_assert(offsetof(UMissionSelectLevel, Nickname) == 0x000080, "Member 'UMissionSelectLevel::Nickname' has a wrong offset!");
static_assert(offsetof(UMissionSelectLevel, Image) == 0x000098, "Member 'UMissionSelectLevel::Image' has a wrong offset!");
static_assert(offsetof(UMissionSelectLevel, Description) == 0x0000C0, "Member 'UMissionSelectLevel::Description' has a wrong offset!");
static_assert(offsetof(UMissionSelectLevel, Location) == 0x0000D8, "Member 'UMissionSelectLevel::Location' has a wrong offset!");
static_assert(offsetof(UMissionSelectLevel, TimeOfDay) == 0x0000F0, "Member 'UMissionSelectLevel::TimeOfDay' has a wrong offset!");
static_assert(offsetof(UMissionSelectLevel, EntryPoints) == 0x000108, "Member 'UMissionSelectLevel::EntryPoints' has a wrong offset!");

// Class ReadyOrNot.MissionSelectWidget
// 0x0020 (0x0430 - 0x0410)
class UMissionSelectWidget : public UCommonActivatableWidget
{
public:
	TArray<class UMissionSelectCampaign*>         CachedCampaigns;                                   // 0x0410(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	class UMetaGameProfile*                       MetaGameProfile;                                   // 0x0420(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCommanderProfile*                      CommanderProfile;                                  // 0x0428(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void CloseMissionSelect();
	const TArray<class UMissionSelectCampaign*> GetCampaigns();
	void PreviewMission(class UMissionSelectLevel* Level);
	void SelectMission(class UMissionSelectLevel* Level);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionSelectWidget">();
	}
	static class UMissionSelectWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionSelectWidget>();
	}
};
static_assert(alignof(UMissionSelectWidget) == 0x000008, "Wrong alignment on UMissionSelectWidget");
static_assert(sizeof(UMissionSelectWidget) == 0x000430, "Wrong size on UMissionSelectWidget");
static_assert(offsetof(UMissionSelectWidget, CachedCampaigns) == 0x000410, "Member 'UMissionSelectWidget::CachedCampaigns' has a wrong offset!");
static_assert(offsetof(UMissionSelectWidget, MetaGameProfile) == 0x000420, "Member 'UMissionSelectWidget::MetaGameProfile' has a wrong offset!");
static_assert(offsetof(UMissionSelectWidget, CommanderProfile) == 0x000428, "Member 'UMissionSelectWidget::CommanderProfile' has a wrong offset!");

// Class ReadyOrNot.MissionTimeEventCondition
// 0x0020 (0x0060 - 0x0040)
class UMissionTimeEventCondition final : public UMissionEventCondition
{
public:
	bool                                          bUseLevelDataIni;                                  // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SecondsElapsedRequired;                            // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ConfigKey;                                         // 0x0048(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SecondsElapsed;                                    // 0x0058(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionTimeEventCondition">();
	}
	static class UMissionTimeEventCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionTimeEventCondition>();
	}
};
static_assert(alignof(UMissionTimeEventCondition) == 0x000008, "Wrong alignment on UMissionTimeEventCondition");
static_assert(sizeof(UMissionTimeEventCondition) == 0x000060, "Wrong size on UMissionTimeEventCondition");
static_assert(offsetof(UMissionTimeEventCondition, bUseLevelDataIni) == 0x000040, "Member 'UMissionTimeEventCondition::bUseLevelDataIni' has a wrong offset!");
static_assert(offsetof(UMissionTimeEventCondition, SecondsElapsedRequired) == 0x000044, "Member 'UMissionTimeEventCondition::SecondsElapsedRequired' has a wrong offset!");
static_assert(offsetof(UMissionTimeEventCondition, ConfigKey) == 0x000048, "Member 'UMissionTimeEventCondition::ConfigKey' has a wrong offset!");
static_assert(offsetof(UMissionTimeEventCondition, SecondsElapsed) == 0x000058, "Member 'UMissionTimeEventCondition::SecondsElapsed' has a wrong offset!");

// Class ReadyOrNot.NavArea_CivilianA
// 0x0000 (0x0048 - 0x0048)
class UNavArea_CivilianA final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_CivilianA">();
	}
	static class UNavArea_CivilianA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_CivilianA>();
	}
};
static_assert(alignof(UNavArea_CivilianA) == 0x000008, "Wrong alignment on UNavArea_CivilianA");
static_assert(sizeof(UNavArea_CivilianA) == 0x000048, "Wrong size on UNavArea_CivilianA");

// Class ReadyOrNot.ModioManager
// 0x0210 (0x0238 - 0x0028)
class UModioManager final : public UObject
{
public:
	uint8                                         Pad_28[0x210];                                     // 0x0028(0x0210)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UModioManager* GetInstance();
	static bool IsModdingEnabled();

	void ClearUserData();
	bool IsModUpdating();

	bool IsRestartRequired() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ModioManager">();
	}
	static class UModioManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UModioManager>();
	}
};
static_assert(alignof(UModioManager) == 0x000008, "Wrong alignment on UModioManager");
static_assert(sizeof(UModioManager) == 0x000238, "Wrong size on UModioManager");

// Class ReadyOrNot.MoraleComponent
// 0x00B0 (0x01A8 - 0x00F8)
class UMoraleComponent final : public UResourceComponent
{
public:
	class ACyberneticCharacter*                   OwnerCharacter;                                    // 0x00F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartingMorale;                                    // 0x0100(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_104[0xA4];                                     // 0x0104(0x00A4)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void ApplyRadialMoraleDamage(const class UObject* WorldContextObject, const struct FVector& Location, float Damage, float Radius, const struct FMoraleDamageTraceParameters& LOSParameters, const TArray<ETeamType>& Teams, class FName Reason);
	static void ApplyRadialMoraleDamageWithFalloff(const class UObject* WorldContextObject, const struct FVector& Location, float Damage, float InnerRadius, float OuterRadius, const struct FMoraleDamageTraceParameters& LOSParameters, const TArray<ETeamType>& Teams, EEasingFunc FalloffCurve, class FName Reason);
	static void IncreaseMoraleOnCharacter(class ACyberneticCharacter* Character, float MoraleValue, class FName Reason);
	static void LowerMoraleOnCharacter(class ACyberneticCharacter* Character, float MoraleValue, class FName Reason);
	static void ResetMoraleOnCharacter(class ACyberneticCharacter* Character);

	TMap<class FName, struct FMoraleChangeInfo> GetMoraleDamageHistory();
	TMap<class FName, struct FMoraleChangeInfo> GetMoraleGainHistory();

	float GetMorale() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoraleComponent">();
	}
	static class UMoraleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoraleComponent>();
	}
};
static_assert(alignof(UMoraleComponent) == 0x000008, "Wrong alignment on UMoraleComponent");
static_assert(sizeof(UMoraleComponent) == 0x0001A8, "Wrong size on UMoraleComponent");
static_assert(offsetof(UMoraleComponent, OwnerCharacter) == 0x0000F8, "Member 'UMoraleComponent::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(UMoraleComponent, StartingMorale) == 0x000100, "Member 'UMoraleComponent::StartingMorale' has a wrong offset!");

// Class ReadyOrNot.MoveActivity
// 0x0020 (0x0220 - 0x0200)
class UMoveActivity final : public UTeamBaseActivity
{
public:
	uint8                                         Pad_200[0x20];                                     // 0x0200(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoveActivity">();
	}
	static class UMoveActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoveActivity>();
	}
};
static_assert(alignof(UMoveActivity) == 0x000008, "Wrong alignment on UMoveActivity");
static_assert(sizeof(UMoveActivity) == 0x000220, "Wrong size on UMoveActivity");

// Class ReadyOrNot.MoveIntoLOSActivity
// 0x0008 (0x01F8 - 0x01F0)
class UMoveIntoLOSActivity final : public UBaseActivity
{
public:
	class AActor*                                 LOSActor;                                          // 0x01F0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoveIntoLOSActivity">();
	}
	static class UMoveIntoLOSActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoveIntoLOSActivity>();
	}
};
static_assert(alignof(UMoveIntoLOSActivity) == 0x000008, "Wrong alignment on UMoveIntoLOSActivity");
static_assert(sizeof(UMoveIntoLOSActivity) == 0x0001F8, "Wrong size on UMoveIntoLOSActivity");
static_assert(offsetof(UMoveIntoLOSActivity, LOSActor) == 0x0001F0, "Member 'UMoveIntoLOSActivity::LOSActor' has a wrong offset!");

// Class ReadyOrNot.NavArea_CivilianE
// 0x0000 (0x0048 - 0x0048)
class UNavArea_CivilianE final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_CivilianE">();
	}
	static class UNavArea_CivilianE* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_CivilianE>();
	}
};
static_assert(alignof(UNavArea_CivilianE) == 0x000008, "Wrong alignment on UNavArea_CivilianE");
static_assert(sizeof(UNavArea_CivilianE) == 0x000048, "Wrong size on UNavArea_CivilianE");

// Class ReadyOrNot.MoveToActivity
// 0x0020 (0x0210 - 0x01F0)
class UMoveToActivity final : public UBaseActivity
{
public:
	uint8                                         Pad_1F0[0x20];                                     // 0x01F0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoveToActivity">();
	}
	static class UMoveToActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoveToActivity>();
	}
};
static_assert(alignof(UMoveToActivity) == 0x000008, "Wrong alignment on UMoveToActivity");
static_assert(sizeof(UMoveToActivity) == 0x000210, "Wrong size on UMoveToActivity");

// Class ReadyOrNot.MoveToExitActivity
// 0x0018 (0x0208 - 0x01F0)
class UMoveToExitActivity final : public UBaseActivity
{
public:
	uint8                                         Pad_1F0[0x18];                                     // 0x01F0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoveToExitActivity">();
	}
	static class UMoveToExitActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoveToExitActivity>();
	}
};
static_assert(alignof(UMoveToExitActivity) == 0x000008, "Wrong alignment on UMoveToExitActivity");
static_assert(sizeof(UMoveToExitActivity) == 0x000208, "Wrong size on UMoveToExitActivity");

// Class ReadyOrNot.MoveToPlayerSpawn
// 0x0008 (0x0238 - 0x0230)
class UMoveToPlayerSpawn final : public UBaseCombatMoveActivity
{
public:
	bool                                          bBeArrestedOnceReachedLocation;                    // 0x0230(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_231[0x7];                                      // 0x0231(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoveToPlayerSpawn">();
	}
	static class UMoveToPlayerSpawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoveToPlayerSpawn>();
	}
};
static_assert(alignof(UMoveToPlayerSpawn) == 0x000008, "Wrong alignment on UMoveToPlayerSpawn");
static_assert(sizeof(UMoveToPlayerSpawn) == 0x000238, "Wrong size on UMoveToPlayerSpawn");
static_assert(offsetof(UMoveToPlayerSpawn, bBeArrestedOnceReachedLocation) == 0x000230, "Member 'UMoveToPlayerSpawn::bBeArrestedOnceReachedLocation' has a wrong offset!");

// Class ReadyOrNot.MoveToZoneCombatMove
// 0x0008 (0x0238 - 0x0230)
class UMoveToZoneCombatMove final : public UBaseCombatMoveActivity
{
public:
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoveToZoneCombatMove">();
	}
	static class UMoveToZoneCombatMove* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoveToZoneCombatMove>();
	}
};
static_assert(alignof(UMoveToZoneCombatMove) == 0x000008, "Wrong alignment on UMoveToZoneCombatMove");
static_assert(sizeof(UMoveToZoneCombatMove) == 0x000238, "Wrong size on UMoveToZoneCombatMove");

// Class ReadyOrNot.NavArea_SuspectD
// 0x0000 (0x0048 - 0x0048)
class UNavArea_SuspectD final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_SuspectD">();
	}
	static class UNavArea_SuspectD* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_SuspectD>();
	}
};
static_assert(alignof(UNavArea_SuspectD) == 0x000008, "Wrong alignment on UNavArea_SuspectD");
static_assert(sizeof(UNavArea_SuspectD) == 0x000048, "Wrong size on UNavArea_SuspectD");

// Class ReadyOrNot.Multitool
// 0x0080 (0x0C50 - 0x0BD0)
class AMultitool : public ATool
{
public:
	TMap<EMultitoolFunctions, class UReadyOrNotWeaponAnimData*> MultitoolAnimData;                   // 0x0BC8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, NativeAccessSpecifierPublic)
	class UInteractionsData*                      PvPFreeInteraction;                                // 0x0C18(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMultitoolFunctions                           CurrentToolKit;                                    // 0x0C20(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bAudioBasedProgress : 1;                           // 0x0C21(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_C22[0x6];                                      // 0x0C22(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             FMODLockpickingSound;                              // 0x0C28(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             FMODKnifeSound;                                    // 0x0C30(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             FMODWirecutterSound;                               // 0x0C38(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             FMODFreeingSound;                                  // 0x0C40(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerCharacter*                       PendingFreeCharacter;                              // 0x0C48(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void ChangeToolkit(EMultitoolFunctions MultitoolFunction, bool bPlayAnimation);
	void Client_ChangeToolkit(EMultitoolFunctions MultitoolFunction, bool bPlayAnimation);
	void Client_PlayMultitoolAudio();
	void Client_StopMultitoolAudio();

	float GetMultitoolOperatingTimeFromActiveToolkit() const;
	float GetMultitoolOperatingTimeFromAudioLength(class UFMODEvent* Event) const;
	float GetMultitoolOperatingTimeFromToolkit(EMultitoolFunctions MultitoolFunction) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Multitool">();
	}
	static class AMultitool* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMultitool>();
	}
};
static_assert(alignof(AMultitool) == 0x000010, "Wrong alignment on AMultitool");
static_assert(sizeof(AMultitool) == 0x000C50, "Wrong size on AMultitool");
static_assert(offsetof(AMultitool, MultitoolAnimData) == 0x000BC8, "Member 'AMultitool::MultitoolAnimData' has a wrong offset!");
static_assert(offsetof(AMultitool, PvPFreeInteraction) == 0x000C18, "Member 'AMultitool::PvPFreeInteraction' has a wrong offset!");
static_assert(offsetof(AMultitool, CurrentToolKit) == 0x000C20, "Member 'AMultitool::CurrentToolKit' has a wrong offset!");
static_assert(offsetof(AMultitool, FMODLockpickingSound) == 0x000C28, "Member 'AMultitool::FMODLockpickingSound' has a wrong offset!");
static_assert(offsetof(AMultitool, FMODKnifeSound) == 0x000C30, "Member 'AMultitool::FMODKnifeSound' has a wrong offset!");
static_assert(offsetof(AMultitool, FMODWirecutterSound) == 0x000C38, "Member 'AMultitool::FMODWirecutterSound' has a wrong offset!");
static_assert(offsetof(AMultitool, FMODFreeingSound) == 0x000C40, "Member 'AMultitool::FMODFreeingSound' has a wrong offset!");
static_assert(offsetof(AMultitool, PendingFreeCharacter) == 0x000C48, "Member 'AMultitool::PendingFreeCharacter' has a wrong offset!");

// Class ReadyOrNot.MunitionsSlot
// 0x0088 (0x0370 - 0x02E8)
class UMunitionsSlot : public UCommonUserWidget
{
public:
	int32                                         SlotCount;                                         // 0x02E8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2EC[0x4];                                      // 0x02EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UHorizontalBox*                         ElementContainer;                                  // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AReadyOrNotGameState*                   gs;                                                // 0x02F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasElementsPrevious;                              // 0x0300(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasElementsNext;                                  // 0x0301(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_302[0x6];                                      // 0x0302(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UReadyOrNotLoadoutManager*              LoadoutFunctionLibrary;                            // 0x0308(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             PrimaryAmmoIcon;                                   // 0x0310(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             SecondaryAmmoIcon;                                 // 0x0318(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             CS_GasIcon;                                        // 0x0320(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             FlashbangIcon;                                     // 0x0328(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             StingerIcon;                                       // 0x0330(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             C2ChargeIcon;                                      // 0x0338(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             WedgeIcon;                                         // 0x0340(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             PeppersprayIcon;                                   // 0x0348(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             LockpickGunIcon;                                   // 0x0350(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             TaserIcon;                                         // 0x0358(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class ABaseItem>>          SlotItems;                                         // 0x0360(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	void CreateElement(class UTexture2D* Icon, int32 Amount, bool bIsAmmoElement, const class FText& AmmoType);
	void CreateSeparator(bool bShouldCreateSeparator);
	void SetGrenadeSlot();
	void SetPreviewGrenadeSlot(const struct FSavedLoadout& PreviewLoadout);
	void SetPreviewPrimaryAmmoSlot(const struct FSavedLoadout& PreviewLoadout);
	void SetPreviewSecondaryAmmoSlot(const struct FSavedLoadout& PreviewLoadout);
	void SetPreviewTacticalSlot(const struct FSavedLoadout& PreviewLoadout);
	void SetPrimaryAmmoSlot();
	void SetSecondaryAmmoSlot();
	void SetTacticalSlot();
	void UpdateElementContainer();
	void UpdateElementContainerPreview(const struct FSavedLoadout& PreviewLoadout);
	void UpdateSlotCount();
	void UpdateSlotText(int32 CurrentSlots, int32 MaxSlots);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MunitionsSlot">();
	}
	static class UMunitionsSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMunitionsSlot>();
	}
};
static_assert(alignof(UMunitionsSlot) == 0x000008, "Wrong alignment on UMunitionsSlot");
static_assert(sizeof(UMunitionsSlot) == 0x000370, "Wrong size on UMunitionsSlot");
static_assert(offsetof(UMunitionsSlot, SlotCount) == 0x0002E8, "Member 'UMunitionsSlot::SlotCount' has a wrong offset!");
static_assert(offsetof(UMunitionsSlot, ElementContainer) == 0x0002F0, "Member 'UMunitionsSlot::ElementContainer' has a wrong offset!");
static_assert(offsetof(UMunitionsSlot, gs) == 0x0002F8, "Member 'UMunitionsSlot::gs' has a wrong offset!");
static_assert(offsetof(UMunitionsSlot, bHasElementsPrevious) == 0x000300, "Member 'UMunitionsSlot::bHasElementsPrevious' has a wrong offset!");
static_assert(offsetof(UMunitionsSlot, bHasElementsNext) == 0x000301, "Member 'UMunitionsSlot::bHasElementsNext' has a wrong offset!");
static_assert(offsetof(UMunitionsSlot, LoadoutFunctionLibrary) == 0x000308, "Member 'UMunitionsSlot::LoadoutFunctionLibrary' has a wrong offset!");
static_assert(offsetof(UMunitionsSlot, PrimaryAmmoIcon) == 0x000310, "Member 'UMunitionsSlot::PrimaryAmmoIcon' has a wrong offset!");
static_assert(offsetof(UMunitionsSlot, SecondaryAmmoIcon) == 0x000318, "Member 'UMunitionsSlot::SecondaryAmmoIcon' has a wrong offset!");
static_assert(offsetof(UMunitionsSlot, CS_GasIcon) == 0x000320, "Member 'UMunitionsSlot::CS_GasIcon' has a wrong offset!");
static_assert(offsetof(UMunitionsSlot, FlashbangIcon) == 0x000328, "Member 'UMunitionsSlot::FlashbangIcon' has a wrong offset!");
static_assert(offsetof(UMunitionsSlot, StingerIcon) == 0x000330, "Member 'UMunitionsSlot::StingerIcon' has a wrong offset!");
static_assert(offsetof(UMunitionsSlot, C2ChargeIcon) == 0x000338, "Member 'UMunitionsSlot::C2ChargeIcon' has a wrong offset!");
static_assert(offsetof(UMunitionsSlot, WedgeIcon) == 0x000340, "Member 'UMunitionsSlot::WedgeIcon' has a wrong offset!");
static_assert(offsetof(UMunitionsSlot, PeppersprayIcon) == 0x000348, "Member 'UMunitionsSlot::PeppersprayIcon' has a wrong offset!");
static_assert(offsetof(UMunitionsSlot, LockpickGunIcon) == 0x000350, "Member 'UMunitionsSlot::LockpickGunIcon' has a wrong offset!");
static_assert(offsetof(UMunitionsSlot, TaserIcon) == 0x000358, "Member 'UMunitionsSlot::TaserIcon' has a wrong offset!");
static_assert(offsetof(UMunitionsSlot, SlotItems) == 0x000360, "Member 'UMunitionsSlot::SlotItems' has a wrong offset!");

// Class ReadyOrNot.MunitionsSlotElement
// 0x0010 (0x02D0 - 0x02C0)
class UMunitionsSlotElement : public UUserWidget
{
public:
	class UImage*                                 ElementImage;                                      // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             ElementText;                                       // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MunitionsSlotElement">();
	}
	static class UMunitionsSlotElement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMunitionsSlotElement>();
	}
};
static_assert(alignof(UMunitionsSlotElement) == 0x000008, "Wrong alignment on UMunitionsSlotElement");
static_assert(sizeof(UMunitionsSlotElement) == 0x0002D0, "Wrong size on UMunitionsSlotElement");
static_assert(offsetof(UMunitionsSlotElement, ElementImage) == 0x0002C0, "Member 'UMunitionsSlotElement::ElementImage' has a wrong offset!");
static_assert(offsetof(UMunitionsSlotElement, ElementText) == 0x0002C8, "Member 'UMunitionsSlotElement::ElementText' has a wrong offset!");

// Class ReadyOrNot.MusicData
// 0x0088 (0x00B8 - 0x0030)
class UMusicData final : public UDataAsset
{
public:
	struct FMusicTrack                            PreplanningTrack;                                  // 0x0030(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FMusicTrack                            AmbientTrack;                                      // 0x0058(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FMusicTrack                            ActionTrack;                                       // 0x0080(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FMusicTrackFMOD                        FMODTracks;                                        // 0x00A8(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MusicData">();
	}
	static class UMusicData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMusicData>();
	}
};
static_assert(alignof(UMusicData) == 0x000008, "Wrong alignment on UMusicData");
static_assert(sizeof(UMusicData) == 0x0000B8, "Wrong size on UMusicData");
static_assert(offsetof(UMusicData, PreplanningTrack) == 0x000030, "Member 'UMusicData::PreplanningTrack' has a wrong offset!");
static_assert(offsetof(UMusicData, AmbientTrack) == 0x000058, "Member 'UMusicData::AmbientTrack' has a wrong offset!");
static_assert(offsetof(UMusicData, ActionTrack) == 0x000080, "Member 'UMusicData::ActionTrack' has a wrong offset!");
static_assert(offsetof(UMusicData, FMODTracks) == 0x0000A8, "Member 'UMusicData::FMODTracks' has a wrong offset!");

// Class ReadyOrNot.NavQuery_DoorTest
// 0x0000 (0x0048 - 0x0048)
class UNavQuery_DoorTest final : public UNavigationQueryFilter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavQuery_DoorTest">();
	}
	static class UNavQuery_DoorTest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavQuery_DoorTest>();
	}
};
static_assert(alignof(UNavQuery_DoorTest) == 0x000008, "Wrong alignment on UNavQuery_DoorTest");
static_assert(sizeof(UNavQuery_DoorTest) == 0x000048, "Wrong size on UNavQuery_DoorTest");

// Class ReadyOrNot.MusicManager
// 0x0020 (0x0050 - 0x0030)
class UMusicManager final : public UWorldSubsystem
{
public:
	class UFMODEvent*                             MusicEvent;                                        // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFMODEventInstance                     MusicEventInst;                                    // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FTimerHandle                           TH_UpdateMusicParameters;                          // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PauseMusicParametersUpdate();
	void ResumeMusicParametersUpdate();
	void SetMusicParameterValue(const class FString& ParamName, float ParamValue);
	void StartMusicParametersUpdate();
	void StopMusicParametersUpdate();
	void StopTheMusic(bool bGoHome);
	void UpdateMusicParameters();

	TArray<class FString> GetMusicParameters() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MusicManager">();
	}
	static class UMusicManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMusicManager>();
	}
};
static_assert(alignof(UMusicManager) == 0x000008, "Wrong alignment on UMusicManager");
static_assert(sizeof(UMusicManager) == 0x000050, "Wrong size on UMusicManager");
static_assert(offsetof(UMusicManager, MusicEvent) == 0x000030, "Member 'UMusicManager::MusicEvent' has a wrong offset!");
static_assert(offsetof(UMusicManager, MusicEventInst) == 0x000038, "Member 'UMusicManager::MusicEventInst' has a wrong offset!");
static_assert(offsetof(UMusicManager, TH_UpdateMusicParameters) == 0x000040, "Member 'UMusicManager::TH_UpdateMusicParameters' has a wrong offset!");

// Class ReadyOrNot.MusicSequencerBase
// 0x0008 (0x02A0 - 0x0298)
class AMusicSequencerBase : public AActor
{
public:
	class USceneComponent*                        Scene;                                             // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void Multicast_ResetAudio();
	void Multicast_StartTransitioningToState(EMusicState NewState);
	void Multicast_StopAudio();
	void OnAudioReset();
	void OnStartedTransitioningToState(EMusicState NewState);
	void OnStoppedAudio();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MusicSequencerBase">();
	}
	static class AMusicSequencerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMusicSequencerBase>();
	}
};
static_assert(alignof(AMusicSequencerBase) == 0x000008, "Wrong alignment on AMusicSequencerBase");
static_assert(sizeof(AMusicSequencerBase) == 0x0002A0, "Wrong size on AMusicSequencerBase");
static_assert(offsetof(AMusicSequencerBase, Scene) == 0x000298, "Member 'AMusicSequencerBase::Scene' has a wrong offset!");

// Class ReadyOrNot.MusicSequencerUnreal
// 0x0030 (0x02D0 - 0x02A0)
class AMusicSequencerUnreal final : public AMusicSequencerBase
{
public:
	uint8                                         Pad_2A0[0x20];                                     // 0x02A0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UAudioComponent*                        AudioPlayer;                                       // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMusicState                                   CurrentState;                                      // 0x02C8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMusicState                                   NextState;                                         // 0x02C9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMusicState                                   NextScriptedState;                                 // 0x02CA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CB[0x5];                                      // 0x02CB(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAudioFinished();
	void OnAudioPlaybackPercent(const class USoundWave* PlayingSoundWave, const float PlaybackPercent);
	void PlayScriptedMusic(class USoundCue* Music, EMusicState NewScriptedState, bool bImmediately);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MusicSequencerUnreal">();
	}
	static class AMusicSequencerUnreal* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMusicSequencerUnreal>();
	}
};
static_assert(alignof(AMusicSequencerUnreal) == 0x000008, "Wrong alignment on AMusicSequencerUnreal");
static_assert(sizeof(AMusicSequencerUnreal) == 0x0002D0, "Wrong size on AMusicSequencerUnreal");
static_assert(offsetof(AMusicSequencerUnreal, AudioPlayer) == 0x0002C0, "Member 'AMusicSequencerUnreal::AudioPlayer' has a wrong offset!");
static_assert(offsetof(AMusicSequencerUnreal, CurrentState) == 0x0002C8, "Member 'AMusicSequencerUnreal::CurrentState' has a wrong offset!");
static_assert(offsetof(AMusicSequencerUnreal, NextState) == 0x0002C9, "Member 'AMusicSequencerUnreal::NextState' has a wrong offset!");
static_assert(offsetof(AMusicSequencerUnreal, NextScriptedState) == 0x0002CA, "Member 'AMusicSequencerUnreal::NextScriptedState' has a wrong offset!");

// Class ReadyOrNot.NameTag
// 0x0058 (0x0300 - 0x02A8)
class ANameTag final : public ACustomizationExtra
{
public:
	TSoftObjectPtr<class UFont>                   Font;                                              // 0x02A8(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FontFace;                                          // 0x02D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FontSize;                                          // 0x02D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaterialIndex;                                     // 0x02DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MaterialParameter;                                 // 0x02E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x02E8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               MaterialInstance;                                  // 0x02F0(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextureRenderTarget2D*                 RenderTarget;                                      // 0x02F8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NameTag">();
	}
	static class ANameTag* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANameTag>();
	}
};
static_assert(alignof(ANameTag) == 0x000008, "Wrong alignment on ANameTag");
static_assert(sizeof(ANameTag) == 0x000300, "Wrong size on ANameTag");
static_assert(offsetof(ANameTag, Font) == 0x0002A8, "Member 'ANameTag::Font' has a wrong offset!");
static_assert(offsetof(ANameTag, FontFace) == 0x0002D0, "Member 'ANameTag::FontFace' has a wrong offset!");
static_assert(offsetof(ANameTag, FontSize) == 0x0002D8, "Member 'ANameTag::FontSize' has a wrong offset!");
static_assert(offsetof(ANameTag, MaterialIndex) == 0x0002DC, "Member 'ANameTag::MaterialIndex' has a wrong offset!");
static_assert(offsetof(ANameTag, MaterialParameter) == 0x0002E0, "Member 'ANameTag::MaterialParameter' has a wrong offset!");
static_assert(offsetof(ANameTag, StaticMeshComponent) == 0x0002E8, "Member 'ANameTag::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(ANameTag, MaterialInstance) == 0x0002F0, "Member 'ANameTag::MaterialInstance' has a wrong offset!");
static_assert(offsetof(ANameTag, RenderTarget) == 0x0002F8, "Member 'ANameTag::RenderTarget' has a wrong offset!");

// Class ReadyOrNot.RandomSubLevelController
// 0x0020 (0x02B8 - 0x0298)
class ARandomSubLevelController final : public AActor
{
public:
	bool                                          bIsEnabled;                                        // 0x0298(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_299[0x7];                                      // 0x0299(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           PossibleLevels;                                    // 0x02A0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	int32                                         NumLevelsToLoad;                                   // 0x02B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B4[0x4];                                      // 0x02B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TArray<class FString> GetStreamingLevelOptions() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RandomSubLevelController">();
	}
	static class ARandomSubLevelController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARandomSubLevelController>();
	}
};
static_assert(alignof(ARandomSubLevelController) == 0x000008, "Wrong alignment on ARandomSubLevelController");
static_assert(sizeof(ARandomSubLevelController) == 0x0002B8, "Wrong size on ARandomSubLevelController");
static_assert(offsetof(ARandomSubLevelController, bIsEnabled) == 0x000298, "Member 'ARandomSubLevelController::bIsEnabled' has a wrong offset!");
static_assert(offsetof(ARandomSubLevelController, PossibleLevels) == 0x0002A0, "Member 'ARandomSubLevelController::PossibleLevels' has a wrong offset!");
static_assert(offsetof(ARandomSubLevelController, NumLevelsToLoad) == 0x0002B0, "Member 'ARandomSubLevelController::NumLevelsToLoad' has a wrong offset!");

// Class ReadyOrNot.NavigationSplinePathPreview
// 0x0080 (0x0318 - 0x0298)
class ANavigationSplinePathPreview final : public AActor
{
public:
	float                                         PathPointDistanceThreshold;                        // 0x0298(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PathPointSubStep;                                  // 0x029C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bDrawRawPath : 1;                                  // 0x02A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDrawRawPathPoints : 1;                            // 0x02A0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDrawSmoothedPath : 1;                             // 0x02A0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDrawSmoothedPathPoints : 1;                       // 0x02A0(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDrawSmoothedPathPointsDetail : 1;                 // 0x02A0(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_2A1[0x3];                                      // 0x02A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PathLineThickness;                                 // 0x02A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A8[0x70];                                     // 0x02A8(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavigationSplinePathPreview">();
	}
	static class ANavigationSplinePathPreview* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANavigationSplinePathPreview>();
	}
};
static_assert(alignof(ANavigationSplinePathPreview) == 0x000008, "Wrong alignment on ANavigationSplinePathPreview");
static_assert(sizeof(ANavigationSplinePathPreview) == 0x000318, "Wrong size on ANavigationSplinePathPreview");
static_assert(offsetof(ANavigationSplinePathPreview, PathPointDistanceThreshold) == 0x000298, "Member 'ANavigationSplinePathPreview::PathPointDistanceThreshold' has a wrong offset!");
static_assert(offsetof(ANavigationSplinePathPreview, PathPointSubStep) == 0x00029C, "Member 'ANavigationSplinePathPreview::PathPointSubStep' has a wrong offset!");
static_assert(offsetof(ANavigationSplinePathPreview, PathLineThickness) == 0x0002A4, "Member 'ANavigationSplinePathPreview::PathLineThickness' has a wrong offset!");

// Class ReadyOrNot.NavSplinePathRenderingComponent
// 0x00B0 (0x0620 - 0x0570)
class UNavSplinePathRenderingComponent final : public UPrimitiveComponent
{
public:
	uint8                                         Pad_570[0xB0];                                     // 0x0570(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavSplinePathRenderingComponent">();
	}
	static class UNavSplinePathRenderingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavSplinePathRenderingComponent>();
	}
};
static_assert(alignof(UNavSplinePathRenderingComponent) == 0x000010, "Wrong alignment on UNavSplinePathRenderingComponent");
static_assert(sizeof(UNavSplinePathRenderingComponent) == 0x000620, "Wrong size on UNavSplinePathRenderingComponent");

// Class ReadyOrNot.NeutralizeSuspectByTag
// 0x0018 (0x0338 - 0x0320)
class ANeutralizeSuspectByTag final : public AObjective
{
public:
	class ACyberneticCharacter*                   suspect;                                           // 0x0320(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   SuspectTag;                                        // 0x0328(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequireArrest;                                    // 0x0330(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowIncapacitation;                              // 0x0331(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_332[0x6];                                      // 0x0332(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAISpawned();
	void OnSuspectKilled(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NeutralizeSuspectByTag">();
	}
	static class ANeutralizeSuspectByTag* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANeutralizeSuspectByTag>();
	}
};
static_assert(alignof(ANeutralizeSuspectByTag) == 0x000008, "Wrong alignment on ANeutralizeSuspectByTag");
static_assert(sizeof(ANeutralizeSuspectByTag) == 0x000338, "Wrong size on ANeutralizeSuspectByTag");
static_assert(offsetof(ANeutralizeSuspectByTag, suspect) == 0x000320, "Member 'ANeutralizeSuspectByTag::suspect' has a wrong offset!");
static_assert(offsetof(ANeutralizeSuspectByTag, SuspectTag) == 0x000328, "Member 'ANeutralizeSuspectByTag::SuspectTag' has a wrong offset!");
static_assert(offsetof(ANeutralizeSuspectByTag, bRequireArrest) == 0x000330, "Member 'ANeutralizeSuspectByTag::bRequireArrest' has a wrong offset!");
static_assert(offsetof(ANeutralizeSuspectByTag, bAllowIncapacitation) == 0x000331, "Member 'ANeutralizeSuspectByTag::bAllowIncapacitation' has a wrong offset!");

// Class ReadyOrNot.NightvisionGoggles
// 0x0740 (0x2210 - 0x1AD0)
class ANightvisionGoggles : public AHeadwear
{
public:
	class UUserWidget*                            SpawnedWidget;                                     // 0x1AC8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             Green_LUT;                                         // 0x1AD0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             White_LUT;                                         // 0x1AD8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PostProcessingEffectName;                          // 0x1AE0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialParameterCollection*           GlobalMaterialParameters;                          // 0x1AE8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NVGGlobalParameterName;                            // 0x1AF0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UUserWidget>                NightVisionFirstPersonWidget;                      // 0x1AF8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FirstPersonCameraOffset;                           // 0x1B00(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENVGStyle                                     NvgStyle;                                          // 0x1B04(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B05[0xB];                                     // 0x1B05(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPostProcessSettings                   NightVisionPostProcess;                            // 0x1B10(0x06E0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bNVGOn;                                            // 0x21F0(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTogglingNVG;                                      // 0x21F1(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21F2[0x6];                                     // 0x21F2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UDamageType>>        BlockDamageTypesWhileActive;                       // 0x21F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_2208[0x8];                                     // 0x2208(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DestroyNightvisionWidget();
	void OnNightvisionActivated();
	void OnNightvisionDeactivated();
	void Server_SetTogglingNVG(bool bNewTogglingNVG);
	void SpawnNightvisionWidget();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NightvisionGoggles">();
	}
	static class ANightvisionGoggles* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANightvisionGoggles>();
	}
};
static_assert(alignof(ANightvisionGoggles) == 0x000010, "Wrong alignment on ANightvisionGoggles");
static_assert(sizeof(ANightvisionGoggles) == 0x002210, "Wrong size on ANightvisionGoggles");
static_assert(offsetof(ANightvisionGoggles, SpawnedWidget) == 0x001AC8, "Member 'ANightvisionGoggles::SpawnedWidget' has a wrong offset!");
static_assert(offsetof(ANightvisionGoggles, Green_LUT) == 0x001AD0, "Member 'ANightvisionGoggles::Green_LUT' has a wrong offset!");
static_assert(offsetof(ANightvisionGoggles, White_LUT) == 0x001AD8, "Member 'ANightvisionGoggles::White_LUT' has a wrong offset!");
static_assert(offsetof(ANightvisionGoggles, PostProcessingEffectName) == 0x001AE0, "Member 'ANightvisionGoggles::PostProcessingEffectName' has a wrong offset!");
static_assert(offsetof(ANightvisionGoggles, GlobalMaterialParameters) == 0x001AE8, "Member 'ANightvisionGoggles::GlobalMaterialParameters' has a wrong offset!");
static_assert(offsetof(ANightvisionGoggles, NVGGlobalParameterName) == 0x001AF0, "Member 'ANightvisionGoggles::NVGGlobalParameterName' has a wrong offset!");
static_assert(offsetof(ANightvisionGoggles, NightVisionFirstPersonWidget) == 0x001AF8, "Member 'ANightvisionGoggles::NightVisionFirstPersonWidget' has a wrong offset!");
static_assert(offsetof(ANightvisionGoggles, FirstPersonCameraOffset) == 0x001B00, "Member 'ANightvisionGoggles::FirstPersonCameraOffset' has a wrong offset!");
static_assert(offsetof(ANightvisionGoggles, NvgStyle) == 0x001B04, "Member 'ANightvisionGoggles::NvgStyle' has a wrong offset!");
static_assert(offsetof(ANightvisionGoggles, NightVisionPostProcess) == 0x001B10, "Member 'ANightvisionGoggles::NightVisionPostProcess' has a wrong offset!");
static_assert(offsetof(ANightvisionGoggles, bNVGOn) == 0x0021F0, "Member 'ANightvisionGoggles::bNVGOn' has a wrong offset!");
static_assert(offsetof(ANightvisionGoggles, bTogglingNVG) == 0x0021F1, "Member 'ANightvisionGoggles::bTogglingNVG' has a wrong offset!");
static_assert(offsetof(ANightvisionGoggles, BlockDamageTypesWhileActive) == 0x0021F8, "Member 'ANightvisionGoggles::BlockDamageTypesWhileActive' has a wrong offset!");

// Class ReadyOrNot.ReadyOrNotAISystem
// 0x0000 (0x01A0 - 0x01A0)
class UReadyOrNotAISystem final : public UAISystem
{
public:
	static bool ProjectPointToNav(const struct FVector& Point, struct FVector* OutLocation, const struct FVector& Extent);
	static bool WasRecentlyInCombat(float SinceSeconds, bool bCivilianCheck);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotAISystem">();
	}
	static class UReadyOrNotAISystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotAISystem>();
	}
};
static_assert(alignof(UReadyOrNotAISystem) == 0x000008, "Wrong alignment on UReadyOrNotAISystem");
static_assert(sizeof(UReadyOrNotAISystem) == 0x0001A0, "Wrong size on UReadyOrNotAISystem");

// Class ReadyOrNot.NinebangDamageType
// 0x0000 (0x07B0 - 0x07B0)
class UNinebangDamageType : public UStunDamage
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NinebangDamageType">();
	}
	static class UNinebangDamageType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNinebangDamageType>();
	}
};
static_assert(alignof(UNinebangDamageType) == 0x000010, "Wrong alignment on UNinebangDamageType");
static_assert(sizeof(UNinebangDamageType) == 0x0007B0, "Wrong size on UNinebangDamageType");

// Class ReadyOrNot.ObituaryData
// 0x0060 (0x0090 - 0x0030)
class UObituaryData final : public UDataAsset
{
public:
	TMap<class FName, struct FObituaryForBone>    PointDeathMessages;                                // 0x0030(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<class FText>                           DefaultBulletDeathText;                            // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObituaryData">();
	}
	static class UObituaryData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObituaryData>();
	}
};
static_assert(alignof(UObituaryData) == 0x000008, "Wrong alignment on UObituaryData");
static_assert(sizeof(UObituaryData) == 0x000090, "Wrong size on UObituaryData");
static_assert(offsetof(UObituaryData, PointDeathMessages) == 0x000030, "Member 'UObituaryData::PointDeathMessages' has a wrong offset!");
static_assert(offsetof(UObituaryData, DefaultBulletDeathText) == 0x000080, "Member 'UObituaryData::DefaultBulletDeathText' has a wrong offset!");

// Class ReadyOrNot.ObjectiveMarkerComponent
// 0x0180 (0x0870 - 0x06F0)
class UObjectiveMarkerComponent final : public UWidgetComponent
{
public:
	uint8                                         bEnabled : 1;                                      // 0x06E8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bStartHidden : 1;                                  // 0x06E8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_6E8_2 : 1;                                  // 0x06E8(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bCustomLocation : 1;                               // 0x06E8(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFadeOffscreen : 1;                                // 0x06E8(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDistanceScaleIcon : 1;                            // 0x06E8(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bHideIconOffscreen : 1;                            // 0x06E8(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCompletelyFadeWhenOverlappingOtherWidgets : 1;    // 0x06E8(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCompletelyFadeWhenClose : 1;                      // 0x06E9(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_6EA[0x2];                                      // 0x06EA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FadeAtDistance_Close;                              // 0x06EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bCompletelyFadeWhenFar : 1;                        // 0x06F0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_6F1[0x3];                                      // 0x06F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FadeAtDistance_Far;                                // 0x06F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bHideDistanceInfo : 1;                             // 0x06F8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_6F9[0x3];                                      // 0x06F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HideDistanceInfoAtDistance;                        // 0x06FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bHideDirectionalArrow : 1;                         // 0x0700(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDisplayMarkerText : 1;                            // 0x0700(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_701[0x7];                                      // 0x0701(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   MarkerText;                                        // 0x0708(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSubclassOf<class UObjectiveMarkerWidget>     MarkerWidgetClass;                                 // 0x0720(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_728[0x8];                                      // 0x0728(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            IconBrush;                                         // 0x0730(0x00D0)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FLinearColor                           IconColorAndOpacity;                               // 0x0800(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              IconSize;                                          // 0x0810(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bDebug : 1;                                        // 0x0820(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_821[0x7];                                      // 0x0821(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UObjectiveMarkerWidget*                 ObjectiveMarkerWidget_Offscreen;                   // 0x0828(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UObjectiveMarkerWidget*                 ObjectiveMarkerWidget_Onscreen;                    // 0x0830(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsOffscreen;                                      // 0x0838(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRequestingFadeOut;                                // 0x0839(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_83A[0x36];                                     // 0x083A(0x0036)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DisableObjectiveMarker();
	void EnableObjectiveMarker();
	void HideIcon();
	void HideMarkerText();
	void HideObjectiveMarker(bool bFadeOut);
	void SetIconBrush(const struct FSlateBrush& NewIconBrush);
	void SetIconColor(const struct FLinearColor& InIconColorAndOpacity);
	void SetIconSize(const struct FVector2D& NewIconSize);
	void SetMarkerText(const class FText& NewMarkerText);
	void SetMarkerTextColor(const struct FLinearColor& InIconColorAndOpacity);
	void SetMarkerTextFontSize(int32 NewFontSize);
	void SetNewFadeDistance(float NewDistance);
	void ShowIcon();
	void ShowMarkerText();
	void ShowObjectiveMarker();
	void ToggleObjectiveMarkerVisibility();

	bool CanShowObjectiveMarker() const;
	bool IsObjectiveMarkerOffscreen() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectiveMarkerComponent">();
	}
	static class UObjectiveMarkerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectiveMarkerComponent>();
	}
};
static_assert(alignof(UObjectiveMarkerComponent) == 0x000010, "Wrong alignment on UObjectiveMarkerComponent");
static_assert(sizeof(UObjectiveMarkerComponent) == 0x000870, "Wrong size on UObjectiveMarkerComponent");
static_assert(offsetof(UObjectiveMarkerComponent, FadeAtDistance_Close) == 0x0006EC, "Member 'UObjectiveMarkerComponent::FadeAtDistance_Close' has a wrong offset!");
static_assert(offsetof(UObjectiveMarkerComponent, FadeAtDistance_Far) == 0x0006F4, "Member 'UObjectiveMarkerComponent::FadeAtDistance_Far' has a wrong offset!");
static_assert(offsetof(UObjectiveMarkerComponent, HideDistanceInfoAtDistance) == 0x0006FC, "Member 'UObjectiveMarkerComponent::HideDistanceInfoAtDistance' has a wrong offset!");
static_assert(offsetof(UObjectiveMarkerComponent, MarkerText) == 0x000708, "Member 'UObjectiveMarkerComponent::MarkerText' has a wrong offset!");
static_assert(offsetof(UObjectiveMarkerComponent, MarkerWidgetClass) == 0x000720, "Member 'UObjectiveMarkerComponent::MarkerWidgetClass' has a wrong offset!");
static_assert(offsetof(UObjectiveMarkerComponent, IconBrush) == 0x000730, "Member 'UObjectiveMarkerComponent::IconBrush' has a wrong offset!");
static_assert(offsetof(UObjectiveMarkerComponent, IconColorAndOpacity) == 0x000800, "Member 'UObjectiveMarkerComponent::IconColorAndOpacity' has a wrong offset!");
static_assert(offsetof(UObjectiveMarkerComponent, IconSize) == 0x000810, "Member 'UObjectiveMarkerComponent::IconSize' has a wrong offset!");
static_assert(offsetof(UObjectiveMarkerComponent, ObjectiveMarkerWidget_Offscreen) == 0x000828, "Member 'UObjectiveMarkerComponent::ObjectiveMarkerWidget_Offscreen' has a wrong offset!");
static_assert(offsetof(UObjectiveMarkerComponent, ObjectiveMarkerWidget_Onscreen) == 0x000830, "Member 'UObjectiveMarkerComponent::ObjectiveMarkerWidget_Onscreen' has a wrong offset!");
static_assert(offsetof(UObjectiveMarkerComponent, bIsOffscreen) == 0x000838, "Member 'UObjectiveMarkerComponent::bIsOffscreen' has a wrong offset!");
static_assert(offsetof(UObjectiveMarkerComponent, bRequestingFadeOut) == 0x000839, "Member 'UObjectiveMarkerComponent::bRequestingFadeOut' has a wrong offset!");

// Class ReadyOrNot.ObjectiveMarkerWidget
// 0x0060 (0x0348 - 0x02E8)
class UObjectiveMarkerWidget : public UBaseWidget
{
public:
	class UObjectiveMarkerComponent*              ParentComponent;                                   // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           RootCanvasPanel;                                   // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USizeBox*                               Icon_SizeBox;                                      // 0x02F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Icon_Image;                                        // 0x0300(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 DirectionalArrow_Image;                            // 0x0308(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             DistanceInMeters_Text;                             // 0x0310(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             MarkerName_Text;                                   // 0x0318(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                Location;                                          // 0x0320(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DistanceToLocalPlayer;                             // 0x0338(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DirectionAngle;                                    // 0x033C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bHideDistance : 1;                                 // 0x0340(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_341[0x7];                                      // 0x0341(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HideAll();
	void HideIcon();
	void HideMarkerText();
	void OnMarkerVisibilityDisabled();
	void OnMarkerVisibilityEnabled();
	void SetDirectionAngle(float Angle);
	void SetIconColorAndOpacity(const struct FLinearColor& InColor);
	void SetIconImage(const struct FSlateBrush& InBrush);
	void SetIconSize(const struct FVector2D& NewIconSize);
	void SetMarkerNameText(const class FText& NewMarkerNameText);
	void SetMarkerNameTextColorAndOpacity(const struct FLinearColor& InColor);
	void SetMarkerNameTextFontSize(int32 NewFontSize);
	void SetTargetLocation(const struct FVector& NewLocation);
	void ShowAll();
	void ShowIcon();
	void ShowMarkerText();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectiveMarkerWidget">();
	}
	static class UObjectiveMarkerWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectiveMarkerWidget>();
	}
};
static_assert(alignof(UObjectiveMarkerWidget) == 0x000008, "Wrong alignment on UObjectiveMarkerWidget");
static_assert(sizeof(UObjectiveMarkerWidget) == 0x000348, "Wrong size on UObjectiveMarkerWidget");
static_assert(offsetof(UObjectiveMarkerWidget, ParentComponent) == 0x0002E8, "Member 'UObjectiveMarkerWidget::ParentComponent' has a wrong offset!");
static_assert(offsetof(UObjectiveMarkerWidget, RootCanvasPanel) == 0x0002F0, "Member 'UObjectiveMarkerWidget::RootCanvasPanel' has a wrong offset!");
static_assert(offsetof(UObjectiveMarkerWidget, Icon_SizeBox) == 0x0002F8, "Member 'UObjectiveMarkerWidget::Icon_SizeBox' has a wrong offset!");
static_assert(offsetof(UObjectiveMarkerWidget, Icon_Image) == 0x000300, "Member 'UObjectiveMarkerWidget::Icon_Image' has a wrong offset!");
static_assert(offsetof(UObjectiveMarkerWidget, DirectionalArrow_Image) == 0x000308, "Member 'UObjectiveMarkerWidget::DirectionalArrow_Image' has a wrong offset!");
static_assert(offsetof(UObjectiveMarkerWidget, DistanceInMeters_Text) == 0x000310, "Member 'UObjectiveMarkerWidget::DistanceInMeters_Text' has a wrong offset!");
static_assert(offsetof(UObjectiveMarkerWidget, MarkerName_Text) == 0x000318, "Member 'UObjectiveMarkerWidget::MarkerName_Text' has a wrong offset!");
static_assert(offsetof(UObjectiveMarkerWidget, Location) == 0x000320, "Member 'UObjectiveMarkerWidget::Location' has a wrong offset!");
static_assert(offsetof(UObjectiveMarkerWidget, DistanceToLocalPlayer) == 0x000338, "Member 'UObjectiveMarkerWidget::DistanceToLocalPlayer' has a wrong offset!");
static_assert(offsetof(UObjectiveMarkerWidget, DirectionAngle) == 0x00033C, "Member 'UObjectiveMarkerWidget::DirectionAngle' has a wrong offset!");

// Class ReadyOrNot.ReadyOrNotAvoidanceManager
// 0x0010 (0x0050 - 0x0040)
class UReadyOrNotAvoidanceManager final : public UTickableWorldSubsystem
{
public:
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotAvoidanceManager">();
	}
	static class UReadyOrNotAvoidanceManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotAvoidanceManager>();
	}
};
static_assert(alignof(UReadyOrNotAvoidanceManager) == 0x000008, "Wrong alignment on UReadyOrNotAvoidanceManager");
static_assert(sizeof(UReadyOrNotAvoidanceManager) == 0x000050, "Wrong size on UReadyOrNotAvoidanceManager");

// Class ReadyOrNot.ObjectivePoint
// 0x0018 (0x02B0 - 0x0298)
class AObjectivePoint final : public AActor
{
public:
	class AActor*                                 TiedToActor;                                       // 0x0298(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObjectiveMarkerComponent*              ObjectiveMarkerComponent;                          // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMapActorComponent*                     MapActorComponent;                                 // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void HideObjectiveMarker();
	void InitSettings(const struct FSlateBrush& Icon, const class FText& Text, float ShowMarkerAtDistance);
	void ShowObjectiveMarker();
	void ToggleObjectiveMarkerVisibility();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectivePoint">();
	}
	static class AObjectivePoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AObjectivePoint>();
	}
};
static_assert(alignof(AObjectivePoint) == 0x000008, "Wrong alignment on AObjectivePoint");
static_assert(sizeof(AObjectivePoint) == 0x0002B0, "Wrong size on AObjectivePoint");
static_assert(offsetof(AObjectivePoint, TiedToActor) == 0x000298, "Member 'AObjectivePoint::TiedToActor' has a wrong offset!");
static_assert(offsetof(AObjectivePoint, ObjectiveMarkerComponent) == 0x0002A0, "Member 'AObjectivePoint::ObjectiveMarkerComponent' has a wrong offset!");
static_assert(offsetof(AObjectivePoint, MapActorComponent) == 0x0002A8, "Member 'AObjectivePoint::MapActorComponent' has a wrong offset!");

// Class ReadyOrNot.OcclusionTestActor
// 0x0048 (0x02E0 - 0x0298)
class AOcclusionTestActor final : public AActor
{
public:
	float                                         OcclusionMultiplier;                               // 0x0298(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FullOcclusionDepth;                                // 0x029C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TickInterval;                                      // 0x02A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          GunshotOrFootstep;                                 // 0x02A4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A5[0x3];                                      // 0x02A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             GunshotSound;                                      // 0x02A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsOutside;                                        // 0x02B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B1[0x7];                                      // 0x02B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             FootstepSound;                                     // 0x02B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             FoleySound;                                        // 0x02C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHeavyArmor;                                       // 0x02C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCrouching;                                      // 0x02C9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CA[0x6];                                      // 0x02CA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODAudioPropagationComponent*         FMODAudioPropagationComp;                          // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODAudioComponent*                    AudioComponent;                                    // 0x02D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OcclusionTestActor">();
	}
	static class AOcclusionTestActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOcclusionTestActor>();
	}
};
static_assert(alignof(AOcclusionTestActor) == 0x000008, "Wrong alignment on AOcclusionTestActor");
static_assert(sizeof(AOcclusionTestActor) == 0x0002E0, "Wrong size on AOcclusionTestActor");
static_assert(offsetof(AOcclusionTestActor, OcclusionMultiplier) == 0x000298, "Member 'AOcclusionTestActor::OcclusionMultiplier' has a wrong offset!");
static_assert(offsetof(AOcclusionTestActor, FullOcclusionDepth) == 0x00029C, "Member 'AOcclusionTestActor::FullOcclusionDepth' has a wrong offset!");
static_assert(offsetof(AOcclusionTestActor, TickInterval) == 0x0002A0, "Member 'AOcclusionTestActor::TickInterval' has a wrong offset!");
static_assert(offsetof(AOcclusionTestActor, GunshotOrFootstep) == 0x0002A4, "Member 'AOcclusionTestActor::GunshotOrFootstep' has a wrong offset!");
static_assert(offsetof(AOcclusionTestActor, GunshotSound) == 0x0002A8, "Member 'AOcclusionTestActor::GunshotSound' has a wrong offset!");
static_assert(offsetof(AOcclusionTestActor, bIsOutside) == 0x0002B0, "Member 'AOcclusionTestActor::bIsOutside' has a wrong offset!");
static_assert(offsetof(AOcclusionTestActor, FootstepSound) == 0x0002B8, "Member 'AOcclusionTestActor::FootstepSound' has a wrong offset!");
static_assert(offsetof(AOcclusionTestActor, FoleySound) == 0x0002C0, "Member 'AOcclusionTestActor::FoleySound' has a wrong offset!");
static_assert(offsetof(AOcclusionTestActor, bHeavyArmor) == 0x0002C8, "Member 'AOcclusionTestActor::bHeavyArmor' has a wrong offset!");
static_assert(offsetof(AOcclusionTestActor, bIsCrouching) == 0x0002C9, "Member 'AOcclusionTestActor::bIsCrouching' has a wrong offset!");
static_assert(offsetof(AOcclusionTestActor, FMODAudioPropagationComp) == 0x0002D0, "Member 'AOcclusionTestActor::FMODAudioPropagationComp' has a wrong offset!");
static_assert(offsetof(AOcclusionTestActor, AudioComponent) == 0x0002D8, "Member 'AOcclusionTestActor::AudioComponent' has a wrong offset!");

// Class ReadyOrNot.optiwand
// 0x0130 (0x0CE0 - 0x0BB0)
class Aoptiwand : public ABaseItem
{
public:
	class UAnimMontage*                           Montage_StartOptiwandADS;                          // 0x0BB0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Montage_EndOptiwandADS;                            // 0x0BB8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CollisionTraceDistance;                            // 0x0BC0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC4[0x4];                                      // 0x0BC4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             FMODOptiwandMove;                                  // 0x0BC8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             FMODOptiwandEnterView;                             // 0x0BD0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             FMODOptiwandExitView;                              // 0x0BD8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BE0[0x8];                                      // 0x0BE0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneCaptureComponent2D*               SceneCapture2D;                                    // 0x0BE8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextureRenderTarget2D*                 CameraRenderTarget;                                // 0x0BF0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACameraActor*                           CameraActor;                                       // 0x0BF8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                LookAtPosition;                                    // 0x0C00(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               LookAtRotation;                                    // 0x0C18(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               OptiwandCaptureRotation;                           // 0x0C30(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         bMirorring : 1;                                    // 0x0C48(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	bool                                          bRepMirroring;                                     // 0x0C49(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bInUse : 1;                                        // 0x0C4A(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_C4B[0x5];                                      // 0x0C4B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class ADoor*                                  LastUsedDoor;                                      // 0x0C50(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFMODAudioComponent*                    FMODOptiwandMoveAudioComp;                         // 0x0C58(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFMODAudioComponent*                    FMODOptiwandEnterViewComp;                         // 0x0C60(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFMODAudioComponent*                    FMODOptiwandExitViewComp;                          // 0x0C68(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C70[0x70];                                     // 0x0C70(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Server_NotifyMirroring(bool bIsMirroring);

	EOptiwandViewMode GetViewMode() const;
	bool IsCameraBlocked() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"optiwand">();
	}
	static class Aoptiwand* GetDefaultObj()
	{
		return GetDefaultObjImpl<Aoptiwand>();
	}
};
static_assert(alignof(Aoptiwand) == 0x000010, "Wrong alignment on Aoptiwand");
static_assert(sizeof(Aoptiwand) == 0x000CE0, "Wrong size on Aoptiwand");
static_assert(offsetof(Aoptiwand, Montage_StartOptiwandADS) == 0x000BB0, "Member 'Aoptiwand::Montage_StartOptiwandADS' has a wrong offset!");
static_assert(offsetof(Aoptiwand, Montage_EndOptiwandADS) == 0x000BB8, "Member 'Aoptiwand::Montage_EndOptiwandADS' has a wrong offset!");
static_assert(offsetof(Aoptiwand, CollisionTraceDistance) == 0x000BC0, "Member 'Aoptiwand::CollisionTraceDistance' has a wrong offset!");
static_assert(offsetof(Aoptiwand, FMODOptiwandMove) == 0x000BC8, "Member 'Aoptiwand::FMODOptiwandMove' has a wrong offset!");
static_assert(offsetof(Aoptiwand, FMODOptiwandEnterView) == 0x000BD0, "Member 'Aoptiwand::FMODOptiwandEnterView' has a wrong offset!");
static_assert(offsetof(Aoptiwand, FMODOptiwandExitView) == 0x000BD8, "Member 'Aoptiwand::FMODOptiwandExitView' has a wrong offset!");
static_assert(offsetof(Aoptiwand, SceneCapture2D) == 0x000BE8, "Member 'Aoptiwand::SceneCapture2D' has a wrong offset!");
static_assert(offsetof(Aoptiwand, CameraRenderTarget) == 0x000BF0, "Member 'Aoptiwand::CameraRenderTarget' has a wrong offset!");
static_assert(offsetof(Aoptiwand, CameraActor) == 0x000BF8, "Member 'Aoptiwand::CameraActor' has a wrong offset!");
static_assert(offsetof(Aoptiwand, LookAtPosition) == 0x000C00, "Member 'Aoptiwand::LookAtPosition' has a wrong offset!");
static_assert(offsetof(Aoptiwand, LookAtRotation) == 0x000C18, "Member 'Aoptiwand::LookAtRotation' has a wrong offset!");
static_assert(offsetof(Aoptiwand, OptiwandCaptureRotation) == 0x000C30, "Member 'Aoptiwand::OptiwandCaptureRotation' has a wrong offset!");
static_assert(offsetof(Aoptiwand, bRepMirroring) == 0x000C49, "Member 'Aoptiwand::bRepMirroring' has a wrong offset!");
static_assert(offsetof(Aoptiwand, LastUsedDoor) == 0x000C50, "Member 'Aoptiwand::LastUsedDoor' has a wrong offset!");
static_assert(offsetof(Aoptiwand, FMODOptiwandMoveAudioComp) == 0x000C58, "Member 'Aoptiwand::FMODOptiwandMoveAudioComp' has a wrong offset!");
static_assert(offsetof(Aoptiwand, FMODOptiwandEnterViewComp) == 0x000C60, "Member 'Aoptiwand::FMODOptiwandEnterViewComp' has a wrong offset!");
static_assert(offsetof(Aoptiwand, FMODOptiwandExitViewComp) == 0x000C68, "Member 'Aoptiwand::FMODOptiwandExitViewComp' has a wrong offset!");

// Class ReadyOrNot.OutOfBoundsVolume
// 0x0008 (0x02A0 - 0x0298)
class AOutOfBoundsVolume final : public AActor
{
public:
	class UBoxComponent*                          Bounds;                                            // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OutOfBoundsVolume">();
	}
	static class AOutOfBoundsVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOutOfBoundsVolume>();
	}
};
static_assert(alignof(AOutOfBoundsVolume) == 0x000008, "Wrong alignment on AOutOfBoundsVolume");
static_assert(sizeof(AOutOfBoundsVolume) == 0x0002A0, "Wrong size on AOutOfBoundsVolume");
static_assert(offsetof(AOutOfBoundsVolume, Bounds) == 0x000298, "Member 'AOutOfBoundsVolume::Bounds' has a wrong offset!");

// Class ReadyOrNot.ReadyOrNotCommandFunctionLibrary
// 0x0470 (0x0498 - 0x0028)
class UReadyOrNotCommandFunctionLibrary final : public UObject
{
public:
	TMulticastInlineDelegate<void()>              OnTeamChanged;                                     // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x440];                                     // 0x0038(0x0440)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 LastActorBeforeGoingIntoSubPage;                   // 0x0478(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_480[0x18];                                     // 0x0480(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RespondToSWATCommand(const struct FSwatCommand& Command, ETeamType TeamType, const struct FHitResult& CommandContextualData);

	bool HasQueuedCommandForActiveTeam() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotCommandFunctionLibrary">();
	}
	static class UReadyOrNotCommandFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotCommandFunctionLibrary>();
	}
};
static_assert(alignof(UReadyOrNotCommandFunctionLibrary) == 0x000008, "Wrong alignment on UReadyOrNotCommandFunctionLibrary");
static_assert(sizeof(UReadyOrNotCommandFunctionLibrary) == 0x000498, "Wrong size on UReadyOrNotCommandFunctionLibrary");
static_assert(offsetof(UReadyOrNotCommandFunctionLibrary, OnTeamChanged) == 0x000028, "Member 'UReadyOrNotCommandFunctionLibrary::OnTeamChanged' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCommandFunctionLibrary, LastActorBeforeGoingIntoSubPage) == 0x000478, "Member 'UReadyOrNotCommandFunctionLibrary::LastActorBeforeGoingIntoSubPage' has a wrong offset!");

// Class ReadyOrNot.Overview_V2
// 0x0018 (0x0428 - 0x0410)
class UOverview_V2 : public UCommonActivatableWidget
{
public:
	class FString                                 ActiveLoadoutName;                                 // 0x0410(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       SwitchCharacter;                                   // 0x0420(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SavePresets(const struct FSavedLoadout& Loadout, bool isNPC);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Overview_V2">();
	}
	static class UOverview_V2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOverview_V2>();
	}
};
static_assert(alignof(UOverview_V2) == 0x000008, "Wrong alignment on UOverview_V2");
static_assert(sizeof(UOverview_V2) == 0x000428, "Wrong size on UOverview_V2");
static_assert(offsetof(UOverview_V2, ActiveLoadoutName) == 0x000410, "Member 'UOverview_V2::ActiveLoadoutName' has a wrong offset!");
static_assert(offsetof(UOverview_V2, SwitchCharacter) == 0x000420, "Member 'UOverview_V2::SwitchCharacter' has a wrong offset!");

// Class ReadyOrNot.PageWidget
// 0x0000 (0x0410 - 0x0410)
class UPageWidget : public UCommonActivatableWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PageWidget">();
	}
	static class UPageWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPageWidget>();
	}
};
static_assert(alignof(UPageWidget) == 0x000008, "Wrong alignment on UPageWidget");
static_assert(sizeof(UPageWidget) == 0x000410, "Wrong size on UPageWidget");

// Class ReadyOrNot.PageFooter
// 0x0050 (0x0460 - 0x0410)
class UPageFooter : public UPageWidget
{
public:
	TMap<class FString, struct FScreenFooterEntry> FooterEntries;                                    // 0x0410(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	void GetInputActionData(const struct FDataTableRowHandle& InputActionRow, class FText* ActionName, struct FKey* ActionKey);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PageFooter">();
	}
	static class UPageFooter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPageFooter>();
	}
};
static_assert(alignof(UPageFooter) == 0x000008, "Wrong alignment on UPageFooter");
static_assert(sizeof(UPageFooter) == 0x000460, "Wrong size on UPageFooter");
static_assert(offsetof(UPageFooter, FooterEntries) == 0x000410, "Member 'UPageFooter::FooterEntries' has a wrong offset!");

// Class ReadyOrNot.PairedInteractionDriver
// 0x0178 (0x0410 - 0x0298)
class APairedInteractionDriver final : public AInfo
{
public:
	class UInteractionsData*                      InteractionData;                                   // 0x0298(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 Driver;                                            // 0x02A0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 Slave;                                             // 0x02A8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABaseItem*                              OptionalItem;                                      // 0x02B0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B8[0x100];                                    // 0x02B8(0x0100)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              Event_OnPairedInteractionStarted;                  // 0x03B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AActor* InActor)> Event_OnDriverInteractionFinished;         // 0x03C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AActor* InActor)> Event_OnSlaveInteractionFinished;          // 0x03D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AActor* InDriver, class AActor* InSlave)> Event_OnPairedInteractionFinished; // 0x03E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F8[0x18];                                     // 0x03F8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDriverInteractionFinished();
	void OnEquippedItemHolstered(class ABaseItem* Item);
	void OnInteractionFinished();
	void OnSlaveInteractionFinished();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PairedInteractionDriver">();
	}
	static class APairedInteractionDriver* GetDefaultObj()
	{
		return GetDefaultObjImpl<APairedInteractionDriver>();
	}
};
static_assert(alignof(APairedInteractionDriver) == 0x000008, "Wrong alignment on APairedInteractionDriver");
static_assert(sizeof(APairedInteractionDriver) == 0x000410, "Wrong size on APairedInteractionDriver");
static_assert(offsetof(APairedInteractionDriver, InteractionData) == 0x000298, "Member 'APairedInteractionDriver::InteractionData' has a wrong offset!");
static_assert(offsetof(APairedInteractionDriver, Driver) == 0x0002A0, "Member 'APairedInteractionDriver::Driver' has a wrong offset!");
static_assert(offsetof(APairedInteractionDriver, Slave) == 0x0002A8, "Member 'APairedInteractionDriver::Slave' has a wrong offset!");
static_assert(offsetof(APairedInteractionDriver, OptionalItem) == 0x0002B0, "Member 'APairedInteractionDriver::OptionalItem' has a wrong offset!");
static_assert(offsetof(APairedInteractionDriver, Event_OnPairedInteractionStarted) == 0x0003B8, "Member 'APairedInteractionDriver::Event_OnPairedInteractionStarted' has a wrong offset!");
static_assert(offsetof(APairedInteractionDriver, Event_OnDriverInteractionFinished) == 0x0003C8, "Member 'APairedInteractionDriver::Event_OnDriverInteractionFinished' has a wrong offset!");
static_assert(offsetof(APairedInteractionDriver, Event_OnSlaveInteractionFinished) == 0x0003D8, "Member 'APairedInteractionDriver::Event_OnSlaveInteractionFinished' has a wrong offset!");
static_assert(offsetof(APairedInteractionDriver, Event_OnPairedInteractionFinished) == 0x0003E8, "Member 'APairedInteractionDriver::Event_OnPairedInteractionFinished' has a wrong offset!");

// Class ReadyOrNot.PauseMenu_Wrapper
// 0x0020 (0x0308 - 0x02E8)
class UPauseMenu_Wrapper : public UCommonUserWidget
{
public:
	class UCommonActivatableWidgetStack*          WidgetStack;                                       // 0x02E8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCommonActivatableWidget*               PauseMenu;                                         // 0x02F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnPauseMenuClosed;                                 // 0x02F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void ClosePauseMenu();
	void OnOwnerKilled(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter);
	void OpenPauseMenu();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PauseMenu_Wrapper">();
	}
	static class UPauseMenu_Wrapper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPauseMenu_Wrapper>();
	}
};
static_assert(alignof(UPauseMenu_Wrapper) == 0x000008, "Wrong alignment on UPauseMenu_Wrapper");
static_assert(sizeof(UPauseMenu_Wrapper) == 0x000308, "Wrong size on UPauseMenu_Wrapper");
static_assert(offsetof(UPauseMenu_Wrapper, WidgetStack) == 0x0002E8, "Member 'UPauseMenu_Wrapper::WidgetStack' has a wrong offset!");
static_assert(offsetof(UPauseMenu_Wrapper, PauseMenu) == 0x0002F0, "Member 'UPauseMenu_Wrapper::PauseMenu' has a wrong offset!");
static_assert(offsetof(UPauseMenu_Wrapper, OnPauseMenuClosed) == 0x0002F8, "Member 'UPauseMenu_Wrapper::OnPauseMenuClosed' has a wrong offset!");

// Class ReadyOrNot.PepperballGun
// 0x0020 (0x1760 - 0x1740)
class APepperballGun : public ABaseMagazineWeapon
{
public:
	class UParticleSystemComponent*               ShootTrailComponent;                               // 0x1738(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        ParticleShootTrail;                                // 0x1740(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HeadshotsUntilAbuse;                               // 0x1748(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentHeadshotCounter;                            // 0x174C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StunShotsUntilAbuse;                               // 0x1750(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentStunShotCounter;                            // 0x1754(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxBallsInHopper;                                  // 0x1758(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BallsInHopper;                                     // 0x175C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void IncrementHeadshotCounter(class ACyberneticCharacter* HeadshottedPerson);
	void IncrementStunShotCounter(class ACyberneticCharacter* StunnedPerson);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PepperballGun">();
	}
	static class APepperballGun* GetDefaultObj()
	{
		return GetDefaultObjImpl<APepperballGun>();
	}
};
static_assert(alignof(APepperballGun) == 0x000010, "Wrong alignment on APepperballGun");
static_assert(sizeof(APepperballGun) == 0x001760, "Wrong size on APepperballGun");
static_assert(offsetof(APepperballGun, ShootTrailComponent) == 0x001738, "Member 'APepperballGun::ShootTrailComponent' has a wrong offset!");
static_assert(offsetof(APepperballGun, ParticleShootTrail) == 0x001740, "Member 'APepperballGun::ParticleShootTrail' has a wrong offset!");
static_assert(offsetof(APepperballGun, HeadshotsUntilAbuse) == 0x001748, "Member 'APepperballGun::HeadshotsUntilAbuse' has a wrong offset!");
static_assert(offsetof(APepperballGun, CurrentHeadshotCounter) == 0x00174C, "Member 'APepperballGun::CurrentHeadshotCounter' has a wrong offset!");
static_assert(offsetof(APepperballGun, StunShotsUntilAbuse) == 0x001750, "Member 'APepperballGun::StunShotsUntilAbuse' has a wrong offset!");
static_assert(offsetof(APepperballGun, CurrentStunShotCounter) == 0x001754, "Member 'APepperballGun::CurrentStunShotCounter' has a wrong offset!");
static_assert(offsetof(APepperballGun, MaxBallsInHopper) == 0x001758, "Member 'APepperballGun::MaxBallsInHopper' has a wrong offset!");
static_assert(offsetof(APepperballGun, BallsInHopper) == 0x00175C, "Member 'APepperballGun::BallsInHopper' has a wrong offset!");

// Class ReadyOrNot.PepperSprayDamageType
// 0x0000 (0x07B0 - 0x07B0)
class UPepperSprayDamageType : public UStunDamage
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PepperSprayDamageType">();
	}
	static class UPepperSprayDamageType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPepperSprayDamageType>();
	}
};
static_assert(alignof(UPepperSprayDamageType) == 0x000010, "Wrong alignment on UPepperSprayDamageType");
static_assert(sizeof(UPepperSprayDamageType) == 0x0007B0, "Wrong size on UPepperSprayDamageType");

// Class ReadyOrNot.PickupItemActivity
// 0x0020 (0x0210 - 0x01F0)
class UPickupItemActivity final : public UBaseActivity
{
public:
	float                                         SearchRadius;                                      // 0x01F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F4[0x4];                                      // 0x01F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AItemCacheActor*                        ItemCacheActor;                                    // 0x01F8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_200[0x8];                                      // 0x0200(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ABaseItem*                              PickupItem;                                        // 0x0208(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnPickupItemComplete();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PickupItemActivity">();
	}
	static class UPickupItemActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPickupItemActivity>();
	}
};
static_assert(alignof(UPickupItemActivity) == 0x000008, "Wrong alignment on UPickupItemActivity");
static_assert(sizeof(UPickupItemActivity) == 0x000210, "Wrong size on UPickupItemActivity");
static_assert(offsetof(UPickupItemActivity, SearchRadius) == 0x0001F0, "Member 'UPickupItemActivity::SearchRadius' has a wrong offset!");
static_assert(offsetof(UPickupItemActivity, ItemCacheActor) == 0x0001F8, "Member 'UPickupItemActivity::ItemCacheActor' has a wrong offset!");
static_assert(offsetof(UPickupItemActivity, PickupItem) == 0x000208, "Member 'UPickupItemActivity::PickupItem' has a wrong offset!");

// Class ReadyOrNot.PingInterface
// 0x0000 (0x0000 - 0x0000)
class IPingInterface final
{
public:
	bool CanPing();
	float GetPingDuration();
	struct FSlateBrush GetPingIcon();
	struct FVector GetPingLocation();
	class FText GetPingText();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PingInterface">();
	}
	static class IPingInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPingInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IPingInterface) == 0x000001, "Wrong alignment on IPingInterface");
static_assert(sizeof(IPingInterface) == 0x000001, "Wrong size on IPingInterface");

// Class ReadyOrNot.PlanningMapWidget
// 0x0018 (0x02D8 - 0x02C0)
class UPlanningMapWidget final : public UUserWidget
{
public:
	bool                                          bDrawable;                                         // 0x02C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C1[0x7];                                      // 0x02C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFloorMapPointData>             DrawPointData;                                     // 0x02C8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void AddPointData(const struct FVector2D& PointData, int32 FloorNum, EFreeDrawColor Color, bool bNewPoint, float Thickness);
	void ClearPointData(bool bClearAll, int32 FloorNum, bool bClearAllFloors);
	class UWorld* GetWorldContext();
	void OnForceMapRefresh();
	void OnPersonnelAdded(int32 PersonnelNum, int32 PersonnelZone);
	void OnPersonnelRemoved(int32 PersonnelNum);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlanningMapWidget">();
	}
	static class UPlanningMapWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlanningMapWidget>();
	}
};
static_assert(alignof(UPlanningMapWidget) == 0x000008, "Wrong alignment on UPlanningMapWidget");
static_assert(sizeof(UPlanningMapWidget) == 0x0002D8, "Wrong size on UPlanningMapWidget");
static_assert(offsetof(UPlanningMapWidget, bDrawable) == 0x0002C0, "Member 'UPlanningMapWidget::bDrawable' has a wrong offset!");
static_assert(offsetof(UPlanningMapWidget, DrawPointData) == 0x0002C8, "Member 'UPlanningMapWidget::DrawPointData' has a wrong offset!");

// Class ReadyOrNot.PlayableCharacterData
// 0x0100 (0x0130 - 0x0030)
class UPlayableCharacterData final : public UDataAsset
{
public:
	class FText                                   CharacterNameUI;                                   // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   CharacterName;                                     // 0x0048(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   CharacterRole;                                     // 0x0060(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   CharacterBio;                                      // 0x0078(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   CharacterRealName;                                 // 0x0090(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   CharacterYearsOfService;                           // 0x00A8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   CharacterDateOfBirth;                              // 0x00C0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FName                                   HandleName;                                        // 0x00D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           FaceMesh;                                          // 0x00E0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UPoseAsset>              FaceROM;                                           // 0x0108(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayableCharacterData">();
	}
	static class UPlayableCharacterData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayableCharacterData>();
	}
};
static_assert(alignof(UPlayableCharacterData) == 0x000008, "Wrong alignment on UPlayableCharacterData");
static_assert(sizeof(UPlayableCharacterData) == 0x000130, "Wrong size on UPlayableCharacterData");
static_assert(offsetof(UPlayableCharacterData, CharacterNameUI) == 0x000030, "Member 'UPlayableCharacterData::CharacterNameUI' has a wrong offset!");
static_assert(offsetof(UPlayableCharacterData, CharacterName) == 0x000048, "Member 'UPlayableCharacterData::CharacterName' has a wrong offset!");
static_assert(offsetof(UPlayableCharacterData, CharacterRole) == 0x000060, "Member 'UPlayableCharacterData::CharacterRole' has a wrong offset!");
static_assert(offsetof(UPlayableCharacterData, CharacterBio) == 0x000078, "Member 'UPlayableCharacterData::CharacterBio' has a wrong offset!");
static_assert(offsetof(UPlayableCharacterData, CharacterRealName) == 0x000090, "Member 'UPlayableCharacterData::CharacterRealName' has a wrong offset!");
static_assert(offsetof(UPlayableCharacterData, CharacterYearsOfService) == 0x0000A8, "Member 'UPlayableCharacterData::CharacterYearsOfService' has a wrong offset!");
static_assert(offsetof(UPlayableCharacterData, CharacterDateOfBirth) == 0x0000C0, "Member 'UPlayableCharacterData::CharacterDateOfBirth' has a wrong offset!");
static_assert(offsetof(UPlayableCharacterData, HandleName) == 0x0000D8, "Member 'UPlayableCharacterData::HandleName' has a wrong offset!");
static_assert(offsetof(UPlayableCharacterData, FaceMesh) == 0x0000E0, "Member 'UPlayableCharacterData::FaceMesh' has a wrong offset!");
static_assert(offsetof(UPlayableCharacterData, FaceROM) == 0x000108, "Member 'UPlayableCharacterData::FaceROM' has a wrong offset!");

// Class ReadyOrNot.PlayDeadSpot
// 0x0000 (0x0298 - 0x0298)
class APlayDeadSpot final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayDeadSpot">();
	}
	static class APlayDeadSpot* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayDeadSpot>();
	}
};
static_assert(alignof(APlayDeadSpot) == 0x000008, "Wrong alignment on APlayDeadSpot");
static_assert(sizeof(APlayDeadSpot) == 0x000298, "Wrong size on APlayDeadSpot");

// Class ReadyOrNot.PlayerActionPromptWidget
// 0x0040 (0x0328 - 0x02E8)
class UPlayerActionPromptWidget : public UBaseWidget
{
public:
	uint8                                         Pad_2E8[0x10];                                     // 0x02E8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ActionText;                                        // 0x02F8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, ExposeOnSpawn, NativeAccessSpecifierProtected)
	class URichTextBlock*                         Action_RichText;                                   // 0x0310(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       Anim_OnShow;                                       // 0x0318(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bInUse : 1;                                        // 0x0320(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_321[0x7];                                      // 0x0321(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearText();
	void OnScalingSet(float Scale);
	void SetUIScaling();
	void UpdateActionSlot(const class FText& InText, bool ClearText, bool bAnimate, bool bLoopAnimation);
	void UpdateText(const class FText& InText, bool bAnimate, bool bLoopAnimation);

	bool IsInUse() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerActionPromptWidget">();
	}
	static class UPlayerActionPromptWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerActionPromptWidget>();
	}
};
static_assert(alignof(UPlayerActionPromptWidget) == 0x000008, "Wrong alignment on UPlayerActionPromptWidget");
static_assert(sizeof(UPlayerActionPromptWidget) == 0x000328, "Wrong size on UPlayerActionPromptWidget");
static_assert(offsetof(UPlayerActionPromptWidget, ActionText) == 0x0002F8, "Member 'UPlayerActionPromptWidget::ActionText' has a wrong offset!");
static_assert(offsetof(UPlayerActionPromptWidget, Action_RichText) == 0x000310, "Member 'UPlayerActionPromptWidget::Action_RichText' has a wrong offset!");
static_assert(offsetof(UPlayerActionPromptWidget, Anim_OnShow) == 0x000318, "Member 'UPlayerActionPromptWidget::Anim_OnShow' has a wrong offset!");

// Class ReadyOrNot.PlayerHUD
// 0x0008 (0x0390 - 0x0388)
class APlayerHUD final : public AHUD
{
public:
	class UUserWidget*                            PlayerHUD;                                         // 0x0388(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static void SetCanvasTranslationByMouseDelta(class APlayerController* Controller, class UCanvasPanel* Widget, float DeltaSeconds, float InterpSpeed, float InputScale, float ClampAt);
	static void SetWidgetTranslationByMouseDelta(class APlayerController* Controller, class UUserWidget* Widget, float DeltaSeconds, float InterpSpeed, float InputScale, float ClampAt);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerHUD">();
	}
	static class APlayerHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayerHUD>();
	}
};
static_assert(alignof(APlayerHUD) == 0x000008, "Wrong alignment on APlayerHUD");
static_assert(sizeof(APlayerHUD) == 0x000390, "Wrong size on APlayerHUD");
static_assert(offsetof(APlayerHUD, PlayerHUD) == 0x000388, "Member 'APlayerHUD::PlayerHUD' has a wrong offset!");

// Class ReadyOrNot.PlayerPaperdollWidget
// 0x0148 (0x0408 - 0x02C0)
class UPlayerPaperdollWidget : public UUserWidget
{
public:
	class UWidgetSwitcher*                        StanceSwitcher;                                    // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        Stand_CarrySwitcher;                               // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        Crouch_CarrySwitcher;                              // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               Stand_Overlay;                                     // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               Crouch_Overlay;                                    // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               StandCarry_Overlay;                                // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               StandNoCarry_Overlay;                              // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               CrouchCarry_Overlay;                               // 0x02F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               CrouchNoCarry_Overlay;                             // 0x0300(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Outline_Image;                                     // 0x0308(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Head_Image;                                        // 0x0310(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Body_Image;                                        // 0x0318(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 RightArm_Image;                                    // 0x0320(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 LeftArm_Image;                                     // 0x0328(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 RightLeg_Image;                                    // 0x0330(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 LeftLeg_Image;                                     // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Headwear_Image;                                    // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 BodyArmor_Image;                                   // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Carry_Outline_Image;                               // 0x0350(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Carry_Head_Image;                                  // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Carry_Body_Image;                                  // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Carry_RightArm_Image;                              // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Carry_LeftArm_Image;                               // 0x0370(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Carry_BodyArmor_Image;                             // 0x0378(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Outline_Crouch_Image;                              // 0x0380(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Head_Crouch_Image;                                 // 0x0388(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Body_Crouch_Image;                                 // 0x0390(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 RightArm_Crouch_Image;                             // 0x0398(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 LeftArm_Crouch_Image;                              // 0x03A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 RightLeg_Crouch_Image;                             // 0x03A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 LeftLeg_Crouch_Image;                              // 0x03B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Headwear_Crouch_Image;                             // 0x03B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 BodyArmor_Crouch_Image;                            // 0x03C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Carry_Outline_Crouch_Image;                        // 0x03C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Carry_Head_Crouch_Image;                           // 0x03D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Carry_Body_Crouch_Image;                           // 0x03D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Carry_RightArm_Crouch_Image;                       // 0x03E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Carry_LeftArm_Crouch_Image;                        // 0x03E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Carry_RightLeg_Crouch_Image;                       // 0x03F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Carry_LeftLeg_Crouch_Image;                        // 0x03F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Carry_BodyArmor_Crouch_Image;                      // 0x0400(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void UpdateHealth(class ABaseItem* Item);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerPaperdollWidget">();
	}
	static class UPlayerPaperdollWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerPaperdollWidget>();
	}
};
static_assert(alignof(UPlayerPaperdollWidget) == 0x000008, "Wrong alignment on UPlayerPaperdollWidget");
static_assert(sizeof(UPlayerPaperdollWidget) == 0x000408, "Wrong size on UPlayerPaperdollWidget");
static_assert(offsetof(UPlayerPaperdollWidget, StanceSwitcher) == 0x0002C0, "Member 'UPlayerPaperdollWidget::StanceSwitcher' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, Stand_CarrySwitcher) == 0x0002C8, "Member 'UPlayerPaperdollWidget::Stand_CarrySwitcher' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, Crouch_CarrySwitcher) == 0x0002D0, "Member 'UPlayerPaperdollWidget::Crouch_CarrySwitcher' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, Stand_Overlay) == 0x0002D8, "Member 'UPlayerPaperdollWidget::Stand_Overlay' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, Crouch_Overlay) == 0x0002E0, "Member 'UPlayerPaperdollWidget::Crouch_Overlay' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, StandCarry_Overlay) == 0x0002E8, "Member 'UPlayerPaperdollWidget::StandCarry_Overlay' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, StandNoCarry_Overlay) == 0x0002F0, "Member 'UPlayerPaperdollWidget::StandNoCarry_Overlay' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, CrouchCarry_Overlay) == 0x0002F8, "Member 'UPlayerPaperdollWidget::CrouchCarry_Overlay' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, CrouchNoCarry_Overlay) == 0x000300, "Member 'UPlayerPaperdollWidget::CrouchNoCarry_Overlay' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, Outline_Image) == 0x000308, "Member 'UPlayerPaperdollWidget::Outline_Image' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, Head_Image) == 0x000310, "Member 'UPlayerPaperdollWidget::Head_Image' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, Body_Image) == 0x000318, "Member 'UPlayerPaperdollWidget::Body_Image' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, RightArm_Image) == 0x000320, "Member 'UPlayerPaperdollWidget::RightArm_Image' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, LeftArm_Image) == 0x000328, "Member 'UPlayerPaperdollWidget::LeftArm_Image' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, RightLeg_Image) == 0x000330, "Member 'UPlayerPaperdollWidget::RightLeg_Image' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, LeftLeg_Image) == 0x000338, "Member 'UPlayerPaperdollWidget::LeftLeg_Image' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, Headwear_Image) == 0x000340, "Member 'UPlayerPaperdollWidget::Headwear_Image' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, BodyArmor_Image) == 0x000348, "Member 'UPlayerPaperdollWidget::BodyArmor_Image' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, Carry_Outline_Image) == 0x000350, "Member 'UPlayerPaperdollWidget::Carry_Outline_Image' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, Carry_Head_Image) == 0x000358, "Member 'UPlayerPaperdollWidget::Carry_Head_Image' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, Carry_Body_Image) == 0x000360, "Member 'UPlayerPaperdollWidget::Carry_Body_Image' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, Carry_RightArm_Image) == 0x000368, "Member 'UPlayerPaperdollWidget::Carry_RightArm_Image' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, Carry_LeftArm_Image) == 0x000370, "Member 'UPlayerPaperdollWidget::Carry_LeftArm_Image' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, Carry_BodyArmor_Image) == 0x000378, "Member 'UPlayerPaperdollWidget::Carry_BodyArmor_Image' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, Outline_Crouch_Image) == 0x000380, "Member 'UPlayerPaperdollWidget::Outline_Crouch_Image' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, Head_Crouch_Image) == 0x000388, "Member 'UPlayerPaperdollWidget::Head_Crouch_Image' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, Body_Crouch_Image) == 0x000390, "Member 'UPlayerPaperdollWidget::Body_Crouch_Image' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, RightArm_Crouch_Image) == 0x000398, "Member 'UPlayerPaperdollWidget::RightArm_Crouch_Image' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, LeftArm_Crouch_Image) == 0x0003A0, "Member 'UPlayerPaperdollWidget::LeftArm_Crouch_Image' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, RightLeg_Crouch_Image) == 0x0003A8, "Member 'UPlayerPaperdollWidget::RightLeg_Crouch_Image' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, LeftLeg_Crouch_Image) == 0x0003B0, "Member 'UPlayerPaperdollWidget::LeftLeg_Crouch_Image' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, Headwear_Crouch_Image) == 0x0003B8, "Member 'UPlayerPaperdollWidget::Headwear_Crouch_Image' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, BodyArmor_Crouch_Image) == 0x0003C0, "Member 'UPlayerPaperdollWidget::BodyArmor_Crouch_Image' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, Carry_Outline_Crouch_Image) == 0x0003C8, "Member 'UPlayerPaperdollWidget::Carry_Outline_Crouch_Image' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, Carry_Head_Crouch_Image) == 0x0003D0, "Member 'UPlayerPaperdollWidget::Carry_Head_Crouch_Image' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, Carry_Body_Crouch_Image) == 0x0003D8, "Member 'UPlayerPaperdollWidget::Carry_Body_Crouch_Image' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, Carry_RightArm_Crouch_Image) == 0x0003E0, "Member 'UPlayerPaperdollWidget::Carry_RightArm_Crouch_Image' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, Carry_LeftArm_Crouch_Image) == 0x0003E8, "Member 'UPlayerPaperdollWidget::Carry_LeftArm_Crouch_Image' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, Carry_RightLeg_Crouch_Image) == 0x0003F0, "Member 'UPlayerPaperdollWidget::Carry_RightLeg_Crouch_Image' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, Carry_LeftLeg_Crouch_Image) == 0x0003F8, "Member 'UPlayerPaperdollWidget::Carry_LeftLeg_Crouch_Image' has a wrong offset!");
static_assert(offsetof(UPlayerPaperdollWidget, Carry_BodyArmor_Crouch_Image) == 0x000400, "Member 'UPlayerPaperdollWidget::Carry_BodyArmor_Crouch_Image' has a wrong offset!");

// Class ReadyOrNot.PlayerReferendum
// 0x0008 (0x0328 - 0x0320)
class APlayerReferendum final : public AReferendum
{
public:
	class AReadyOrNotPlayerState*                 TargetPlayerState;                                 // 0x0320(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerReferendum">();
	}
	static class APlayerReferendum* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayerReferendum>();
	}
};
static_assert(alignof(APlayerReferendum) == 0x000008, "Wrong alignment on APlayerReferendum");
static_assert(sizeof(APlayerReferendum) == 0x000328, "Wrong size on APlayerReferendum");
static_assert(offsetof(APlayerReferendum, TargetPlayerState) == 0x000320, "Member 'APlayerReferendum::TargetPlayerState' has a wrong offset!");

// Class ReadyOrNot.PlayersList
// 0x0050 (0x0460 - 0x0410)
class UPlayersList : public UCommonActivatableWidget
{
public:
	uint8                                         Pad_410[0x8];                                      // 0x0410(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnSuccess;                                         // 0x0418(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnFailure;                                         // 0x0428(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FLobbyPlayer>                   PlayersList;                                       // 0x0438(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnMuteStateDelegate;                               // 0x0448(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_458[0x8];                                      // 0x0458(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetMutedState(const class FString& UniqueNetId);
	void GetPlayersList();
	class APlayerState* GetPlayerStateFromUniqueId(const class FString& UniqueID);
	void SetMutedState(const class FString& UniqueNetId, bool Value);
	void UpdatedMutedState();
	bool VivoxAvailable();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayersList">();
	}
	static class UPlayersList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayersList>();
	}
};
static_assert(alignof(UPlayersList) == 0x000008, "Wrong alignment on UPlayersList");
static_assert(sizeof(UPlayersList) == 0x000460, "Wrong size on UPlayersList");
static_assert(offsetof(UPlayersList, OnSuccess) == 0x000418, "Member 'UPlayersList::OnSuccess' has a wrong offset!");
static_assert(offsetof(UPlayersList, OnFailure) == 0x000428, "Member 'UPlayersList::OnFailure' has a wrong offset!");
static_assert(offsetof(UPlayersList, PlayersList) == 0x000438, "Member 'UPlayersList::PlayersList' has a wrong offset!");
static_assert(offsetof(UPlayersList, OnMuteStateDelegate) == 0x000448, "Member 'UPlayersList::OnMuteStateDelegate' has a wrong offset!");

// Class ReadyOrNot.PlayerViewActor
// 0x00D8 (0x0370 - 0x0298)
class APlayerViewActor : public AActor
{
public:
	uint8                                         bShouldCaptureScene : 1;                           // 0x0298(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_299[0x7];                                      // 0x0299(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        SceneComponent;                                    // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneCaptureComponent2D*               CameraCaptureComponent;                            // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPostProcessEffect                     SwitchViewEffects;                                 // 0x02B0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UFMODEvent*                             SwitchViewEvent;                                   // 0x02D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DeathViewTime;                                     // 0x02E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E4[0x4];                                      // 0x02E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             DeathViewEvent;                                    // 0x02E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODEvent*                             CloseViewEvent;                                    // 0x02F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextureRenderTarget2D*                 CameraRenderTarget;                                // 0x02F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APlayerCharacter*                       OwningPlayerCharacter;                             // 0x0300(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AReadyOrNotCharacter*                   ViewCharacter;                                     // 0x0308(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                TargetLocation;                                    // 0x0310(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               TargetRotation;                                    // 0x0328(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UMaterialInstance*                      MI_PostProcess_Greyscale;                          // 0x0340(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstance*                      MI_PostProcess_Bump;                               // 0x0348(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstance*                      MI_PostProcess_Glitch;                             // 0x0350(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bDeathEffectsApplied : 1;                          // 0x0358(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bSwitchViewEffectsApplied : 1;                     // 0x0358(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_359[0x17];                                     // 0x0359(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetOwningPlayer(class APlayerCharacter* NewOwnerCharacter);
	void SetViewPlayer(class AReadyOrNotCharacter* NewViewCharacter);
	void TryNextView(bool bRequestClose, const bool bIncludeDeadViews);
	void UpdateViewTarget(const struct FVector& NewLocation, const struct FRotator& NewRotation);

	void ClearHiddenComponents() const;
	void HideActor(class AActor* ActorToHide, const bool bIncludeChildActors) const;
	void HideComponent(class UPrimitiveComponent* ComponentToHide) const;
	bool IsSwitchingView() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerViewActor">();
	}
	static class APlayerViewActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayerViewActor>();
	}
};
static_assert(alignof(APlayerViewActor) == 0x000008, "Wrong alignment on APlayerViewActor");
static_assert(sizeof(APlayerViewActor) == 0x000370, "Wrong size on APlayerViewActor");
static_assert(offsetof(APlayerViewActor, SceneComponent) == 0x0002A0, "Member 'APlayerViewActor::SceneComponent' has a wrong offset!");
static_assert(offsetof(APlayerViewActor, CameraCaptureComponent) == 0x0002A8, "Member 'APlayerViewActor::CameraCaptureComponent' has a wrong offset!");
static_assert(offsetof(APlayerViewActor, SwitchViewEffects) == 0x0002B0, "Member 'APlayerViewActor::SwitchViewEffects' has a wrong offset!");
static_assert(offsetof(APlayerViewActor, SwitchViewEvent) == 0x0002D8, "Member 'APlayerViewActor::SwitchViewEvent' has a wrong offset!");
static_assert(offsetof(APlayerViewActor, DeathViewTime) == 0x0002E0, "Member 'APlayerViewActor::DeathViewTime' has a wrong offset!");
static_assert(offsetof(APlayerViewActor, DeathViewEvent) == 0x0002E8, "Member 'APlayerViewActor::DeathViewEvent' has a wrong offset!");
static_assert(offsetof(APlayerViewActor, CloseViewEvent) == 0x0002F0, "Member 'APlayerViewActor::CloseViewEvent' has a wrong offset!");
static_assert(offsetof(APlayerViewActor, CameraRenderTarget) == 0x0002F8, "Member 'APlayerViewActor::CameraRenderTarget' has a wrong offset!");
static_assert(offsetof(APlayerViewActor, OwningPlayerCharacter) == 0x000300, "Member 'APlayerViewActor::OwningPlayerCharacter' has a wrong offset!");
static_assert(offsetof(APlayerViewActor, ViewCharacter) == 0x000308, "Member 'APlayerViewActor::ViewCharacter' has a wrong offset!");
static_assert(offsetof(APlayerViewActor, TargetLocation) == 0x000310, "Member 'APlayerViewActor::TargetLocation' has a wrong offset!");
static_assert(offsetof(APlayerViewActor, TargetRotation) == 0x000328, "Member 'APlayerViewActor::TargetRotation' has a wrong offset!");
static_assert(offsetof(APlayerViewActor, MI_PostProcess_Greyscale) == 0x000340, "Member 'APlayerViewActor::MI_PostProcess_Greyscale' has a wrong offset!");
static_assert(offsetof(APlayerViewActor, MI_PostProcess_Bump) == 0x000348, "Member 'APlayerViewActor::MI_PostProcess_Bump' has a wrong offset!");
static_assert(offsetof(APlayerViewActor, MI_PostProcess_Glitch) == 0x000350, "Member 'APlayerViewActor::MI_PostProcess_Glitch' has a wrong offset!");

// Class ReadyOrNot.PolicePresenceTestActor
// 0x0018 (0x02B0 - 0x0298)
class APolicePresenceTestActor final : public AActor
{
public:
	class USceneComponent*                        Scene;                                             // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBillboardComponent*                    Police;                                            // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBillboardComponent*                    suspect;                                           // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PolicePresenceTestActor">();
	}
	static class APolicePresenceTestActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<APolicePresenceTestActor>();
	}
};
static_assert(alignof(APolicePresenceTestActor) == 0x000008, "Wrong alignment on APolicePresenceTestActor");
static_assert(sizeof(APolicePresenceTestActor) == 0x0002B0, "Wrong size on APolicePresenceTestActor");
static_assert(offsetof(APolicePresenceTestActor, Scene) == 0x000298, "Member 'APolicePresenceTestActor::Scene' has a wrong offset!");
static_assert(offsetof(APolicePresenceTestActor, Police) == 0x0002A0, "Member 'APolicePresenceTestActor::Police' has a wrong offset!");
static_assert(offsetof(APolicePresenceTestActor, suspect) == 0x0002A8, "Member 'APolicePresenceTestActor::suspect' has a wrong offset!");

// Class ReadyOrNot.PopupTarget
// 0x0028 (0x02C0 - 0x0298)
class APopupTarget final : public AActor
{
public:
	class USkeletalMeshComponent*                 Mesh;                                              // 0x0298(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MaxHealth;                                         // 0x02A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PopupTime;                                         // 0x02A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Health;                                            // 0x02A8(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2AC[0xC];                                      // 0x02AC(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bFallDown;                                         // 0x02B8(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B9[0x7];                                      // 0x02B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsAlive();
	void Popup();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PopupTarget">();
	}
	static class APopupTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<APopupTarget>();
	}
};
static_assert(alignof(APopupTarget) == 0x000008, "Wrong alignment on APopupTarget");
static_assert(sizeof(APopupTarget) == 0x0002C0, "Wrong size on APopupTarget");
static_assert(offsetof(APopupTarget, Mesh) == 0x000298, "Member 'APopupTarget::Mesh' has a wrong offset!");
static_assert(offsetof(APopupTarget, MaxHealth) == 0x0002A0, "Member 'APopupTarget::MaxHealth' has a wrong offset!");
static_assert(offsetof(APopupTarget, PopupTime) == 0x0002A4, "Member 'APopupTarget::PopupTime' has a wrong offset!");
static_assert(offsetof(APopupTarget, Health) == 0x0002A8, "Member 'APopupTarget::Health' has a wrong offset!");
static_assert(offsetof(APopupTarget, bFallDown) == 0x0002B8, "Member 'APopupTarget::bFallDown' has a wrong offset!");

// Class ReadyOrNot.PostProcessEffectData
// 0x0410 (0x0440 - 0x0030)
class UPostProcessEffectData final : public UDataAsset
{
public:
	class UMaterialInterface*                     PostProcess_Material;                              // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPostProcessSetting_FloatParam> ScalarParameters;                                  // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPostProcessSetting_VectorParam> VectorParameters;                                 // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bDebug : 1;                                        // 0x0058(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Note;                                              // 0x0060(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_78[0x3C8];                                     // 0x0078(0x03C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PostProcessEffectData">();
	}
	static class UPostProcessEffectData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPostProcessEffectData>();
	}
};
static_assert(alignof(UPostProcessEffectData) == 0x000008, "Wrong alignment on UPostProcessEffectData");
static_assert(sizeof(UPostProcessEffectData) == 0x000440, "Wrong size on UPostProcessEffectData");
static_assert(offsetof(UPostProcessEffectData, PostProcess_Material) == 0x000030, "Member 'UPostProcessEffectData::PostProcess_Material' has a wrong offset!");
static_assert(offsetof(UPostProcessEffectData, ScalarParameters) == 0x000038, "Member 'UPostProcessEffectData::ScalarParameters' has a wrong offset!");
static_assert(offsetof(UPostProcessEffectData, VectorParameters) == 0x000048, "Member 'UPostProcessEffectData::VectorParameters' has a wrong offset!");
static_assert(offsetof(UPostProcessEffectData, Note) == 0x000060, "Member 'UPostProcessEffectData::Note' has a wrong offset!");

// Class ReadyOrNot.PostProcessRequirement
// 0x0010 (0x0038 - 0x0028)
class UPostProcessRequirement : public UObject
{
public:
	class APlayerCharacter*                       PlayerCharacter;                                   // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 DamageCauser;                                      // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool EnablePostProcessEffect();
	void Initialize(class APlayerCharacter* InPlayerCharacter, class AActor* InDamageCauser);

	class AActor* GetDamageCauser() const;
	class APlayerCharacter* GetPlayerCharacter() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PostProcessRequirement">();
	}
	static class UPostProcessRequirement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPostProcessRequirement>();
	}
};
static_assert(alignof(UPostProcessRequirement) == 0x000008, "Wrong alignment on UPostProcessRequirement");
static_assert(sizeof(UPostProcessRequirement) == 0x000038, "Wrong size on UPostProcessRequirement");
static_assert(offsetof(UPostProcessRequirement, PlayerCharacter) == 0x000028, "Member 'UPostProcessRequirement::PlayerCharacter' has a wrong offset!");
static_assert(offsetof(UPostProcessRequirement, DamageCauser) == 0x000030, "Member 'UPostProcessRequirement::DamageCauser' has a wrong offset!");

// Class ReadyOrNot.PPR_IsDamageCauserOnScreen
// 0x0000 (0x0038 - 0x0038)
class UPPR_IsDamageCauserOnScreen final : public UPostProcessRequirement
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PPR_IsDamageCauserOnScreen">();
	}
	static class UPPR_IsDamageCauserOnScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPPR_IsDamageCauserOnScreen>();
	}
};
static_assert(alignof(UPPR_IsDamageCauserOnScreen) == 0x000008, "Wrong alignment on UPPR_IsDamageCauserOnScreen");
static_assert(sizeof(UPPR_IsDamageCauserOnScreen) == 0x000038, "Wrong size on UPPR_IsDamageCauserOnScreen");

// Class ReadyOrNot.PredictionPFComponent
// 0x0048 (0x0360 - 0x0318)
class UPredictionPFComponent final : public UCrowdFollowingComponent
{
public:
	struct FVector                                PathStopLocation;                                  // 0x0318(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFixPathToAlwaysHaveBraking;                       // 0x0330(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFixPathRemoveClosePoints;                         // 0x0331(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_332[0x2];                                      // 0x0332(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PathPointRemoveDistanceThreshold;                  // 0x0334(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CustomAcceptanceRadius;                            // 0x0338(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33C[0x24];                                     // 0x033C(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PredictionPFComponent">();
	}
	static class UPredictionPFComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPredictionPFComponent>();
	}
};
static_assert(alignof(UPredictionPFComponent) == 0x000008, "Wrong alignment on UPredictionPFComponent");
static_assert(sizeof(UPredictionPFComponent) == 0x000360, "Wrong size on UPredictionPFComponent");
static_assert(offsetof(UPredictionPFComponent, PathStopLocation) == 0x000318, "Member 'UPredictionPFComponent::PathStopLocation' has a wrong offset!");
static_assert(offsetof(UPredictionPFComponent, bFixPathToAlwaysHaveBraking) == 0x000330, "Member 'UPredictionPFComponent::bFixPathToAlwaysHaveBraking' has a wrong offset!");
static_assert(offsetof(UPredictionPFComponent, bFixPathRemoveClosePoints) == 0x000331, "Member 'UPredictionPFComponent::bFixPathRemoveClosePoints' has a wrong offset!");
static_assert(offsetof(UPredictionPFComponent, PathPointRemoveDistanceThreshold) == 0x000334, "Member 'UPredictionPFComponent::PathPointRemoveDistanceThreshold' has a wrong offset!");
static_assert(offsetof(UPredictionPFComponent, CustomAcceptanceRadius) == 0x000338, "Member 'UPredictionPFComponent::CustomAcceptanceRadius' has a wrong offset!");

// Class ReadyOrNot.PremissionStreetView
// 0x0068 (0x0300 - 0x0298)
class APremissionStreetView final : public AActor
{
public:
	class UStaticMeshComponent*                   LeftBuildingMesh;                                  // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   RightBuildingMesh;                                 // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UChildActorComponent*                   LeftTrafficLight;                                  // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UChildActorComponent*                   RightTrafficLight;                                 // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UArrowComponent*                        Direction;                                         // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UStaticMesh*>                    Buildings;                                         // 0x02C0(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class AActor>>             TrafficLights;                                     // 0x02D0(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E0[0x18];                                     // 0x02E0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InterpConstantSpeed;                               // 0x02F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeUntilReset;                                    // 0x02FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PremissionStreetView">();
	}
	static class APremissionStreetView* GetDefaultObj()
	{
		return GetDefaultObjImpl<APremissionStreetView>();
	}
};
static_assert(alignof(APremissionStreetView) == 0x000008, "Wrong alignment on APremissionStreetView");
static_assert(sizeof(APremissionStreetView) == 0x000300, "Wrong size on APremissionStreetView");
static_assert(offsetof(APremissionStreetView, LeftBuildingMesh) == 0x000298, "Member 'APremissionStreetView::LeftBuildingMesh' has a wrong offset!");
static_assert(offsetof(APremissionStreetView, RightBuildingMesh) == 0x0002A0, "Member 'APremissionStreetView::RightBuildingMesh' has a wrong offset!");
static_assert(offsetof(APremissionStreetView, LeftTrafficLight) == 0x0002A8, "Member 'APremissionStreetView::LeftTrafficLight' has a wrong offset!");
static_assert(offsetof(APremissionStreetView, RightTrafficLight) == 0x0002B0, "Member 'APremissionStreetView::RightTrafficLight' has a wrong offset!");
static_assert(offsetof(APremissionStreetView, Direction) == 0x0002B8, "Member 'APremissionStreetView::Direction' has a wrong offset!");
static_assert(offsetof(APremissionStreetView, Buildings) == 0x0002C0, "Member 'APremissionStreetView::Buildings' has a wrong offset!");
static_assert(offsetof(APremissionStreetView, TrafficLights) == 0x0002D0, "Member 'APremissionStreetView::TrafficLights' has a wrong offset!");
static_assert(offsetof(APremissionStreetView, InterpConstantSpeed) == 0x0002F8, "Member 'APremissionStreetView::InterpConstantSpeed' has a wrong offset!");
static_assert(offsetof(APremissionStreetView, TimeUntilReset) == 0x0002FC, "Member 'APremissionStreetView::TimeUntilReset' has a wrong offset!");

// Class ReadyOrNot.ProgressionComponent
// 0x0010 (0x00B0 - 0x00A0)
class UProgressionComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x10];                                      // 0x00A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddExperience(float XP);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProgressionComponent">();
	}
	static class UProgressionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProgressionComponent>();
	}
};
static_assert(alignof(UProgressionComponent) == 0x000008, "Wrong alignment on UProgressionComponent");
static_assert(sizeof(UProgressionComponent) == 0x0000B0, "Wrong size on UProgressionComponent");

// Class ReadyOrNot.ProgressionRequirement
// 0x0000 (0x0028 - 0x0028)
class UProgressionRequirement : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProgressionRequirement">();
	}
	static class UProgressionRequirement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProgressionRequirement>();
	}
};
static_assert(alignof(UProgressionRequirement) == 0x000008, "Wrong alignment on UProgressionRequirement");
static_assert(sizeof(UProgressionRequirement) == 0x000028, "Wrong size on UProgressionRequirement");

// Class ReadyOrNot.LevelCompleteRequirement
// 0x0010 (0x0038 - 0x0028)
class ULevelCompleteRequirement final : public UProgressionRequirement
{
public:
	class FName                                   RequiredLevel;                                     // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELevelGrade                                   RequiredGrade;                                     // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TArray<class FName> GetLevelOptions() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelCompleteRequirement">();
	}
	static class ULevelCompleteRequirement* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelCompleteRequirement>();
	}
};
static_assert(alignof(ULevelCompleteRequirement) == 0x000008, "Wrong alignment on ULevelCompleteRequirement");
static_assert(sizeof(ULevelCompleteRequirement) == 0x000038, "Wrong size on ULevelCompleteRequirement");
static_assert(offsetof(ULevelCompleteRequirement, RequiredLevel) == 0x000028, "Member 'ULevelCompleteRequirement::RequiredLevel' has a wrong offset!");
static_assert(offsetof(ULevelCompleteRequirement, RequiredGrade) == 0x000030, "Member 'ULevelCompleteRequirement::RequiredGrade' has a wrong offset!");

// Class ReadyOrNot.PropagationTestactor
// 0x0028 (0x02C0 - 0x0298)
class APropagationTestactor final : public AActor
{
public:
	float                                         TickInterval;                                      // 0x0298(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29C[0x4];                                      // 0x029C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             Event;                                             // 0x02A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugMode;                                        // 0x02A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A9[0x7];                                      // 0x02A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBillboardComponent*                    BillBoard;                                         // 0x02B0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOcclusionType                                OcclusionType;                                     // 0x02B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPropagationType                              PropagationType;                                   // 0x02B9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BA[0x6];                                      // 0x02BA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PropagationTestactor">();
	}
	static class APropagationTestactor* GetDefaultObj()
	{
		return GetDefaultObjImpl<APropagationTestactor>();
	}
};
static_assert(alignof(APropagationTestactor) == 0x000008, "Wrong alignment on APropagationTestactor");
static_assert(sizeof(APropagationTestactor) == 0x0002C0, "Wrong size on APropagationTestactor");
static_assert(offsetof(APropagationTestactor, TickInterval) == 0x000298, "Member 'APropagationTestactor::TickInterval' has a wrong offset!");
static_assert(offsetof(APropagationTestactor, Event) == 0x0002A0, "Member 'APropagationTestactor::Event' has a wrong offset!");
static_assert(offsetof(APropagationTestactor, bDebugMode) == 0x0002A8, "Member 'APropagationTestactor::bDebugMode' has a wrong offset!");
static_assert(offsetof(APropagationTestactor, BillBoard) == 0x0002B0, "Member 'APropagationTestactor::BillBoard' has a wrong offset!");
static_assert(offsetof(APropagationTestactor, OcclusionType) == 0x0002B8, "Member 'APropagationTestactor::OcclusionType' has a wrong offset!");
static_assert(offsetof(APropagationTestactor, PropagationType) == 0x0002B9, "Member 'APropagationTestactor::PropagationType' has a wrong offset!");

// Class ReadyOrNot.PropHuntGM
// 0x0030 (0x0A00 - 0x09D0)
class APropHuntGM final : public AReadyOrNotGameMode_PVP
{
public:
	TSubclassOf<class ACharacter>                 PropHuntCharacterClass;                            // 0x09D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AReadyOrNotPlayerController*>    Hunters;                                           // 0x09D8(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class AReadyOrNotPlayerController*>    Props;                                             // 0x09E8(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_9F8[0x8];                                      // 0x09F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PropHuntGM">();
	}
	static class APropHuntGM* GetDefaultObj()
	{
		return GetDefaultObjImpl<APropHuntGM>();
	}
};
static_assert(alignof(APropHuntGM) == 0x000010, "Wrong alignment on APropHuntGM");
static_assert(sizeof(APropHuntGM) == 0x000A00, "Wrong size on APropHuntGM");
static_assert(offsetof(APropHuntGM, PropHuntCharacterClass) == 0x0009D0, "Member 'APropHuntGM::PropHuntCharacterClass' has a wrong offset!");
static_assert(offsetof(APropHuntGM, Hunters) == 0x0009D8, "Member 'APropHuntGM::Hunters' has a wrong offset!");
static_assert(offsetof(APropHuntGM, Props) == 0x0009E8, "Member 'APropHuntGM::Props' has a wrong offset!");

// Class ReadyOrNot.PropHuntGS
// 0x0010 (0x0908 - 0x08F8)
class APropHuntGS final : public AReadyOrNotGameState
{
public:
	TArray<class UStaticMesh*>                    AvailableProps;                                    // 0x08F8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PropHuntGS">();
	}
	static class APropHuntGS* GetDefaultObj()
	{
		return GetDefaultObjImpl<APropHuntGS>();
	}
};
static_assert(alignof(APropHuntGS) == 0x000008, "Wrong alignment on APropHuntGS");
static_assert(sizeof(APropHuntGS) == 0x000908, "Wrong size on APropHuntGS");
static_assert(offsetof(APropHuntGS, AvailableProps) == 0x0008F8, "Member 'APropHuntGS::AvailableProps' has a wrong offset!");

// Class ReadyOrNot.PS5ActivitiesStatics
// 0x0000 (0x0028 - 0x0028)
class UPS5ActivitiesStatics final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PS5ActivitiesStatics">();
	}
	static class UPS5ActivitiesStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPS5ActivitiesStatics>();
	}
};
static_assert(alignof(UPS5ActivitiesStatics) == 0x000008, "Wrong alignment on UPS5ActivitiesStatics");
static_assert(sizeof(UPS5ActivitiesStatics) == 0x000028, "Wrong size on UPS5ActivitiesStatics");

// Class ReadyOrNot.PushCombatMove
// 0x0000 (0x0230 - 0x0230)
class UPushCombatMove final : public UBaseCombatMoveActivity
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PushCombatMove">();
	}
	static class UPushCombatMove* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPushCombatMove>();
	}
};
static_assert(alignof(UPushCombatMove) == 0x000008, "Wrong alignment on UPushCombatMove");
static_assert(sizeof(UPushCombatMove) == 0x000230, "Wrong size on UPushCombatMove");

// Class ReadyOrNot.Quadrotor
// 0x0090 (0x0C40 - 0x0BB0)
class AQuadrotor final : public ABaseItem
{
public:
	class USkeletalMeshComponent*                 ViewfinderMesh;                                    // 0x0BB0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneCaptureComponent2D*               SceneCapture2D;                                    // 0x0BB8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextureRenderTarget2D*                 RenderTarget;                                      // 0x0BC0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bToggleDroneControl;                               // 0x0BC8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC9[0x7];                                      // 0x0BC9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterial*                              DefaultViewfinderMaterial;                         // 0x0BD0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               ViewfinderScreenMaterial;                          // 0x0BD8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              LocalPlayerCaptureResolution;                      // 0x0BE0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              SimulatedPlayerCaptureResolution;                  // 0x0BF0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C00[0x8];                                      // 0x0C00(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ViewfinderSocket_Hands;                            // 0x0C08(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ViewfinderSocket_Body;                             // 0x0C10(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ThrowDrone_1P;                                     // 0x0C18(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ThrowDrone_3P;                                     // 0x0C20(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AQuadrotorPawn>             DronePawnClass;                                    // 0x0C28(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AQuadrotorPawn*                         SpawnedDrone;                                      // 0x0C30(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C38[0x8];                                      // 0x0C38(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Server_SpawnDrone();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Quadrotor">();
	}
	static class AQuadrotor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AQuadrotor>();
	}
};
static_assert(alignof(AQuadrotor) == 0x000010, "Wrong alignment on AQuadrotor");
static_assert(sizeof(AQuadrotor) == 0x000C40, "Wrong size on AQuadrotor");
static_assert(offsetof(AQuadrotor, ViewfinderMesh) == 0x000BB0, "Member 'AQuadrotor::ViewfinderMesh' has a wrong offset!");
static_assert(offsetof(AQuadrotor, SceneCapture2D) == 0x000BB8, "Member 'AQuadrotor::SceneCapture2D' has a wrong offset!");
static_assert(offsetof(AQuadrotor, RenderTarget) == 0x000BC0, "Member 'AQuadrotor::RenderTarget' has a wrong offset!");
static_assert(offsetof(AQuadrotor, bToggleDroneControl) == 0x000BC8, "Member 'AQuadrotor::bToggleDroneControl' has a wrong offset!");
static_assert(offsetof(AQuadrotor, DefaultViewfinderMaterial) == 0x000BD0, "Member 'AQuadrotor::DefaultViewfinderMaterial' has a wrong offset!");
static_assert(offsetof(AQuadrotor, ViewfinderScreenMaterial) == 0x000BD8, "Member 'AQuadrotor::ViewfinderScreenMaterial' has a wrong offset!");
static_assert(offsetof(AQuadrotor, LocalPlayerCaptureResolution) == 0x000BE0, "Member 'AQuadrotor::LocalPlayerCaptureResolution' has a wrong offset!");
static_assert(offsetof(AQuadrotor, SimulatedPlayerCaptureResolution) == 0x000BF0, "Member 'AQuadrotor::SimulatedPlayerCaptureResolution' has a wrong offset!");
static_assert(offsetof(AQuadrotor, ViewfinderSocket_Hands) == 0x000C08, "Member 'AQuadrotor::ViewfinderSocket_Hands' has a wrong offset!");
static_assert(offsetof(AQuadrotor, ViewfinderSocket_Body) == 0x000C10, "Member 'AQuadrotor::ViewfinderSocket_Body' has a wrong offset!");
static_assert(offsetof(AQuadrotor, ThrowDrone_1P) == 0x000C18, "Member 'AQuadrotor::ThrowDrone_1P' has a wrong offset!");
static_assert(offsetof(AQuadrotor, ThrowDrone_3P) == 0x000C20, "Member 'AQuadrotor::ThrowDrone_3P' has a wrong offset!");
static_assert(offsetof(AQuadrotor, DronePawnClass) == 0x000C28, "Member 'AQuadrotor::DronePawnClass' has a wrong offset!");
static_assert(offsetof(AQuadrotor, SpawnedDrone) == 0x000C30, "Member 'AQuadrotor::SpawnedDrone' has a wrong offset!");

// Class ReadyOrNot.RadialSectorWidget
// 0x0018 (0x02D8 - 0x02C0)
class URadialSectorWidget : public UUserWidget
{
public:
	class UPanelWidget*                           SectorImagePanel;                                  // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 SectorImage;                                       // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SectorInnerRadius;                                 // 0x02D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SectorOuterRadius;                                 // 0x02D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool InitializeSectorWidget(float Angle, float Percentage, float InSectorInnerRadius, float InSectorOuterRadius, class UMaterialInterface* InSectorMaterial, const struct FLinearColor& UnselectedColor, class UImage* InSectorImage);
	bool SetSectorColor(const struct FLinearColor& NewColor, class UImage* InSectorImage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RadialSectorWidget">();
	}
	static class URadialSectorWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URadialSectorWidget>();
	}
};
static_assert(alignof(URadialSectorWidget) == 0x000008, "Wrong alignment on URadialSectorWidget");
static_assert(sizeof(URadialSectorWidget) == 0x0002D8, "Wrong size on URadialSectorWidget");
static_assert(offsetof(URadialSectorWidget, SectorImagePanel) == 0x0002C0, "Member 'URadialSectorWidget::SectorImagePanel' has a wrong offset!");
static_assert(offsetof(URadialSectorWidget, SectorImage) == 0x0002C8, "Member 'URadialSectorWidget::SectorImage' has a wrong offset!");
static_assert(offsetof(URadialSectorWidget, SectorInnerRadius) == 0x0002D0, "Member 'URadialSectorWidget::SectorInnerRadius' has a wrong offset!");
static_assert(offsetof(URadialSectorWidget, SectorOuterRadius) == 0x0002D4, "Member 'URadialSectorWidget::SectorOuterRadius' has a wrong offset!");

// Class ReadyOrNot.RadialTrackingComponent
// 0x0110 (0x01B0 - 0x00A0)
class alignas(0x10) URadialTrackingComponent final : public UActorComponent
{
public:
	ERadialTrackingState                          State;                                             // 0x00A0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class ACyberneticCharacter* Target)> OnTargetFound;                // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(ETrackingTargetLoseReason LoseReason)> OnTargetLost;               // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnTargetLostBP;                                    // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         MaxRotationAngle;                                  // 0x00D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TargetTrackingSpeed;                               // 0x00DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TargetTrackingRange;                               // 0x00E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TargetTrackingRadius;                              // 0x00E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RotationSmoothingRate;                             // 0x00E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_EC[0x4];                                       // 0x00EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               RootRotation;                                      // 0x00F0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         TrackingInterval;                                  // 0x0108(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10C[0x4];                                      // 0x010C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EObjectTypeQuery>                      TrackingTypes;                                     // 0x0110(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bShowTracking;                                     // 0x0120(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_121[0x2F];                                     // 0x0121(0x002F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               Rotation;                                          // 0x0150(0x0018)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_168[0x18];                                     // 0x0168(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsEnabled;                                        // 0x0180(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHasTarget;                                        // 0x0181(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_182[0x2E];                                     // 0x0182(0x002E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Initialise(const struct FRadialTrackingInitStruct& initData);
	void SetTrackingRoot(class USceneComponent* trackingRoot);
	void Stop();
	void TargetFound(class ACyberneticCharacter* Target);
	void TargetLost(ETrackingTargetLoseReason LoseReason);

	struct FRotator GetRotation() const;
	bool IsTracking() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RadialTrackingComponent">();
	}
	static class URadialTrackingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URadialTrackingComponent>();
	}
};
static_assert(alignof(URadialTrackingComponent) == 0x000010, "Wrong alignment on URadialTrackingComponent");
static_assert(sizeof(URadialTrackingComponent) == 0x0001B0, "Wrong size on URadialTrackingComponent");
static_assert(offsetof(URadialTrackingComponent, State) == 0x0000A0, "Member 'URadialTrackingComponent::State' has a wrong offset!");
static_assert(offsetof(URadialTrackingComponent, OnTargetFound) == 0x0000A8, "Member 'URadialTrackingComponent::OnTargetFound' has a wrong offset!");
static_assert(offsetof(URadialTrackingComponent, OnTargetLost) == 0x0000B8, "Member 'URadialTrackingComponent::OnTargetLost' has a wrong offset!");
static_assert(offsetof(URadialTrackingComponent, OnTargetLostBP) == 0x0000C8, "Member 'URadialTrackingComponent::OnTargetLostBP' has a wrong offset!");
static_assert(offsetof(URadialTrackingComponent, MaxRotationAngle) == 0x0000D8, "Member 'URadialTrackingComponent::MaxRotationAngle' has a wrong offset!");
static_assert(offsetof(URadialTrackingComponent, TargetTrackingSpeed) == 0x0000DC, "Member 'URadialTrackingComponent::TargetTrackingSpeed' has a wrong offset!");
static_assert(offsetof(URadialTrackingComponent, TargetTrackingRange) == 0x0000E0, "Member 'URadialTrackingComponent::TargetTrackingRange' has a wrong offset!");
static_assert(offsetof(URadialTrackingComponent, TargetTrackingRadius) == 0x0000E4, "Member 'URadialTrackingComponent::TargetTrackingRadius' has a wrong offset!");
static_assert(offsetof(URadialTrackingComponent, RotationSmoothingRate) == 0x0000E8, "Member 'URadialTrackingComponent::RotationSmoothingRate' has a wrong offset!");
static_assert(offsetof(URadialTrackingComponent, RootRotation) == 0x0000F0, "Member 'URadialTrackingComponent::RootRotation' has a wrong offset!");
static_assert(offsetof(URadialTrackingComponent, TrackingInterval) == 0x000108, "Member 'URadialTrackingComponent::TrackingInterval' has a wrong offset!");
static_assert(offsetof(URadialTrackingComponent, TrackingTypes) == 0x000110, "Member 'URadialTrackingComponent::TrackingTypes' has a wrong offset!");
static_assert(offsetof(URadialTrackingComponent, bShowTracking) == 0x000120, "Member 'URadialTrackingComponent::bShowTracking' has a wrong offset!");
static_assert(offsetof(URadialTrackingComponent, Rotation) == 0x000150, "Member 'URadialTrackingComponent::Rotation' has a wrong offset!");
static_assert(offsetof(URadialTrackingComponent, bIsEnabled) == 0x000180, "Member 'URadialTrackingComponent::bIsEnabled' has a wrong offset!");
static_assert(offsetof(URadialTrackingComponent, bHasTarget) == 0x000181, "Member 'URadialTrackingComponent::bHasTarget' has a wrong offset!");

// Class ReadyOrNot.RadialWidgetThemeData
// 0x00A0 (0x00D0 - 0x0030)
class URadialWidgetThemeData final : public UDataAsset
{
public:
	class FName                                   Name_0;                                            // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0038(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         StartingSectorIndex;                               // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartingSectorAngle;                               // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IconSize;                                          // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IconPadding;                                       // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SectorInnerRadius;                                 // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SectorOuterRadius;                                 // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GapSize;                                           // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WheelSize;                                         // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WheelCursorDistanceFromCenterWheel;                // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bHideRadialWheelCursorOnMenuOpened : 1;            // 0x0074(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_75[0x3];                                       // 0x0075(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           SelectedColor;                                     // 0x0078(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           UnselectedColor;                                   // 0x0088(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           UnselectableColor;                                 // 0x0098(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFont*                                  Font;                                              // 0x00A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             SelectionSound;                                    // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             MenuOpenSound;                                     // 0x00B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             MenuCloseSound;                                    // 0x00C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             MenuCloseSound_NoSelection;                        // 0x00C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RadialWidgetThemeData">();
	}
	static class URadialWidgetThemeData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URadialWidgetThemeData>();
	}
};
static_assert(alignof(URadialWidgetThemeData) == 0x000008, "Wrong alignment on URadialWidgetThemeData");
static_assert(sizeof(URadialWidgetThemeData) == 0x0000D0, "Wrong size on URadialWidgetThemeData");
static_assert(offsetof(URadialWidgetThemeData, Name_0) == 0x000030, "Member 'URadialWidgetThemeData::Name_0' has a wrong offset!");
static_assert(offsetof(URadialWidgetThemeData, Description) == 0x000038, "Member 'URadialWidgetThemeData::Description' has a wrong offset!");
static_assert(offsetof(URadialWidgetThemeData, StartingSectorIndex) == 0x000050, "Member 'URadialWidgetThemeData::StartingSectorIndex' has a wrong offset!");
static_assert(offsetof(URadialWidgetThemeData, StartingSectorAngle) == 0x000054, "Member 'URadialWidgetThemeData::StartingSectorAngle' has a wrong offset!");
static_assert(offsetof(URadialWidgetThemeData, IconSize) == 0x000058, "Member 'URadialWidgetThemeData::IconSize' has a wrong offset!");
static_assert(offsetof(URadialWidgetThemeData, IconPadding) == 0x00005C, "Member 'URadialWidgetThemeData::IconPadding' has a wrong offset!");
static_assert(offsetof(URadialWidgetThemeData, SectorInnerRadius) == 0x000060, "Member 'URadialWidgetThemeData::SectorInnerRadius' has a wrong offset!");
static_assert(offsetof(URadialWidgetThemeData, SectorOuterRadius) == 0x000064, "Member 'URadialWidgetThemeData::SectorOuterRadius' has a wrong offset!");
static_assert(offsetof(URadialWidgetThemeData, GapSize) == 0x000068, "Member 'URadialWidgetThemeData::GapSize' has a wrong offset!");
static_assert(offsetof(URadialWidgetThemeData, WheelSize) == 0x00006C, "Member 'URadialWidgetThemeData::WheelSize' has a wrong offset!");
static_assert(offsetof(URadialWidgetThemeData, WheelCursorDistanceFromCenterWheel) == 0x000070, "Member 'URadialWidgetThemeData::WheelCursorDistanceFromCenterWheel' has a wrong offset!");
static_assert(offsetof(URadialWidgetThemeData, SelectedColor) == 0x000078, "Member 'URadialWidgetThemeData::SelectedColor' has a wrong offset!");
static_assert(offsetof(URadialWidgetThemeData, UnselectedColor) == 0x000088, "Member 'URadialWidgetThemeData::UnselectedColor' has a wrong offset!");
static_assert(offsetof(URadialWidgetThemeData, UnselectableColor) == 0x000098, "Member 'URadialWidgetThemeData::UnselectableColor' has a wrong offset!");
static_assert(offsetof(URadialWidgetThemeData, Font) == 0x0000A8, "Member 'URadialWidgetThemeData::Font' has a wrong offset!");
static_assert(offsetof(URadialWidgetThemeData, SelectionSound) == 0x0000B0, "Member 'URadialWidgetThemeData::SelectionSound' has a wrong offset!");
static_assert(offsetof(URadialWidgetThemeData, MenuOpenSound) == 0x0000B8, "Member 'URadialWidgetThemeData::MenuOpenSound' has a wrong offset!");
static_assert(offsetof(URadialWidgetThemeData, MenuCloseSound) == 0x0000C0, "Member 'URadialWidgetThemeData::MenuCloseSound' has a wrong offset!");
static_assert(offsetof(URadialWidgetThemeData, MenuCloseSound_NoSelection) == 0x0000C8, "Member 'URadialWidgetThemeData::MenuCloseSound_NoSelection' has a wrong offset!");

// Class ReadyOrNot.RallyToActivity
// 0x0008 (0x01F8 - 0x01F0)
class URallyToActivity final : public UBaseActivity
{
public:
	class AReadyOrNotCharacter*                   Target;                                            // 0x01F0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void EnterFindLOSOnTarget();
	void EnterMoveToTargetState();
	void TickFindLOSOnTarget(float DeltaTime, float Uptime);
	void TickMoveToTargetState(float DeltaTime, float Uptime);

	bool CanFindLOSOnTarget() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RallyToActivity">();
	}
	static class URallyToActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<URallyToActivity>();
	}
};
static_assert(alignof(URallyToActivity) == 0x000008, "Wrong alignment on URallyToActivity");
static_assert(sizeof(URallyToActivity) == 0x0001F8, "Wrong size on URallyToActivity");
static_assert(offsetof(URallyToActivity, Target) == 0x0001F0, "Member 'URallyToActivity::Target' has a wrong offset!");

// Class ReadyOrNot.ReadyOrNotAIConfig
// 0x0000 (0x0028 - 0x0028)
class UReadyOrNotAIConfig final : public UGameplayConfig
{
public:
	static class UReadyOrNotAIConfig* Get();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotAIConfig">();
	}
	static class UReadyOrNotAIConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotAIConfig>();
	}
};
static_assert(alignof(UReadyOrNotAIConfig) == 0x000008, "Wrong alignment on UReadyOrNotAIConfig");
static_assert(sizeof(UReadyOrNotAIConfig) == 0x000028, "Wrong size on UReadyOrNotAIConfig");

// Class ReadyOrNot.ReadyOrNotAISenseConfig_Sight
// 0x0000 (0x0070 - 0x0070)
class UReadyOrNotAISenseConfig_Sight final : public UAISenseConfig_Sight
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotAISenseConfig_Sight">();
	}
	static class UReadyOrNotAISenseConfig_Sight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotAISenseConfig_Sight>();
	}
};
static_assert(alignof(UReadyOrNotAISenseConfig_Sight) == 0x000008, "Wrong alignment on UReadyOrNotAISenseConfig_Sight");
static_assert(sizeof(UReadyOrNotAISenseConfig_Sight) == 0x000070, "Wrong size on UReadyOrNotAISenseConfig_Sight");

// Class ReadyOrNot.ReadyOrNotAssetManager
// 0x0078 (0x0548 - 0x04D0)
class UReadyOrNotAssetManager final : public UAssetManager
{
public:
	TSet<class UObject*>                          LoadedAssets;                                      // 0x04D0(0x0050)(UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_520[0x28];                                     // 0x0520(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotAssetManager">();
	}
	static class UReadyOrNotAssetManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotAssetManager>();
	}
};
static_assert(alignof(UReadyOrNotAssetManager) == 0x000008, "Wrong alignment on UReadyOrNotAssetManager");
static_assert(sizeof(UReadyOrNotAssetManager) == 0x000548, "Wrong size on UReadyOrNotAssetManager");
static_assert(offsetof(UReadyOrNotAssetManager, LoadedAssets) == 0x0004D0, "Member 'UReadyOrNotAssetManager::LoadedAssets' has a wrong offset!");

// Class ReadyOrNot.ReadyOrNotAudioVolume
// 0x0040 (0x0310 - 0x02D0)
class AReadyOrNotAudioVolume final : public AVolume
{
public:
	TArray<class UFMODEvent*>                     ReverbEvents;                                      // 0x02D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bLocalEffectsPlayed;                               // 0x02E0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E1[0x7];                                      // 0x02E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFMODEventInstance>             EventInstances;                                    // 0x02E8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UFMODAudioComponent*>            AttachedAudioComponents;                           // 0x02F8(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_308[0x8];                                      // 0x0308(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool HasRanOnce() const;
	bool IsAnotherVolumeActivatedAndPlayingEvent(class UFMODEvent* Event, struct FFMODEventInstance* EventInstance) const;
	bool IsAnotherVolumeActivatedAndPlayingEventInst(const struct FFMODEventInstance& EventInst) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotAudioVolume">();
	}
	static class AReadyOrNotAudioVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AReadyOrNotAudioVolume>();
	}
};
static_assert(alignof(AReadyOrNotAudioVolume) == 0x000008, "Wrong alignment on AReadyOrNotAudioVolume");
static_assert(sizeof(AReadyOrNotAudioVolume) == 0x000310, "Wrong size on AReadyOrNotAudioVolume");
static_assert(offsetof(AReadyOrNotAudioVolume, ReverbEvents) == 0x0002D0, "Member 'AReadyOrNotAudioVolume::ReverbEvents' has a wrong offset!");
static_assert(offsetof(AReadyOrNotAudioVolume, bLocalEffectsPlayed) == 0x0002E0, "Member 'AReadyOrNotAudioVolume::bLocalEffectsPlayed' has a wrong offset!");
static_assert(offsetof(AReadyOrNotAudioVolume, EventInstances) == 0x0002E8, "Member 'AReadyOrNotAudioVolume::EventInstances' has a wrong offset!");
static_assert(offsetof(AReadyOrNotAudioVolume, AttachedAudioComponents) == 0x0002F8, "Member 'AReadyOrNotAudioVolume::AttachedAudioComponents' has a wrong offset!");

// Class ReadyOrNot.ReadyOrNotBackend
// 0x04D8 (0x0500 - 0x0028)
class UReadyOrNotBackend final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SteamId;                                           // 0x0038(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 SteamName;                                         // 0x0048(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 Ticket;                                            // 0x0058(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 CachedDiscordOneTimeUseCode;                       // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_78[0x10];                                      // 0x0078(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         rgchToken[0x400];                                  // 0x0088(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_488[0x4];                                      // 0x0488(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	ReadyOrNot::ELoginState                       LoginState;                                        // 0x048C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48D[0x1B];                                     // 0x048D(0x001B)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnStatsStarted;                                    // 0x04A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class FString& Filename, float Percentage)> OnStatsUploadProgress; // 0x04B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C8[0x10];                                     // 0x04C8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(bool bWasSuccessful, const class FString& StatsName)> OnStatsSaved; // 0x04D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bProfileInProgress;                                // 0x04E8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E9[0x17];                                     // 0x04E9(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DoLogin();
	void OnFinishedCapturingProfile();
	void OnGameCrashedMetric(const class FString& InState);
	void OnGameFinishedMetric(const class FString& InMap, const class FString& InGameType, const class FString& InGameResult);
	void OnGameLaunchedMetric(const class FString& PlayerId);
	void OnGameStartedMetric(const class FString& InMap, const class FString& InGameType, const int32 InNumPlayers);
	void OnPlayerGameFinishedMetric(const class FString& InMap, const class FString& InGameType, float InAverageFps);
	void StartCapturingProfile();
	void TickLoginDelay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotBackend">();
	}
	static class UReadyOrNotBackend* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotBackend>();
	}
};
static_assert(alignof(UReadyOrNotBackend) == 0x000008, "Wrong alignment on UReadyOrNotBackend");
static_assert(sizeof(UReadyOrNotBackend) == 0x000500, "Wrong size on UReadyOrNotBackend");
static_assert(offsetof(UReadyOrNotBackend, SteamId) == 0x000038, "Member 'UReadyOrNotBackend::SteamId' has a wrong offset!");
static_assert(offsetof(UReadyOrNotBackend, SteamName) == 0x000048, "Member 'UReadyOrNotBackend::SteamName' has a wrong offset!");
static_assert(offsetof(UReadyOrNotBackend, Ticket) == 0x000058, "Member 'UReadyOrNotBackend::Ticket' has a wrong offset!");
static_assert(offsetof(UReadyOrNotBackend, CachedDiscordOneTimeUseCode) == 0x000068, "Member 'UReadyOrNotBackend::CachedDiscordOneTimeUseCode' has a wrong offset!");
static_assert(offsetof(UReadyOrNotBackend, rgchToken) == 0x000088, "Member 'UReadyOrNotBackend::rgchToken' has a wrong offset!");
static_assert(offsetof(UReadyOrNotBackend, LoginState) == 0x00048C, "Member 'UReadyOrNotBackend::LoginState' has a wrong offset!");
static_assert(offsetof(UReadyOrNotBackend, OnStatsStarted) == 0x0004A8, "Member 'UReadyOrNotBackend::OnStatsStarted' has a wrong offset!");
static_assert(offsetof(UReadyOrNotBackend, OnStatsUploadProgress) == 0x0004B8, "Member 'UReadyOrNotBackend::OnStatsUploadProgress' has a wrong offset!");
static_assert(offsetof(UReadyOrNotBackend, OnStatsSaved) == 0x0004D8, "Member 'UReadyOrNotBackend::OnStatsSaved' has a wrong offset!");
static_assert(offsetof(UReadyOrNotBackend, bProfileInProgress) == 0x0004E8, "Member 'UReadyOrNotBackend::bProfileInProgress' has a wrong offset!");

// Class ReadyOrNot.ReadyOrNotCharacterAnimData
// 0x0358 (0x0388 - 0x0030)
class UReadyOrNotCharacterAnimData final : public UDataAsset
{
public:
	TArray<struct FCharacterTPAnim>               Surrender;                                         // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               FakeSurrender;                                     // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               Spooked_Front;                                     // 0x0050(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               Spooked_Right;                                     // 0x0060(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               Spooked_Left;                                      // 0x0070(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               Spooked_Back;                                      // 0x0080(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               Arrested;                                          // 0x0090(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               Decision;                                          // 0x00A0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               StandRelaxedFidget;                                // 0x00B0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               StandAlertFidget;                                  // 0x00C0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               HitReaction_Head;                                  // 0x00D0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               HitReaction_UpperBody;                             // 0x00E0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               HitReaction_LowerBody;                             // 0x00F0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               HitReaction_LeftArm;                               // 0x0100(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               HitReaction_RightArm;                              // 0x0110(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               HitReaction_LeftLeg;                               // 0x0120(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               HitReaction_RightLeg;                              // 0x0130(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               HitReaction_LeftFoot;                              // 0x0140(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               HitReaction_RightFoot;                             // 0x0150(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               HitReaction_DropWeapon;                            // 0x0160(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FCharacterTPAnim                       FireWeapon;                                        // 0x0170(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FCharacterTPAnim                       DrawWeapon;                                        // 0x0178(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FCharacterTPAnim                       HolsterWeapon;                                     // 0x0180(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FCharacterTPAnim                       ReloadWeapon;                                      // 0x0188(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               Death_Head_Front;                                  // 0x0190(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               Death_Head_Back;                                   // 0x01A0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               Death_Arm_Left_Front;                              // 0x01B0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               Death_Arm_Left_Back;                               // 0x01C0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               Death_Arm_Right_Front;                             // 0x01D0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               Death_Arm_Right_Back;                              // 0x01E0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               Death_Leg_Left_Front;                              // 0x01F0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               Death_Leg_Left_Back;                               // 0x0200(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               Death_Leg_Right_Front;                             // 0x0210(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               Death_Leg_Right_Back;                              // 0x0220(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               Death_Front;                                       // 0x0230(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               Death_Back;                                        // 0x0240(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               Death_Bleedout_Head;                               // 0x0250(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               Death_Bleedout_Chest;                              // 0x0260(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               Death_Bleedout_Stomach;                            // 0x0270(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               Death_Bleedout_Left_Arm;                           // 0x0280(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               Death_Bleedout_Right_Arm;                          // 0x0290(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               Death_Bleedout_Left_Leg;                           // 0x02A0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               Death_Bleedout_Right_Leg;                          // 0x02B0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               Flashbanged;                                       // 0x02C0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               Stingballed;                                       // 0x02D0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               Gassed;                                            // 0x02E0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               Sprayed;                                           // 0x02F0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               Tasered;                                           // 0x0300(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               Meleed;                                            // 0x0310(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FCharacterTPAnim                       OpenDoor;                                          // 0x0320(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FCharacterTPAnim                       CloseDoor;                                         // 0x0328(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FCharacterTPAnim                       Flinches;                                          // 0x0330(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Calm_Turn90Left;                                   // 0x0338(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Calm_Turn90Right;                                  // 0x0340(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Calm_Turn180Left;                                  // 0x0348(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Calm_Turn180Right;                                 // 0x0350(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Alert_Turn90Left;                                  // 0x0358(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Alert_Turn90Right;                                 // 0x0360(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Alert_Turn180Left;                                 // 0x0368(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Alert_Turn180Right;                                // 0x0370(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCharacterTPAnim>               AllAnimsList;                                      // 0x0378(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotCharacterAnimData">();
	}
	static class UReadyOrNotCharacterAnimData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotCharacterAnimData>();
	}
};
static_assert(alignof(UReadyOrNotCharacterAnimData) == 0x000008, "Wrong alignment on UReadyOrNotCharacterAnimData");
static_assert(sizeof(UReadyOrNotCharacterAnimData) == 0x000388, "Wrong size on UReadyOrNotCharacterAnimData");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Surrender) == 0x000030, "Member 'UReadyOrNotCharacterAnimData::Surrender' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, FakeSurrender) == 0x000040, "Member 'UReadyOrNotCharacterAnimData::FakeSurrender' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Spooked_Front) == 0x000050, "Member 'UReadyOrNotCharacterAnimData::Spooked_Front' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Spooked_Right) == 0x000060, "Member 'UReadyOrNotCharacterAnimData::Spooked_Right' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Spooked_Left) == 0x000070, "Member 'UReadyOrNotCharacterAnimData::Spooked_Left' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Spooked_Back) == 0x000080, "Member 'UReadyOrNotCharacterAnimData::Spooked_Back' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Arrested) == 0x000090, "Member 'UReadyOrNotCharacterAnimData::Arrested' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Decision) == 0x0000A0, "Member 'UReadyOrNotCharacterAnimData::Decision' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, StandRelaxedFidget) == 0x0000B0, "Member 'UReadyOrNotCharacterAnimData::StandRelaxedFidget' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, StandAlertFidget) == 0x0000C0, "Member 'UReadyOrNotCharacterAnimData::StandAlertFidget' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, HitReaction_Head) == 0x0000D0, "Member 'UReadyOrNotCharacterAnimData::HitReaction_Head' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, HitReaction_UpperBody) == 0x0000E0, "Member 'UReadyOrNotCharacterAnimData::HitReaction_UpperBody' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, HitReaction_LowerBody) == 0x0000F0, "Member 'UReadyOrNotCharacterAnimData::HitReaction_LowerBody' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, HitReaction_LeftArm) == 0x000100, "Member 'UReadyOrNotCharacterAnimData::HitReaction_LeftArm' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, HitReaction_RightArm) == 0x000110, "Member 'UReadyOrNotCharacterAnimData::HitReaction_RightArm' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, HitReaction_LeftLeg) == 0x000120, "Member 'UReadyOrNotCharacterAnimData::HitReaction_LeftLeg' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, HitReaction_RightLeg) == 0x000130, "Member 'UReadyOrNotCharacterAnimData::HitReaction_RightLeg' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, HitReaction_LeftFoot) == 0x000140, "Member 'UReadyOrNotCharacterAnimData::HitReaction_LeftFoot' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, HitReaction_RightFoot) == 0x000150, "Member 'UReadyOrNotCharacterAnimData::HitReaction_RightFoot' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, HitReaction_DropWeapon) == 0x000160, "Member 'UReadyOrNotCharacterAnimData::HitReaction_DropWeapon' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, FireWeapon) == 0x000170, "Member 'UReadyOrNotCharacterAnimData::FireWeapon' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, DrawWeapon) == 0x000178, "Member 'UReadyOrNotCharacterAnimData::DrawWeapon' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, HolsterWeapon) == 0x000180, "Member 'UReadyOrNotCharacterAnimData::HolsterWeapon' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, ReloadWeapon) == 0x000188, "Member 'UReadyOrNotCharacterAnimData::ReloadWeapon' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Death_Head_Front) == 0x000190, "Member 'UReadyOrNotCharacterAnimData::Death_Head_Front' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Death_Head_Back) == 0x0001A0, "Member 'UReadyOrNotCharacterAnimData::Death_Head_Back' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Death_Arm_Left_Front) == 0x0001B0, "Member 'UReadyOrNotCharacterAnimData::Death_Arm_Left_Front' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Death_Arm_Left_Back) == 0x0001C0, "Member 'UReadyOrNotCharacterAnimData::Death_Arm_Left_Back' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Death_Arm_Right_Front) == 0x0001D0, "Member 'UReadyOrNotCharacterAnimData::Death_Arm_Right_Front' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Death_Arm_Right_Back) == 0x0001E0, "Member 'UReadyOrNotCharacterAnimData::Death_Arm_Right_Back' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Death_Leg_Left_Front) == 0x0001F0, "Member 'UReadyOrNotCharacterAnimData::Death_Leg_Left_Front' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Death_Leg_Left_Back) == 0x000200, "Member 'UReadyOrNotCharacterAnimData::Death_Leg_Left_Back' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Death_Leg_Right_Front) == 0x000210, "Member 'UReadyOrNotCharacterAnimData::Death_Leg_Right_Front' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Death_Leg_Right_Back) == 0x000220, "Member 'UReadyOrNotCharacterAnimData::Death_Leg_Right_Back' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Death_Front) == 0x000230, "Member 'UReadyOrNotCharacterAnimData::Death_Front' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Death_Back) == 0x000240, "Member 'UReadyOrNotCharacterAnimData::Death_Back' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Death_Bleedout_Head) == 0x000250, "Member 'UReadyOrNotCharacterAnimData::Death_Bleedout_Head' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Death_Bleedout_Chest) == 0x000260, "Member 'UReadyOrNotCharacterAnimData::Death_Bleedout_Chest' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Death_Bleedout_Stomach) == 0x000270, "Member 'UReadyOrNotCharacterAnimData::Death_Bleedout_Stomach' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Death_Bleedout_Left_Arm) == 0x000280, "Member 'UReadyOrNotCharacterAnimData::Death_Bleedout_Left_Arm' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Death_Bleedout_Right_Arm) == 0x000290, "Member 'UReadyOrNotCharacterAnimData::Death_Bleedout_Right_Arm' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Death_Bleedout_Left_Leg) == 0x0002A0, "Member 'UReadyOrNotCharacterAnimData::Death_Bleedout_Left_Leg' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Death_Bleedout_Right_Leg) == 0x0002B0, "Member 'UReadyOrNotCharacterAnimData::Death_Bleedout_Right_Leg' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Flashbanged) == 0x0002C0, "Member 'UReadyOrNotCharacterAnimData::Flashbanged' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Stingballed) == 0x0002D0, "Member 'UReadyOrNotCharacterAnimData::Stingballed' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Gassed) == 0x0002E0, "Member 'UReadyOrNotCharacterAnimData::Gassed' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Sprayed) == 0x0002F0, "Member 'UReadyOrNotCharacterAnimData::Sprayed' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Tasered) == 0x000300, "Member 'UReadyOrNotCharacterAnimData::Tasered' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Meleed) == 0x000310, "Member 'UReadyOrNotCharacterAnimData::Meleed' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, OpenDoor) == 0x000320, "Member 'UReadyOrNotCharacterAnimData::OpenDoor' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, CloseDoor) == 0x000328, "Member 'UReadyOrNotCharacterAnimData::CloseDoor' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Flinches) == 0x000330, "Member 'UReadyOrNotCharacterAnimData::Flinches' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Calm_Turn90Left) == 0x000338, "Member 'UReadyOrNotCharacterAnimData::Calm_Turn90Left' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Calm_Turn90Right) == 0x000340, "Member 'UReadyOrNotCharacterAnimData::Calm_Turn90Right' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Calm_Turn180Left) == 0x000348, "Member 'UReadyOrNotCharacterAnimData::Calm_Turn180Left' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Calm_Turn180Right) == 0x000350, "Member 'UReadyOrNotCharacterAnimData::Calm_Turn180Right' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Alert_Turn90Left) == 0x000358, "Member 'UReadyOrNotCharacterAnimData::Alert_Turn90Left' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Alert_Turn90Right) == 0x000360, "Member 'UReadyOrNotCharacterAnimData::Alert_Turn90Right' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Alert_Turn180Left) == 0x000368, "Member 'UReadyOrNotCharacterAnimData::Alert_Turn180Left' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, Alert_Turn180Right) == 0x000370, "Member 'UReadyOrNotCharacterAnimData::Alert_Turn180Right' has a wrong offset!");
static_assert(offsetof(UReadyOrNotCharacterAnimData, AllAnimsList) == 0x000378, "Member 'UReadyOrNotCharacterAnimData::AllAnimsList' has a wrong offset!");

// Class ReadyOrNot.ReadyOrNotConsoleFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UReadyOrNotConsoleFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void ConsoleApplyLevelSpecificSettings(const class FString& MapName, bool QualityOverFrameRate);
	static ERuntimeDevice GetRuntimeDeviceProfile();
	static bool IsPcPlatform();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotConsoleFunctionLibrary">();
	}
	static class UReadyOrNotConsoleFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotConsoleFunctionLibrary>();
	}
};
static_assert(alignof(UReadyOrNotConsoleFunctionLibrary) == 0x000008, "Wrong alignment on UReadyOrNotConsoleFunctionLibrary");
static_assert(sizeof(UReadyOrNotConsoleFunctionLibrary) == 0x000028, "Wrong size on UReadyOrNotConsoleFunctionLibrary");

// Class ReadyOrNot.ReadyOrNotDebugSubsystem
// 0x0028 (0x0058 - 0x0030)
class UReadyOrNotDebugSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         bDrawMeleeRange : 1;                               // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bInfiniteHealth : 1;                               // 0x0030(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPlayerGodMode : 1;                                // 0x0030(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bInfiniteAmmo : 1;                                 // 0x0030(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawGrenadePath : 1;                              // 0x0030(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRTXOn : 1;                                        // 0x0030(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRTX_GlobalIlluminationOn : 1;                     // 0x0030(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRTX_ReflectionsOn : 1;                            // 0x0030(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRTX_AmbientOcclusionOn : 1;                       // 0x0031(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRTX_ShadowsOn : 1;                                // 0x0031(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRTX_TranslucencyOn : 1;                           // 0x0031(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bVSyncOn : 1;                                      // 0x0031(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bOverlayOn_Fibonacci;                              // 0x0032(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverlayOn_LineUp;                                 // 0x0033(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverlayOn_PistolLine;                             // 0x0034(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverlayOn_RifleLine;                              // 0x0035(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverlayOn_RuleOfThirds;                           // 0x0036(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bApplyGlobalDamageMultiplier_Weapons : 1;          // 0x0037(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bApplyGlobalDamageMultiplier_Grenades : 1;         // 0x0037(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	float                                         GlobalDamageMultiplier_Weapons;                    // 0x0038(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlobalDamageMultiplier_Grenades;                   // 0x003C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bLogWeaponDamageValuesToConsole : 1;               // 0x0040(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bShowObjectiveMarkers : 1;                         // 0x0040(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bShowAllEvidenceActors : 1;                        // 0x0040(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bShowHesitationBar : 1;                            // 0x0040(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bLogPlayerAnimationStatus : 1;                     // 0x0040(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawInteractableComponents : 1;                   // 0x0040(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDisableInteractableComponent : 1;                 // 0x0040(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawDebugTraces : 1;                              // 0x0040(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawDoorKillStunDistances : 1;                    // 0x0041(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bMuteFMOD : 1;                                     // 0x0041(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPauseFMOD : 1;                                    // 0x0041(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bForceOpenAllDoors : 1;                            // 0x0041(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bForceCloseAllDoors : 1;                           // 0x0041(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bLaserEyes : 1;                                    // 0x0041(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDisableMusic : 1;                                 // 0x0041(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawCoverPoints : 1;                              // 0x0041(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawCoverOctree : 1;                              // 0x0042(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSWATDynamicCover : 1;                             // 0x0042(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSuspectDynamicCover : 1;                          // 0x0042(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawSWATCoverLogic : 1;                           // 0x0042(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawSuspectCoverLogic : 1;                        // 0x0042(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bInfiniteSWATItems : 1;                            // 0x0042(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bShowNavigation : 1;                               // 0x0042(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_43[0x15];                                      // 0x0043(0x0015)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddOrUpdatePostProcessMaterial(class UMaterialInterface* InMaterial, bool* bMaterialOn);
	void CloseAllDoors();
	void DecreaseGlobalDamageMultiplier_Grenades(float Amount);
	void DecreaseGlobalDamageMultiplier_Weapons(float Amount);
	void DisableAllDebugLines();
	void EnableAllDebugLines();
	void IncreaseGlobalDamageMultiplier_Grenades(float Amount);
	void IncreaseGlobalDamageMultiplier_Weapons(float Amount);
	void OpenAllDoors();
	void RTX_ToggleAmbientOcclusion();
	void RTX_ToggleGlobalIllumination();
	void RTX_ToggleReflections();
	void RTX_ToggleShadows();
	void RTX_ToggleTranslucency();
	void SetDebugLinesVisibility(bool bVisible);
	void SetGlobalDamageMultiplier_Grenades(float NewDamageMultiplier);
	void SetGlobalDamageMultiplier_Weapons(float NewDamageMultiplier);
	void SetMeleeDamage(class APlayerCharacter* PlayerCharacter, float NewMeleeDamage);
	void SetMeleeRange(class APlayerCharacter* PlayerCharacter, float NewMeleeRange);
	void ToggleAllEvidenceActorMarkers();
	void ToggleCoverOctree();
	void ToggleCoverPoints();
	void ToggleDrawDebugTraces();
	void ToggleDrawDoorKillStunDistances();
	void ToggleDrawInteractableComponents();
	void ToggleDrawMeleeRange();
	void ToggleDrawSuspectCoverLogic();
	void ToggleDrawSWATCoverLogic();
	void ToggleFibonacciOverlayGuide(class UMaterialInterface* InMaterial);
	void ToggleGlobalDamageMultiplier_Grenades();
	void ToggleGlobalDamageMultiplier_Weapons();
	void ToggleGodMode();
	void ToggleGrenadeDrawDebug();
	void ToggleHesitationBar();
	void ToggleInfiniteAmmo();
	void ToggleInfiniteHealth();
	void ToggleInfiniteSWATItems();
	void ToggleInteractableComponents();
	void ToggleLaserEyes();
	void ToggleLineUpOverlayGuide(class UMaterialInterface* InMaterial);
	void ToggleLogPlayerAnimationStatus();
	void ToggleLogWeaponDamage();
	void ToggleMusic(bool bMusicOn);
	void ToggleMuteFMOD();
	void ToggleNavigation();
	void ToggleObjectiveMarkers();
	void TogglePauseFMOD();
	void TogglePistolLineOverlayGuide(class UMaterialInterface* InMaterial);
	void ToggleRifleLineOverlayGuide(class UMaterialInterface* InMaterial);
	void ToggleRTXSettings();
	void ToggleRuleOfThirdsOverlayGuide(class UMaterialInterface* InMaterial);
	void ToggleSuspectDynamicCover();
	void ToggleSWATDynamicCover();
	void ToggleThreatOctree();
	void ToggleThreatPoints();
	void ToggleThreatRoomNames();
	void ToggleVSync();
	void WeakenAllEnemiesToLowHealth();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotDebugSubsystem">();
	}
	static class UReadyOrNotDebugSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotDebugSubsystem>();
	}
};
static_assert(alignof(UReadyOrNotDebugSubsystem) == 0x000008, "Wrong alignment on UReadyOrNotDebugSubsystem");
static_assert(sizeof(UReadyOrNotDebugSubsystem) == 0x000058, "Wrong size on UReadyOrNotDebugSubsystem");
static_assert(offsetof(UReadyOrNotDebugSubsystem, bOverlayOn_Fibonacci) == 0x000032, "Member 'UReadyOrNotDebugSubsystem::bOverlayOn_Fibonacci' has a wrong offset!");
static_assert(offsetof(UReadyOrNotDebugSubsystem, bOverlayOn_LineUp) == 0x000033, "Member 'UReadyOrNotDebugSubsystem::bOverlayOn_LineUp' has a wrong offset!");
static_assert(offsetof(UReadyOrNotDebugSubsystem, bOverlayOn_PistolLine) == 0x000034, "Member 'UReadyOrNotDebugSubsystem::bOverlayOn_PistolLine' has a wrong offset!");
static_assert(offsetof(UReadyOrNotDebugSubsystem, bOverlayOn_RifleLine) == 0x000035, "Member 'UReadyOrNotDebugSubsystem::bOverlayOn_RifleLine' has a wrong offset!");
static_assert(offsetof(UReadyOrNotDebugSubsystem, bOverlayOn_RuleOfThirds) == 0x000036, "Member 'UReadyOrNotDebugSubsystem::bOverlayOn_RuleOfThirds' has a wrong offset!");
static_assert(offsetof(UReadyOrNotDebugSubsystem, GlobalDamageMultiplier_Weapons) == 0x000038, "Member 'UReadyOrNotDebugSubsystem::GlobalDamageMultiplier_Weapons' has a wrong offset!");
static_assert(offsetof(UReadyOrNotDebugSubsystem, GlobalDamageMultiplier_Grenades) == 0x00003C, "Member 'UReadyOrNotDebugSubsystem::GlobalDamageMultiplier_Grenades' has a wrong offset!");

// Class ReadyOrNot.ReadyOrNotFaceAnimInstance
// 0x0090 (0x03E0 - 0x0350)
class UReadyOrNotFaceAnimInstance : public UAnimInstance
{
public:
	class USkeletalMeshComponent*                 BodyDriverMesh;                                    // 0x0348(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPoseAsset*                             DefaultFaceROMData;                                // 0x0350(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               FocalTargetLookRotation;                           // 0x0358(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               HeadLookRotation;                                  // 0x0370(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         EyeTargetLookLeft;                                 // 0x0388(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EyeTargetLookRight;                                // 0x038C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EyeTargetLookUp;                                   // 0x0390(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EyeTargetLookDown;                                 // 0x0394(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          CurrentLipSyncAnimation;                           // 0x0398(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentLipSyncTime;                                // 0x03A0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseLipSyncAnimation;                              // 0x03A4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A5[0x27];                                     // 0x03A5(0x0027)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurrentBlinkAmount;                                // 0x03CC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D0[0x10];                                     // 0x03D0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UPoseAsset* GetFaceROM() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotFaceAnimInstance">();
	}
	static class UReadyOrNotFaceAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotFaceAnimInstance>();
	}
};
static_assert(alignof(UReadyOrNotFaceAnimInstance) == 0x000010, "Wrong alignment on UReadyOrNotFaceAnimInstance");
static_assert(sizeof(UReadyOrNotFaceAnimInstance) == 0x0003E0, "Wrong size on UReadyOrNotFaceAnimInstance");
static_assert(offsetof(UReadyOrNotFaceAnimInstance, BodyDriverMesh) == 0x000348, "Member 'UReadyOrNotFaceAnimInstance::BodyDriverMesh' has a wrong offset!");
static_assert(offsetof(UReadyOrNotFaceAnimInstance, DefaultFaceROMData) == 0x000350, "Member 'UReadyOrNotFaceAnimInstance::DefaultFaceROMData' has a wrong offset!");
static_assert(offsetof(UReadyOrNotFaceAnimInstance, FocalTargetLookRotation) == 0x000358, "Member 'UReadyOrNotFaceAnimInstance::FocalTargetLookRotation' has a wrong offset!");
static_assert(offsetof(UReadyOrNotFaceAnimInstance, HeadLookRotation) == 0x000370, "Member 'UReadyOrNotFaceAnimInstance::HeadLookRotation' has a wrong offset!");
static_assert(offsetof(UReadyOrNotFaceAnimInstance, EyeTargetLookLeft) == 0x000388, "Member 'UReadyOrNotFaceAnimInstance::EyeTargetLookLeft' has a wrong offset!");
static_assert(offsetof(UReadyOrNotFaceAnimInstance, EyeTargetLookRight) == 0x00038C, "Member 'UReadyOrNotFaceAnimInstance::EyeTargetLookRight' has a wrong offset!");
static_assert(offsetof(UReadyOrNotFaceAnimInstance, EyeTargetLookUp) == 0x000390, "Member 'UReadyOrNotFaceAnimInstance::EyeTargetLookUp' has a wrong offset!");
static_assert(offsetof(UReadyOrNotFaceAnimInstance, EyeTargetLookDown) == 0x000394, "Member 'UReadyOrNotFaceAnimInstance::EyeTargetLookDown' has a wrong offset!");
static_assert(offsetof(UReadyOrNotFaceAnimInstance, CurrentLipSyncAnimation) == 0x000398, "Member 'UReadyOrNotFaceAnimInstance::CurrentLipSyncAnimation' has a wrong offset!");
static_assert(offsetof(UReadyOrNotFaceAnimInstance, CurrentLipSyncTime) == 0x0003A0, "Member 'UReadyOrNotFaceAnimInstance::CurrentLipSyncTime' has a wrong offset!");
static_assert(offsetof(UReadyOrNotFaceAnimInstance, bUseLipSyncAnimation) == 0x0003A4, "Member 'UReadyOrNotFaceAnimInstance::bUseLipSyncAnimation' has a wrong offset!");
static_assert(offsetof(UReadyOrNotFaceAnimInstance, CurrentBlinkAmount) == 0x0003CC, "Member 'UReadyOrNotFaceAnimInstance::CurrentBlinkAmount' has a wrong offset!");

// Class ReadyOrNot.ReadyOrNotGameSession
// 0x0180 (0x0430 - 0x02B0)
class AReadyOrNotGameSession final : public AGameSession
{
public:
	uint8                                         Pad_2B0[0xB0];                                     // 0x02B0(0x00B0)(Fixing Size After Last Property [ Dumper-7 ])
	class UReadyOrNotSessionData*                 SessionData;                                       // 0x0360(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_368[0x18];                                     // 0x0368(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ServerName;                                        // 0x0380(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         MapList;                                           // 0x0390(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	int32                                         ReturnToLobbyAfterXMissions;                       // 0x03A0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A4[0x4];                                      // 0x03A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Password;                                          // 0x03A8(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxConnections;                                    // 0x03B8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3BC[0x4];                                      // 0x03BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AdminPassword;                                     // 0x03C0(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         LoggedInAdmins;                                    // 0x03D0(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<class FString>                         BanList;                                           // 0x03E0(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	int32                                         MaxTeamKillsBeforeAutoKick;                        // 0x03F0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxTeamKillsBeforeAutoBan;                         // 0x03F4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SecondsUntilKickedForAFK;                          // 0x03F8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SecondsUntilAutostartLobby;                        // 0x03FC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinPlayersForAutostart;                            // 0x0400(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RoundTimerGameStart;                               // 0x0404(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RoundTimerBetweenMaps;                             // 0x0408(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReinforcementTimer;                                // 0x040C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RespawnTimer;                                      // 0x0410(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Timelimit;                                         // 0x0414(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Scorelimit;                                        // 0x0418(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RoundsPerMap;                                      // 0x041C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAiEnabled;                                        // 0x0420(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_421[0x3];                                      // 0x0421(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         EventID;                                           // 0x0424(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ClientNetSpeed;                                    // 0x0428(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42C[0x4];                                      // 0x042C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MakeLoadingMapOnlyURL(const class FString& MapURL);
	void SetServerSettings(float NewRoundTimerGameStart, float NewRoundTimerBetweenMaps, float NewReinforcementTimer, float NewTimelimit, int32 NewRoundsPerMap, int32 NewScorelimit, bool NewAiEnabled);
	void WriteOutConfig();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotGameSession">();
	}
	static class AReadyOrNotGameSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<AReadyOrNotGameSession>();
	}
};
static_assert(alignof(AReadyOrNotGameSession) == 0x000008, "Wrong alignment on AReadyOrNotGameSession");
static_assert(sizeof(AReadyOrNotGameSession) == 0x000430, "Wrong size on AReadyOrNotGameSession");
static_assert(offsetof(AReadyOrNotGameSession, SessionData) == 0x000360, "Member 'AReadyOrNotGameSession::SessionData' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameSession, ServerName) == 0x000380, "Member 'AReadyOrNotGameSession::ServerName' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameSession, MapList) == 0x000390, "Member 'AReadyOrNotGameSession::MapList' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameSession, ReturnToLobbyAfterXMissions) == 0x0003A0, "Member 'AReadyOrNotGameSession::ReturnToLobbyAfterXMissions' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameSession, Password) == 0x0003A8, "Member 'AReadyOrNotGameSession::Password' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameSession, MaxConnections) == 0x0003B8, "Member 'AReadyOrNotGameSession::MaxConnections' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameSession, AdminPassword) == 0x0003C0, "Member 'AReadyOrNotGameSession::AdminPassword' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameSession, LoggedInAdmins) == 0x0003D0, "Member 'AReadyOrNotGameSession::LoggedInAdmins' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameSession, BanList) == 0x0003E0, "Member 'AReadyOrNotGameSession::BanList' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameSession, MaxTeamKillsBeforeAutoKick) == 0x0003F0, "Member 'AReadyOrNotGameSession::MaxTeamKillsBeforeAutoKick' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameSession, MaxTeamKillsBeforeAutoBan) == 0x0003F4, "Member 'AReadyOrNotGameSession::MaxTeamKillsBeforeAutoBan' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameSession, SecondsUntilKickedForAFK) == 0x0003F8, "Member 'AReadyOrNotGameSession::SecondsUntilKickedForAFK' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameSession, SecondsUntilAutostartLobby) == 0x0003FC, "Member 'AReadyOrNotGameSession::SecondsUntilAutostartLobby' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameSession, MinPlayersForAutostart) == 0x000400, "Member 'AReadyOrNotGameSession::MinPlayersForAutostart' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameSession, RoundTimerGameStart) == 0x000404, "Member 'AReadyOrNotGameSession::RoundTimerGameStart' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameSession, RoundTimerBetweenMaps) == 0x000408, "Member 'AReadyOrNotGameSession::RoundTimerBetweenMaps' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameSession, ReinforcementTimer) == 0x00040C, "Member 'AReadyOrNotGameSession::ReinforcementTimer' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameSession, RespawnTimer) == 0x000410, "Member 'AReadyOrNotGameSession::RespawnTimer' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameSession, Timelimit) == 0x000414, "Member 'AReadyOrNotGameSession::Timelimit' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameSession, Scorelimit) == 0x000418, "Member 'AReadyOrNotGameSession::Scorelimit' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameSession, RoundsPerMap) == 0x00041C, "Member 'AReadyOrNotGameSession::RoundsPerMap' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameSession, bAiEnabled) == 0x000420, "Member 'AReadyOrNotGameSession::bAiEnabled' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameSession, EventID) == 0x000424, "Member 'AReadyOrNotGameSession::EventID' has a wrong offset!");
static_assert(offsetof(AReadyOrNotGameSession, ClientNetSpeed) == 0x000428, "Member 'AReadyOrNotGameSession::ClientNetSpeed' has a wrong offset!");

// Class ReadyOrNot.ReadyOrNotInputComponent
// 0x0000 (0x0160 - 0x0160)
class UReadyOrNotInputComponent final : public UEnhancedInputComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotInputComponent">();
	}
	static class UReadyOrNotInputComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotInputComponent>();
	}
};
static_assert(alignof(UReadyOrNotInputComponent) == 0x000008, "Wrong alignment on UReadyOrNotInputComponent");
static_assert(sizeof(UReadyOrNotInputComponent) == 0x000160, "Wrong size on UReadyOrNotInputComponent");

// Class ReadyOrNot.ReadyOrNotInputConfig
// 0x0010 (0x0040 - 0x0030)
class UReadyOrNotInputConfig final : public UDataAsset
{
public:
	TArray<struct FInputActionMap>                NativeInputActions;                                // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	const class UInputAction* FindNativeInputActionForTag(const struct FGameplayTag& InputTag, bool bLogNotFound) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotInputConfig">();
	}
	static class UReadyOrNotInputConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotInputConfig>();
	}
};
static_assert(alignof(UReadyOrNotInputConfig) == 0x000008, "Wrong alignment on UReadyOrNotInputConfig");
static_assert(sizeof(UReadyOrNotInputConfig) == 0x000040, "Wrong size on UReadyOrNotInputConfig");
static_assert(offsetof(UReadyOrNotInputConfig, NativeInputActions) == 0x000030, "Member 'UReadyOrNotInputConfig::NativeInputActions' has a wrong offset!");

// Class ReadyOrNot.ReadyOrNotLevelScript
// 0x0988 (0x0C28 - 0x02A0)
class AReadyOrNotLevelScript : public ALevelScriptActor
{
public:
	EGenerationType                               WorldGenerationType;                               // 0x02A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A1[0x7];                                      // 0x02A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterial*                              TAASharpenFilter;                                  // 0x02A8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlashlightIntensity;                               // 0x02B0(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlashlightIntensityBoost;                          // 0x02B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlashlightBouncedIntensityBoost;                   // 0x02B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BC[0x4];                                      // 0x02BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ABlockingVolume*>                BlockingVolumesInLevel;                            // 0x02C0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class AVisibilityBlockingVolume*>      VisibilityBlockingVolumesInLevel;                  // 0x02D0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class AReadyOrNotTriggerVolume*>       TriggerVolumesInLevel;                             // 0x02E0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class AConversationManager*                   ConversationManager;                               // 0x02F0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<ELightType, class FName>                 LightingScenarios;                                 // 0x02F8(0x0050)(Edit, NativeAccessSpecifierPublic)
	ELightType                                    LightingType;                                      // 0x0348(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawCoverDebug;                                   // 0x0349(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34A[0x6];                                      // 0x034A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLevelDataLookupTable                  LevelData;                                         // 0x0350(0x0818)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	class UMusicData*                             MusicData;                                         // 0x0B68(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UItemData*                              ItemData;                                          // 0x0B70(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundData*                             SoundData;                                         // 0x0B78(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              Delegate_OnOutOfBoundsTimeLimitEnded;              // 0x0B80(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         OutOfBounds_MaxTimeLimit;                          // 0x0B90(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutOfBoundsTimeRemaining;                          // 0x0B94(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B98[0x8];                                      // 0x0B98(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AAmbientSound*>                  AudioSourcesInLevel;                               // 0x0BA0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class AFMODAmbientSound*>              FMODAudioSourcesInLevel;                           // 0x0BB0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC0[0x10];                                     // 0x0BC0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AReadyOrNotAudioVolume*>         AudioVolumes;                                      // 0x0BD0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class ACyberneticCharacter*>           AIRequestingCover;                                 // 0x0BE0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bUseDarkness;                                      // 0x0BF0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BF1[0x3];                                      // 0x0BF1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinimumLightIntensityForSource;                    // 0x0BF4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DarknessSightRangeMultiplier;                      // 0x0BF8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncludeWorldLightsAsSources;                      // 0x0BFC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRaining;                                          // 0x0BFD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpawnSwat;                                        // 0x0BFE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BFF[0x1];                                      // 0x0BFF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class ULevelSequence*                         LevelSequenceMVP;                                  // 0x0C00(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULevelSequence*                         LevelSequenceTeam;                                 // 0x0C08(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULevelSequencePlayer*                   LastPlayedSequence;                                // 0x0C10(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C18[0x10];                                     // 0x0C18(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DisableOutOfBounds();
	void EnableOutOfBounds();
	class AConversationManager* GetConversationManager();
	void OnMVPSequenceFinished();
	void OnOutOfBoundsTimeLimitEnded();
	void OnPiracyCheckUpdate(bool bIsPirated, const class FString& ProgramDetected);
	void OnPiracyCheckUpdate_Private(bool bIsPirated, const class FString& ProgramDetected);
	void OnTeamSequenceFinished();
	void PlayMVPSequence();
	void Start3DAudioVisualizer();
	void StartOutOfBoundsCountdown();
	void Stop3DAudioVisualizer();
	void StopOutOfBoundsCountdown();

	bool AllAudioVolumesTicked() const;
	bool IsCountingDownForOutOfBounds() const;
	bool IsOutOfBoundsEnabled() const;
	bool IsVisualizingAudioSources() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotLevelScript">();
	}
	static class AReadyOrNotLevelScript* GetDefaultObj()
	{
		return GetDefaultObjImpl<AReadyOrNotLevelScript>();
	}
};
static_assert(alignof(AReadyOrNotLevelScript) == 0x000008, "Wrong alignment on AReadyOrNotLevelScript");
static_assert(sizeof(AReadyOrNotLevelScript) == 0x000C28, "Wrong size on AReadyOrNotLevelScript");
static_assert(offsetof(AReadyOrNotLevelScript, WorldGenerationType) == 0x0002A0, "Member 'AReadyOrNotLevelScript::WorldGenerationType' has a wrong offset!");
static_assert(offsetof(AReadyOrNotLevelScript, TAASharpenFilter) == 0x0002A8, "Member 'AReadyOrNotLevelScript::TAASharpenFilter' has a wrong offset!");
static_assert(offsetof(AReadyOrNotLevelScript, FlashlightIntensity) == 0x0002B0, "Member 'AReadyOrNotLevelScript::FlashlightIntensity' has a wrong offset!");
static_assert(offsetof(AReadyOrNotLevelScript, FlashlightIntensityBoost) == 0x0002B4, "Member 'AReadyOrNotLevelScript::FlashlightIntensityBoost' has a wrong offset!");
static_assert(offsetof(AReadyOrNotLevelScript, FlashlightBouncedIntensityBoost) == 0x0002B8, "Member 'AReadyOrNotLevelScript::FlashlightBouncedIntensityBoost' has a wrong offset!");
static_assert(offsetof(AReadyOrNotLevelScript, BlockingVolumesInLevel) == 0x0002C0, "Member 'AReadyOrNotLevelScript::BlockingVolumesInLevel' has a wrong offset!");
static_assert(offsetof(AReadyOrNotLevelScript, VisibilityBlockingVolumesInLevel) == 0x0002D0, "Member 'AReadyOrNotLevelScript::VisibilityBlockingVolumesInLevel' has a wrong offset!");
static_assert(offsetof(AReadyOrNotLevelScript, TriggerVolumesInLevel) == 0x0002E0, "Member 'AReadyOrNotLevelScript::TriggerVolumesInLevel' has a wrong offset!");
static_assert(offsetof(AReadyOrNotLevelScript, ConversationManager) == 0x0002F0, "Member 'AReadyOrNotLevelScript::ConversationManager' has a wrong offset!");
static_assert(offsetof(AReadyOrNotLevelScript, LightingScenarios) == 0x0002F8, "Member 'AReadyOrNotLevelScript::LightingScenarios' has a wrong offset!");
static_assert(offsetof(AReadyOrNotLevelScript, LightingType) == 0x000348, "Member 'AReadyOrNotLevelScript::LightingType' has a wrong offset!");
static_assert(offsetof(AReadyOrNotLevelScript, bDrawCoverDebug) == 0x000349, "Member 'AReadyOrNotLevelScript::bDrawCoverDebug' has a wrong offset!");
static_assert(offsetof(AReadyOrNotLevelScript, LevelData) == 0x000350, "Member 'AReadyOrNotLevelScript::LevelData' has a wrong offset!");
static_assert(offsetof(AReadyOrNotLevelScript, MusicData) == 0x000B68, "Member 'AReadyOrNotLevelScript::MusicData' has a wrong offset!");
static_assert(offsetof(AReadyOrNotLevelScript, ItemData) == 0x000B70, "Member 'AReadyOrNotLevelScript::ItemData' has a wrong offset!");
static_assert(offsetof(AReadyOrNotLevelScript, SoundData) == 0x000B78, "Member 'AReadyOrNotLevelScript::SoundData' has a wrong offset!");
static_assert(offsetof(AReadyOrNotLevelScript, Delegate_OnOutOfBoundsTimeLimitEnded) == 0x000B80, "Member 'AReadyOrNotLevelScript::Delegate_OnOutOfBoundsTimeLimitEnded' has a wrong offset!");
static_assert(offsetof(AReadyOrNotLevelScript, OutOfBounds_MaxTimeLimit) == 0x000B90, "Member 'AReadyOrNotLevelScript::OutOfBounds_MaxTimeLimit' has a wrong offset!");
static_assert(offsetof(AReadyOrNotLevelScript, OutOfBoundsTimeRemaining) == 0x000B94, "Member 'AReadyOrNotLevelScript::OutOfBoundsTimeRemaining' has a wrong offset!");
static_assert(offsetof(AReadyOrNotLevelScript, AudioSourcesInLevel) == 0x000BA0, "Member 'AReadyOrNotLevelScript::AudioSourcesInLevel' has a wrong offset!");
static_assert(offsetof(AReadyOrNotLevelScript, FMODAudioSourcesInLevel) == 0x000BB0, "Member 'AReadyOrNotLevelScript::FMODAudioSourcesInLevel' has a wrong offset!");
static_assert(offsetof(AReadyOrNotLevelScript, AudioVolumes) == 0x000BD0, "Member 'AReadyOrNotLevelScript::AudioVolumes' has a wrong offset!");
static_assert(offsetof(AReadyOrNotLevelScript, AIRequestingCover) == 0x000BE0, "Member 'AReadyOrNotLevelScript::AIRequestingCover' has a wrong offset!");
static_assert(offsetof(AReadyOrNotLevelScript, bUseDarkness) == 0x000BF0, "Member 'AReadyOrNotLevelScript::bUseDarkness' has a wrong offset!");
static_assert(offsetof(AReadyOrNotLevelScript, MinimumLightIntensityForSource) == 0x000BF4, "Member 'AReadyOrNotLevelScript::MinimumLightIntensityForSource' has a wrong offset!");
static_assert(offsetof(AReadyOrNotLevelScript, DarknessSightRangeMultiplier) == 0x000BF8, "Member 'AReadyOrNotLevelScript::DarknessSightRangeMultiplier' has a wrong offset!");
static_assert(offsetof(AReadyOrNotLevelScript, bIncludeWorldLightsAsSources) == 0x000BFC, "Member 'AReadyOrNotLevelScript::bIncludeWorldLightsAsSources' has a wrong offset!");
static_assert(offsetof(AReadyOrNotLevelScript, bRaining) == 0x000BFD, "Member 'AReadyOrNotLevelScript::bRaining' has a wrong offset!");
static_assert(offsetof(AReadyOrNotLevelScript, bSpawnSwat) == 0x000BFE, "Member 'AReadyOrNotLevelScript::bSpawnSwat' has a wrong offset!");
static_assert(offsetof(AReadyOrNotLevelScript, LevelSequenceMVP) == 0x000C00, "Member 'AReadyOrNotLevelScript::LevelSequenceMVP' has a wrong offset!");
static_assert(offsetof(AReadyOrNotLevelScript, LevelSequenceTeam) == 0x000C08, "Member 'AReadyOrNotLevelScript::LevelSequenceTeam' has a wrong offset!");
static_assert(offsetof(AReadyOrNotLevelScript, LastPlayedSequence) == 0x000C10, "Member 'AReadyOrNotLevelScript::LastPlayedSequence' has a wrong offset!");

// Class ReadyOrNot.NavArea_NoSuspects
// 0x0000 (0x0048 - 0x0048)
class UNavArea_NoSuspects final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_NoSuspects">();
	}
	static class UNavArea_NoSuspects* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_NoSuspects>();
	}
};
static_assert(alignof(UNavArea_NoSuspects) == 0x000008, "Wrong alignment on UNavArea_NoSuspects");
static_assert(sizeof(UNavArea_NoSuspects) == 0x000048, "Wrong size on UNavArea_NoSuspects");

// Class ReadyOrNot.NavArea_FlankingAvoidanceArea
// 0x0000 (0x0048 - 0x0048)
class UNavArea_FlankingAvoidanceArea final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_FlankingAvoidanceArea">();
	}
	static class UNavArea_FlankingAvoidanceArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_FlankingAvoidanceArea>();
	}
};
static_assert(alignof(UNavArea_FlankingAvoidanceArea) == 0x000008, "Wrong alignment on UNavArea_FlankingAvoidanceArea");
static_assert(sizeof(UNavArea_FlankingAvoidanceArea) == 0x000048, "Wrong size on UNavArea_FlankingAvoidanceArea");

// Class ReadyOrNot.NavArea_LockedDoor
// 0x0000 (0x0048 - 0x0048)
class UNavArea_LockedDoor final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_LockedDoor">();
	}
	static class UNavArea_LockedDoor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_LockedDoor>();
	}
};
static_assert(alignof(UNavArea_LockedDoor) == 0x000008, "Wrong alignment on UNavArea_LockedDoor");
static_assert(sizeof(UNavArea_LockedDoor) == 0x000048, "Wrong size on UNavArea_LockedDoor");

// Class ReadyOrNot.NavArea_LockedDoorSuspect
// 0x0000 (0x0048 - 0x0048)
class UNavArea_LockedDoorSuspect final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_LockedDoorSuspect">();
	}
	static class UNavArea_LockedDoorSuspect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_LockedDoorSuspect>();
	}
};
static_assert(alignof(UNavArea_LockedDoorSuspect) == 0x000008, "Wrong alignment on UNavArea_LockedDoorSuspect");
static_assert(sizeof(UNavArea_LockedDoorSuspect) == 0x000048, "Wrong size on UNavArea_LockedDoorSuspect");

// Class ReadyOrNot.NavArea_WallTraversalHole
// 0x0000 (0x0048 - 0x0048)
class UNavArea_WallTraversalHole final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_WallTraversalHole">();
	}
	static class UNavArea_WallTraversalHole* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_WallTraversalHole>();
	}
};
static_assert(alignof(UNavArea_WallTraversalHole) == 0x000008, "Wrong alignment on UNavArea_WallTraversalHole");
static_assert(sizeof(UNavArea_WallTraversalHole) == 0x000048, "Wrong size on UNavArea_WallTraversalHole");

// Class ReadyOrNot.NavArea_Player
// 0x0000 (0x0048 - 0x0048)
class UNavArea_Player final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_Player">();
	}
	static class UNavArea_Player* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_Player>();
	}
};
static_assert(alignof(UNavArea_Player) == 0x000008, "Wrong alignment on UNavArea_Player");
static_assert(sizeof(UNavArea_Player) == 0x000048, "Wrong size on UNavArea_Player");

// Class ReadyOrNot.NavArea_SwatBeta
// 0x0000 (0x0048 - 0x0048)
class UNavArea_SwatBeta final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_SwatBeta">();
	}
	static class UNavArea_SwatBeta* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_SwatBeta>();
	}
};
static_assert(alignof(UNavArea_SwatBeta) == 0x000008, "Wrong alignment on UNavArea_SwatBeta");
static_assert(sizeof(UNavArea_SwatBeta) == 0x000048, "Wrong size on UNavArea_SwatBeta");

// Class ReadyOrNot.NavArea_SwatCharlie
// 0x0000 (0x0048 - 0x0048)
class UNavArea_SwatCharlie final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_SwatCharlie">();
	}
	static class UNavArea_SwatCharlie* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_SwatCharlie>();
	}
};
static_assert(alignof(UNavArea_SwatCharlie) == 0x000008, "Wrong alignment on UNavArea_SwatCharlie");
static_assert(sizeof(UNavArea_SwatCharlie) == 0x000048, "Wrong size on UNavArea_SwatCharlie");

// Class ReadyOrNot.NavArea_CivilianC
// 0x0000 (0x0048 - 0x0048)
class UNavArea_CivilianC final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_CivilianC">();
	}
	static class UNavArea_CivilianC* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_CivilianC>();
	}
};
static_assert(alignof(UNavArea_CivilianC) == 0x000008, "Wrong alignment on UNavArea_CivilianC");
static_assert(sizeof(UNavArea_CivilianC) == 0x000048, "Wrong size on UNavArea_CivilianC");

// Class ReadyOrNot.NavArea_SuspectB
// 0x0000 (0x0048 - 0x0048)
class UNavArea_SuspectB final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_SuspectB">();
	}
	static class UNavArea_SuspectB* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_SuspectB>();
	}
};
static_assert(alignof(UNavArea_SuspectB) == 0x000008, "Wrong alignment on UNavArea_SuspectB");
static_assert(sizeof(UNavArea_SuspectB) == 0x000048, "Wrong size on UNavArea_SuspectB");

// Class ReadyOrNot.NavArea_CSGas
// 0x0000 (0x0048 - 0x0048)
class UNavArea_CSGas final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_CSGas">();
	}
	static class UNavArea_CSGas* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_CSGas>();
	}
};
static_assert(alignof(UNavArea_CSGas) == 0x000008, "Wrong alignment on UNavArea_CSGas");
static_assert(sizeof(UNavArea_CSGas) == 0x000048, "Wrong size on UNavArea_CSGas");

// Class ReadyOrNot.NavQuery_SwatFallIn
// 0x0000 (0x0048 - 0x0048)
class UNavQuery_SwatFallIn final : public UNavQuery_Swat
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavQuery_SwatFallIn">();
	}
	static class UNavQuery_SwatFallIn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavQuery_SwatFallIn>();
	}
};
static_assert(alignof(UNavQuery_SwatFallIn) == 0x000008, "Wrong alignment on UNavQuery_SwatFallIn");
static_assert(sizeof(UNavQuery_SwatFallIn) == 0x000048, "Wrong size on UNavQuery_SwatFallIn");

// Class ReadyOrNot.NavQuery_SwatAlpha
// 0x0000 (0x0048 - 0x0048)
class UNavQuery_SwatAlpha final : public UNavQuery_Swat
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavQuery_SwatAlpha">();
	}
	static class UNavQuery_SwatAlpha* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavQuery_SwatAlpha>();
	}
};
static_assert(alignof(UNavQuery_SwatAlpha) == 0x000008, "Wrong alignment on UNavQuery_SwatAlpha");
static_assert(sizeof(UNavQuery_SwatAlpha) == 0x000048, "Wrong size on UNavQuery_SwatAlpha");

// Class ReadyOrNot.NavQuery_SwatBeta
// 0x0000 (0x0048 - 0x0048)
class UNavQuery_SwatBeta final : public UNavQuery_Swat
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavQuery_SwatBeta">();
	}
	static class UNavQuery_SwatBeta* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavQuery_SwatBeta>();
	}
};
static_assert(alignof(UNavQuery_SwatBeta) == 0x000008, "Wrong alignment on UNavQuery_SwatBeta");
static_assert(sizeof(UNavQuery_SwatBeta) == 0x000048, "Wrong size on UNavQuery_SwatBeta");

// Class ReadyOrNot.NavQuery_SwatCharlie
// 0x0000 (0x0048 - 0x0048)
class UNavQuery_SwatCharlie final : public UNavQuery_Swat
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavQuery_SwatCharlie">();
	}
	static class UNavQuery_SwatCharlie* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavQuery_SwatCharlie>();
	}
};
static_assert(alignof(UNavQuery_SwatCharlie) == 0x000008, "Wrong alignment on UNavQuery_SwatCharlie");
static_assert(sizeof(UNavQuery_SwatCharlie) == 0x000048, "Wrong size on UNavQuery_SwatCharlie");

// Class ReadyOrNot.NavQuery_Civilian
// 0x0000 (0x0048 - 0x0048)
class UNavQuery_Civilian final : public UNavigationQueryFilter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavQuery_Civilian">();
	}
	static class UNavQuery_Civilian* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavQuery_Civilian>();
	}
};
static_assert(alignof(UNavQuery_Civilian) == 0x000008, "Wrong alignment on UNavQuery_Civilian");
static_assert(sizeof(UNavQuery_Civilian) == 0x000048, "Wrong size on UNavQuery_Civilian");

// Class ReadyOrNot.NavQuery_FlankingSuspect
// 0x0000 (0x0048 - 0x0048)
class UNavQuery_FlankingSuspect final : public UNavigationQueryFilter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavQuery_FlankingSuspect">();
	}
	static class UNavQuery_FlankingSuspect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavQuery_FlankingSuspect>();
	}
};
static_assert(alignof(UNavQuery_FlankingSuspect) == 0x000008, "Wrong alignment on UNavQuery_FlankingSuspect");
static_assert(sizeof(UNavQuery_FlankingSuspect) == 0x000048, "Wrong size on UNavQuery_FlankingSuspect");

// Class ReadyOrNot.NavQuery_GasFleeingSuspect
// 0x0000 (0x0048 - 0x0048)
class UNavQuery_GasFleeingSuspect final : public UNavigationQueryFilter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavQuery_GasFleeingSuspect">();
	}
	static class UNavQuery_GasFleeingSuspect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavQuery_GasFleeingSuspect>();
	}
};
static_assert(alignof(UNavQuery_GasFleeingSuspect) == 0x000008, "Wrong alignment on UNavQuery_GasFleeingSuspect");
static_assert(sizeof(UNavQuery_GasFleeingSuspect) == 0x000048, "Wrong size on UNavQuery_GasFleeingSuspect");

// Class ReadyOrNot.NavQuery_NoiseCheck
// 0x0000 (0x0048 - 0x0048)
class UNavQuery_NoiseCheck final : public UNavigationQueryFilter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavQuery_NoiseCheck">();
	}
	static class UNavQuery_NoiseCheck* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavQuery_NoiseCheck>();
	}
};
static_assert(alignof(UNavQuery_NoiseCheck) == 0x000008, "Wrong alignment on UNavQuery_NoiseCheck");
static_assert(sizeof(UNavQuery_NoiseCheck) == 0x000048, "Wrong size on UNavQuery_NoiseCheck");

// Class ReadyOrNot.NavQuery_CSGas
// 0x0000 (0x0048 - 0x0048)
class UNavQuery_CSGas final : public UNavigationQueryFilter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavQuery_CSGas">();
	}
	static class UNavQuery_CSGas* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavQuery_CSGas>();
	}
};
static_assert(alignof(UNavQuery_CSGas) == 0x000008, "Wrong alignment on UNavQuery_CSGas");
static_assert(sizeof(UNavQuery_CSGas) == 0x000048, "Wrong size on UNavQuery_CSGas");

// Class ReadyOrNot.NavQuery_Awareness
// 0x0000 (0x0048 - 0x0048)
class UNavQuery_Awareness final : public UNavigationQueryFilter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavQuery_Awareness">();
	}
	static class UNavQuery_Awareness* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavQuery_Awareness>();
	}
};
static_assert(alignof(UNavQuery_Awareness) == 0x000008, "Wrong alignment on UNavQuery_Awareness");
static_assert(sizeof(UNavQuery_Awareness) == 0x000048, "Wrong size on UNavQuery_Awareness");

// Class ReadyOrNot.NavQuery_SearchAndSecure
// 0x0000 (0x0048 - 0x0048)
class UNavQuery_SearchAndSecure final : public UNavigationQueryFilter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavQuery_SearchAndSecure">();
	}
	static class UNavQuery_SearchAndSecure* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavQuery_SearchAndSecure>();
	}
};
static_assert(alignof(UNavQuery_SearchAndSecure) == 0x000008, "Wrong alignment on UNavQuery_SearchAndSecure");
static_assert(sizeof(UNavQuery_SearchAndSecure) == 0x000048, "Wrong size on UNavQuery_SearchAndSecure");

// Class ReadyOrNot.NavQuery_MoveToExit
// 0x0000 (0x0048 - 0x0048)
class UNavQuery_MoveToExit final : public UNavigationQueryFilter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavQuery_MoveToExit">();
	}
	static class UNavQuery_MoveToExit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavQuery_MoveToExit>();
	}
};
static_assert(alignof(UNavQuery_MoveToExit) == 0x000008, "Wrong alignment on UNavQuery_MoveToExit");
static_assert(sizeof(UNavQuery_MoveToExit) == 0x000048, "Wrong size on UNavQuery_MoveToExit");

// Class ReadyOrNot.ReadyOrNotPlayerCameraManager
// 0x0000 (0x23C0 - 0x23C0)
class AReadyOrNotPlayerCameraManager final : public APlayerCameraManager
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotPlayerCameraManager">();
	}
	static class AReadyOrNotPlayerCameraManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AReadyOrNotPlayerCameraManager>();
	}
};
static_assert(alignof(AReadyOrNotPlayerCameraManager) == 0x000010, "Wrong alignment on AReadyOrNotPlayerCameraManager");
static_assert(sizeof(AReadyOrNotPlayerCameraManager) == 0x0023C0, "Wrong size on AReadyOrNotPlayerCameraManager");

// Class ReadyOrNot.ReadyOrNotPlayerState
// 0x0AC0 (0x0E10 - 0x0350)
class AReadyOrNotPlayerState final : public APlayerState
{
public:
	uint8                                         Pad_350[0x18];                                     // 0x0350(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bHasFinishedLoading;                               // 0x0368(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_369[0x3];                                      // 0x0369(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Kills;                                             // 0x036C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KillsThisLife;                                     // 0x0370(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamKills;                                         // 0x0374(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Arrests;                                           // 0x0378(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TimesArrested;                                     // 0x037C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ArrestsThisLife;                                   // 0x0380(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Objectives;                                        // 0x0384(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Reports;                                           // 0x0388(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Evidence;                                          // 0x038C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AEvidenceActor*>                 EvidenceActorsInPossession;                        // 0x0390(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A0[0x8];                                      // 0x03A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerCharacter*                       LastCharacter;                                     // 0x03A8(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageType>                DeathDamageType;                                   // 0x03B0(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABaseMagazineWeapon*                    DeathWeapon;                                       // 0x03B8(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFireMode                                     LastFireMode;                                      // 0x03C0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDeadToPointDamage;                                // 0x03C1(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C2[0x6];                                      // 0x03C2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             DeathTraceHit;                                     // 0x03C8(0x00E8)(BlueprintVisible, BlueprintReadOnly, Net, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class APlayerCharacter*                       DeathKiller;                                       // 0x04B0(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Deaths;                                            // 0x04B8(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Incapacitations;                                   // 0x04BC(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageDealt;                                       // 0x04C0(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageReceived;                                    // 0x04C4(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlayerSpawnTag;                                    // 0x04C8(0x0010)(BlueprintVisible, Net, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D8[0x2];                                      // 0x04D8(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	ETeamType                                     Team;                                              // 0x04DA(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4DB[0x1];                                      // 0x04DB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	EPlanningLineTeam                             PlanningTeam;                                      // 0x04DC(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4DD[0x3];                                      // 0x04DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSavedLoadout                          ServerSavedLoadout;                                // 0x04E0(0x02E8)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FSavedLoadout& NewLoadout)> OnPlayerLoadoutChanged;   // 0x07C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D8[0x1];                                      // 0x07D8(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bReady;                                            // 0x07D9(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSquadLeader;                                      // 0x07DA(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7DB[0x1D];                                     // 0x07DB(0x001D)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSavedLoadout                          LastLoadout;                                       // 0x07F8(0x02E8)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	float                                         PointsFromKills;                                   // 0x0AE0(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PointsFromDamage;                                  // 0x0AE4(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PointsFromArrests;                                 // 0x0AE8(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PointsFromObjective;                               // 0x0AEC(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PointsFromReportingKills;                          // 0x0AF0(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PointsFromReportingArrests;                        // 0x0AF4(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(ETeamType Team)> OnTeamChanged;                                    // 0x0AF8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(EPlanningLineTeam Team)> OnPlanningTeamChanged;                    // 0x0B08(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bIsInGame;                                         // 0x0B18(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bJoinInProgress;                                   // 0x0B19(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsVIP;                                            // 0x0B1A(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasVIP;                                           // 0x0B1B(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GrenadesThrown;                                    // 0x0B1C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalYells;                                        // 0x0B20(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumberOrdersGiven;                                 // 0x0B24(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BulletsHit;                                        // 0x0B28(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BulletsHitThisLife;                                // 0x0B2C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Headshots;                                         // 0x0B30(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeAlive;                                         // 0x0B34(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B38[0x8];                                      // 0x0B38(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EVoiceType                                    VoiceType;                                         // 0x0B40(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsTalking;                                        // 0x0B41(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B42[0x6];                                      // 0x0B42(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnVoiceChannelChanged;                             // 0x0B48(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B58[0x8];                                      // 0x0B58(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bTorsoInjured;                                     // 0x0B60(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLeftArmInjured;                                   // 0x0B61(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRightArmInjured;                                  // 0x0B62(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLeftLegInjured;                                   // 0x0B63(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRightLegInjured;                                  // 0x0B64(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHeadInjured;                                      // 0x0B65(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B66[0x2];                                      // 0x0B66(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BulletsBlocked;                                    // 0x0B68(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HitsReceived;                                      // 0x0B6C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B70[0x10];                                     // 0x0B70(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsReplaySpectator;                                // 0x0B80(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B81[0x3];                                      // 0x0B81(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PlanningPlayerNumber;                              // 0x0B84(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPlanningDrawingArray                  DrawingArray;                                      // 0x0B88(0x0118)(Net, NativeAccessSpecifierPublic)
	struct FPlanningDrawing                       CurrentDrawing;                                    // 0x0CA0(0x0028)(Net, NativeAccessSpecifierPublic)
	struct FSavedCustomization                    Customization;                                     // 0x0CC8(0x0140)(Net, RepNotify, NativeAccessSpecifierPublic)
	uint8                                         Pad_E08[0x8];                                      // 0x0E08(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool HasEveryoneFinishedLoading(int32* OutTotal, int32* OutLoading, int32* OutLoaded);

	void Client_GrantAchievement(EAchievement AchievementType);
	void Client_IncreaseAchievementStat(EAchievementStats AchievementStat, int32 Value);
	void Client_IncreaseCurrentMissionAchievementStat(EAchievement Achievement, int32 AddedToCount);
	int32 GetDeathCount();
	int32 GetKillCount();
	void GetNetworkStatus(float* AvgLag);
	ETeamType GetPendingTeam();
	ETeamType GetTeam();
	EVoiceType GetVoiceType();
	bool IsOwnerOfPlayerState();
	bool IsSquadLeader();
	bool IsVipPlayerState();
	void Notify_PendingChangeTeam(ETeamType NewTeamType);
	void OnRep_Customization();
	void OnRep_PlanningTeam();
	void OnRep_SquadLeader();
	void OnRep_Team();
	void OnRep_UpdateServerSavedLoadout();
	void OnRep_VoiceType();
	void Server_FinishDrawing();
	void Server_SendUnlockedDLC(EGameVersionRestriction Dlc);
	void Server_SetCustomization(const struct FSavedCustomization& InCustomization);
	void Server_SetIsInGame(bool bNewIsInGame);
	void Server_SetLoadout(const struct FSavedLoadout& NewLoadout);
	void Server_SetPlanningTeam(EPlanningLineTeam NewTeam);
	void Server_SetPlayerName(class FName NewPlayerName);
	void Server_SetReady(bool bIsReady, const struct FSavedLoadout& NewLoadout);
	void Server_SetTeam(ETeamType NewTeam);
	void Server_SetVoiceType(EVoiceType NewVoiceType);
	void Server_StartDrawing(int32 Floor, const struct FVector2D& StartingPoint);
	void Server_UpdateDrawing(const struct FVector2D& NewPoint);
	void Server_UpdatePlayerSpawnTag(const class FString& NewTag);
	void ServerSetJoinedOnSquadLeader();
	void SetIsTalking(bool bNewTalking);
	void SetReady(bool bIsReady, const struct FSavedLoadout& NewLoadout);
	void SetTeam(ETeamType NewTeam);
	void UpdateScore();

	int32 GetPlanningPlayerNumber() const;
	bool IsTalking() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotPlayerState">();
	}
	static class AReadyOrNotPlayerState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AReadyOrNotPlayerState>();
	}
};
static_assert(alignof(AReadyOrNotPlayerState) == 0x000008, "Wrong alignment on AReadyOrNotPlayerState");
static_assert(sizeof(AReadyOrNotPlayerState) == 0x000E10, "Wrong size on AReadyOrNotPlayerState");
static_assert(offsetof(AReadyOrNotPlayerState, bHasFinishedLoading) == 0x000368, "Member 'AReadyOrNotPlayerState::bHasFinishedLoading' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, Kills) == 0x00036C, "Member 'AReadyOrNotPlayerState::Kills' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, KillsThisLife) == 0x000370, "Member 'AReadyOrNotPlayerState::KillsThisLife' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, TeamKills) == 0x000374, "Member 'AReadyOrNotPlayerState::TeamKills' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, Arrests) == 0x000378, "Member 'AReadyOrNotPlayerState::Arrests' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, TimesArrested) == 0x00037C, "Member 'AReadyOrNotPlayerState::TimesArrested' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, ArrestsThisLife) == 0x000380, "Member 'AReadyOrNotPlayerState::ArrestsThisLife' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, Objectives) == 0x000384, "Member 'AReadyOrNotPlayerState::Objectives' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, Reports) == 0x000388, "Member 'AReadyOrNotPlayerState::Reports' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, Evidence) == 0x00038C, "Member 'AReadyOrNotPlayerState::Evidence' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, EvidenceActorsInPossession) == 0x000390, "Member 'AReadyOrNotPlayerState::EvidenceActorsInPossession' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, LastCharacter) == 0x0003A8, "Member 'AReadyOrNotPlayerState::LastCharacter' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, DeathDamageType) == 0x0003B0, "Member 'AReadyOrNotPlayerState::DeathDamageType' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, DeathWeapon) == 0x0003B8, "Member 'AReadyOrNotPlayerState::DeathWeapon' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, LastFireMode) == 0x0003C0, "Member 'AReadyOrNotPlayerState::LastFireMode' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, bDeadToPointDamage) == 0x0003C1, "Member 'AReadyOrNotPlayerState::bDeadToPointDamage' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, DeathTraceHit) == 0x0003C8, "Member 'AReadyOrNotPlayerState::DeathTraceHit' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, DeathKiller) == 0x0004B0, "Member 'AReadyOrNotPlayerState::DeathKiller' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, Deaths) == 0x0004B8, "Member 'AReadyOrNotPlayerState::Deaths' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, Incapacitations) == 0x0004BC, "Member 'AReadyOrNotPlayerState::Incapacitations' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, DamageDealt) == 0x0004C0, "Member 'AReadyOrNotPlayerState::DamageDealt' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, DamageReceived) == 0x0004C4, "Member 'AReadyOrNotPlayerState::DamageReceived' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, PlayerSpawnTag) == 0x0004C8, "Member 'AReadyOrNotPlayerState::PlayerSpawnTag' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, Team) == 0x0004DA, "Member 'AReadyOrNotPlayerState::Team' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, PlanningTeam) == 0x0004DC, "Member 'AReadyOrNotPlayerState::PlanningTeam' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, ServerSavedLoadout) == 0x0004E0, "Member 'AReadyOrNotPlayerState::ServerSavedLoadout' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, OnPlayerLoadoutChanged) == 0x0007C8, "Member 'AReadyOrNotPlayerState::OnPlayerLoadoutChanged' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, bReady) == 0x0007D9, "Member 'AReadyOrNotPlayerState::bReady' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, bSquadLeader) == 0x0007DA, "Member 'AReadyOrNotPlayerState::bSquadLeader' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, LastLoadout) == 0x0007F8, "Member 'AReadyOrNotPlayerState::LastLoadout' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, PointsFromKills) == 0x000AE0, "Member 'AReadyOrNotPlayerState::PointsFromKills' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, PointsFromDamage) == 0x000AE4, "Member 'AReadyOrNotPlayerState::PointsFromDamage' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, PointsFromArrests) == 0x000AE8, "Member 'AReadyOrNotPlayerState::PointsFromArrests' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, PointsFromObjective) == 0x000AEC, "Member 'AReadyOrNotPlayerState::PointsFromObjective' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, PointsFromReportingKills) == 0x000AF0, "Member 'AReadyOrNotPlayerState::PointsFromReportingKills' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, PointsFromReportingArrests) == 0x000AF4, "Member 'AReadyOrNotPlayerState::PointsFromReportingArrests' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, OnTeamChanged) == 0x000AF8, "Member 'AReadyOrNotPlayerState::OnTeamChanged' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, OnPlanningTeamChanged) == 0x000B08, "Member 'AReadyOrNotPlayerState::OnPlanningTeamChanged' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, bIsInGame) == 0x000B18, "Member 'AReadyOrNotPlayerState::bIsInGame' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, bJoinInProgress) == 0x000B19, "Member 'AReadyOrNotPlayerState::bJoinInProgress' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, bIsVIP) == 0x000B1A, "Member 'AReadyOrNotPlayerState::bIsVIP' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, bWasVIP) == 0x000B1B, "Member 'AReadyOrNotPlayerState::bWasVIP' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, GrenadesThrown) == 0x000B1C, "Member 'AReadyOrNotPlayerState::GrenadesThrown' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, TotalYells) == 0x000B20, "Member 'AReadyOrNotPlayerState::TotalYells' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, NumberOrdersGiven) == 0x000B24, "Member 'AReadyOrNotPlayerState::NumberOrdersGiven' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, BulletsHit) == 0x000B28, "Member 'AReadyOrNotPlayerState::BulletsHit' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, BulletsHitThisLife) == 0x000B2C, "Member 'AReadyOrNotPlayerState::BulletsHitThisLife' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, Headshots) == 0x000B30, "Member 'AReadyOrNotPlayerState::Headshots' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, TimeAlive) == 0x000B34, "Member 'AReadyOrNotPlayerState::TimeAlive' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, VoiceType) == 0x000B40, "Member 'AReadyOrNotPlayerState::VoiceType' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, bIsTalking) == 0x000B41, "Member 'AReadyOrNotPlayerState::bIsTalking' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, OnVoiceChannelChanged) == 0x000B48, "Member 'AReadyOrNotPlayerState::OnVoiceChannelChanged' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, bTorsoInjured) == 0x000B60, "Member 'AReadyOrNotPlayerState::bTorsoInjured' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, bLeftArmInjured) == 0x000B61, "Member 'AReadyOrNotPlayerState::bLeftArmInjured' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, bRightArmInjured) == 0x000B62, "Member 'AReadyOrNotPlayerState::bRightArmInjured' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, bLeftLegInjured) == 0x000B63, "Member 'AReadyOrNotPlayerState::bLeftLegInjured' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, bRightLegInjured) == 0x000B64, "Member 'AReadyOrNotPlayerState::bRightLegInjured' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, bHeadInjured) == 0x000B65, "Member 'AReadyOrNotPlayerState::bHeadInjured' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, BulletsBlocked) == 0x000B68, "Member 'AReadyOrNotPlayerState::BulletsBlocked' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, HitsReceived) == 0x000B6C, "Member 'AReadyOrNotPlayerState::HitsReceived' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, bIsReplaySpectator) == 0x000B80, "Member 'AReadyOrNotPlayerState::bIsReplaySpectator' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, PlanningPlayerNumber) == 0x000B84, "Member 'AReadyOrNotPlayerState::PlanningPlayerNumber' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, DrawingArray) == 0x000B88, "Member 'AReadyOrNotPlayerState::DrawingArray' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, CurrentDrawing) == 0x000CA0, "Member 'AReadyOrNotPlayerState::CurrentDrawing' has a wrong offset!");
static_assert(offsetof(AReadyOrNotPlayerState, Customization) == 0x000CC8, "Member 'AReadyOrNotPlayerState::Customization' has a wrong offset!");

// Class ReadyOrNot.ReadyOrNotSignificanceManager
// 0x0210 (0x0250 - 0x0040)
class UReadyOrNotSignificanceManager final : public UTickableWorldSubsystem
{
public:
	uint8                                         Pad_40[0x18];                                      // 0x0040(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         ActorsMadeIrrelevantThisFrame;                     // 0x0058(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         ActorsMadeRelevantThisFrame;                       // 0x0068(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         ActorsMadeIrrelevant;                              // 0x0078(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         ActorsRelevantToSignificance;                      // 0x0090(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<class AReadyOrNotCharacter*>           CharactersRelevantToSignificance;                  // 0x00A0(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TMap<class USkeletalMeshComponent*, class USkeletalMesh*> SkeletalMeshLookupMap;                 // 0x00B0(0x0050)(ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TMap<class USceneComponent*, struct FOptimizationAttachmentData> SceneCompAttachmentData;        // 0x0100(0x0050)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<class UStaticMeshComponent*, class UStaticMesh*> StaticMeshLookupMap;                       // 0x0150(0x0050)(ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<class AReadyOrNotCharacter*>           IrrelevantPlayerCharacters;                        // 0x01A0(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B0[0x70];                                     // 0x01B0(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTransform>                     RelevantViewpoints;                                // 0x0220(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         PlayerViewTargets;                                 // 0x0230(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_240[0x10];                                     // 0x0240(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotSignificanceManager">();
	}
	static class UReadyOrNotSignificanceManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotSignificanceManager>();
	}
};
static_assert(alignof(UReadyOrNotSignificanceManager) == 0x000008, "Wrong alignment on UReadyOrNotSignificanceManager");
static_assert(sizeof(UReadyOrNotSignificanceManager) == 0x000250, "Wrong size on UReadyOrNotSignificanceManager");
static_assert(offsetof(UReadyOrNotSignificanceManager, ActorsMadeIrrelevantThisFrame) == 0x000058, "Member 'UReadyOrNotSignificanceManager::ActorsMadeIrrelevantThisFrame' has a wrong offset!");
static_assert(offsetof(UReadyOrNotSignificanceManager, ActorsMadeRelevantThisFrame) == 0x000068, "Member 'UReadyOrNotSignificanceManager::ActorsMadeRelevantThisFrame' has a wrong offset!");
static_assert(offsetof(UReadyOrNotSignificanceManager, ActorsMadeIrrelevant) == 0x000078, "Member 'UReadyOrNotSignificanceManager::ActorsMadeIrrelevant' has a wrong offset!");
static_assert(offsetof(UReadyOrNotSignificanceManager, ActorsRelevantToSignificance) == 0x000090, "Member 'UReadyOrNotSignificanceManager::ActorsRelevantToSignificance' has a wrong offset!");
static_assert(offsetof(UReadyOrNotSignificanceManager, CharactersRelevantToSignificance) == 0x0000A0, "Member 'UReadyOrNotSignificanceManager::CharactersRelevantToSignificance' has a wrong offset!");
static_assert(offsetof(UReadyOrNotSignificanceManager, SkeletalMeshLookupMap) == 0x0000B0, "Member 'UReadyOrNotSignificanceManager::SkeletalMeshLookupMap' has a wrong offset!");
static_assert(offsetof(UReadyOrNotSignificanceManager, SceneCompAttachmentData) == 0x000100, "Member 'UReadyOrNotSignificanceManager::SceneCompAttachmentData' has a wrong offset!");
static_assert(offsetof(UReadyOrNotSignificanceManager, StaticMeshLookupMap) == 0x000150, "Member 'UReadyOrNotSignificanceManager::StaticMeshLookupMap' has a wrong offset!");
static_assert(offsetof(UReadyOrNotSignificanceManager, IrrelevantPlayerCharacters) == 0x0001A0, "Member 'UReadyOrNotSignificanceManager::IrrelevantPlayerCharacters' has a wrong offset!");
static_assert(offsetof(UReadyOrNotSignificanceManager, RelevantViewpoints) == 0x000220, "Member 'UReadyOrNotSignificanceManager::RelevantViewpoints' has a wrong offset!");
static_assert(offsetof(UReadyOrNotSignificanceManager, PlayerViewTargets) == 0x000230, "Member 'UReadyOrNotSignificanceManager::PlayerViewTargets' has a wrong offset!");

// Class ReadyOrNot.ReadyOrNotSpinTestController
// 0x0058 (0x0088 - 0x0030)
class UReadyOrNotSpinTestController final : public UGauntletTestController
{
public:
	uint8                                         Pad_30[0x58];                                      // 0x0030(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void On60FPSTick();
	void StartTesting();
	void StopProfiling();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotSpinTestController">();
	}
	static class UReadyOrNotSpinTestController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotSpinTestController>();
	}
};
static_assert(alignof(UReadyOrNotSpinTestController) == 0x000008, "Wrong alignment on UReadyOrNotSpinTestController");
static_assert(sizeof(UReadyOrNotSpinTestController) == 0x000088, "Wrong size on UReadyOrNotSpinTestController");

// Class ReadyOrNot.ReadyOrNotStatics
// 0x0000 (0x0028 - 0x0028)
class UReadyOrNotStatics final : public UBlueprintFunctionLibrary
{
public:
	static bool DoesMapExist(const class FString& Map);
	static class AConversationManager* GetConversationManager();
	static class UReadyOrNotGameInstance* GetReadyOrNotGameInstance();
	static class AReadyOrNotGameMode* GetReadyOrNotGameMode();
	static class AReadyOrNotGameState* GetReadyOrNotGameState();
	static class AReadyOrNotLevelScript* GetReadyOrNotLevelScript();
	static class AReadyOrNotPlayerController* GetReadyOrNotPlayerController();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotStatics">();
	}
	static class UReadyOrNotStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotStatics>();
	}
};
static_assert(alignof(UReadyOrNotStatics) == 0x000008, "Wrong alignment on UReadyOrNotStatics");
static_assert(sizeof(UReadyOrNotStatics) == 0x000028, "Wrong size on UReadyOrNotStatics");

// Class ReadyOrNot.ReadyOrNotWeaponAnimData
// 0x10A8 (0x10D8 - 0x0030)
class UReadyOrNotWeaponAnimData final : public UDataAsset
{
public:
	class UAnimSequenceBase*                      IdlePose_FP;                                       // 0x0030(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Idle_FP;                                           // 0x0038(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Run_FP;                                            // 0x0040(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Walk_FP;                                           // 0x0048(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Run_Limp_FP;                                       // 0x0050(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Walk_Limp_FP;                                      // 0x0058(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            Look_BS_FP;                                        // 0x0060(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Lowered_Up_Pose_FP;                                // 0x0068(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Lowered_Down_Pose_FP;                              // 0x0070(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      ADS_Run_FP;                                        // 0x0078(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      ADS_Walk_FP;                                       // 0x0080(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      ADS_Run_Limp_FP;                                   // 0x0088(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      ADS_Walk_Limp_FP;                                  // 0x0090(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      IdlePose_AFG_FP;                                   // 0x0098(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      IdlePose_VFG_FP;                                   // 0x00A0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      IdlePose_HSTOP_FP;                                 // 0x00A8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      IdlePose_RK1_FP;                                   // 0x00B0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      IdlePose_CQR_FP;                                   // 0x00B8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      IdlePose_Low_TP;                                   // 0x00C0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      IdlePose_Up_TP;                                    // 0x00C8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      IdlePose_Shld_TP;                                  // 0x00D0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      IdlePose_Sights_TP;                                // 0x00D8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      IdlePose_Ret_TP;                                   // 0x00E0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      IdlePose_Ovr_TP;                                   // 0x00E8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Crouch_IdlePose_Low_TP;                            // 0x00F0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Crouch_IdlePose_Up_TP;                             // 0x00F8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Crouch_IdlePose_Shld_TP;                           // 0x0100(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Crouch_IdlePose_Sights_TP;                         // 0x0108(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Crouch_IdlePose_Ret_TP;                            // 0x0110(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Crouch_IdlePose_Ovr_TP;                            // 0x0118(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Reload;                                            // 0x0120(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            ReloadEmpty;                                       // 0x0140(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Crouch_Reload;                                     // 0x0160(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Crouch_ReloadEmpty;                                // 0x0180(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Tactical_Reload;                                   // 0x01A0(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Tactical_ReloadEmpty;                              // 0x01C0(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FWeaponAnim>                    ShellRack_Reload;                                  // 0x01E0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FWeaponAnim>                    ShellRack_ReloadEmpty;                             // 0x01F0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FWeaponAnim>                    ShellRack_ReloadRack;                              // 0x0200(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Tactical_Crouch_Reload;                            // 0x0210(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Tactical_Crouch_ReloadEmpty;                       // 0x0230(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            MeleeHit;                                          // 0x0250(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            MeleeMiss;                                         // 0x0270(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            FireSelect_Auto;                                   // 0x0290(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            FireSelect_Burst;                                  // 0x02B0(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            FireSelect_Semi;                                   // 0x02D0(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            FireSelect_Safe;                                   // 0x02F0(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Crouch_FireSelect_Auto;                            // 0x0310(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Crouch_FireSelect_Burst;                           // 0x0330(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Crouch_FireSelect_Semi;                            // 0x0350(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Crouch_FireSelect_Safe;                            // 0x0370(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Reload_Start;                                      // 0x0390(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Reload_Loop;                                       // 0x03B0(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Reload_End;                                        // 0x03D0(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Reload_Start_Empty;                                // 0x03F0(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Reload_Loop_Empty;                                 // 0x0410(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Reload_End_Empty;                                  // 0x0430(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Crouch_Reload_Start;                               // 0x0450(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Crouch_Reload_Loop;                                // 0x0470(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Crouch_Reload_End;                                 // 0x0490(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Crouch_Reload_Start_Empty;                         // 0x04B0(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Crouch_Reload_Loop_Empty;                          // 0x04D0(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Crouch_Reload_End_Empty;                           // 0x04F0(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            MagazineCheck;                                     // 0x0510(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Crouch_MagazineCheck;                              // 0x0530(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            MagazineCheckSights;                               // 0x0550(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Crouch_MagazineCheckSights;                        // 0x0570(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FWeaponAnim>                    FireSingle;                                        // 0x0590(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FWeaponAnim>                    FireSingleSights;                                  // 0x05A0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            FireSingleLast;                                    // 0x05B0(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            FireSingleSightsLast;                              // 0x05D0(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            DryFire;                                           // 0x05F0(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FWeaponAnim>                    Crouch_FireSingle;                                 // 0x0610(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FWeaponAnim>                    Crouch_FireSingleSights;                           // 0x0620(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Crouch_FireSingleLast;                             // 0x0630(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Crouch_FireSingleSightsLast;                       // 0x0650(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Crouch_Dryfire;                                    // 0x0670(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            FireLoop;                                          // 0x0690(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            FireLoopEnd;                                       // 0x06B0(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            FireLoopSights;                                    // 0x06D0(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            FireLoopSightsEnd;                                 // 0x06F0(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Crouch_FireLoop;                                   // 0x0710(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Crouch_FireLoopEnd;                                // 0x0730(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Crouch_FireLoopSights;                             // 0x0750(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Crouch_FireLoopSightsEnd;                          // 0x0770(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Draw;                                              // 0x0790(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            DrawFirst;                                         // 0x07B0(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Crouch_Draw;                                       // 0x07D0(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Crouch_DrawFirst;                                  // 0x07F0(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Holster;                                           // 0x0810(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Crouch_Holster;                                    // 0x0830(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            PullPin;                                           // 0x0850(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Throw;                                             // 0x0870(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            PullPinUnderarm;                                   // 0x0890(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            ThrowUnderarm;                                     // 0x08B0(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Crouch_PullPin;                                    // 0x08D0(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Crouch_Throw;                                      // 0x08F0(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Crouch_PullPinUnderarm;                            // 0x0910(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Crouch_ThrowUnderarm;                              // 0x0930(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            QuickThrow_PinPull;                                // 0x0950(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Quickthrow_Throw;                                  // 0x0970(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Crouch_QuickThrow_PinPull;                         // 0x0990(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Crouch_QuickThrow_Throw;                           // 0x09B0(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            QuickThrow_Fast;                                   // 0x09D0(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Crouch_QuickThrow_Fast;                            // 0x09F0(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Multitool_Use;                                     // 0x0A10(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Multitool_Use_End;                                 // 0x0A30(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Multitool_Cutters_To_Lockpick;                     // 0x0A50(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Multitool_Cutters_To_Knife;                        // 0x0A70(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Multitool_Lockpick_To_Cutters;                     // 0x0A90(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Multitool_Lockpick_To_Knife;                       // 0x0AB0(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Multitool_Knife_To_Lockpick;                       // 0x0AD0(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Multitool_Knife_To_Cutters;                        // 0x0AF0(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Optiwand_Start_Screening;                          // 0x0B10(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Optiwand_End_Screening;                            // 0x0B30(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Charge_Valid_Plant_Start;                          // 0x0B50(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Charge_Valid_Plant_End;                            // 0x0B70(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            PlantCharge;                                       // 0x0B90(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            DetonateCharge;                                    // 0x0BB0(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            EnableNVG;                                         // 0x0BD0(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            DisableNVG;                                        // 0x0BF0(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            ShieldDownToUp;                                    // 0x0C10(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            ShieldUpToDown;                                    // 0x0C30(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Crouch_ShieldDownToUp;                             // 0x0C50(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Crouch_ShieldUpToDown;                             // 0x0C70(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            ShieldHit;                                         // 0x0C90(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            TabletDownToUp;                                    // 0x0CB0(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            TabletUpToDown;                                    // 0x0CD0(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            TabletSwitchCameraDown;                            // 0x0CF0(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            TabletSwitchCameraUp;                              // 0x0D10(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            EvidencePickup;                                    // 0x0D30(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Yell;                                              // 0x0D50(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            RadioSelect;                                       // 0x0D70(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bRadioUsesNotifies;                                // 0x0D90(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D91[0x7];                                      // 0x0D91(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FWeaponAnim                            DoorPush;                                          // 0x0D98(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            ButtonPush;                                        // 0x0DB8(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            WeaponClearing;                                    // 0x0DD8(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            ReactToSting;                                      // 0x0DF8(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            ReactToFlash;                                      // 0x0E18(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            ReactToTaser;                                      // 0x0E38(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            ReactToGas;                                        // 0x0E58(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            ReactToPepperSpray;                                // 0x0E78(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            ReactToSting_End;                                  // 0x0E98(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            ReactToFlash_End;                                  // 0x0EB8(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            ReactToTaser_End;                                  // 0x0ED8(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            ReactToGas_End;                                    // 0x0EF8(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            ReactToPepperSpray_End;                            // 0x0F18(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Reload_Level_01;                                   // 0x0F38(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Reload_Level_02;                                   // 0x0F58(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Reload_Level_03;                                   // 0x0F78(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Recoil_Level_01;                                   // 0x0F98(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Recoil_Level_02;                                   // 0x0FB8(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            Recoil_Level_03;                                   // 0x0FD8(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Grip_VFG_Body_FP_Fire;                             // 0x0FF8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Grip_VFG_Body_FP_Fire_Last;                        // 0x1000(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Grip_VFG_Body_FP_Fire_Aim;                         // 0x1008(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Grip_VFG_Body_FP_Fire_Aim_Last;                    // 0x1010(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Grip_AFG_Body_FP_Fire;                             // 0x1018(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Grip_AFG_Body_FP_Fire_Last;                        // 0x1020(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Grip_AFG_Body_FP_Fire_Aim;                         // 0x1028(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Grip_AFG_Body_FP_Fire_Aim_Last;                    // 0x1030(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            SpeedReload_OneTime;                               // 0x1038(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeaponAnim                            SpeedReloadEmpty_OneTime;                          // 0x1058(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Reload_FP_Ads;                                     // 0x1078(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ReloadEmpty_FP_Ads;                                // 0x1080(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Tactical_Reload_FP_Ads;                            // 0x1088(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Tactical_ReloadEmpty_FP_Ads;                       // 0x1090(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEmptyReload;                                      // 0x1098(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasRetentionAdditives;                            // 0x1099(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasLoweredAdditives;                              // 0x109A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasSightAdditives;                                // 0x109B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideFireAnimForGrip;                          // 0x109C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseOneTimeSpeedReload;                            // 0x109D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_109E[0x2];                                     // 0x109E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      IdlePose_AFG_TP;                                   // 0x10A0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      IdlePose_VFG_TP;                                   // 0x10A8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      IdlePose_HSTOP_TP;                                 // 0x10B0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      IdlePose_RK1_TP;                                   // 0x10B8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      IdlePose_CQR_TP;                                   // 0x10C0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      IdlePose_AI_Calm;                                  // 0x10C8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      IdlePose_AI_Aiming;                                // 0x10D0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadyOrNotWeaponAnimData">();
	}
	static class UReadyOrNotWeaponAnimData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadyOrNotWeaponAnimData>();
	}
};
static_assert(alignof(UReadyOrNotWeaponAnimData) == 0x000008, "Wrong alignment on UReadyOrNotWeaponAnimData");
static_assert(sizeof(UReadyOrNotWeaponAnimData) == 0x0010D8, "Wrong size on UReadyOrNotWeaponAnimData");
static_assert(offsetof(UReadyOrNotWeaponAnimData, IdlePose_FP) == 0x000030, "Member 'UReadyOrNotWeaponAnimData::IdlePose_FP' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Idle_FP) == 0x000038, "Member 'UReadyOrNotWeaponAnimData::Idle_FP' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Run_FP) == 0x000040, "Member 'UReadyOrNotWeaponAnimData::Run_FP' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Walk_FP) == 0x000048, "Member 'UReadyOrNotWeaponAnimData::Walk_FP' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Run_Limp_FP) == 0x000050, "Member 'UReadyOrNotWeaponAnimData::Run_Limp_FP' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Walk_Limp_FP) == 0x000058, "Member 'UReadyOrNotWeaponAnimData::Walk_Limp_FP' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Look_BS_FP) == 0x000060, "Member 'UReadyOrNotWeaponAnimData::Look_BS_FP' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Lowered_Up_Pose_FP) == 0x000068, "Member 'UReadyOrNotWeaponAnimData::Lowered_Up_Pose_FP' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Lowered_Down_Pose_FP) == 0x000070, "Member 'UReadyOrNotWeaponAnimData::Lowered_Down_Pose_FP' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, ADS_Run_FP) == 0x000078, "Member 'UReadyOrNotWeaponAnimData::ADS_Run_FP' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, ADS_Walk_FP) == 0x000080, "Member 'UReadyOrNotWeaponAnimData::ADS_Walk_FP' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, ADS_Run_Limp_FP) == 0x000088, "Member 'UReadyOrNotWeaponAnimData::ADS_Run_Limp_FP' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, ADS_Walk_Limp_FP) == 0x000090, "Member 'UReadyOrNotWeaponAnimData::ADS_Walk_Limp_FP' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, IdlePose_AFG_FP) == 0x000098, "Member 'UReadyOrNotWeaponAnimData::IdlePose_AFG_FP' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, IdlePose_VFG_FP) == 0x0000A0, "Member 'UReadyOrNotWeaponAnimData::IdlePose_VFG_FP' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, IdlePose_HSTOP_FP) == 0x0000A8, "Member 'UReadyOrNotWeaponAnimData::IdlePose_HSTOP_FP' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, IdlePose_RK1_FP) == 0x0000B0, "Member 'UReadyOrNotWeaponAnimData::IdlePose_RK1_FP' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, IdlePose_CQR_FP) == 0x0000B8, "Member 'UReadyOrNotWeaponAnimData::IdlePose_CQR_FP' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, IdlePose_Low_TP) == 0x0000C0, "Member 'UReadyOrNotWeaponAnimData::IdlePose_Low_TP' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, IdlePose_Up_TP) == 0x0000C8, "Member 'UReadyOrNotWeaponAnimData::IdlePose_Up_TP' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, IdlePose_Shld_TP) == 0x0000D0, "Member 'UReadyOrNotWeaponAnimData::IdlePose_Shld_TP' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, IdlePose_Sights_TP) == 0x0000D8, "Member 'UReadyOrNotWeaponAnimData::IdlePose_Sights_TP' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, IdlePose_Ret_TP) == 0x0000E0, "Member 'UReadyOrNotWeaponAnimData::IdlePose_Ret_TP' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, IdlePose_Ovr_TP) == 0x0000E8, "Member 'UReadyOrNotWeaponAnimData::IdlePose_Ovr_TP' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_IdlePose_Low_TP) == 0x0000F0, "Member 'UReadyOrNotWeaponAnimData::Crouch_IdlePose_Low_TP' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_IdlePose_Up_TP) == 0x0000F8, "Member 'UReadyOrNotWeaponAnimData::Crouch_IdlePose_Up_TP' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_IdlePose_Shld_TP) == 0x000100, "Member 'UReadyOrNotWeaponAnimData::Crouch_IdlePose_Shld_TP' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_IdlePose_Sights_TP) == 0x000108, "Member 'UReadyOrNotWeaponAnimData::Crouch_IdlePose_Sights_TP' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_IdlePose_Ret_TP) == 0x000110, "Member 'UReadyOrNotWeaponAnimData::Crouch_IdlePose_Ret_TP' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_IdlePose_Ovr_TP) == 0x000118, "Member 'UReadyOrNotWeaponAnimData::Crouch_IdlePose_Ovr_TP' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Reload) == 0x000120, "Member 'UReadyOrNotWeaponAnimData::Reload' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, ReloadEmpty) == 0x000140, "Member 'UReadyOrNotWeaponAnimData::ReloadEmpty' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_Reload) == 0x000160, "Member 'UReadyOrNotWeaponAnimData::Crouch_Reload' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_ReloadEmpty) == 0x000180, "Member 'UReadyOrNotWeaponAnimData::Crouch_ReloadEmpty' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Tactical_Reload) == 0x0001A0, "Member 'UReadyOrNotWeaponAnimData::Tactical_Reload' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Tactical_ReloadEmpty) == 0x0001C0, "Member 'UReadyOrNotWeaponAnimData::Tactical_ReloadEmpty' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, ShellRack_Reload) == 0x0001E0, "Member 'UReadyOrNotWeaponAnimData::ShellRack_Reload' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, ShellRack_ReloadEmpty) == 0x0001F0, "Member 'UReadyOrNotWeaponAnimData::ShellRack_ReloadEmpty' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, ShellRack_ReloadRack) == 0x000200, "Member 'UReadyOrNotWeaponAnimData::ShellRack_ReloadRack' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Tactical_Crouch_Reload) == 0x000210, "Member 'UReadyOrNotWeaponAnimData::Tactical_Crouch_Reload' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Tactical_Crouch_ReloadEmpty) == 0x000230, "Member 'UReadyOrNotWeaponAnimData::Tactical_Crouch_ReloadEmpty' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, MeleeHit) == 0x000250, "Member 'UReadyOrNotWeaponAnimData::MeleeHit' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, MeleeMiss) == 0x000270, "Member 'UReadyOrNotWeaponAnimData::MeleeMiss' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, FireSelect_Auto) == 0x000290, "Member 'UReadyOrNotWeaponAnimData::FireSelect_Auto' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, FireSelect_Burst) == 0x0002B0, "Member 'UReadyOrNotWeaponAnimData::FireSelect_Burst' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, FireSelect_Semi) == 0x0002D0, "Member 'UReadyOrNotWeaponAnimData::FireSelect_Semi' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, FireSelect_Safe) == 0x0002F0, "Member 'UReadyOrNotWeaponAnimData::FireSelect_Safe' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_FireSelect_Auto) == 0x000310, "Member 'UReadyOrNotWeaponAnimData::Crouch_FireSelect_Auto' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_FireSelect_Burst) == 0x000330, "Member 'UReadyOrNotWeaponAnimData::Crouch_FireSelect_Burst' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_FireSelect_Semi) == 0x000350, "Member 'UReadyOrNotWeaponAnimData::Crouch_FireSelect_Semi' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_FireSelect_Safe) == 0x000370, "Member 'UReadyOrNotWeaponAnimData::Crouch_FireSelect_Safe' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Reload_Start) == 0x000390, "Member 'UReadyOrNotWeaponAnimData::Reload_Start' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Reload_Loop) == 0x0003B0, "Member 'UReadyOrNotWeaponAnimData::Reload_Loop' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Reload_End) == 0x0003D0, "Member 'UReadyOrNotWeaponAnimData::Reload_End' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Reload_Start_Empty) == 0x0003F0, "Member 'UReadyOrNotWeaponAnimData::Reload_Start_Empty' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Reload_Loop_Empty) == 0x000410, "Member 'UReadyOrNotWeaponAnimData::Reload_Loop_Empty' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Reload_End_Empty) == 0x000430, "Member 'UReadyOrNotWeaponAnimData::Reload_End_Empty' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_Reload_Start) == 0x000450, "Member 'UReadyOrNotWeaponAnimData::Crouch_Reload_Start' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_Reload_Loop) == 0x000470, "Member 'UReadyOrNotWeaponAnimData::Crouch_Reload_Loop' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_Reload_End) == 0x000490, "Member 'UReadyOrNotWeaponAnimData::Crouch_Reload_End' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_Reload_Start_Empty) == 0x0004B0, "Member 'UReadyOrNotWeaponAnimData::Crouch_Reload_Start_Empty' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_Reload_Loop_Empty) == 0x0004D0, "Member 'UReadyOrNotWeaponAnimData::Crouch_Reload_Loop_Empty' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_Reload_End_Empty) == 0x0004F0, "Member 'UReadyOrNotWeaponAnimData::Crouch_Reload_End_Empty' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, MagazineCheck) == 0x000510, "Member 'UReadyOrNotWeaponAnimData::MagazineCheck' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_MagazineCheck) == 0x000530, "Member 'UReadyOrNotWeaponAnimData::Crouch_MagazineCheck' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, MagazineCheckSights) == 0x000550, "Member 'UReadyOrNotWeaponAnimData::MagazineCheckSights' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_MagazineCheckSights) == 0x000570, "Member 'UReadyOrNotWeaponAnimData::Crouch_MagazineCheckSights' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, FireSingle) == 0x000590, "Member 'UReadyOrNotWeaponAnimData::FireSingle' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, FireSingleSights) == 0x0005A0, "Member 'UReadyOrNotWeaponAnimData::FireSingleSights' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, FireSingleLast) == 0x0005B0, "Member 'UReadyOrNotWeaponAnimData::FireSingleLast' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, FireSingleSightsLast) == 0x0005D0, "Member 'UReadyOrNotWeaponAnimData::FireSingleSightsLast' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, DryFire) == 0x0005F0, "Member 'UReadyOrNotWeaponAnimData::DryFire' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_FireSingle) == 0x000610, "Member 'UReadyOrNotWeaponAnimData::Crouch_FireSingle' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_FireSingleSights) == 0x000620, "Member 'UReadyOrNotWeaponAnimData::Crouch_FireSingleSights' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_FireSingleLast) == 0x000630, "Member 'UReadyOrNotWeaponAnimData::Crouch_FireSingleLast' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_FireSingleSightsLast) == 0x000650, "Member 'UReadyOrNotWeaponAnimData::Crouch_FireSingleSightsLast' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_Dryfire) == 0x000670, "Member 'UReadyOrNotWeaponAnimData::Crouch_Dryfire' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, FireLoop) == 0x000690, "Member 'UReadyOrNotWeaponAnimData::FireLoop' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, FireLoopEnd) == 0x0006B0, "Member 'UReadyOrNotWeaponAnimData::FireLoopEnd' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, FireLoopSights) == 0x0006D0, "Member 'UReadyOrNotWeaponAnimData::FireLoopSights' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, FireLoopSightsEnd) == 0x0006F0, "Member 'UReadyOrNotWeaponAnimData::FireLoopSightsEnd' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_FireLoop) == 0x000710, "Member 'UReadyOrNotWeaponAnimData::Crouch_FireLoop' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_FireLoopEnd) == 0x000730, "Member 'UReadyOrNotWeaponAnimData::Crouch_FireLoopEnd' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_FireLoopSights) == 0x000750, "Member 'UReadyOrNotWeaponAnimData::Crouch_FireLoopSights' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_FireLoopSightsEnd) == 0x000770, "Member 'UReadyOrNotWeaponAnimData::Crouch_FireLoopSightsEnd' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Draw) == 0x000790, "Member 'UReadyOrNotWeaponAnimData::Draw' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, DrawFirst) == 0x0007B0, "Member 'UReadyOrNotWeaponAnimData::DrawFirst' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_Draw) == 0x0007D0, "Member 'UReadyOrNotWeaponAnimData::Crouch_Draw' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_DrawFirst) == 0x0007F0, "Member 'UReadyOrNotWeaponAnimData::Crouch_DrawFirst' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Holster) == 0x000810, "Member 'UReadyOrNotWeaponAnimData::Holster' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_Holster) == 0x000830, "Member 'UReadyOrNotWeaponAnimData::Crouch_Holster' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, PullPin) == 0x000850, "Member 'UReadyOrNotWeaponAnimData::PullPin' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Throw) == 0x000870, "Member 'UReadyOrNotWeaponAnimData::Throw' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, PullPinUnderarm) == 0x000890, "Member 'UReadyOrNotWeaponAnimData::PullPinUnderarm' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, ThrowUnderarm) == 0x0008B0, "Member 'UReadyOrNotWeaponAnimData::ThrowUnderarm' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_PullPin) == 0x0008D0, "Member 'UReadyOrNotWeaponAnimData::Crouch_PullPin' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_Throw) == 0x0008F0, "Member 'UReadyOrNotWeaponAnimData::Crouch_Throw' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_PullPinUnderarm) == 0x000910, "Member 'UReadyOrNotWeaponAnimData::Crouch_PullPinUnderarm' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_ThrowUnderarm) == 0x000930, "Member 'UReadyOrNotWeaponAnimData::Crouch_ThrowUnderarm' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, QuickThrow_PinPull) == 0x000950, "Member 'UReadyOrNotWeaponAnimData::QuickThrow_PinPull' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Quickthrow_Throw) == 0x000970, "Member 'UReadyOrNotWeaponAnimData::Quickthrow_Throw' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_QuickThrow_PinPull) == 0x000990, "Member 'UReadyOrNotWeaponAnimData::Crouch_QuickThrow_PinPull' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_QuickThrow_Throw) == 0x0009B0, "Member 'UReadyOrNotWeaponAnimData::Crouch_QuickThrow_Throw' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, QuickThrow_Fast) == 0x0009D0, "Member 'UReadyOrNotWeaponAnimData::QuickThrow_Fast' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_QuickThrow_Fast) == 0x0009F0, "Member 'UReadyOrNotWeaponAnimData::Crouch_QuickThrow_Fast' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Multitool_Use) == 0x000A10, "Member 'UReadyOrNotWeaponAnimData::Multitool_Use' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Multitool_Use_End) == 0x000A30, "Member 'UReadyOrNotWeaponAnimData::Multitool_Use_End' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Multitool_Cutters_To_Lockpick) == 0x000A50, "Member 'UReadyOrNotWeaponAnimData::Multitool_Cutters_To_Lockpick' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Multitool_Cutters_To_Knife) == 0x000A70, "Member 'UReadyOrNotWeaponAnimData::Multitool_Cutters_To_Knife' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Multitool_Lockpick_To_Cutters) == 0x000A90, "Member 'UReadyOrNotWeaponAnimData::Multitool_Lockpick_To_Cutters' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Multitool_Lockpick_To_Knife) == 0x000AB0, "Member 'UReadyOrNotWeaponAnimData::Multitool_Lockpick_To_Knife' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Multitool_Knife_To_Lockpick) == 0x000AD0, "Member 'UReadyOrNotWeaponAnimData::Multitool_Knife_To_Lockpick' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Multitool_Knife_To_Cutters) == 0x000AF0, "Member 'UReadyOrNotWeaponAnimData::Multitool_Knife_To_Cutters' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Optiwand_Start_Screening) == 0x000B10, "Member 'UReadyOrNotWeaponAnimData::Optiwand_Start_Screening' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Optiwand_End_Screening) == 0x000B30, "Member 'UReadyOrNotWeaponAnimData::Optiwand_End_Screening' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Charge_Valid_Plant_Start) == 0x000B50, "Member 'UReadyOrNotWeaponAnimData::Charge_Valid_Plant_Start' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Charge_Valid_Plant_End) == 0x000B70, "Member 'UReadyOrNotWeaponAnimData::Charge_Valid_Plant_End' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, PlantCharge) == 0x000B90, "Member 'UReadyOrNotWeaponAnimData::PlantCharge' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, DetonateCharge) == 0x000BB0, "Member 'UReadyOrNotWeaponAnimData::DetonateCharge' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, EnableNVG) == 0x000BD0, "Member 'UReadyOrNotWeaponAnimData::EnableNVG' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, DisableNVG) == 0x000BF0, "Member 'UReadyOrNotWeaponAnimData::DisableNVG' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, ShieldDownToUp) == 0x000C10, "Member 'UReadyOrNotWeaponAnimData::ShieldDownToUp' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, ShieldUpToDown) == 0x000C30, "Member 'UReadyOrNotWeaponAnimData::ShieldUpToDown' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_ShieldDownToUp) == 0x000C50, "Member 'UReadyOrNotWeaponAnimData::Crouch_ShieldDownToUp' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Crouch_ShieldUpToDown) == 0x000C70, "Member 'UReadyOrNotWeaponAnimData::Crouch_ShieldUpToDown' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, ShieldHit) == 0x000C90, "Member 'UReadyOrNotWeaponAnimData::ShieldHit' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, TabletDownToUp) == 0x000CB0, "Member 'UReadyOrNotWeaponAnimData::TabletDownToUp' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, TabletUpToDown) == 0x000CD0, "Member 'UReadyOrNotWeaponAnimData::TabletUpToDown' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, TabletSwitchCameraDown) == 0x000CF0, "Member 'UReadyOrNotWeaponAnimData::TabletSwitchCameraDown' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, TabletSwitchCameraUp) == 0x000D10, "Member 'UReadyOrNotWeaponAnimData::TabletSwitchCameraUp' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, EvidencePickup) == 0x000D30, "Member 'UReadyOrNotWeaponAnimData::EvidencePickup' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Yell) == 0x000D50, "Member 'UReadyOrNotWeaponAnimData::Yell' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, RadioSelect) == 0x000D70, "Member 'UReadyOrNotWeaponAnimData::RadioSelect' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, bRadioUsesNotifies) == 0x000D90, "Member 'UReadyOrNotWeaponAnimData::bRadioUsesNotifies' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, DoorPush) == 0x000D98, "Member 'UReadyOrNotWeaponAnimData::DoorPush' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, ButtonPush) == 0x000DB8, "Member 'UReadyOrNotWeaponAnimData::ButtonPush' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, WeaponClearing) == 0x000DD8, "Member 'UReadyOrNotWeaponAnimData::WeaponClearing' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, ReactToSting) == 0x000DF8, "Member 'UReadyOrNotWeaponAnimData::ReactToSting' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, ReactToFlash) == 0x000E18, "Member 'UReadyOrNotWeaponAnimData::ReactToFlash' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, ReactToTaser) == 0x000E38, "Member 'UReadyOrNotWeaponAnimData::ReactToTaser' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, ReactToGas) == 0x000E58, "Member 'UReadyOrNotWeaponAnimData::ReactToGas' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, ReactToPepperSpray) == 0x000E78, "Member 'UReadyOrNotWeaponAnimData::ReactToPepperSpray' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, ReactToSting_End) == 0x000E98, "Member 'UReadyOrNotWeaponAnimData::ReactToSting_End' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, ReactToFlash_End) == 0x000EB8, "Member 'UReadyOrNotWeaponAnimData::ReactToFlash_End' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, ReactToTaser_End) == 0x000ED8, "Member 'UReadyOrNotWeaponAnimData::ReactToTaser_End' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, ReactToGas_End) == 0x000EF8, "Member 'UReadyOrNotWeaponAnimData::ReactToGas_End' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, ReactToPepperSpray_End) == 0x000F18, "Member 'UReadyOrNotWeaponAnimData::ReactToPepperSpray_End' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Reload_Level_01) == 0x000F38, "Member 'UReadyOrNotWeaponAnimData::Reload_Level_01' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Reload_Level_02) == 0x000F58, "Member 'UReadyOrNotWeaponAnimData::Reload_Level_02' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Reload_Level_03) == 0x000F78, "Member 'UReadyOrNotWeaponAnimData::Reload_Level_03' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Recoil_Level_01) == 0x000F98, "Member 'UReadyOrNotWeaponAnimData::Recoil_Level_01' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Recoil_Level_02) == 0x000FB8, "Member 'UReadyOrNotWeaponAnimData::Recoil_Level_02' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Recoil_Level_03) == 0x000FD8, "Member 'UReadyOrNotWeaponAnimData::Recoil_Level_03' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Grip_VFG_Body_FP_Fire) == 0x000FF8, "Member 'UReadyOrNotWeaponAnimData::Grip_VFG_Body_FP_Fire' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Grip_VFG_Body_FP_Fire_Last) == 0x001000, "Member 'UReadyOrNotWeaponAnimData::Grip_VFG_Body_FP_Fire_Last' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Grip_VFG_Body_FP_Fire_Aim) == 0x001008, "Member 'UReadyOrNotWeaponAnimData::Grip_VFG_Body_FP_Fire_Aim' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Grip_VFG_Body_FP_Fire_Aim_Last) == 0x001010, "Member 'UReadyOrNotWeaponAnimData::Grip_VFG_Body_FP_Fire_Aim_Last' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Grip_AFG_Body_FP_Fire) == 0x001018, "Member 'UReadyOrNotWeaponAnimData::Grip_AFG_Body_FP_Fire' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Grip_AFG_Body_FP_Fire_Last) == 0x001020, "Member 'UReadyOrNotWeaponAnimData::Grip_AFG_Body_FP_Fire_Last' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Grip_AFG_Body_FP_Fire_Aim) == 0x001028, "Member 'UReadyOrNotWeaponAnimData::Grip_AFG_Body_FP_Fire_Aim' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Grip_AFG_Body_FP_Fire_Aim_Last) == 0x001030, "Member 'UReadyOrNotWeaponAnimData::Grip_AFG_Body_FP_Fire_Aim_Last' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, SpeedReload_OneTime) == 0x001038, "Member 'UReadyOrNotWeaponAnimData::SpeedReload_OneTime' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, SpeedReloadEmpty_OneTime) == 0x001058, "Member 'UReadyOrNotWeaponAnimData::SpeedReloadEmpty_OneTime' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Reload_FP_Ads) == 0x001078, "Member 'UReadyOrNotWeaponAnimData::Reload_FP_Ads' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, ReloadEmpty_FP_Ads) == 0x001080, "Member 'UReadyOrNotWeaponAnimData::ReloadEmpty_FP_Ads' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Tactical_Reload_FP_Ads) == 0x001088, "Member 'UReadyOrNotWeaponAnimData::Tactical_Reload_FP_Ads' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, Tactical_ReloadEmpty_FP_Ads) == 0x001090, "Member 'UReadyOrNotWeaponAnimData::Tactical_ReloadEmpty_FP_Ads' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, bEmptyReload) == 0x001098, "Member 'UReadyOrNotWeaponAnimData::bEmptyReload' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, bHasRetentionAdditives) == 0x001099, "Member 'UReadyOrNotWeaponAnimData::bHasRetentionAdditives' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, bHasLoweredAdditives) == 0x00109A, "Member 'UReadyOrNotWeaponAnimData::bHasLoweredAdditives' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, bHasSightAdditives) == 0x00109B, "Member 'UReadyOrNotWeaponAnimData::bHasSightAdditives' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, bOverrideFireAnimForGrip) == 0x00109C, "Member 'UReadyOrNotWeaponAnimData::bOverrideFireAnimForGrip' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, bUseOneTimeSpeedReload) == 0x00109D, "Member 'UReadyOrNotWeaponAnimData::bUseOneTimeSpeedReload' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, IdlePose_AFG_TP) == 0x0010A0, "Member 'UReadyOrNotWeaponAnimData::IdlePose_AFG_TP' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, IdlePose_VFG_TP) == 0x0010A8, "Member 'UReadyOrNotWeaponAnimData::IdlePose_VFG_TP' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, IdlePose_HSTOP_TP) == 0x0010B0, "Member 'UReadyOrNotWeaponAnimData::IdlePose_HSTOP_TP' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, IdlePose_RK1_TP) == 0x0010B8, "Member 'UReadyOrNotWeaponAnimData::IdlePose_RK1_TP' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, IdlePose_CQR_TP) == 0x0010C0, "Member 'UReadyOrNotWeaponAnimData::IdlePose_CQR_TP' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, IdlePose_AI_Calm) == 0x0010C8, "Member 'UReadyOrNotWeaponAnimData::IdlePose_AI_Calm' has a wrong offset!");
static_assert(offsetof(UReadyOrNotWeaponAnimData, IdlePose_AI_Aiming) == 0x0010D0, "Member 'UReadyOrNotWeaponAnimData::IdlePose_AI_Aiming' has a wrong offset!");

// Class ReadyOrNot.RealtimeWidget
// 0x0000 (0x02C0 - 0x02C0)
class URealtimeWidget : public UUserWidget
{
public:
	void OnSynchronizeProperties();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RealtimeWidget">();
	}
	static class URealtimeWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URealtimeWidget>();
	}
};
static_assert(alignof(URealtimeWidget) == 0x000008, "Wrong alignment on URealtimeWidget");
static_assert(sizeof(URealtimeWidget) == 0x0002C0, "Wrong size on URealtimeWidget");

// Class ReadyOrNot.ReceiveAISenseUpdates
// 0x0000 (0x0000 - 0x0000)
class IReceiveAISenseUpdates final
{
public:
	void OnAIDamageSense(class ACyberneticController* InSenseController, const struct FAIStimulus& Stimulus, class AActor** OutOverrideSensedActor);
	void OnAIHearingSense(class ACyberneticController* InSenseController, const struct FAIStimulus& Stimulus, class AActor** OutOverrideSensedActor);
	void OnAIPerceptionSense(class ACyberneticController* InSenseController, const struct FAIStimulus& Stimulus, class AActor** OutOverrideSensedActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReceiveAISenseUpdates">();
	}
	static class IReceiveAISenseUpdates* GetDefaultObj()
	{
		return GetDefaultObjImpl<IReceiveAISenseUpdates>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IReceiveAISenseUpdates) == 0x000001, "Wrong alignment on IReceiveAISenseUpdates");
static_assert(sizeof(IReceiveAISenseUpdates) == 0x000001, "Wrong size on IReceiveAISenseUpdates");

// Class ReadyOrNot.ReflectionProbeGenerator
// 0x0008 (0x02A0 - 0x0298)
class AReflectionProbeGenerator final : public AActor
{
public:
	class UFMODEvent*                             Event;                                             // 0x0298(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReflectionProbeGenerator">();
	}
	static class AReflectionProbeGenerator* GetDefaultObj()
	{
		return GetDefaultObjImpl<AReflectionProbeGenerator>();
	}
};
static_assert(alignof(AReflectionProbeGenerator) == 0x000008, "Wrong alignment on AReflectionProbeGenerator");
static_assert(sizeof(AReflectionProbeGenerator) == 0x0002A0, "Wrong size on AReflectionProbeGenerator");
static_assert(offsetof(AReflectionProbeGenerator, Event) == 0x000298, "Member 'AReflectionProbeGenerator::Event' has a wrong offset!");

// Class ReadyOrNot.RegroupActivity
// 0x0008 (0x01F8 - 0x01F0)
class URegroupActivity final : public UBaseActivity
{
public:
	class AReadyOrNotCharacter*                   Target;                                            // 0x01F0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void EnterFallbackToSquadMemberState();
	void TickFallbackToSquadMemberState(float DeltaTime, float Uptime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RegroupActivity">();
	}
	static class URegroupActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<URegroupActivity>();
	}
};
static_assert(alignof(URegroupActivity) == 0x000008, "Wrong alignment on URegroupActivity");
static_assert(sizeof(URegroupActivity) == 0x0001F8, "Wrong size on URegroupActivity");
static_assert(offsetof(URegroupActivity, Target) == 0x0001F0, "Member 'URegroupActivity::Target' has a wrong offset!");

// Class ReadyOrNot.ReloadSafelyActivity
// 0x0010 (0x0200 - 0x01F0)
class UReloadSafelyActivity final : public UBaseActivity
{
public:
	class UAnimMontage*                           ReloadMontage;                                     // 0x01F0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1F8[0x8];                                      // 0x01F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ReloadFinished();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReloadSafelyActivity">();
	}
	static class UReloadSafelyActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReloadSafelyActivity>();
	}
};
static_assert(alignof(UReloadSafelyActivity) == 0x000008, "Wrong alignment on UReloadSafelyActivity");
static_assert(sizeof(UReloadSafelyActivity) == 0x000200, "Wrong size on UReloadSafelyActivity");
static_assert(offsetof(UReloadSafelyActivity, ReloadMontage) == 0x0001F0, "Member 'UReloadSafelyActivity::ReloadMontage' has a wrong offset!");

// Class ReadyOrNot.ReplayControls
// 0x03C0 (0x07D0 - 0x0410)
class UReplayControls : public UCommonActivatableWidget
{
public:
	struct FScreenFooterEntry                     PlayInputAction;                                   // 0x0410(0x0078)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FScreenFooterEntry                     SelectInputAction;                                 // 0x0488(0x0078)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FScreenFooterEntry                     BackInputAction;                                   // 0x0500(0x0078)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FScreenFooterEntry                     CameraModeInputAction;                             // 0x0578(0x0078)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FScreenFooterEntry                     CameraZoomInputAction;                             // 0x05F0(0x0078)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FScreenFooterEntry                     CycleActorInputAction;                             // 0x0668(0x0078)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FScreenFooterEntry                     ResetToDefaultInputAction;                         // 0x06E0(0x0078)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FScreenFooterEntry                     HideHUDInputAction;                                // 0x0758(0x0078)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	void CustomTick();
	void NextActor();
	void PauseReplay();
	void PreviousActor();
	void SetMinimumReplayBarTime(float Percent);
	void SkipReplayBackward();
	void SkipReplayForward();
	void ToggleHUD();
	void UpdateMountedSocketSelections();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReplayControls">();
	}
	static class UReplayControls* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReplayControls>();
	}
};
static_assert(alignof(UReplayControls) == 0x000008, "Wrong alignment on UReplayControls");
static_assert(sizeof(UReplayControls) == 0x0007D0, "Wrong size on UReplayControls");
static_assert(offsetof(UReplayControls, PlayInputAction) == 0x000410, "Member 'UReplayControls::PlayInputAction' has a wrong offset!");
static_assert(offsetof(UReplayControls, SelectInputAction) == 0x000488, "Member 'UReplayControls::SelectInputAction' has a wrong offset!");
static_assert(offsetof(UReplayControls, BackInputAction) == 0x000500, "Member 'UReplayControls::BackInputAction' has a wrong offset!");
static_assert(offsetof(UReplayControls, CameraModeInputAction) == 0x000578, "Member 'UReplayControls::CameraModeInputAction' has a wrong offset!");
static_assert(offsetof(UReplayControls, CameraZoomInputAction) == 0x0005F0, "Member 'UReplayControls::CameraZoomInputAction' has a wrong offset!");
static_assert(offsetof(UReplayControls, CycleActorInputAction) == 0x000668, "Member 'UReplayControls::CycleActorInputAction' has a wrong offset!");
static_assert(offsetof(UReplayControls, ResetToDefaultInputAction) == 0x0006E0, "Member 'UReplayControls::ResetToDefaultInputAction' has a wrong offset!");
static_assert(offsetof(UReplayControls, HideHUDInputAction) == 0x000758, "Member 'UReplayControls::HideHUDInputAction' has a wrong offset!");

// Class ReadyOrNot.ReplaySplineActor
// 0x0018 (0x02B0 - 0x0298)
class AReplaySplineActor final : public AActor
{
public:
	class USplineComponent*                       SplineComponent;                                   // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FRotator>                       SplinePointRotations;                              // 0x02A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReplaySplineActor">();
	}
	static class AReplaySplineActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AReplaySplineActor>();
	}
};
static_assert(alignof(AReplaySplineActor) == 0x000008, "Wrong alignment on AReplaySplineActor");
static_assert(sizeof(AReplaySplineActor) == 0x0002B0, "Wrong size on AReplaySplineActor");
static_assert(offsetof(AReplaySplineActor, SplineComponent) == 0x000298, "Member 'AReplaySplineActor::SplineComponent' has a wrong offset!");
static_assert(offsetof(AReplaySplineActor, SplinePointRotations) == 0x0002A0, "Member 'AReplaySplineActor::SplinePointRotations' has a wrong offset!");

// Class ReadyOrNot.ReportReportableByTag
// 0x0010 (0x0330 - 0x0320)
class AReportReportableByTag final : public AObjective
{
public:
	uint32                                        NumReportsToComplete;                              // 0x0320(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                        CurrentReportCount;                                // 0x0324(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   ReportTag;                                         // 0x0328(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	bool HasReportedReportableByTag(const class FName& Tag);
	void OnReportableReported(class AReportableActor* Reportable, class AReadyOrNotCharacter* Reporter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReportReportableByTag">();
	}
	static class AReportReportableByTag* GetDefaultObj()
	{
		return GetDefaultObjImpl<AReportReportableByTag>();
	}
};
static_assert(alignof(AReportReportableByTag) == 0x000008, "Wrong alignment on AReportReportableByTag");
static_assert(sizeof(AReportReportableByTag) == 0x000330, "Wrong size on AReportReportableByTag");
static_assert(offsetof(AReportReportableByTag, NumReportsToComplete) == 0x000320, "Member 'AReportReportableByTag::NumReportsToComplete' has a wrong offset!");
static_assert(offsetof(AReportReportableByTag, CurrentReportCount) == 0x000324, "Member 'AReportReportableByTag::CurrentReportCount' has a wrong offset!");
static_assert(offsetof(AReportReportableByTag, ReportTag) == 0x000328, "Member 'AReportReportableByTag::ReportTag' has a wrong offset!");

// Class ReadyOrNot.RescueAllOfTheCivilians
// 0x0010 (0x0330 - 0x0320)
class ARescueAllOfTheCivilians final : public AObjective
{
public:
	uint8                                         Pad_320[0x10];                                     // 0x0320(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAISpawned();
	void OnCivilianKilled(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RescueAllOfTheCivilians">();
	}
	static class ARescueAllOfTheCivilians* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARescueAllOfTheCivilians>();
	}
};
static_assert(alignof(ARescueAllOfTheCivilians) == 0x000008, "Wrong alignment on ARescueAllOfTheCivilians");
static_assert(sizeof(ARescueAllOfTheCivilians) == 0x000330, "Wrong size on ARescueAllOfTheCivilians");

// Class ReadyOrNot.RescueCivilianByTag
// 0x0028 (0x0348 - 0x0320)
class ARescueCivilianByTag final : public AObjective
{
public:
	uint8                                         Pad_320[0x10];                                     // 0x0320(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CivilianTag;                                       // 0x0330(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AReadyOrNotCharacter*                   civilian;                                          // 0x0338(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowIncapacitation;                              // 0x0340(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_341[0x7];                                      // 0x0341(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool HasNeutralizedCivilianByTag(bool* bArrested);
	void OnAISpawned();
	void OnCivilianKilled(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RescueCivilianByTag">();
	}
	static class ARescueCivilianByTag* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARescueCivilianByTag>();
	}
};
static_assert(alignof(ARescueCivilianByTag) == 0x000008, "Wrong alignment on ARescueCivilianByTag");
static_assert(sizeof(ARescueCivilianByTag) == 0x000348, "Wrong size on ARescueCivilianByTag");
static_assert(offsetof(ARescueCivilianByTag, CivilianTag) == 0x000330, "Member 'ARescueCivilianByTag::CivilianTag' has a wrong offset!");
static_assert(offsetof(ARescueCivilianByTag, civilian) == 0x000338, "Member 'ARescueCivilianByTag::civilian' has a wrong offset!");
static_assert(offsetof(ARescueCivilianByTag, bAllowIncapacitation) == 0x000340, "Member 'ARescueCivilianByTag::bAllowIncapacitation' has a wrong offset!");

// Class ReadyOrNot.RoNAnimInstance_PlayerTP
// 0x0C70 (0x1210 - 0x05A0)
class URoNAnimInstance_PlayerTP final : public UReadyOrNotAnimInstance
{
public:
	uint8                                         Pad_598[0x8];                                      // 0x0598(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FReadyOrNotAnimInstanceProxyTP         Proxy;                                             // 0x05A0(0x0700)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	class UReadyOrNotWeaponAnimData*              LastAnimWeaponData;                                // 0x0CA0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReadyOrNotWeaponAnimData*              EditorWeaponAnimData;                              // 0x0CA8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowTurnInPlace;                                 // 0x0CB0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTurnInPlaceStateRelevant;                       // 0x0CB1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CB2[0x2];                                      // 0x0CB2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         YawOffsetLimit;                                    // 0x0CB4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnInPlaceSpeedMultiplier;                        // 0x0CB8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CBC[0x4];                                      // 0x0CBC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnimTurnInPlaceAnimSet                TurnInPlaceAnimSet;                                // 0x0CC0(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FAnimTurnInPlaceState                  TurnInPlaceState;                                  // 0x0CD8(0x0060)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FAnimTurnInPlaceAnimSet                StandRifAnimSet;                                   // 0x0D38(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FAnimTurnInPlaceAnimSet                CrouchRifAnimSet;                                  // 0x0D50(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bWeaponDown;                                       // 0x0D68(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAiming;                                         // 0x0D69(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsShieldEquipped;                                 // 0x0D6A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D6B[0x1];                                      // 0x0D6B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AimingAlpha;                                       // 0x0D6C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLeanLeft;                                         // 0x0D70(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLeanRight;                                        // 0x0D71(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D72[0x2];                                      // 0x0D72(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         QuickLeanLeftAmount;                               // 0x0D74(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         QuickLeanRightAmount;                              // 0x0D78(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         QuickLeanLeftAlpha;                                // 0x0D7C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         QuickLeanRightAlpha;                               // 0x0D80(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         QuickLeanIntensity;                                // 0x0D84(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         QuickLeanInterpSpeed;                              // 0x0D88(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootIKValue;                                       // 0x0D8C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootIKAlpha;                                       // 0x0D90(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRagdoll;                                          // 0x0D94(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPlayingDeathAnim;                               // 0x0D95(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bArrested;                                         // 0x0D96(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDead;                                           // 0x0D97(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDeathAnimEnd;                                     // 0x0D98(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStunned;                                          // 0x0D99(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTased;                                            // 0x0D9A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnLadder;                                         // 0x0D9B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LadderUpDownMovement;                              // 0x0D9C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeanAngleY;                                        // 0x0DA0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeanAngleZ;                                        // 0x0DA4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCoverLeft;                                        // 0x0DA8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCoverRight;                                       // 0x0DA9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCoverMiddle;                                      // 0x0DAA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCoverLeftLow;                                     // 0x0DAB(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCoverRightLow;                                    // 0x0DAC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCoverPeek;                                        // 0x0DAD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DAE[0x2];                                      // 0x0DAE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AimOffsetAlpha;                                    // 0x0DB0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DB4[0x4];                                      // 0x0DB4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              AimOffsets;                                        // 0x0DB8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bJumpStartTrigger;                                 // 0x0DC8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC9[0x3];                                      // 0x0DC9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SmoothMappedLeanToAnimStandLeft;                   // 0x0DCC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SmoothMappedLeanToAnimStandRight;                  // 0x0DD0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SmoothMappedLeanToAnimCrouchLeft;                  // 0x0DD4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SmoothMappedLeanToAnimCrouchRight;                 // 0x0DD8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed_tp_rifle_stand_sprint_f;                     // 0x0DDC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Crouch_Idle_Pose_Low_TP;                           // 0x0DE0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Crouch_Idle_Pose_Up_TP;                            // 0x0DE8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Crouch_Idle_Pose_Shld_TP;                          // 0x0DF0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Crouch_Idle_Pose_Sights_TP;                        // 0x0DF8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Crouch_Idle_Pose_Ret_TP;                           // 0x0E00(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Crouch_Idle_Pose_Ovr_TP;                           // 0x0E08(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Idle_Pose_Low_TP;                                  // 0x0E10(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Idle_Pose_Up_TP;                                   // 0x0E18(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Idle_Pose_Shld_TP;                                 // 0x0E20(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Idle_Pose_Sights_TP;                               // 0x0E28(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Idle_Pose_Ret_TP;                                  // 0x0E30(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Idle_Pose_Ovr_TP;                                  // 0x0E38(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Idle_Pose_VFG_TP;                                  // 0x0E40(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Idle_Pose_AFG_TP;                                  // 0x0E48(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Idle_Pose_HSTOP_TP;                                // 0x0E50(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLeaningLeftNotCrouching;                          // 0x0E58(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNotLeaningLeftOrCrouching;                        // 0x0E59(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNotLeaningLeftOrNotCrouching;                     // 0x0E5A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLeaningRightNotCrouching;                         // 0x0E5B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNotLeaningRightOrCrouching;                       // 0x0E5C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNotLeaningRightOrNotCrouching;                    // 0x0E5D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCrouchingAndMoving;                               // 0x0E5E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNotCrouchingAndMoving;                            // 0x0E5F(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAimingAndNotDeployable;                           // 0x0E60(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E61[0x3];                                      // 0x0E61(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WalkSpeedForward;                                  // 0x0E64(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkSpeedLeft;                                     // 0x0E68(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkSpeedRight;                                    // 0x0E6C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkSpeedBackward;                                 // 0x0E70(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrouchWalkSpeedForward;                            // 0x0E74(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrouchWalkSpeedLeft;                               // 0x0E78(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrouchWalkSpeedRight;                              // 0x0E7C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrouchWalkSpeedBackward;                           // 0x0E80(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RunSpeedForward;                                   // 0x0E84(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RunSpeedLeft;                                      // 0x0E88(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RunSpeedRight;                                     // 0x0E8C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RunSpeedBackward;                                  // 0x0E90(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLessThanPointOneSecondOnRelevantAnim;             // 0x0E94(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInCombatOrAlerted;                              // 0x0E95(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMoving;                                           // 0x0E96(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAlerted;                                        // 0x0E97(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AlertAlpha;                                        // 0x0E98(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInCombat;                                       // 0x0E9C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSurrendering;                                   // 0x0E9D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSprayed;                                          // 0x0E9E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStung;                                            // 0x0E9F(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPseudoSpeedType                              CurPseudoSpeed;                                    // 0x0EA0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFemale;                                           // 0x0EA1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChild;                                            // 0x0EA2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasInjury;                                        // 0x0EA3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimSpeedFwdPlayrateSync;                          // 0x0EA4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimSpeedSidePlayrateSync;                         // 0x0EA8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimSpeedPlayrateSync;                             // 0x0EAC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RetentionAlpha;                                    // 0x0EB0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoweredAlpha;                                      // 0x0EB4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EB8[0x8];                                      // 0x0EB8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SightAlpha;                                        // 0x0EC0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoweredCooldownTime;                               // 0x0EC4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLoweredUp;                                       // 0x0EC8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EC9[0x13];                                     // 0x0EC9(0x0013)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ArmsOnlySlotAlpha;                                 // 0x0EDC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftArmOnlySlotAlpha;                              // 0x0EE0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VelocityInterpTime;                                // 0x0EE4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VelocitySmoothed;                                  // 0x0EE8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedScaling;                                      // 0x0F00(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayrateClampMax;                                  // 0x0F04(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAnimCharacterMovementSnapshot         CharMovementSnapshot;                              // 0x0F08(0x00F8)(Edit, BlueprintVisible, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	float                                         PostPivotTriggerThreshold;                         // 0x1000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCardinalDirectionSnapshot             PivotingCardinalDirSnapShot;                       // 0x1004(0x0018)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_101C[0x1C];                                    // 0x101C(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerCharacter*                       CharacterRef;                                      // 0x1038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACyberneticCharacter*                   CharacterAiRef;                                    // 0x1040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseDistanceMatching;                              // 0x1048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDistanceMatchingType                         DistanceMatchingCurrentState;                      // 0x1049(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_104A[0x6];                                     // 0x104A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPredictionResult                      StartMarker;                                       // 0x1050(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FPredictionResult                      StopMarker;                                        // 0x1080(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FPredictionResult                      PivotMarker;                                       // 0x10B0(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FPredictionResult                      PostPivotMarker;                                   // 0x10E0(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FPredictionResult                      TakeOffMarker;                                     // 0x1110(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FPredictionResult                      ApexMarker;                                        // 0x1140(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FPredictionResult                      LandingMarker;                                     // 0x1170(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	EMoveDirectionExt                             CurrentPivotDirectionExt;                          // 0x11A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPivotDirectionBroken;                             // 0x11A1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanPivotInCurDirection;                           // 0x11A2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSMPrePivotRuleset;                                // 0x11A3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStartDirectionBroken;                             // 0x11A4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11A5[0x3];                                     // 0x11A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReplicatedMaxSpeed;                                // 0x11A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSMStartRuleset;                                   // 0x11AC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSMStopRuleset;                                    // 0x11AD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11AE[0x2];                                     // 0x11AE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                PelvisDefaultWorldPos;                             // 0x11B0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CrouchedPelvisDefaultWorldPos;                     // 0x11C8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CrouchedPelvisMovingWorldPos;                      // 0x11E0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CrouchedPelvisCurrentWorldPos;                     // 0x11F8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	class UAnimSequenceBase* GetPlayerAnimation_TP(EBaseAnimType_TP AnimName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RoNAnimInstance_PlayerTP">();
	}
	static class URoNAnimInstance_PlayerTP* GetDefaultObj()
	{
		return GetDefaultObjImpl<URoNAnimInstance_PlayerTP>();
	}
};
static_assert(alignof(URoNAnimInstance_PlayerTP) == 0x000010, "Wrong alignment on URoNAnimInstance_PlayerTP");
static_assert(sizeof(URoNAnimInstance_PlayerTP) == 0x001210, "Wrong size on URoNAnimInstance_PlayerTP");
static_assert(offsetof(URoNAnimInstance_PlayerTP, Proxy) == 0x0005A0, "Member 'URoNAnimInstance_PlayerTP::Proxy' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, LastAnimWeaponData) == 0x000CA0, "Member 'URoNAnimInstance_PlayerTP::LastAnimWeaponData' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, EditorWeaponAnimData) == 0x000CA8, "Member 'URoNAnimInstance_PlayerTP::EditorWeaponAnimData' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bAllowTurnInPlace) == 0x000CB0, "Member 'URoNAnimInstance_PlayerTP::bAllowTurnInPlace' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bIsTurnInPlaceStateRelevant) == 0x000CB1, "Member 'URoNAnimInstance_PlayerTP::bIsTurnInPlaceStateRelevant' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, YawOffsetLimit) == 0x000CB4, "Member 'URoNAnimInstance_PlayerTP::YawOffsetLimit' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, TurnInPlaceSpeedMultiplier) == 0x000CB8, "Member 'URoNAnimInstance_PlayerTP::TurnInPlaceSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, TurnInPlaceAnimSet) == 0x000CC0, "Member 'URoNAnimInstance_PlayerTP::TurnInPlaceAnimSet' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, TurnInPlaceState) == 0x000CD8, "Member 'URoNAnimInstance_PlayerTP::TurnInPlaceState' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, StandRifAnimSet) == 0x000D38, "Member 'URoNAnimInstance_PlayerTP::StandRifAnimSet' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, CrouchRifAnimSet) == 0x000D50, "Member 'URoNAnimInstance_PlayerTP::CrouchRifAnimSet' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bWeaponDown) == 0x000D68, "Member 'URoNAnimInstance_PlayerTP::bWeaponDown' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bIsAiming) == 0x000D69, "Member 'URoNAnimInstance_PlayerTP::bIsAiming' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bIsShieldEquipped) == 0x000D6A, "Member 'URoNAnimInstance_PlayerTP::bIsShieldEquipped' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, AimingAlpha) == 0x000D6C, "Member 'URoNAnimInstance_PlayerTP::AimingAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bLeanLeft) == 0x000D70, "Member 'URoNAnimInstance_PlayerTP::bLeanLeft' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bLeanRight) == 0x000D71, "Member 'URoNAnimInstance_PlayerTP::bLeanRight' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, QuickLeanLeftAmount) == 0x000D74, "Member 'URoNAnimInstance_PlayerTP::QuickLeanLeftAmount' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, QuickLeanRightAmount) == 0x000D78, "Member 'URoNAnimInstance_PlayerTP::QuickLeanRightAmount' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, QuickLeanLeftAlpha) == 0x000D7C, "Member 'URoNAnimInstance_PlayerTP::QuickLeanLeftAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, QuickLeanRightAlpha) == 0x000D80, "Member 'URoNAnimInstance_PlayerTP::QuickLeanRightAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, QuickLeanIntensity) == 0x000D84, "Member 'URoNAnimInstance_PlayerTP::QuickLeanIntensity' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, QuickLeanInterpSpeed) == 0x000D88, "Member 'URoNAnimInstance_PlayerTP::QuickLeanInterpSpeed' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, FootIKValue) == 0x000D8C, "Member 'URoNAnimInstance_PlayerTP::FootIKValue' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, FootIKAlpha) == 0x000D90, "Member 'URoNAnimInstance_PlayerTP::FootIKAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bRagdoll) == 0x000D94, "Member 'URoNAnimInstance_PlayerTP::bRagdoll' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bIsPlayingDeathAnim) == 0x000D95, "Member 'URoNAnimInstance_PlayerTP::bIsPlayingDeathAnim' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bArrested) == 0x000D96, "Member 'URoNAnimInstance_PlayerTP::bArrested' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bIsDead) == 0x000D97, "Member 'URoNAnimInstance_PlayerTP::bIsDead' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bDeathAnimEnd) == 0x000D98, "Member 'URoNAnimInstance_PlayerTP::bDeathAnimEnd' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bStunned) == 0x000D99, "Member 'URoNAnimInstance_PlayerTP::bStunned' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bTased) == 0x000D9A, "Member 'URoNAnimInstance_PlayerTP::bTased' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bOnLadder) == 0x000D9B, "Member 'URoNAnimInstance_PlayerTP::bOnLadder' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, LadderUpDownMovement) == 0x000D9C, "Member 'URoNAnimInstance_PlayerTP::LadderUpDownMovement' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, LeanAngleY) == 0x000DA0, "Member 'URoNAnimInstance_PlayerTP::LeanAngleY' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, LeanAngleZ) == 0x000DA4, "Member 'URoNAnimInstance_PlayerTP::LeanAngleZ' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bCoverLeft) == 0x000DA8, "Member 'URoNAnimInstance_PlayerTP::bCoverLeft' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bCoverRight) == 0x000DA9, "Member 'URoNAnimInstance_PlayerTP::bCoverRight' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bCoverMiddle) == 0x000DAA, "Member 'URoNAnimInstance_PlayerTP::bCoverMiddle' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bCoverLeftLow) == 0x000DAB, "Member 'URoNAnimInstance_PlayerTP::bCoverLeftLow' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bCoverRightLow) == 0x000DAC, "Member 'URoNAnimInstance_PlayerTP::bCoverRightLow' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bCoverPeek) == 0x000DAD, "Member 'URoNAnimInstance_PlayerTP::bCoverPeek' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, AimOffsetAlpha) == 0x000DB0, "Member 'URoNAnimInstance_PlayerTP::AimOffsetAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, AimOffsets) == 0x000DB8, "Member 'URoNAnimInstance_PlayerTP::AimOffsets' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bJumpStartTrigger) == 0x000DC8, "Member 'URoNAnimInstance_PlayerTP::bJumpStartTrigger' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, SmoothMappedLeanToAnimStandLeft) == 0x000DCC, "Member 'URoNAnimInstance_PlayerTP::SmoothMappedLeanToAnimStandLeft' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, SmoothMappedLeanToAnimStandRight) == 0x000DD0, "Member 'URoNAnimInstance_PlayerTP::SmoothMappedLeanToAnimStandRight' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, SmoothMappedLeanToAnimCrouchLeft) == 0x000DD4, "Member 'URoNAnimInstance_PlayerTP::SmoothMappedLeanToAnimCrouchLeft' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, SmoothMappedLeanToAnimCrouchRight) == 0x000DD8, "Member 'URoNAnimInstance_PlayerTP::SmoothMappedLeanToAnimCrouchRight' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, Speed_tp_rifle_stand_sprint_f) == 0x000DDC, "Member 'URoNAnimInstance_PlayerTP::Speed_tp_rifle_stand_sprint_f' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, Crouch_Idle_Pose_Low_TP) == 0x000DE0, "Member 'URoNAnimInstance_PlayerTP::Crouch_Idle_Pose_Low_TP' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, Crouch_Idle_Pose_Up_TP) == 0x000DE8, "Member 'URoNAnimInstance_PlayerTP::Crouch_Idle_Pose_Up_TP' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, Crouch_Idle_Pose_Shld_TP) == 0x000DF0, "Member 'URoNAnimInstance_PlayerTP::Crouch_Idle_Pose_Shld_TP' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, Crouch_Idle_Pose_Sights_TP) == 0x000DF8, "Member 'URoNAnimInstance_PlayerTP::Crouch_Idle_Pose_Sights_TP' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, Crouch_Idle_Pose_Ret_TP) == 0x000E00, "Member 'URoNAnimInstance_PlayerTP::Crouch_Idle_Pose_Ret_TP' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, Crouch_Idle_Pose_Ovr_TP) == 0x000E08, "Member 'URoNAnimInstance_PlayerTP::Crouch_Idle_Pose_Ovr_TP' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, Idle_Pose_Low_TP) == 0x000E10, "Member 'URoNAnimInstance_PlayerTP::Idle_Pose_Low_TP' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, Idle_Pose_Up_TP) == 0x000E18, "Member 'URoNAnimInstance_PlayerTP::Idle_Pose_Up_TP' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, Idle_Pose_Shld_TP) == 0x000E20, "Member 'URoNAnimInstance_PlayerTP::Idle_Pose_Shld_TP' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, Idle_Pose_Sights_TP) == 0x000E28, "Member 'URoNAnimInstance_PlayerTP::Idle_Pose_Sights_TP' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, Idle_Pose_Ret_TP) == 0x000E30, "Member 'URoNAnimInstance_PlayerTP::Idle_Pose_Ret_TP' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, Idle_Pose_Ovr_TP) == 0x000E38, "Member 'URoNAnimInstance_PlayerTP::Idle_Pose_Ovr_TP' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, Idle_Pose_VFG_TP) == 0x000E40, "Member 'URoNAnimInstance_PlayerTP::Idle_Pose_VFG_TP' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, Idle_Pose_AFG_TP) == 0x000E48, "Member 'URoNAnimInstance_PlayerTP::Idle_Pose_AFG_TP' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, Idle_Pose_HSTOP_TP) == 0x000E50, "Member 'URoNAnimInstance_PlayerTP::Idle_Pose_HSTOP_TP' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bLeaningLeftNotCrouching) == 0x000E58, "Member 'URoNAnimInstance_PlayerTP::bLeaningLeftNotCrouching' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bNotLeaningLeftOrCrouching) == 0x000E59, "Member 'URoNAnimInstance_PlayerTP::bNotLeaningLeftOrCrouching' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bNotLeaningLeftOrNotCrouching) == 0x000E5A, "Member 'URoNAnimInstance_PlayerTP::bNotLeaningLeftOrNotCrouching' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bLeaningRightNotCrouching) == 0x000E5B, "Member 'URoNAnimInstance_PlayerTP::bLeaningRightNotCrouching' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bNotLeaningRightOrCrouching) == 0x000E5C, "Member 'URoNAnimInstance_PlayerTP::bNotLeaningRightOrCrouching' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bNotLeaningRightOrNotCrouching) == 0x000E5D, "Member 'URoNAnimInstance_PlayerTP::bNotLeaningRightOrNotCrouching' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bCrouchingAndMoving) == 0x000E5E, "Member 'URoNAnimInstance_PlayerTP::bCrouchingAndMoving' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bNotCrouchingAndMoving) == 0x000E5F, "Member 'URoNAnimInstance_PlayerTP::bNotCrouchingAndMoving' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bAimingAndNotDeployable) == 0x000E60, "Member 'URoNAnimInstance_PlayerTP::bAimingAndNotDeployable' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, WalkSpeedForward) == 0x000E64, "Member 'URoNAnimInstance_PlayerTP::WalkSpeedForward' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, WalkSpeedLeft) == 0x000E68, "Member 'URoNAnimInstance_PlayerTP::WalkSpeedLeft' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, WalkSpeedRight) == 0x000E6C, "Member 'URoNAnimInstance_PlayerTP::WalkSpeedRight' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, WalkSpeedBackward) == 0x000E70, "Member 'URoNAnimInstance_PlayerTP::WalkSpeedBackward' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, CrouchWalkSpeedForward) == 0x000E74, "Member 'URoNAnimInstance_PlayerTP::CrouchWalkSpeedForward' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, CrouchWalkSpeedLeft) == 0x000E78, "Member 'URoNAnimInstance_PlayerTP::CrouchWalkSpeedLeft' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, CrouchWalkSpeedRight) == 0x000E7C, "Member 'URoNAnimInstance_PlayerTP::CrouchWalkSpeedRight' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, CrouchWalkSpeedBackward) == 0x000E80, "Member 'URoNAnimInstance_PlayerTP::CrouchWalkSpeedBackward' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, RunSpeedForward) == 0x000E84, "Member 'URoNAnimInstance_PlayerTP::RunSpeedForward' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, RunSpeedLeft) == 0x000E88, "Member 'URoNAnimInstance_PlayerTP::RunSpeedLeft' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, RunSpeedRight) == 0x000E8C, "Member 'URoNAnimInstance_PlayerTP::RunSpeedRight' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, RunSpeedBackward) == 0x000E90, "Member 'URoNAnimInstance_PlayerTP::RunSpeedBackward' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bLessThanPointOneSecondOnRelevantAnim) == 0x000E94, "Member 'URoNAnimInstance_PlayerTP::bLessThanPointOneSecondOnRelevantAnim' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bIsInCombatOrAlerted) == 0x000E95, "Member 'URoNAnimInstance_PlayerTP::bIsInCombatOrAlerted' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bMoving) == 0x000E96, "Member 'URoNAnimInstance_PlayerTP::bMoving' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bIsAlerted) == 0x000E97, "Member 'URoNAnimInstance_PlayerTP::bIsAlerted' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, AlertAlpha) == 0x000E98, "Member 'URoNAnimInstance_PlayerTP::AlertAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bIsInCombat) == 0x000E9C, "Member 'URoNAnimInstance_PlayerTP::bIsInCombat' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bIsSurrendering) == 0x000E9D, "Member 'URoNAnimInstance_PlayerTP::bIsSurrendering' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bSprayed) == 0x000E9E, "Member 'URoNAnimInstance_PlayerTP::bSprayed' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bStung) == 0x000E9F, "Member 'URoNAnimInstance_PlayerTP::bStung' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, CurPseudoSpeed) == 0x000EA0, "Member 'URoNAnimInstance_PlayerTP::CurPseudoSpeed' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bFemale) == 0x000EA1, "Member 'URoNAnimInstance_PlayerTP::bFemale' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bChild) == 0x000EA2, "Member 'URoNAnimInstance_PlayerTP::bChild' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bHasInjury) == 0x000EA3, "Member 'URoNAnimInstance_PlayerTP::bHasInjury' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, AnimSpeedFwdPlayrateSync) == 0x000EA4, "Member 'URoNAnimInstance_PlayerTP::AnimSpeedFwdPlayrateSync' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, AnimSpeedSidePlayrateSync) == 0x000EA8, "Member 'URoNAnimInstance_PlayerTP::AnimSpeedSidePlayrateSync' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, AnimSpeedPlayrateSync) == 0x000EAC, "Member 'URoNAnimInstance_PlayerTP::AnimSpeedPlayrateSync' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, RetentionAlpha) == 0x000EB0, "Member 'URoNAnimInstance_PlayerTP::RetentionAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, LoweredAlpha) == 0x000EB4, "Member 'URoNAnimInstance_PlayerTP::LoweredAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, SightAlpha) == 0x000EC0, "Member 'URoNAnimInstance_PlayerTP::SightAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, LoweredCooldownTime) == 0x000EC4, "Member 'URoNAnimInstance_PlayerTP::LoweredCooldownTime' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, IsLoweredUp) == 0x000EC8, "Member 'URoNAnimInstance_PlayerTP::IsLoweredUp' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, ArmsOnlySlotAlpha) == 0x000EDC, "Member 'URoNAnimInstance_PlayerTP::ArmsOnlySlotAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, LeftArmOnlySlotAlpha) == 0x000EE0, "Member 'URoNAnimInstance_PlayerTP::LeftArmOnlySlotAlpha' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, VelocityInterpTime) == 0x000EE4, "Member 'URoNAnimInstance_PlayerTP::VelocityInterpTime' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, VelocitySmoothed) == 0x000EE8, "Member 'URoNAnimInstance_PlayerTP::VelocitySmoothed' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, SpeedScaling) == 0x000F00, "Member 'URoNAnimInstance_PlayerTP::SpeedScaling' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, PlayrateClampMax) == 0x000F04, "Member 'URoNAnimInstance_PlayerTP::PlayrateClampMax' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, CharMovementSnapshot) == 0x000F08, "Member 'URoNAnimInstance_PlayerTP::CharMovementSnapshot' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, PostPivotTriggerThreshold) == 0x001000, "Member 'URoNAnimInstance_PlayerTP::PostPivotTriggerThreshold' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, PivotingCardinalDirSnapShot) == 0x001004, "Member 'URoNAnimInstance_PlayerTP::PivotingCardinalDirSnapShot' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, CharacterRef) == 0x001038, "Member 'URoNAnimInstance_PlayerTP::CharacterRef' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, CharacterAiRef) == 0x001040, "Member 'URoNAnimInstance_PlayerTP::CharacterAiRef' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bUseDistanceMatching) == 0x001048, "Member 'URoNAnimInstance_PlayerTP::bUseDistanceMatching' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, DistanceMatchingCurrentState) == 0x001049, "Member 'URoNAnimInstance_PlayerTP::DistanceMatchingCurrentState' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, StartMarker) == 0x001050, "Member 'URoNAnimInstance_PlayerTP::StartMarker' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, StopMarker) == 0x001080, "Member 'URoNAnimInstance_PlayerTP::StopMarker' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, PivotMarker) == 0x0010B0, "Member 'URoNAnimInstance_PlayerTP::PivotMarker' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, PostPivotMarker) == 0x0010E0, "Member 'URoNAnimInstance_PlayerTP::PostPivotMarker' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, TakeOffMarker) == 0x001110, "Member 'URoNAnimInstance_PlayerTP::TakeOffMarker' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, ApexMarker) == 0x001140, "Member 'URoNAnimInstance_PlayerTP::ApexMarker' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, LandingMarker) == 0x001170, "Member 'URoNAnimInstance_PlayerTP::LandingMarker' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, CurrentPivotDirectionExt) == 0x0011A0, "Member 'URoNAnimInstance_PlayerTP::CurrentPivotDirectionExt' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bPivotDirectionBroken) == 0x0011A1, "Member 'URoNAnimInstance_PlayerTP::bPivotDirectionBroken' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bCanPivotInCurDirection) == 0x0011A2, "Member 'URoNAnimInstance_PlayerTP::bCanPivotInCurDirection' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bSMPrePivotRuleset) == 0x0011A3, "Member 'URoNAnimInstance_PlayerTP::bSMPrePivotRuleset' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bStartDirectionBroken) == 0x0011A4, "Member 'URoNAnimInstance_PlayerTP::bStartDirectionBroken' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, ReplicatedMaxSpeed) == 0x0011A8, "Member 'URoNAnimInstance_PlayerTP::ReplicatedMaxSpeed' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bSMStartRuleset) == 0x0011AC, "Member 'URoNAnimInstance_PlayerTP::bSMStartRuleset' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, bSMStopRuleset) == 0x0011AD, "Member 'URoNAnimInstance_PlayerTP::bSMStopRuleset' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, PelvisDefaultWorldPos) == 0x0011B0, "Member 'URoNAnimInstance_PlayerTP::PelvisDefaultWorldPos' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, CrouchedPelvisDefaultWorldPos) == 0x0011C8, "Member 'URoNAnimInstance_PlayerTP::CrouchedPelvisDefaultWorldPos' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, CrouchedPelvisMovingWorldPos) == 0x0011E0, "Member 'URoNAnimInstance_PlayerTP::CrouchedPelvisMovingWorldPos' has a wrong offset!");
static_assert(offsetof(URoNAnimInstance_PlayerTP, CrouchedPelvisCurrentWorldPos) == 0x0011F8, "Member 'URoNAnimInstance_PlayerTP::CrouchedPelvisCurrentWorldPos' has a wrong offset!");

// Class ReadyOrNot.RONCameraModifier_CameraShake
// 0x0000 (0x00B0 - 0x00B0)
class URONCameraModifier_CameraShake final : public UCameraModifier_CameraShake
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RONCameraModifier_CameraShake">();
	}
	static class URONCameraModifier_CameraShake* GetDefaultObj()
	{
		return GetDefaultObjImpl<URONCameraModifier_CameraShake>();
	}
};
static_assert(alignof(URONCameraModifier_CameraShake) == 0x000008, "Wrong alignment on URONCameraModifier_CameraShake");
static_assert(sizeof(URONCameraModifier_CameraShake) == 0x0000B0, "Wrong size on URONCameraModifier_CameraShake");

// Class ReadyOrNot.RoNMoveStyleCharacter
// 0x0020 (0x06A0 - 0x0680)
class ARoNMoveStyleCharacter final : public ACharacter
{
public:
	class USpringArmComponent*                    CameraBoom;                                        // 0x0678(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCameraComponent*                       FollowCamera;                                      // 0x0680(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URoNMoveStyleComponent*                 MoveStyle;                                         // 0x0688(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseTurnRate;                                      // 0x0690(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseLookUpRate;                                    // 0x0694(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_698[0x8];                                      // 0x0698(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RoNMoveStyleCharacter">();
	}
	static class ARoNMoveStyleCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARoNMoveStyleCharacter>();
	}
};
static_assert(alignof(ARoNMoveStyleCharacter) == 0x000010, "Wrong alignment on ARoNMoveStyleCharacter");
static_assert(sizeof(ARoNMoveStyleCharacter) == 0x0006A0, "Wrong size on ARoNMoveStyleCharacter");
static_assert(offsetof(ARoNMoveStyleCharacter, CameraBoom) == 0x000678, "Member 'ARoNMoveStyleCharacter::CameraBoom' has a wrong offset!");
static_assert(offsetof(ARoNMoveStyleCharacter, FollowCamera) == 0x000680, "Member 'ARoNMoveStyleCharacter::FollowCamera' has a wrong offset!");
static_assert(offsetof(ARoNMoveStyleCharacter, MoveStyle) == 0x000688, "Member 'ARoNMoveStyleCharacter::MoveStyle' has a wrong offset!");
static_assert(offsetof(ARoNMoveStyleCharacter, BaseTurnRate) == 0x000690, "Member 'ARoNMoveStyleCharacter::BaseTurnRate' has a wrong offset!");
static_assert(offsetof(ARoNMoveStyleCharacter, BaseLookUpRate) == 0x000694, "Member 'ARoNMoveStyleCharacter::BaseLookUpRate' has a wrong offset!");

// Class ReadyOrNot.RoNMoveStyleComponent
// 0x0110 (0x01B0 - 0x00A0)
class URoNMoveStyleComponent final : public UActorComponent
{
public:
	class UDataTable*                             MoveStyleDatabase;                                 // 0x00A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DefaultMoveStyleName;                              // 0x00A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DefaulGaitName;                                    // 0x00B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MoveStyleCharacterName;                            // 0x00B8(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PreviousMoveStyleName;                             // 0x00C0(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIsOverriding;                                     // 0x00C8(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRoNMovementStyle                      ActiveMoveStyle;                                   // 0x00D0(0x00A0)(Edit, EditConst, NativeAccessSpecifierPublic)
	class FName                                   Rep_MoveStyleName;                                 // 0x0170(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ActiveGaitIndex;                                   // 0x0178(0x0004)(Edit, Net, ZeroConstructor, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActiveGaitName;                                    // 0x017C(0x0008)(Edit, Net, ZeroConstructor, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GaitTimeOut;                                       // 0x0184(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PendingGaitName;                                   // 0x0188(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsStrafing;                                       // 0x0190(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_191[0x1F];                                     // 0x0191(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearOverrideMoveStyle();
	void OnRep_IsStrafing();
	void OnRep_MoveStyle();
	void SetCharacterAcceleration(float Acceleration);
	void SetCharacterAccelerationMultiplier(float Multiplier);
	void SetCharacterSpeed(float Speed);
	void SetCharacterSpeedMultiplier(float Multiplier);
	bool SetMovementGaitByName(class FName Name_0, bool bForce);
	void SetMovementStyleByName(class FName Name_0);
	void SetOverrideMoveStyleByName(class FName Name_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RoNMoveStyleComponent">();
	}
	static class URoNMoveStyleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URoNMoveStyleComponent>();
	}
};
static_assert(alignof(URoNMoveStyleComponent) == 0x000008, "Wrong alignment on URoNMoveStyleComponent");
static_assert(sizeof(URoNMoveStyleComponent) == 0x0001B0, "Wrong size on URoNMoveStyleComponent");
static_assert(offsetof(URoNMoveStyleComponent, MoveStyleDatabase) == 0x0000A0, "Member 'URoNMoveStyleComponent::MoveStyleDatabase' has a wrong offset!");
static_assert(offsetof(URoNMoveStyleComponent, DefaultMoveStyleName) == 0x0000A8, "Member 'URoNMoveStyleComponent::DefaultMoveStyleName' has a wrong offset!");
static_assert(offsetof(URoNMoveStyleComponent, DefaulGaitName) == 0x0000B0, "Member 'URoNMoveStyleComponent::DefaulGaitName' has a wrong offset!");
static_assert(offsetof(URoNMoveStyleComponent, MoveStyleCharacterName) == 0x0000B8, "Member 'URoNMoveStyleComponent::MoveStyleCharacterName' has a wrong offset!");
static_assert(offsetof(URoNMoveStyleComponent, PreviousMoveStyleName) == 0x0000C0, "Member 'URoNMoveStyleComponent::PreviousMoveStyleName' has a wrong offset!");
static_assert(offsetof(URoNMoveStyleComponent, bIsOverriding) == 0x0000C8, "Member 'URoNMoveStyleComponent::bIsOverriding' has a wrong offset!");
static_assert(offsetof(URoNMoveStyleComponent, ActiveMoveStyle) == 0x0000D0, "Member 'URoNMoveStyleComponent::ActiveMoveStyle' has a wrong offset!");
static_assert(offsetof(URoNMoveStyleComponent, Rep_MoveStyleName) == 0x000170, "Member 'URoNMoveStyleComponent::Rep_MoveStyleName' has a wrong offset!");
static_assert(offsetof(URoNMoveStyleComponent, ActiveGaitIndex) == 0x000178, "Member 'URoNMoveStyleComponent::ActiveGaitIndex' has a wrong offset!");
static_assert(offsetof(URoNMoveStyleComponent, ActiveGaitName) == 0x00017C, "Member 'URoNMoveStyleComponent::ActiveGaitName' has a wrong offset!");
static_assert(offsetof(URoNMoveStyleComponent, GaitTimeOut) == 0x000184, "Member 'URoNMoveStyleComponent::GaitTimeOut' has a wrong offset!");
static_assert(offsetof(URoNMoveStyleComponent, PendingGaitName) == 0x000188, "Member 'URoNMoveStyleComponent::PendingGaitName' has a wrong offset!");
static_assert(offsetof(URoNMoveStyleComponent, bIsStrafing) == 0x000190, "Member 'URoNMoveStyleComponent::bIsStrafing' has a wrong offset!");

// Class ReadyOrNot.DoorSound
// 0x0050 (0x0080 - 0x0030)
class UDoorSound final : public UDataAsset
{
public:
	class UFMODEvent*                             DoorClosed;                                        // 0x0030(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             DoorOpened;                                        // 0x0038(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             DoorStartManipulation;                             // 0x0040(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             DoorStopManipulation;                              // 0x0048(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             BrokenByC2;                                        // 0x0050(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             BrokenByRam;                                       // 0x0058(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             BrokenByShotgun;                                   // 0x0060(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             KickedDown;                                        // 0x0068(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             KickedDownFailed;                                  // 0x0070(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             KickedDownBreak;                                   // 0x0078(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DoorSound">();
	}
	static class UDoorSound* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDoorSound>();
	}
};
static_assert(alignof(UDoorSound) == 0x000008, "Wrong alignment on UDoorSound");
static_assert(sizeof(UDoorSound) == 0x000080, "Wrong size on UDoorSound");
static_assert(offsetof(UDoorSound, DoorClosed) == 0x000030, "Member 'UDoorSound::DoorClosed' has a wrong offset!");
static_assert(offsetof(UDoorSound, DoorOpened) == 0x000038, "Member 'UDoorSound::DoorOpened' has a wrong offset!");
static_assert(offsetof(UDoorSound, DoorStartManipulation) == 0x000040, "Member 'UDoorSound::DoorStartManipulation' has a wrong offset!");
static_assert(offsetof(UDoorSound, DoorStopManipulation) == 0x000048, "Member 'UDoorSound::DoorStopManipulation' has a wrong offset!");
static_assert(offsetof(UDoorSound, BrokenByC2) == 0x000050, "Member 'UDoorSound::BrokenByC2' has a wrong offset!");
static_assert(offsetof(UDoorSound, BrokenByRam) == 0x000058, "Member 'UDoorSound::BrokenByRam' has a wrong offset!");
static_assert(offsetof(UDoorSound, BrokenByShotgun) == 0x000060, "Member 'UDoorSound::BrokenByShotgun' has a wrong offset!");
static_assert(offsetof(UDoorSound, KickedDown) == 0x000068, "Member 'UDoorSound::KickedDown' has a wrong offset!");
static_assert(offsetof(UDoorSound, KickedDownFailed) == 0x000070, "Member 'UDoorSound::KickedDownFailed' has a wrong offset!");
static_assert(offsetof(UDoorSound, KickedDownBreak) == 0x000078, "Member 'UDoorSound::KickedDownBreak' has a wrong offset!");

// Class ReadyOrNot.RoNWeaponAnimInstance
// 0x0020 (0x0370 - 0x0350)
class URoNWeaponAnimInstance : public UAnimInstance
{
public:
	float                                         AmmoRemaining;                                     // 0x0348(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34C[0x4];                                      // 0x034C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               OptiwandBoneModify;                                // 0x0350(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_368[0x4];                                      // 0x0368(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsEquipped;                                       // 0x036C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36D[0x3];                                      // 0x036D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDisassembleMagazineEjected();
	void OnSpeedReloadMagazineEjected();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RoNWeaponAnimInstance">();
	}
	static class URoNWeaponAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<URoNWeaponAnimInstance>();
	}
};
static_assert(alignof(URoNWeaponAnimInstance) == 0x000010, "Wrong alignment on URoNWeaponAnimInstance");
static_assert(sizeof(URoNWeaponAnimInstance) == 0x000370, "Wrong size on URoNWeaponAnimInstance");
static_assert(offsetof(URoNWeaponAnimInstance, AmmoRemaining) == 0x000348, "Member 'URoNWeaponAnimInstance::AmmoRemaining' has a wrong offset!");
static_assert(offsetof(URoNWeaponAnimInstance, OptiwandBoneModify) == 0x000350, "Member 'URoNWeaponAnimInstance::OptiwandBoneModify' has a wrong offset!");
static_assert(offsetof(URoNWeaponAnimInstance, bIsEquipped) == 0x00036C, "Member 'URoNWeaponAnimInstance::bIsEquipped' has a wrong offset!");

// Class ReadyOrNot.RoomVisualizer
// 0x0048 (0x02E0 - 0x0298)
class ARoomVisualizer final : public AActor
{
public:
	class USceneComponent*                        DefaultScene;                                      // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OwningRoom;                                        // 0x02A0(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ADoor*>                          Doors;                                             // 0x02A8(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class AThreatAwarenessActor*>          Threats;                                           // 0x02B8(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class ARoomVisualizer*>                ConnectingRooms;                                   // 0x02C8(0x0010)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnTemplate, EditConst, UObjectWrapper, NativeAccessSpecifierPublic)
	ERoomSize                                     Size;                                              // 0x02D8(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D9[0x7];                                      // 0x02D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RoomVisualizer">();
	}
	static class ARoomVisualizer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARoomVisualizer>();
	}
};
static_assert(alignof(ARoomVisualizer) == 0x000008, "Wrong alignment on ARoomVisualizer");
static_assert(sizeof(ARoomVisualizer) == 0x0002E0, "Wrong size on ARoomVisualizer");
static_assert(offsetof(ARoomVisualizer, DefaultScene) == 0x000298, "Member 'ARoomVisualizer::DefaultScene' has a wrong offset!");
static_assert(offsetof(ARoomVisualizer, OwningRoom) == 0x0002A0, "Member 'ARoomVisualizer::OwningRoom' has a wrong offset!");
static_assert(offsetof(ARoomVisualizer, Doors) == 0x0002A8, "Member 'ARoomVisualizer::Doors' has a wrong offset!");
static_assert(offsetof(ARoomVisualizer, Threats) == 0x0002B8, "Member 'ARoomVisualizer::Threats' has a wrong offset!");
static_assert(offsetof(ARoomVisualizer, ConnectingRooms) == 0x0002C8, "Member 'ARoomVisualizer::ConnectingRooms' has a wrong offset!");
static_assert(offsetof(ARoomVisualizer, Size) == 0x0002D8, "Member 'ARoomVisualizer::Size' has a wrong offset!");

// Class ReadyOrNot.RosterTrait
// 0x00D8 (0x0108 - 0x0030)
class URosterTrait final : public UDataAsset
{
public:
	class FName                                   Reference;                                         // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Name_0;                                            // 0x0038(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0050(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Format;                                            // 0x0068(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     TraitCurve;                                        // 0x0080(0x0088)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RosterTrait">();
	}
	static class URosterTrait* GetDefaultObj()
	{
		return GetDefaultObjImpl<URosterTrait>();
	}
};
static_assert(alignof(URosterTrait) == 0x000008, "Wrong alignment on URosterTrait");
static_assert(sizeof(URosterTrait) == 0x000108, "Wrong size on URosterTrait");
static_assert(offsetof(URosterTrait, Reference) == 0x000030, "Member 'URosterTrait::Reference' has a wrong offset!");
static_assert(offsetof(URosterTrait, Name_0) == 0x000038, "Member 'URosterTrait::Name_0' has a wrong offset!");
static_assert(offsetof(URosterTrait, Description) == 0x000050, "Member 'URosterTrait::Description' has a wrong offset!");
static_assert(offsetof(URosterTrait, Format) == 0x000068, "Member 'URosterTrait::Format' has a wrong offset!");
static_assert(offsetof(URosterTrait, TraitCurve) == 0x000080, "Member 'URosterTrait::TraitCurve' has a wrong offset!");

// Class ReadyOrNot.RosterStoryline
// 0x0070 (0x00A0 - 0x0030)
class URosterStoryline final : public UDataAsset
{
public:
	TArray<class FText>                           DeathEvents;                                       // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FText>                           UnfitForDutyEvents;                                // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FText>                           ReturnFromIncapacitationEvents;                    // 0x0050(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FText>                           ReturnFromTherapyEvents;                           // 0x0060(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FText>                           StressQuitEvents;                                  // 0x0070(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FText>                           TherapistEvents;                                   // 0x0080(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FText>                           TherapistAssessmentEvents;                         // 0x0090(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RosterStoryline">();
	}
	static class URosterStoryline* GetDefaultObj()
	{
		return GetDefaultObjImpl<URosterStoryline>();
	}
};
static_assert(alignof(URosterStoryline) == 0x000008, "Wrong alignment on URosterStoryline");
static_assert(sizeof(URosterStoryline) == 0x0000A0, "Wrong size on URosterStoryline");
static_assert(offsetof(URosterStoryline, DeathEvents) == 0x000030, "Member 'URosterStoryline::DeathEvents' has a wrong offset!");
static_assert(offsetof(URosterStoryline, UnfitForDutyEvents) == 0x000040, "Member 'URosterStoryline::UnfitForDutyEvents' has a wrong offset!");
static_assert(offsetof(URosterStoryline, ReturnFromIncapacitationEvents) == 0x000050, "Member 'URosterStoryline::ReturnFromIncapacitationEvents' has a wrong offset!");
static_assert(offsetof(URosterStoryline, ReturnFromTherapyEvents) == 0x000060, "Member 'URosterStoryline::ReturnFromTherapyEvents' has a wrong offset!");
static_assert(offsetof(URosterStoryline, StressQuitEvents) == 0x000070, "Member 'URosterStoryline::StressQuitEvents' has a wrong offset!");
static_assert(offsetof(URosterStoryline, TherapistEvents) == 0x000080, "Member 'URosterStoryline::TherapistEvents' has a wrong offset!");
static_assert(offsetof(URosterStoryline, TherapistAssessmentEvents) == 0x000090, "Member 'URosterStoryline::TherapistAssessmentEvents' has a wrong offset!");

// Class ReadyOrNot.RosterEventData
// 0x0020 (0x0050 - 0x0030)
class URosterEventData final : public UDataAsset
{
public:
	TArray<class URosterStoryline*>               Storylines;                                        // 0x0030(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FTherapistReminderEvent>        TherapistReminderEvents;                           // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RosterEventData">();
	}
	static class URosterEventData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URosterEventData>();
	}
};
static_assert(alignof(URosterEventData) == 0x000008, "Wrong alignment on URosterEventData");
static_assert(sizeof(URosterEventData) == 0x000050, "Wrong size on URosterEventData");
static_assert(offsetof(URosterEventData, Storylines) == 0x000030, "Member 'URosterEventData::Storylines' has a wrong offset!");
static_assert(offsetof(URosterEventData, TherapistReminderEvents) == 0x000040, "Member 'URosterEventData::TherapistReminderEvents' has a wrong offset!");

// Class ReadyOrNot.RosterCharacter
// 0x00B8 (0x00E0 - 0x0028)
class URosterCharacter final : public UObject
{
public:
	ERosterCharacterState                         State;                                             // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERosterSquadPosition                          Position;                                          // 0x0029(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERosterRemovalReason                          RemovalReason;                                     // 0x002A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B[0x1];                                       // 0x002B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MissionsPlayed;                                    // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StressLevel;                                       // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MissionsUntilReturn;                               // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsNew;                                            // 0x0038(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERosterCharacterState                         PreviousState;                                     // 0x0039(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x2];                                       // 0x003A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PreviousStressLevel;                               // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTherapistIntervened;                              // 0x0040(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class URosterTrait*                           Trait;                                             // 0x0048(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraitUnlocked;                                    // 0x0050(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bJustUnlockedTrait;                                // 0x0051(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52[0x6];                                       // 0x0052(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   MostRecentEventText;                               // 0x0058(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class URosterCharacterArchetype*              Archetype;                                         // 0x0070(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCustomizationCharacter*                Character;                                         // 0x0078(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCustomizationVoice*                    Voice;                                             // 0x0080(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   FirstName;                                         // 0x0088(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   LastName;                                          // 0x00A0(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         SerialNumber;                                      // 0x00B8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         YearsInSWAT;                                       // 0x00BC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x00C0(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class URosterStoryline*                       Storyline;                                         // 0x00D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RosterCharacter">();
	}
	static class URosterCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<URosterCharacter>();
	}
};
static_assert(alignof(URosterCharacter) == 0x000008, "Wrong alignment on URosterCharacter");
static_assert(sizeof(URosterCharacter) == 0x0000E0, "Wrong size on URosterCharacter");
static_assert(offsetof(URosterCharacter, State) == 0x000028, "Member 'URosterCharacter::State' has a wrong offset!");
static_assert(offsetof(URosterCharacter, Position) == 0x000029, "Member 'URosterCharacter::Position' has a wrong offset!");
static_assert(offsetof(URosterCharacter, RemovalReason) == 0x00002A, "Member 'URosterCharacter::RemovalReason' has a wrong offset!");
static_assert(offsetof(URosterCharacter, MissionsPlayed) == 0x00002C, "Member 'URosterCharacter::MissionsPlayed' has a wrong offset!");
static_assert(offsetof(URosterCharacter, StressLevel) == 0x000030, "Member 'URosterCharacter::StressLevel' has a wrong offset!");
static_assert(offsetof(URosterCharacter, MissionsUntilReturn) == 0x000034, "Member 'URosterCharacter::MissionsUntilReturn' has a wrong offset!");
static_assert(offsetof(URosterCharacter, bIsNew) == 0x000038, "Member 'URosterCharacter::bIsNew' has a wrong offset!");
static_assert(offsetof(URosterCharacter, PreviousState) == 0x000039, "Member 'URosterCharacter::PreviousState' has a wrong offset!");
static_assert(offsetof(URosterCharacter, PreviousStressLevel) == 0x00003C, "Member 'URosterCharacter::PreviousStressLevel' has a wrong offset!");
static_assert(offsetof(URosterCharacter, bTherapistIntervened) == 0x000040, "Member 'URosterCharacter::bTherapistIntervened' has a wrong offset!");
static_assert(offsetof(URosterCharacter, Trait) == 0x000048, "Member 'URosterCharacter::Trait' has a wrong offset!");
static_assert(offsetof(URosterCharacter, bTraitUnlocked) == 0x000050, "Member 'URosterCharacter::bTraitUnlocked' has a wrong offset!");
static_assert(offsetof(URosterCharacter, bJustUnlockedTrait) == 0x000051, "Member 'URosterCharacter::bJustUnlockedTrait' has a wrong offset!");
static_assert(offsetof(URosterCharacter, MostRecentEventText) == 0x000058, "Member 'URosterCharacter::MostRecentEventText' has a wrong offset!");
static_assert(offsetof(URosterCharacter, Archetype) == 0x000070, "Member 'URosterCharacter::Archetype' has a wrong offset!");
static_assert(offsetof(URosterCharacter, Character) == 0x000078, "Member 'URosterCharacter::Character' has a wrong offset!");
static_assert(offsetof(URosterCharacter, Voice) == 0x000080, "Member 'URosterCharacter::Voice' has a wrong offset!");
static_assert(offsetof(URosterCharacter, FirstName) == 0x000088, "Member 'URosterCharacter::FirstName' has a wrong offset!");
static_assert(offsetof(URosterCharacter, LastName) == 0x0000A0, "Member 'URosterCharacter::LastName' has a wrong offset!");
static_assert(offsetof(URosterCharacter, SerialNumber) == 0x0000B8, "Member 'URosterCharacter::SerialNumber' has a wrong offset!");
static_assert(offsetof(URosterCharacter, YearsInSWAT) == 0x0000BC, "Member 'URosterCharacter::YearsInSWAT' has a wrong offset!");
static_assert(offsetof(URosterCharacter, Description) == 0x0000C0, "Member 'URosterCharacter::Description' has a wrong offset!");
static_assert(offsetof(URosterCharacter, Storyline) == 0x0000D8, "Member 'URosterCharacter::Storyline' has a wrong offset!");

// Class ReadyOrNot.RosterManagerSettings
// 0x00C0 (0x00F8 - 0x0038)
class URosterManagerSettings final : public UDeveloperSettings
{
public:
	int32                                         RosterSize;                                        // 0x0038(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumRecruitableCharacters;                          // 0x003C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 AdditionalRosterSlots;                             // 0x0040(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	float                                         MaximumStartingStress;                             // 0x0050(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRosterTraitEntry>              AvailableTraits;                                   // 0x0058(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	int32                                         MissionsUntilTraitUnlockable;                      // 0x0068(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class URosterEventData>        EventData;                                         // 0x0070(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeathChance;                                       // 0x0098(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxIncapacitationTime;                             // 0x009C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxStressWhenIncapacitated;                        // 0x00A0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxOfficersFiredAtOnce;                            // 0x00A4(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StressGainForOfficerFired;                         // 0x00A8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxStressForOfficerFired;                          // 0x00AC(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StressGainForOfficerKilled;                        // 0x00B0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StressGainForPlayerKilled;                         // 0x00B4(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StressGainForExfil;                                // 0x00B8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StressGainForActiveShooterExfil;                   // 0x00BC(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StressGainForOfficerNotExfil;                      // 0x00C0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StressGainForFriendlyKilledByPlayer;               // 0x00C4(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StressGainForFriendlyKilledByPlayerBase;           // 0x00C8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinBaseStressGainForKill;                          // 0x00CC(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxBaseStressGainForKill;                          // 0x00D0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StressMultiplierForKillInstigator;                 // 0x00D4(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StressMultiplierForCivilianKill;                   // 0x00D8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StressLossForCivilianArrest;                       // 0x00DC(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StressLossForSuspectArrest;                        // 0x00E0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PassiveStressLoss;                                 // 0x00E4(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxCharactersInTherapy;                            // 0x00E8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimumStressForTherapy;                           // 0x00EC(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TherapistTimeScale;                                // 0x00F0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F4[0x4];                                       // 0x00F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RosterManagerSettings">();
	}
	static class URosterManagerSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<URosterManagerSettings>();
	}
};
static_assert(alignof(URosterManagerSettings) == 0x000008, "Wrong alignment on URosterManagerSettings");
static_assert(sizeof(URosterManagerSettings) == 0x0000F8, "Wrong size on URosterManagerSettings");
static_assert(offsetof(URosterManagerSettings, RosterSize) == 0x000038, "Member 'URosterManagerSettings::RosterSize' has a wrong offset!");
static_assert(offsetof(URosterManagerSettings, NumRecruitableCharacters) == 0x00003C, "Member 'URosterManagerSettings::NumRecruitableCharacters' has a wrong offset!");
static_assert(offsetof(URosterManagerSettings, AdditionalRosterSlots) == 0x000040, "Member 'URosterManagerSettings::AdditionalRosterSlots' has a wrong offset!");
static_assert(offsetof(URosterManagerSettings, MaximumStartingStress) == 0x000050, "Member 'URosterManagerSettings::MaximumStartingStress' has a wrong offset!");
static_assert(offsetof(URosterManagerSettings, AvailableTraits) == 0x000058, "Member 'URosterManagerSettings::AvailableTraits' has a wrong offset!");
static_assert(offsetof(URosterManagerSettings, MissionsUntilTraitUnlockable) == 0x000068, "Member 'URosterManagerSettings::MissionsUntilTraitUnlockable' has a wrong offset!");
static_assert(offsetof(URosterManagerSettings, EventData) == 0x000070, "Member 'URosterManagerSettings::EventData' has a wrong offset!");
static_assert(offsetof(URosterManagerSettings, DeathChance) == 0x000098, "Member 'URosterManagerSettings::DeathChance' has a wrong offset!");
static_assert(offsetof(URosterManagerSettings, MaxIncapacitationTime) == 0x00009C, "Member 'URosterManagerSettings::MaxIncapacitationTime' has a wrong offset!");
static_assert(offsetof(URosterManagerSettings, MaxStressWhenIncapacitated) == 0x0000A0, "Member 'URosterManagerSettings::MaxStressWhenIncapacitated' has a wrong offset!");
static_assert(offsetof(URosterManagerSettings, MaxOfficersFiredAtOnce) == 0x0000A4, "Member 'URosterManagerSettings::MaxOfficersFiredAtOnce' has a wrong offset!");
static_assert(offsetof(URosterManagerSettings, StressGainForOfficerFired) == 0x0000A8, "Member 'URosterManagerSettings::StressGainForOfficerFired' has a wrong offset!");
static_assert(offsetof(URosterManagerSettings, MaxStressForOfficerFired) == 0x0000AC, "Member 'URosterManagerSettings::MaxStressForOfficerFired' has a wrong offset!");
static_assert(offsetof(URosterManagerSettings, StressGainForOfficerKilled) == 0x0000B0, "Member 'URosterManagerSettings::StressGainForOfficerKilled' has a wrong offset!");
static_assert(offsetof(URosterManagerSettings, StressGainForPlayerKilled) == 0x0000B4, "Member 'URosterManagerSettings::StressGainForPlayerKilled' has a wrong offset!");
static_assert(offsetof(URosterManagerSettings, StressGainForExfil) == 0x0000B8, "Member 'URosterManagerSettings::StressGainForExfil' has a wrong offset!");
static_assert(offsetof(URosterManagerSettings, StressGainForActiveShooterExfil) == 0x0000BC, "Member 'URosterManagerSettings::StressGainForActiveShooterExfil' has a wrong offset!");
static_assert(offsetof(URosterManagerSettings, StressGainForOfficerNotExfil) == 0x0000C0, "Member 'URosterManagerSettings::StressGainForOfficerNotExfil' has a wrong offset!");
static_assert(offsetof(URosterManagerSettings, StressGainForFriendlyKilledByPlayer) == 0x0000C4, "Member 'URosterManagerSettings::StressGainForFriendlyKilledByPlayer' has a wrong offset!");
static_assert(offsetof(URosterManagerSettings, StressGainForFriendlyKilledByPlayerBase) == 0x0000C8, "Member 'URosterManagerSettings::StressGainForFriendlyKilledByPlayerBase' has a wrong offset!");
static_assert(offsetof(URosterManagerSettings, MinBaseStressGainForKill) == 0x0000CC, "Member 'URosterManagerSettings::MinBaseStressGainForKill' has a wrong offset!");
static_assert(offsetof(URosterManagerSettings, MaxBaseStressGainForKill) == 0x0000D0, "Member 'URosterManagerSettings::MaxBaseStressGainForKill' has a wrong offset!");
static_assert(offsetof(URosterManagerSettings, StressMultiplierForKillInstigator) == 0x0000D4, "Member 'URosterManagerSettings::StressMultiplierForKillInstigator' has a wrong offset!");
static_assert(offsetof(URosterManagerSettings, StressMultiplierForCivilianKill) == 0x0000D8, "Member 'URosterManagerSettings::StressMultiplierForCivilianKill' has a wrong offset!");
static_assert(offsetof(URosterManagerSettings, StressLossForCivilianArrest) == 0x0000DC, "Member 'URosterManagerSettings::StressLossForCivilianArrest' has a wrong offset!");
static_assert(offsetof(URosterManagerSettings, StressLossForSuspectArrest) == 0x0000E0, "Member 'URosterManagerSettings::StressLossForSuspectArrest' has a wrong offset!");
static_assert(offsetof(URosterManagerSettings, PassiveStressLoss) == 0x0000E4, "Member 'URosterManagerSettings::PassiveStressLoss' has a wrong offset!");
static_assert(offsetof(URosterManagerSettings, MaxCharactersInTherapy) == 0x0000E8, "Member 'URosterManagerSettings::MaxCharactersInTherapy' has a wrong offset!");
static_assert(offsetof(URosterManagerSettings, MinimumStressForTherapy) == 0x0000EC, "Member 'URosterManagerSettings::MinimumStressForTherapy' has a wrong offset!");
static_assert(offsetof(URosterManagerSettings, TherapistTimeScale) == 0x0000F0, "Member 'URosterManagerSettings::TherapistTimeScale' has a wrong offset!");

// Class ReadyOrNot.RosterManager
// 0x0178 (0x01A0 - 0x0028)
class URosterManager final : public UObject
{
public:
	class URosterManagerSettings*                 Settings;                                          // 0x0028(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCommanderProfile*                      CommanderProfile;                                  // 0x0030(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class URosterCharacter*>               Characters;                                        // 0x0038(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class URosterCharacter*>               PreviousCharacters;                                // 0x0048(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class URosterCharacter*>               RecruitableCharacters;                             // 0x0058(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TMap<ERosterSquadPosition, class URosterCharacter*> SquadCharacters;                             // 0x0068(0x0050)(NativeAccessSpecifierPrivate)
	TArray<class URosterCharacterArchetype*>      PossibleCharacters;                                // 0x00B8(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TMap<class FName, class URosterTrait*>        PossibleTraits;                                    // 0x00C8(0x0050)(UObjectWrapper, NativeAccessSpecifierPrivate)
	class URosterEventData*                       EventData;                                         // 0x0118(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URosterCharacterArchetype*              LastArchetype;                                     // 0x0120(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_128[0x78];                                     // 0x0128(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RosterManager">();
	}
	static class URosterManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<URosterManager>();
	}
};
static_assert(alignof(URosterManager) == 0x000008, "Wrong alignment on URosterManager");
static_assert(sizeof(URosterManager) == 0x0001A0, "Wrong size on URosterManager");
static_assert(offsetof(URosterManager, Settings) == 0x000028, "Member 'URosterManager::Settings' has a wrong offset!");
static_assert(offsetof(URosterManager, CommanderProfile) == 0x000030, "Member 'URosterManager::CommanderProfile' has a wrong offset!");
static_assert(offsetof(URosterManager, Characters) == 0x000038, "Member 'URosterManager::Characters' has a wrong offset!");
static_assert(offsetof(URosterManager, PreviousCharacters) == 0x000048, "Member 'URosterManager::PreviousCharacters' has a wrong offset!");
static_assert(offsetof(URosterManager, RecruitableCharacters) == 0x000058, "Member 'URosterManager::RecruitableCharacters' has a wrong offset!");
static_assert(offsetof(URosterManager, SquadCharacters) == 0x000068, "Member 'URosterManager::SquadCharacters' has a wrong offset!");
static_assert(offsetof(URosterManager, PossibleCharacters) == 0x0000B8, "Member 'URosterManager::PossibleCharacters' has a wrong offset!");
static_assert(offsetof(URosterManager, PossibleTraits) == 0x0000C8, "Member 'URosterManager::PossibleTraits' has a wrong offset!");
static_assert(offsetof(URosterManager, EventData) == 0x000118, "Member 'URosterManager::EventData' has a wrong offset!");
static_assert(offsetof(URosterManager, LastArchetype) == 0x000120, "Member 'URosterManager::LastArchetype' has a wrong offset!");

// Class ReadyOrNot.RosterReviewWidget
// 0x0008 (0x0418 - 0x0410)
class URosterReviewWidget : public UCommonActivatableWidget
{
public:
	class URosterManager*                         RosterManager;                                     // 0x0410(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void AddIncapacitatedCharacters(const TArray<class URosterCharacter*>& Characters);
	void AddRemovedCharacters(const TArray<class URosterCharacter*>& Characters);
	void AddReturningCharacters(const TArray<class URosterCharacter*>& Characters);
	void AddSquadCharacters(const TMap<ERosterSquadPosition, class URosterCharacter*>& Characters);
	TArray<class URosterCharacter*> GetAllCharacters();
	class FText GetTherapistReminderPrompt();
	void OpenRoster();

	TArray<class URosterCharacter*> GetCharactersSortedByReviewScore() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RosterReviewWidget">();
	}
	static class URosterReviewWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URosterReviewWidget>();
	}
};
static_assert(alignof(URosterReviewWidget) == 0x000008, "Wrong alignment on URosterReviewWidget");
static_assert(sizeof(URosterReviewWidget) == 0x000418, "Wrong size on URosterReviewWidget");
static_assert(offsetof(URosterReviewWidget, RosterManager) == 0x000410, "Member 'URosterReviewWidget::RosterManager' has a wrong offset!");

// Class ReadyOrNot.RosterScenarioSpawner
// 0x0030 (0x02C8 - 0x0298)
class ARosterScenarioSpawner final : public AInfo
{
public:
	TArray<struct FObjectiveSpawn>                Objectives;                                        // 0x0298(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class ADoor*>                          UsedTrapDoors;                                     // 0x02A8(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B8[0x10];                                     // 0x02B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RosterScenarioSpawner">();
	}
	static class ARosterScenarioSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARosterScenarioSpawner>();
	}
};
static_assert(alignof(ARosterScenarioSpawner) == 0x000008, "Wrong alignment on ARosterScenarioSpawner");
static_assert(sizeof(ARosterScenarioSpawner) == 0x0002C8, "Wrong size on ARosterScenarioSpawner");
static_assert(offsetof(ARosterScenarioSpawner, Objectives) == 0x000298, "Member 'ARosterScenarioSpawner::Objectives' has a wrong offset!");
static_assert(offsetof(ARosterScenarioSpawner, UsedTrapDoors) == 0x0002A8, "Member 'ARosterScenarioSpawner::UsedTrapDoors' has a wrong offset!");

// Class ReadyOrNot.RosterSelectionWidget
// 0x0010 (0x0420 - 0x0410)
class URosterSelectionWidget : public UCommonActivatableWidget
{
public:
	class UCommanderProfile*                      CommanderProfile;                                  // 0x0410(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URosterManager*                         RosterManager;                                     // 0x0418(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool CanFireCharacter(class URosterCharacter* Character);
	bool CanUseTherapist(class URosterCharacter* Character);
	void FireCharacter(class URosterCharacter* Character);
	TArray<class URosterCharacter*> GetAllCharacters();
	struct FRosterLoadout GetCharacterLoadout(class URosterCharacter* Character);
	int32 GetMaxCharactersInTherapy();
	int32 GetNumCharactersInTherapy();
	TArray<class URosterCharacter*> GetRecruitableCharacters();
	TMap<ERosterSquadPosition, class URosterCharacter*> GetSquadCharacters();
	void InitializeRoster();
	void OnCharactersUpdated();
	void RecruitCharacter(class URosterCharacter* Character);
	void RefreshRoster();
	void RefreshRosterEvent();
	void SendCharacterToTherapist(class URosterCharacter* Character);
	void SetSquadCharacter(class URosterCharacter* Character, ERosterSquadPosition Position);

	TArray<struct FRosterActiveTraitInfo> GetActiveTraits() const;
	int32 GetCurrentRosterSize() const;
	int32 GetMaximumRosterSize() const;
	TArray<int32> GetUnlockableSlotMissionsRemaining() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RosterSelectionWidget">();
	}
	static class URosterSelectionWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URosterSelectionWidget>();
	}
};
static_assert(alignof(URosterSelectionWidget) == 0x000008, "Wrong alignment on URosterSelectionWidget");
static_assert(sizeof(URosterSelectionWidget) == 0x000420, "Wrong size on URosterSelectionWidget");
static_assert(offsetof(URosterSelectionWidget, CommanderProfile) == 0x000410, "Member 'URosterSelectionWidget::CommanderProfile' has a wrong offset!");
static_assert(offsetof(URosterSelectionWidget, RosterManager) == 0x000418, "Member 'URosterSelectionWidget::RosterManager' has a wrong offset!");

// Class ReadyOrNot.RoundupWidget
// 0x0050 (0x0460 - 0x0410)
class URoundupWidget : public UCommonActivatableWidget
{
public:
	bool                                          bIsCollapsed;                                      // 0x0410(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_411[0x7];                                      // 0x0411(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FText>                           Unlocks;                                           // 0x0418(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class FText>                           Actions;                                           // 0x0428(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bUsingGamepad;                                     // 0x0438(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_439[0x7];                                      // 0x0439(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMetaGameProfile*                       MetaGameProfile;                                   // 0x0440(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCommanderProfile*                      CommanderProfile;                                  // 0x0448(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URosterManager*                         RosterManager;                                     // 0x0450(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_458[0x8];                                      // 0x0458(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddRoundupAction(const class FText& Action);
	void AddRoundupUnlock(const class FText& Unlock);
	void CollapseContent();
	void EmptyWidget();
	void ExpandContent();
	void HideRoundupActions();
	void HideRoundupUnlocks();
	void HideWidget();
	void OnInputMethodChanged(const ECommonInputType InputMethod);
	void RefreshWidget();
	void ShowWidget();
	void ToggleContent();

	bool IsNewCommanderModeSave() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RoundupWidget">();
	}
	static class URoundupWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URoundupWidget>();
	}
};
static_assert(alignof(URoundupWidget) == 0x000008, "Wrong alignment on URoundupWidget");
static_assert(sizeof(URoundupWidget) == 0x000460, "Wrong size on URoundupWidget");
static_assert(offsetof(URoundupWidget, bIsCollapsed) == 0x000410, "Member 'URoundupWidget::bIsCollapsed' has a wrong offset!");
static_assert(offsetof(URoundupWidget, Unlocks) == 0x000418, "Member 'URoundupWidget::Unlocks' has a wrong offset!");
static_assert(offsetof(URoundupWidget, Actions) == 0x000428, "Member 'URoundupWidget::Actions' has a wrong offset!");
static_assert(offsetof(URoundupWidget, bUsingGamepad) == 0x000438, "Member 'URoundupWidget::bUsingGamepad' has a wrong offset!");
static_assert(offsetof(URoundupWidget, MetaGameProfile) == 0x000440, "Member 'URoundupWidget::MetaGameProfile' has a wrong offset!");
static_assert(offsetof(URoundupWidget, CommanderProfile) == 0x000448, "Member 'URoundupWidget::CommanderProfile' has a wrong offset!");
static_assert(offsetof(URoundupWidget, RosterManager) == 0x000450, "Member 'URoundupWidget::RosterManager' has a wrong offset!");

// Class ReadyOrNot.ScanDoorActivity
// 0x0098 (0x0288 - 0x01F0)
class UScanDoorActivity final : public UBaseActivity
{
public:
	class ADoor*                                  Door;                                              // 0x01F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F8[0x28];                                     // 0x01F8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ACyberneticCharacter*>           SpottedCharacters;                                 // 0x0220(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class ATrapActorAttachedToDoor*               SpottedTrap;                                       // 0x0230(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_238[0x50];                                     // 0x0238(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnterCompleteStage();
	void EnterMoveToStage();
	void EnterScanStage();
	void TickCompleteStage(float DeltaTime, float Uptime);
	void TickMoveToStage(float DeltaTime, float Uptime);
	void TickScanStage(float DeltaTime, float Uptime);

	bool CanStartScanning() const;
	bool IsScanComplete() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScanDoorActivity">();
	}
	static class UScanDoorActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScanDoorActivity>();
	}
};
static_assert(alignof(UScanDoorActivity) == 0x000008, "Wrong alignment on UScanDoorActivity");
static_assert(sizeof(UScanDoorActivity) == 0x000288, "Wrong size on UScanDoorActivity");
static_assert(offsetof(UScanDoorActivity, Door) == 0x0001F0, "Member 'UScanDoorActivity::Door' has a wrong offset!");
static_assert(offsetof(UScanDoorActivity, SpottedCharacters) == 0x000220, "Member 'UScanDoorActivity::SpottedCharacters' has a wrong offset!");
static_assert(offsetof(UScanDoorActivity, SpottedTrap) == 0x000230, "Member 'UScanDoorActivity::SpottedTrap' has a wrong offset!");

// Class ReadyOrNot.ScopedWeaponAttachment
// 0x0770 (0x1840 - 0x10D0)
class UScopedWeaponAttachment : public UWeaponAttachment
{
public:
	TArray<struct FScopeModifications>            ScopeMods;                                         // 0x10D0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         ZoomFOVAddition;                                   // 0x10E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomInSpeed;                                       // 0x10E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomOutSpeed;                                      // 0x10E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSupportsCowitness;                                // 0x10EC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseScopeEffect;                                   // 0x10ED(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10EE[0x2];                                     // 0x10EE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              ScopeReticle;                                      // 0x10F0(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsePipRendering;                                  // 0x1118(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESceneCaptureSource                           CaptureSource;                                     // 0x1119(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverridePostProcessSettings;                      // 0x111A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeedInventoryUpdate;                              // 0x111B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_111C[0x4];                                     // 0x111C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPostProcessSettings                   OverridePostProcessSettings;                       // 0x1120(0x06E0)(Edit, NativeAccessSpecifierPublic)
	int32                                         PipMaterialIdx;                                    // 0x1800(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PipFOV;                                            // 0x1804(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerCameraFOVMultiplier;                         // 0x1808(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_180C[0x4];                                     // 0x180C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               PipRenderDynamicMaterial;                          // 0x1810(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneCaptureComponent2D*               PipSceneCapture;                                   // 0x1818(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextureRenderTarget2D*                 PipRenderTarget;                                   // 0x1820(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              PipResolution;                                     // 0x1828(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1838[0x8];                                     // 0x1838(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetMeshspaceOffsetDistance(class ABaseWeapon* Weapon);
	float GetMeshspaceOffsetHorizontal(class ABaseWeapon* Weapon);
	float GetMeshspaceOffsetVertical(class ABaseWeapon* Weapon);
	struct FScopeModifications GetScopeMods(class ABaseWeapon* Weapon);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScopedWeaponAttachment">();
	}
	static class UScopedWeaponAttachment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScopedWeaponAttachment>();
	}
};
static_assert(alignof(UScopedWeaponAttachment) == 0x000010, "Wrong alignment on UScopedWeaponAttachment");
static_assert(sizeof(UScopedWeaponAttachment) == 0x001840, "Wrong size on UScopedWeaponAttachment");
static_assert(offsetof(UScopedWeaponAttachment, ScopeMods) == 0x0010D0, "Member 'UScopedWeaponAttachment::ScopeMods' has a wrong offset!");
static_assert(offsetof(UScopedWeaponAttachment, ZoomFOVAddition) == 0x0010E0, "Member 'UScopedWeaponAttachment::ZoomFOVAddition' has a wrong offset!");
static_assert(offsetof(UScopedWeaponAttachment, ZoomInSpeed) == 0x0010E4, "Member 'UScopedWeaponAttachment::ZoomInSpeed' has a wrong offset!");
static_assert(offsetof(UScopedWeaponAttachment, ZoomOutSpeed) == 0x0010E8, "Member 'UScopedWeaponAttachment::ZoomOutSpeed' has a wrong offset!");
static_assert(offsetof(UScopedWeaponAttachment, bSupportsCowitness) == 0x0010EC, "Member 'UScopedWeaponAttachment::bSupportsCowitness' has a wrong offset!");
static_assert(offsetof(UScopedWeaponAttachment, bUseScopeEffect) == 0x0010ED, "Member 'UScopedWeaponAttachment::bUseScopeEffect' has a wrong offset!");
static_assert(offsetof(UScopedWeaponAttachment, ScopeReticle) == 0x0010F0, "Member 'UScopedWeaponAttachment::ScopeReticle' has a wrong offset!");
static_assert(offsetof(UScopedWeaponAttachment, bUsePipRendering) == 0x001118, "Member 'UScopedWeaponAttachment::bUsePipRendering' has a wrong offset!");
static_assert(offsetof(UScopedWeaponAttachment, CaptureSource) == 0x001119, "Member 'UScopedWeaponAttachment::CaptureSource' has a wrong offset!");
static_assert(offsetof(UScopedWeaponAttachment, bOverridePostProcessSettings) == 0x00111A, "Member 'UScopedWeaponAttachment::bOverridePostProcessSettings' has a wrong offset!");
static_assert(offsetof(UScopedWeaponAttachment, bNeedInventoryUpdate) == 0x00111B, "Member 'UScopedWeaponAttachment::bNeedInventoryUpdate' has a wrong offset!");
static_assert(offsetof(UScopedWeaponAttachment, OverridePostProcessSettings) == 0x001120, "Member 'UScopedWeaponAttachment::OverridePostProcessSettings' has a wrong offset!");
static_assert(offsetof(UScopedWeaponAttachment, PipMaterialIdx) == 0x001800, "Member 'UScopedWeaponAttachment::PipMaterialIdx' has a wrong offset!");
static_assert(offsetof(UScopedWeaponAttachment, PipFOV) == 0x001804, "Member 'UScopedWeaponAttachment::PipFOV' has a wrong offset!");
static_assert(offsetof(UScopedWeaponAttachment, PlayerCameraFOVMultiplier) == 0x001808, "Member 'UScopedWeaponAttachment::PlayerCameraFOVMultiplier' has a wrong offset!");
static_assert(offsetof(UScopedWeaponAttachment, PipRenderDynamicMaterial) == 0x001810, "Member 'UScopedWeaponAttachment::PipRenderDynamicMaterial' has a wrong offset!");
static_assert(offsetof(UScopedWeaponAttachment, PipSceneCapture) == 0x001818, "Member 'UScopedWeaponAttachment::PipSceneCapture' has a wrong offset!");
static_assert(offsetof(UScopedWeaponAttachment, PipRenderTarget) == 0x001820, "Member 'UScopedWeaponAttachment::PipRenderTarget' has a wrong offset!");
static_assert(offsetof(UScopedWeaponAttachment, PipResolution) == 0x001828, "Member 'UScopedWeaponAttachment::PipResolution' has a wrong offset!");

// Class ReadyOrNot.ScoringInterface
// 0x0000 (0x0000 - 0x0000)
class IScoringInterface final
{
public:
	class UScoringComponent* GetScoringComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScoringInterface">();
	}
	static class IScoringInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IScoringInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IScoringInterface) == 0x000001, "Wrong alignment on IScoringInterface");
static_assert(sizeof(IScoringInterface) == 0x000001, "Wrong size on IScoringInterface");

// Class ReadyOrNot.ScoringManager
// 0x0050 (0x02E8 - 0x0298)
class AScoringManager final : public AInfo
{
public:
	uint8                                         Pad_298[0x18];                                     // 0x0298(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TotalScorePool;                                    // 0x02B0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B4[0xC];                                      // 0x02B4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FScoreGroup>                    ObjectiveScoreGroups;                              // 0x02C0(0x0010)(Net, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FScorePenaltyData>              PenaltyScoreGroups;                                // 0x02D0(0x0010)(Net, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E0[0x1];                                      // 0x02E0(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bCachedHasClearedMission;                          // 0x02E1(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCachedSoftClearedMission;                         // 0x02E2(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCachedMissionFailed;                              // 0x02E3(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsOfficialScoring;                                // 0x02E4(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E5[0x3];                                      // 0x02E5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class FString CalculateGradeLetterFromPercentage(float ScorePercentage);
	static class AScoringManager* Get();
	static void GetCivilianCount(int32* OutReported, int32* OutInjured, int32* OutKilled, int32* OutArrested, int32* OutTotal);
	static void GetEvidenceCount(int32* EvidenceCollected, int32* TotalEvidence);
	static void GetObjectiveCompletionStatus(int32* ObjectivesComplete, int32* ObjectivesFailed, int32* TotalObjectives);
	static void GetReportCount(int32* ReportedCount, int32* TotalReports);
	static void GetScoreCountFromGroup(const class FName& InGroupName, int32* OutScoresGiven, int32* OutTotalScores, bool bRequiredOnly);
	static void GetSuspectCount(int32* OutReported, int32* OutArrested, int32* OutKilled, int32* OutTotal);
	static void HasClearedMission(bool* bHasClearedMission, bool* bSoftClearedMission, bool* bMissionFailed);
	static bool IsOfficialScoring();

	class FString CalculateGradeLetterFromPlayerScore();
	void ChangeScoreGroup(class UScoringComponent* InScoringComponent, class FName NewGroupName);
	void DisplayBonuses(class UScoringComponent* InScoringComponent, bool bCondensed, const class FText& ScoreTextOverride);
	void DisplayBonusesAndPenalties(class UScoringComponent* InScoringComponent, bool bCondensed, const class FText& ScoreTextOverride);
	void DisplayPenalties(class UScoringComponent* InScoringComponent, bool bCondensed, const class FText& ScoreTextOverride);
	void GetTotalScore(int32* TotalScore, bool bIncludePrimaryScores);
	void GetTotalScorePool(int32* MaxScore);
	void GiveAllScores(class UScoringComponent* InScoringComponent, bool bOnlyEnabledScore, bool bDisplayScoreOnHUD, const class FText& ScoreText, float DisplayOnHUDDelay, int32 CustomScoreOnHUD);
	void GiveCustomPenalty(const class FText& PenaltyGroupName, int32 PenaltyScore, bool bDisplayScoreOnHUD, float DisplayOnHUDDelay);
	void GiveFakeScore(class UScoringComponent* InScoringComponent, const class FText& ScoreName, bool bDisplayScoreOnHUD, const class FText& ScoreText, float DisplayOnHUDDelay, int32 CustomScoreOnHUD);
	void GivePenalty(class UScoringComponent* InScoringComponent, const class FText& PenaltyGroupName, bool bDisplayScoreOnHUD, const class FText& ScoreText, float DisplayOnHUDDelay, int32 CustomScoreOnHUD);
	void GiveScore(class UScoringComponent* InScoringComponent, const class FText& ScoreName, bool bDisplayScoreOnHUD, const class FText& ScoreText, float DisplayOnHUDDelay, int32 CustomScoreOnHUD);
	void GiveScores(class UScoringComponent* InScoringComponent, const TArray<class FText>& ScoreNames, bool bDisplayScoreOnHUD, const class FText& ScoreText, float DisplayOnHUDDelay, int32 CustomScoreOnHUD);
	void Multicast_DisplayScore(const class FText& ScoreText, int32 Score, bool bGive);
	void RevokeAllPenalties(class UScoringComponent* InScoringComponent);
	void RevokePenalty(class UScoringComponent* InScoringComponent, const class FText& PenaltyGroupName);
	void TakeAllScores(class UScoringComponent* InScoringComponent, const class FText& TakeReason, bool bDisplayScoreOnHUD, bool bDisableScores);
	void TakeAllScoresExcept(class UScoringComponent* InScoringComponent, const TArray<class FText>& ScoreNames, const class FText& TakeReason, bool bDisplayScoreOnHUD, bool bDisableScores);
	void TakeScore(class UScoringComponent* InScoringComponent, const class FText& ScoreName, const class FText& TakeReason, bool bDisplayScoreOnHUD, bool bDisableScore);
	void TakeScores(class UScoringComponent* InScoringComponent, const TArray<class FText>& ScoreNames, const class FText& TakeReason, bool bDisplayScoreOnHUD, bool bDisableScores);

	bool AllRequiredScoresGiven(const TArray<struct FScoreBonus>& InScoreBonusArray) const;
	bool AllScoresGiven(const TArray<struct FScoreBonus>& InScoreBonusArray) const;
	bool AnyScoresGiven(const TArray<struct FScoreBonus>& InScoreBonusArray) const;
	class FString CalculateGradeLetterFromScore(int32 Score) const;
	float GetCurrentScoreAsPercentage() const;
	int32 GetGivenScoreCountFromArray(const TArray<struct FScoreData>& InScoreDataArray, bool bIncludeHiddenScores) const;
	int32 GetGivenScoreCountFromGroup(const TArray<struct FScoreGroup>& InScoreGroupArray) const;
	int32 GetNonGivenScoreCountFromArray(const TArray<struct FScoreData>& InScoreDataArray, bool bOnlyEnabled) const;
	int32 GetNonGivenScoreCountFromGroup(const TArray<struct FScoreGroup>& InScoreGroupArray) const;
	TArray<struct FScorePenaltyData> GetPenaltyScoreGroups() const;
	TArray<struct FScoreGroup> GetScoreGroups() const;
	int32 GetTotalActorsTrackingScore() const;
	int32 GetTotalGivenScoresFromArray(const TArray<struct FScoreData>& InScoreDataArray, bool bIncludeHiddenScores) const;
	int32 GetTotalNonGivenScoresFromArray(const TArray<struct FScoreData>& InScoreDataArray) const;
	int32 GetTotalScoreCountFromArray(const TArray<struct FScoreData>& InScoreDataArray, bool bIncludeHiddenScores) const;
	int32 GetTotalScoreFromArray(const TArray<struct FScoreData>& InScoreDataArray) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScoringManager">();
	}
	static class AScoringManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AScoringManager>();
	}
};
static_assert(alignof(AScoringManager) == 0x000008, "Wrong alignment on AScoringManager");
static_assert(sizeof(AScoringManager) == 0x0002E8, "Wrong size on AScoringManager");
static_assert(offsetof(AScoringManager, TotalScorePool) == 0x0002B0, "Member 'AScoringManager::TotalScorePool' has a wrong offset!");
static_assert(offsetof(AScoringManager, ObjectiveScoreGroups) == 0x0002C0, "Member 'AScoringManager::ObjectiveScoreGroups' has a wrong offset!");
static_assert(offsetof(AScoringManager, PenaltyScoreGroups) == 0x0002D0, "Member 'AScoringManager::PenaltyScoreGroups' has a wrong offset!");
static_assert(offsetof(AScoringManager, bCachedHasClearedMission) == 0x0002E1, "Member 'AScoringManager::bCachedHasClearedMission' has a wrong offset!");
static_assert(offsetof(AScoringManager, bCachedSoftClearedMission) == 0x0002E2, "Member 'AScoringManager::bCachedSoftClearedMission' has a wrong offset!");
static_assert(offsetof(AScoringManager, bCachedMissionFailed) == 0x0002E3, "Member 'AScoringManager::bCachedMissionFailed' has a wrong offset!");
static_assert(offsetof(AScoringManager, bIsOfficialScoring) == 0x0002E4, "Member 'AScoringManager::bIsOfficialScoring' has a wrong offset!");

// Class ReadyOrNot.ScreenspaceMarkerWidget
// 0x0000 (0x02E8 - 0x02E8)
class UScreenspaceMarkerWidget final : public UCommonUserWidget
{
public:
	void HideWidget();
	void ShowWidget();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScreenspaceMarkerWidget">();
	}
	static class UScreenspaceMarkerWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScreenspaceMarkerWidget>();
	}
};
static_assert(alignof(UScreenspaceMarkerWidget) == 0x000008, "Wrong alignment on UScreenspaceMarkerWidget");
static_assert(sizeof(UScreenspaceMarkerWidget) == 0x0002E8, "Wrong size on UScreenspaceMarkerWidget");

// Class ReadyOrNot.ScriptedLevelEvents
// 0x0000 (0x0028 - 0x0028)
class UScriptedLevelEvents final : public UBlueprintFunctionLibrary
{
public:
	static class ACyberneticCharacter* GetCyberneticsCharacterByTag(class FName Tag);
	static class ACyberneticController* GetCyberneticsControllerByTag(class FName Tag);
	static void GiveWorldBuildingActivityByTag(class ACyberneticController* Controller, class FName Tag, float TimeDoingActivity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScriptedLevelEvents">();
	}
	static class UScriptedLevelEvents* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScriptedLevelEvents>();
	}
};
static_assert(alignof(UScriptedLevelEvents) == 0x000008, "Wrong alignment on UScriptedLevelEvents");
static_assert(sizeof(UScriptedLevelEvents) == 0x000028, "Wrong size on UScriptedLevelEvents");

// Class ReadyOrNot.SearchAndDestroyGM
// 0x0010 (0x09E0 - 0x09D0)
class ASearchAndDestroyGM final : public AReadyOrNotGameMode_PVP
{
public:
	bool                                          bBombPlanted;                                      // 0x09D0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9D1[0x3];                                      // 0x09D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumRedSpawned;                                     // 0x09D4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumBlueSpawned;                                    // 0x09D8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9DC[0x4];                                      // 0x09DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetNumberOfActivePlayersOnTeam(ETeamType Team);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SearchAndDestroyGM">();
	}
	static class ASearchAndDestroyGM* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASearchAndDestroyGM>();
	}
};
static_assert(alignof(ASearchAndDestroyGM) == 0x000010, "Wrong alignment on ASearchAndDestroyGM");
static_assert(sizeof(ASearchAndDestroyGM) == 0x0009E0, "Wrong size on ASearchAndDestroyGM");
static_assert(offsetof(ASearchAndDestroyGM, bBombPlanted) == 0x0009D0, "Member 'ASearchAndDestroyGM::bBombPlanted' has a wrong offset!");
static_assert(offsetof(ASearchAndDestroyGM, NumRedSpawned) == 0x0009D4, "Member 'ASearchAndDestroyGM::NumRedSpawned' has a wrong offset!");
static_assert(offsetof(ASearchAndDestroyGM, NumBlueSpawned) == 0x0009D8, "Member 'ASearchAndDestroyGM::NumBlueSpawned' has a wrong offset!");

// Class ReadyOrNot.SearchAndDestroyGS
// 0x0010 (0x0908 - 0x08F8)
class ASearchAndDestroyGS final : public AReadyOrNotGameState
{
public:
	float                                         BombCountActive;                                   // 0x08F8(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBombPlanted;                                      // 0x08FC(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBombDetonate;                                     // 0x08FD(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBombDefused;                                      // 0x08FE(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8FF[0x1];                                      // 0x08FF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerCharacter*                       bHasBomb;                                          // 0x0900(0x0008)(BlueprintVisible, Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SearchAndDestroyGS">();
	}
	static class ASearchAndDestroyGS* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASearchAndDestroyGS>();
	}
};
static_assert(alignof(ASearchAndDestroyGS) == 0x000008, "Wrong alignment on ASearchAndDestroyGS");
static_assert(sizeof(ASearchAndDestroyGS) == 0x000908, "Wrong size on ASearchAndDestroyGS");
static_assert(offsetof(ASearchAndDestroyGS, BombCountActive) == 0x0008F8, "Member 'ASearchAndDestroyGS::BombCountActive' has a wrong offset!");
static_assert(offsetof(ASearchAndDestroyGS, bBombPlanted) == 0x0008FC, "Member 'ASearchAndDestroyGS::bBombPlanted' has a wrong offset!");
static_assert(offsetof(ASearchAndDestroyGS, bBombDetonate) == 0x0008FD, "Member 'ASearchAndDestroyGS::bBombDetonate' has a wrong offset!");
static_assert(offsetof(ASearchAndDestroyGS, bBombDefused) == 0x0008FE, "Member 'ASearchAndDestroyGS::bBombDefused' has a wrong offset!");
static_assert(offsetof(ASearchAndDestroyGS, bHasBomb) == 0x000900, "Member 'ASearchAndDestroyGS::bHasBomb' has a wrong offset!");

// Class ReadyOrNot.SearchLandmarkActivity
// 0x0020 (0x0210 - 0x01F0)
class USearchLandmarkActivity final : public UBaseActivity
{
public:
	class ACoverLandmark*                         CoverLandmark;                                     // 0x01F0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F8[0x18];                                     // 0x01F8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnterCompleteStage();
	void EnterMoveToStage();
	void EnterSearchStage();
	void Notify_SearchLandmark();
	void TickSearchStage(float DeltaTime, float Uptime);

	bool CanAbortSearch() const;
	bool CanSearchNow() const;
	bool IsSearchFinished() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SearchLandmarkActivity">();
	}
	static class USearchLandmarkActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<USearchLandmarkActivity>();
	}
};
static_assert(alignof(USearchLandmarkActivity) == 0x000008, "Wrong alignment on USearchLandmarkActivity");
static_assert(sizeof(USearchLandmarkActivity) == 0x000210, "Wrong size on USearchLandmarkActivity");
static_assert(offsetof(USearchLandmarkActivity, CoverLandmark) == 0x0001F0, "Member 'USearchLandmarkActivity::CoverLandmark' has a wrong offset!");

// Class ReadyOrNot.Securable
// 0x0000 (0x0000 - 0x0000)
class ISecurable final
{
public:
	void Secure(class AReadyOrNotCharacter* Instigator);

	bool CanBeSecured() const;
	bool CanBeSecuredByTrailers() const;
	class UEvidenceComponent* GetEvidenceComponent() const;
	struct FVector GetLocation() const;
	bool IsSecured() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Securable">();
	}
	static class ISecurable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISecurable>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ISecurable) == 0x000001, "Wrong alignment on ISecurable");
static_assert(sizeof(ISecurable) == 0x000001, "Wrong size on ISecurable");

// Class ReadyOrNot.ServerListData
// 0x0140 (0x0400 - 0x02C0)
class UServerListData final : public UUserWidget
{
public:
	class FString                                 ServerName;                                        // 0x02C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentPlayers;                                    // 0x02D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxPlayers;                                        // 0x02D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Ping;                                              // 0x02D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DC[0x4];                                      // 0x02DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlueprintSessionResult                Session;                                           // 0x02E0(0x0120)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ServerListData">();
	}
	static class UServerListData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UServerListData>();
	}
};
static_assert(alignof(UServerListData) == 0x000008, "Wrong alignment on UServerListData");
static_assert(sizeof(UServerListData) == 0x000400, "Wrong size on UServerListData");
static_assert(offsetof(UServerListData, ServerName) == 0x0002C0, "Member 'UServerListData::ServerName' has a wrong offset!");
static_assert(offsetof(UServerListData, CurrentPlayers) == 0x0002D0, "Member 'UServerListData::CurrentPlayers' has a wrong offset!");
static_assert(offsetof(UServerListData, MaxPlayers) == 0x0002D4, "Member 'UServerListData::MaxPlayers' has a wrong offset!");
static_assert(offsetof(UServerListData, Ping) == 0x0002D8, "Member 'UServerListData::Ping' has a wrong offset!");
static_assert(offsetof(UServerListData, Session) == 0x0002E0, "Member 'UServerListData::Session' has a wrong offset!");

// Class ReadyOrNot.ServerList_Entry
// 0x0030 (0x0440 - 0x0410)
class UServerList_Entry : public UCommonActivatableWidget
{
public:
	uint8                                         Pad_410[0x8];                                      // 0x0410(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UServerListData*                        ListData;                                          // 0x0418(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             ServerName_TextBlock;                              // 0x0420(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             ServerCurrentPlayers_TextBlock;                    // 0x0428(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             ServerMaxPlayers_TextBlock;                        // 0x0430(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             ServerPing_TextBlock;                              // 0x0438(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void JoinSession(const struct FBlueprintSessionResult& Session);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ServerList_Entry">();
	}
	static class UServerList_Entry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UServerList_Entry>();
	}
};
static_assert(alignof(UServerList_Entry) == 0x000008, "Wrong alignment on UServerList_Entry");
static_assert(sizeof(UServerList_Entry) == 0x000440, "Wrong size on UServerList_Entry");
static_assert(offsetof(UServerList_Entry, ListData) == 0x000418, "Member 'UServerList_Entry::ListData' has a wrong offset!");
static_assert(offsetof(UServerList_Entry, ServerName_TextBlock) == 0x000420, "Member 'UServerList_Entry::ServerName_TextBlock' has a wrong offset!");
static_assert(offsetof(UServerList_Entry, ServerCurrentPlayers_TextBlock) == 0x000428, "Member 'UServerList_Entry::ServerCurrentPlayers_TextBlock' has a wrong offset!");
static_assert(offsetof(UServerList_Entry, ServerMaxPlayers_TextBlock) == 0x000430, "Member 'UServerList_Entry::ServerMaxPlayers_TextBlock' has a wrong offset!");
static_assert(offsetof(UServerList_Entry, ServerPing_TextBlock) == 0x000438, "Member 'UServerList_Entry::ServerPing_TextBlock' has a wrong offset!");

// Class ReadyOrNot.SettingsMenuGamepad
// 0x00F0 (0x0500 - 0x0410)
class USettingsMenuGamepad : public UMenuWidget
{
public:
	TArray<struct FKeyBinding>                    CharacterControls;                                 // 0x0410(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FKeyBinding>                    DroneControls;                                     // 0x0420(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FKeyBinding>                    SharedControls;                                    // 0x0430(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class UControlsBind*, struct FAxisMappingStruct> AxesControlBinds;                          // 0x0440(0x0050)(BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TMap<class UControlsBind*, struct FActionMappingStruct> ActionsControlBinds;                     // 0x0490(0x0050)(BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FKeyBinding>                    UnbindableControls;                                // 0x04E0(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class UIllegalUnbindModal*                    IllegalKeyConflictDetectedPopUp;                   // 0x04F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCommonActivatableWidgetStack*          WidgetStack;                                       // 0x04F8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void EndButtonsDisabledForBinding();
	void SelectNewTab(const TArray<class UCommonButtonBase*>& TabButtonsArray, int32 WidgetIndex, bool GoingToPreviousWidget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SettingsMenuGamepad">();
	}
	static class USettingsMenuGamepad* GetDefaultObj()
	{
		return GetDefaultObjImpl<USettingsMenuGamepad>();
	}
};
static_assert(alignof(USettingsMenuGamepad) == 0x000008, "Wrong alignment on USettingsMenuGamepad");
static_assert(sizeof(USettingsMenuGamepad) == 0x000500, "Wrong size on USettingsMenuGamepad");
static_assert(offsetof(USettingsMenuGamepad, CharacterControls) == 0x000410, "Member 'USettingsMenuGamepad::CharacterControls' has a wrong offset!");
static_assert(offsetof(USettingsMenuGamepad, DroneControls) == 0x000420, "Member 'USettingsMenuGamepad::DroneControls' has a wrong offset!");
static_assert(offsetof(USettingsMenuGamepad, SharedControls) == 0x000430, "Member 'USettingsMenuGamepad::SharedControls' has a wrong offset!");
static_assert(offsetof(USettingsMenuGamepad, AxesControlBinds) == 0x000440, "Member 'USettingsMenuGamepad::AxesControlBinds' has a wrong offset!");
static_assert(offsetof(USettingsMenuGamepad, ActionsControlBinds) == 0x000490, "Member 'USettingsMenuGamepad::ActionsControlBinds' has a wrong offset!");
static_assert(offsetof(USettingsMenuGamepad, UnbindableControls) == 0x0004E0, "Member 'USettingsMenuGamepad::UnbindableControls' has a wrong offset!");
static_assert(offsetof(USettingsMenuGamepad, IllegalKeyConflictDetectedPopUp) == 0x0004F0, "Member 'USettingsMenuGamepad::IllegalKeyConflictDetectedPopUp' has a wrong offset!");
static_assert(offsetof(USettingsMenuGamepad, WidgetStack) == 0x0004F8, "Member 'USettingsMenuGamepad::WidgetStack' has a wrong offset!");

// Class ReadyOrNot.ShaderCompilationWidget
// 0x0010 (0x02D0 - 0x02C0)
class UShaderCompilationWidget : public UUserWidget
{
public:
	uint8                                         Pad_2C0[0x10];                                     // 0x02C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnShaderCompileCountUpdated(int32 NumShaders);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShaderCompilationWidget">();
	}
	static class UShaderCompilationWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShaderCompilationWidget>();
	}
};
static_assert(alignof(UShaderCompilationWidget) == 0x000008, "Wrong alignment on UShaderCompilationWidget");
static_assert(sizeof(UShaderCompilationWidget) == 0x0002D0, "Wrong size on UShaderCompilationWidget");

// Class ReadyOrNot.SkinComponent
// 0x01B8 (0x0258 - 0x00A0)
class USkinComponent : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Name_0;                                            // 0x00A8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x00C0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Icon;                                              // 0x00D8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequiresDLC;                                      // 0x0100(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameVersionRestriction                       Dlc;                                               // 0x0101(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bResetsToFactorySkin;                              // 0x0102(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETeamType                                     LockedToTeam;                                      // 0x0103(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_104[0x4];                                      // 0x0104(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class AActor>>             LockedToBlueprint;                                 // 0x0108(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<class USkinnedAsset*, class USkeletalMesh*> SkeletalMeshSkinMap;                            // 0x0118(0x0050)(Edit, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<class USkeletalMeshComponent*, class USkeletalMesh*> PreAppliedSkeletalMeshMap;             // 0x0168(0x0050)(ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<class UStaticMesh*, class UStaticMesh*>  StaticMeshSkinMap;                                 // 0x01B8(0x0050)(Edit, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<class UStaticMeshComponent*, class UStaticMesh*> PreAppliedStaticMeshMap;                   // 0x0208(0x0050)(ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UTexture2D* GetClassDefaultIcon(TSubclassOf<class USkinComponent> SkinComponent);

	bool HasDLCUnlocked();
	bool IsFactorySkin();
	void ResetSkin();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkinComponent">();
	}
	static class USkinComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkinComponent>();
	}
};
static_assert(alignof(USkinComponent) == 0x000008, "Wrong alignment on USkinComponent");
static_assert(sizeof(USkinComponent) == 0x000258, "Wrong size on USkinComponent");
static_assert(offsetof(USkinComponent, Name_0) == 0x0000A8, "Member 'USkinComponent::Name_0' has a wrong offset!");
static_assert(offsetof(USkinComponent, Description) == 0x0000C0, "Member 'USkinComponent::Description' has a wrong offset!");
static_assert(offsetof(USkinComponent, Icon) == 0x0000D8, "Member 'USkinComponent::Icon' has a wrong offset!");
static_assert(offsetof(USkinComponent, bRequiresDLC) == 0x000100, "Member 'USkinComponent::bRequiresDLC' has a wrong offset!");
static_assert(offsetof(USkinComponent, Dlc) == 0x000101, "Member 'USkinComponent::Dlc' has a wrong offset!");
static_assert(offsetof(USkinComponent, bResetsToFactorySkin) == 0x000102, "Member 'USkinComponent::bResetsToFactorySkin' has a wrong offset!");
static_assert(offsetof(USkinComponent, LockedToTeam) == 0x000103, "Member 'USkinComponent::LockedToTeam' has a wrong offset!");
static_assert(offsetof(USkinComponent, LockedToBlueprint) == 0x000108, "Member 'USkinComponent::LockedToBlueprint' has a wrong offset!");
static_assert(offsetof(USkinComponent, SkeletalMeshSkinMap) == 0x000118, "Member 'USkinComponent::SkeletalMeshSkinMap' has a wrong offset!");
static_assert(offsetof(USkinComponent, PreAppliedSkeletalMeshMap) == 0x000168, "Member 'USkinComponent::PreAppliedSkeletalMeshMap' has a wrong offset!");
static_assert(offsetof(USkinComponent, StaticMeshSkinMap) == 0x0001B8, "Member 'USkinComponent::StaticMeshSkinMap' has a wrong offset!");
static_assert(offsetof(USkinComponent, PreAppliedStaticMeshMap) == 0x000208, "Member 'USkinComponent::PreAppliedStaticMeshMap' has a wrong offset!");

// Class ReadyOrNot.SlowDownVolume
// 0x0008 (0x02A8 - 0x02A0)
class ASlowDownVolume final : public ATriggerBox
{
public:
	float                                         SlowDownMultiplier;                                // 0x02A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A4[0x4];                                      // 0x02A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnOverlapBeginComponent(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnOverlapEnd(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnOverlapEndComponent(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SlowDownVolume">();
	}
	static class ASlowDownVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASlowDownVolume>();
	}
};
static_assert(alignof(ASlowDownVolume) == 0x000008, "Wrong alignment on ASlowDownVolume");
static_assert(sizeof(ASlowDownVolume) == 0x0002A8, "Wrong size on ASlowDownVolume");
static_assert(offsetof(ASlowDownVolume, SlowDownMultiplier) == 0x0002A0, "Member 'ASlowDownVolume::SlowDownMultiplier' has a wrong offset!");

// Class ReadyOrNot.SniperCharacter
// 0x0040 (0x2E00 - 0x2DC0)
class ASniperCharacter final : public APlayerCharacter
{
public:
	int32                                         Designation;                                       // 0x2DB8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bADSLocked;                                        // 0x2DBC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DBD[0x3];                                     // 0x2DBD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           ExitControlHandle;                                 // 0x2DC0(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UScopedWeaponAttachment>    PrimaryScopeAttachment;                            // 0x2DC8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWeaponAttachment>          PrimaryMuzzleAttachment;                           // 0x2DD0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWeaponAttachment>          PrimaryUnderbarrelAttachment;                      // 0x2DD8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UScopedWeaponAttachment>    SecondaryScopeAttachment;                          // 0x2DE0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWeaponAttachment>          SecondaryMuzzleAttachment;                         // 0x2DE8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWeaponAttachment>          SecondaryUnderbarrelAttachment;                    // 0x2DF0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DF8[0x8];                                     // 0x2DF8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ExitControl();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SniperCharacter">();
	}
	static class ASniperCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASniperCharacter>();
	}
};
static_assert(alignof(ASniperCharacter) == 0x000010, "Wrong alignment on ASniperCharacter");
static_assert(sizeof(ASniperCharacter) == 0x002E00, "Wrong size on ASniperCharacter");
static_assert(offsetof(ASniperCharacter, Designation) == 0x002DB8, "Member 'ASniperCharacter::Designation' has a wrong offset!");
static_assert(offsetof(ASniperCharacter, bADSLocked) == 0x002DBC, "Member 'ASniperCharacter::bADSLocked' has a wrong offset!");
static_assert(offsetof(ASniperCharacter, ExitControlHandle) == 0x002DC0, "Member 'ASniperCharacter::ExitControlHandle' has a wrong offset!");
static_assert(offsetof(ASniperCharacter, PrimaryScopeAttachment) == 0x002DC8, "Member 'ASniperCharacter::PrimaryScopeAttachment' has a wrong offset!");
static_assert(offsetof(ASniperCharacter, PrimaryMuzzleAttachment) == 0x002DD0, "Member 'ASniperCharacter::PrimaryMuzzleAttachment' has a wrong offset!");
static_assert(offsetof(ASniperCharacter, PrimaryUnderbarrelAttachment) == 0x002DD8, "Member 'ASniperCharacter::PrimaryUnderbarrelAttachment' has a wrong offset!");
static_assert(offsetof(ASniperCharacter, SecondaryScopeAttachment) == 0x002DE0, "Member 'ASniperCharacter::SecondaryScopeAttachment' has a wrong offset!");
static_assert(offsetof(ASniperCharacter, SecondaryMuzzleAttachment) == 0x002DE8, "Member 'ASniperCharacter::SecondaryMuzzleAttachment' has a wrong offset!");
static_assert(offsetof(ASniperCharacter, SecondaryUnderbarrelAttachment) == 0x002DF0, "Member 'ASniperCharacter::SecondaryUnderbarrelAttachment' has a wrong offset!");

// Class ReadyOrNot.SniperSpawn
// 0x0048 (0x02E0 - 0x0298)
class ASniperSpawn final : public AActor
{
public:
	class FName                                   SpawnLabel;                                        // 0x0298(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMovementLocked;                                   // 0x02A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStartInADS;                                       // 0x02A1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockADS;                                          // 0x02A2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A3[0x5];                                      // 0x02A3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ASniperCharacter>           SniperClass;                                       // 0x02A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ASniperCharacter>           SpotterClass;                                      // 0x02B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ASniperCharacter>           MarksmanClass;                                     // 0x02B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UArrowComponent*                        SpawnDirection;                                    // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        RootSceneComponent;                                // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasSniperSpawned;                                 // 0x02D0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D1[0x7];                                      // 0x02D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ASniperCharacter*                       SpawnedSniper;                                     // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void SpawnMarksmanHere(int32 Designation);
	void SpawnPersonnelOfClass(TSubclassOf<class ASniperCharacter> CharacterClass, int32 Designation);
	void SpawnSniperHere(int32 Designation);
	void SpawnSpotterHere(int32 Designation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SniperSpawn">();
	}
	static class ASniperSpawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASniperSpawn>();
	}
};
static_assert(alignof(ASniperSpawn) == 0x000008, "Wrong alignment on ASniperSpawn");
static_assert(sizeof(ASniperSpawn) == 0x0002E0, "Wrong size on ASniperSpawn");
static_assert(offsetof(ASniperSpawn, SpawnLabel) == 0x000298, "Member 'ASniperSpawn::SpawnLabel' has a wrong offset!");
static_assert(offsetof(ASniperSpawn, bMovementLocked) == 0x0002A0, "Member 'ASniperSpawn::bMovementLocked' has a wrong offset!");
static_assert(offsetof(ASniperSpawn, bStartInADS) == 0x0002A1, "Member 'ASniperSpawn::bStartInADS' has a wrong offset!");
static_assert(offsetof(ASniperSpawn, bLockADS) == 0x0002A2, "Member 'ASniperSpawn::bLockADS' has a wrong offset!");
static_assert(offsetof(ASniperSpawn, SniperClass) == 0x0002A8, "Member 'ASniperSpawn::SniperClass' has a wrong offset!");
static_assert(offsetof(ASniperSpawn, SpotterClass) == 0x0002B0, "Member 'ASniperSpawn::SpotterClass' has a wrong offset!");
static_assert(offsetof(ASniperSpawn, MarksmanClass) == 0x0002B8, "Member 'ASniperSpawn::MarksmanClass' has a wrong offset!");
static_assert(offsetof(ASniperSpawn, SpawnDirection) == 0x0002C0, "Member 'ASniperSpawn::SpawnDirection' has a wrong offset!");
static_assert(offsetof(ASniperSpawn, RootSceneComponent) == 0x0002C8, "Member 'ASniperSpawn::RootSceneComponent' has a wrong offset!");
static_assert(offsetof(ASniperSpawn, bHasSniperSpawned) == 0x0002D0, "Member 'ASniperSpawn::bHasSniperSpawned' has a wrong offset!");
static_assert(offsetof(ASniperSpawn, SpawnedSniper) == 0x0002D8, "Member 'ASniperSpawn::SpawnedSniper' has a wrong offset!");

// Class ReadyOrNot.SoundManager
// 0x00A8 (0x00E8 - 0x0040)
class USoundManager final : public UTickableWorldSubsystem
{
public:
	bool                                          bForceLegacySound;                                 // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasFinishedSetup;                                 // 0x0041(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x6];                                       // 0x0042(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class APortalVolume*>                  PortalVolumes;                                     // 0x0048(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class ARoomVolume*>                    RoomVolumes;                                       // 0x0058(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class AReflectionProbe*>               ReflectionProbes;                                  // 0x0068(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class USoundSource*>                   ActiveSoundSources;                                // 0x0078(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class USoundSource*>                   InactiveSoundSources;                              // 0x0088(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class UBVHNode*                               RootBVHNode;                                       // 0x0098(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A0[0x48];                                      // 0x00A0(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class USoundManager* Get(class UWorld* World);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundManager">();
	}
	static class USoundManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundManager>();
	}
};
static_assert(alignof(USoundManager) == 0x000008, "Wrong alignment on USoundManager");
static_assert(sizeof(USoundManager) == 0x0000E8, "Wrong size on USoundManager");
static_assert(offsetof(USoundManager, bForceLegacySound) == 0x000040, "Member 'USoundManager::bForceLegacySound' has a wrong offset!");
static_assert(offsetof(USoundManager, bHasFinishedSetup) == 0x000041, "Member 'USoundManager::bHasFinishedSetup' has a wrong offset!");
static_assert(offsetof(USoundManager, PortalVolumes) == 0x000048, "Member 'USoundManager::PortalVolumes' has a wrong offset!");
static_assert(offsetof(USoundManager, RoomVolumes) == 0x000058, "Member 'USoundManager::RoomVolumes' has a wrong offset!");
static_assert(offsetof(USoundManager, ReflectionProbes) == 0x000068, "Member 'USoundManager::ReflectionProbes' has a wrong offset!");
static_assert(offsetof(USoundManager, ActiveSoundSources) == 0x000078, "Member 'USoundManager::ActiveSoundSources' has a wrong offset!");
static_assert(offsetof(USoundManager, InactiveSoundSources) == 0x000088, "Member 'USoundManager::InactiveSoundSources' has a wrong offset!");
static_assert(offsetof(USoundManager, RootBVHNode) == 0x000098, "Member 'USoundManager::RootBVHNode' has a wrong offset!");

// Class ReadyOrNot.BVHNode
// 0x0068 (0x0090 - 0x0028)
class UBVHNode final : public UObject
{
public:
	uint8                                         Pad_28[0x40];                                      // 0x0028(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UBVHNode*>                       Children;                                          // 0x0068(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class ARoomVolume*>                    Rooms;                                             // 0x0078(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class UWorld*                                 World;                                             // 0x0088(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BVHNode">();
	}
	static class UBVHNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBVHNode>();
	}
};
static_assert(alignof(UBVHNode) == 0x000008, "Wrong alignment on UBVHNode");
static_assert(sizeof(UBVHNode) == 0x000090, "Wrong size on UBVHNode");
static_assert(offsetof(UBVHNode, Children) == 0x000068, "Member 'UBVHNode::Children' has a wrong offset!");
static_assert(offsetof(UBVHNode, Rooms) == 0x000078, "Member 'UBVHNode::Rooms' has a wrong offset!");
static_assert(offsetof(UBVHNode, World) == 0x000088, "Member 'UBVHNode::World' has a wrong offset!");

// Class ReadyOrNot.SoundNodeVolume
// 0x0008 (0x0050 - 0x0048)
class USoundNodeVolume final : public USoundNodeAssetReferencer
{
public:
	float                                         VolumeAdjust;                                      // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundNodeVolume">();
	}
	static class USoundNodeVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundNodeVolume>();
	}
};
static_assert(alignof(USoundNodeVolume) == 0x000008, "Wrong alignment on USoundNodeVolume");
static_assert(sizeof(USoundNodeVolume) == 0x000050, "Wrong size on USoundNodeVolume");
static_assert(offsetof(USoundNodeVolume, VolumeAdjust) == 0x000048, "Member 'USoundNodeVolume::VolumeAdjust' has a wrong offset!");

// Class ReadyOrNot.SoundSource
// 0x0278 (0x02A0 - 0x0028)
class USoundSource final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsRunning;                                        // 0x0030(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsActive;                                         // 0x0031(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPaused;                                         // 0x0032(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33[0x1];                                       // 0x0033(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeSincePrimaryUpdate;                            // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeSincePropagationUpdate;                        // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PrimaryUpdateInterval;                             // 0x003C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PropagationUpdateInterval;                         // 0x0040(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOcclusionType                                OcclusionType;                                     // 0x0044(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPropagationType                              PropagationType;                                   // 0x0045(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESoundSourceType                              SoundSourceType;                                   // 0x0046(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHierarchyType                                HierarchyType;                                     // 0x0047(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USoundSource*>                   ChildrenSoundSources;                              // 0x0048(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class USoundSource*                           ParentSoundSource;                                 // 0x0058(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  InstanceGuid;                                      // 0x0060(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             Event;                                             // 0x0070(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0080(0x0060)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        AttachToComponent;                                 // 0x00E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachPointName;                                   // 0x00E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugMode;                                        // 0x00F0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDoorAttachedSound;                              // 0x00F1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F2[0x6];                                       // 0x00F2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UWorld*                                 World;                                             // 0x00F8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRegisterLater;                                    // 0x0100(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayLater;                                        // 0x0101(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_102[0xE];                                      // 0x0102(0x000E)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnSoundStopped;                                    // 0x0110(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_120[0x38];                                     // 0x0120(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ProgrammerSoundName;                               // 0x0158(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_168[0x50];                                     // 0x0168(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnEventStopped;                                    // 0x01B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnSoundFinished;                                   // 0x01C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class FString& Name, int32 Position)> OnTimelineMarker;      // 0x01D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 Bar, int32 Beat, int32 Position, float Tempo, int32 TimeSignatureUpper, int32 TimeSignatureLower)> OnTimelineBeat; // 0x01E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMap<class FName, float>                      ParameterCache;                                    // 0x01F8(0x0050)(Edit, BlueprintVisible, SimpleDisplay, NativeAccessSpecifierPublic)
	uint8                                         Pad_248[0x58];                                     // 0x0248(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class USoundSource* CreateFirstPersonSound(class UWorld* InWorld, class UFMODEvent* InEvent, const struct FTransform& InTransform, const TArray<struct FMODParam>& Params_0, bool InbDebugMode);
	static class USoundSource* CreateThirdPersonSound(class UWorld* InWorld, class UFMODEvent* InEvent, const struct FTransform& InTransform, const TArray<struct FMODParam>& Params_0, EOcclusionType InOcclusionType, EPropagationType InPropagationType, bool InbDebugMode);
	static void ReplaceAnimNotifies(class UAnimSequenceBase* AnimationSequence);

	void AddChild(class USoundSource* Child);
	void Attach(class USceneComponent* InAttachToComponent, class FName InAttachPointName);
	void Detach();
	void Initialize(class UFMODEvent* InEvent, const struct FTransform& InTransform, const TArray<struct FMODParam>& Params_0, EOcclusionType InOcclusionType, EPropagationType InPropagationType, bool InbDebugMode);
	void Play();
	void ResetSoundSource();
	void SetDebugMode(bool InbDebugMode);
	void SetOcclusionType(EOcclusionType InOcclusionType);
	void SetParameter(class FName Name_0, float Value);
	void SetPaused(bool paused);
	void SetPrimaryTickInterval(float Interval);
	void SetProgrammerSoundName(const class FString& Value);
	void SetPropagationTickInterval(float Interval);
	void SetPropagationType(EPropagationType InPropagationType);
	void Stop();

	float GetCurrentTime() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundSource">();
	}
	static class USoundSource* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundSource>();
	}
};
static_assert(alignof(USoundSource) == 0x000010, "Wrong alignment on USoundSource");
static_assert(sizeof(USoundSource) == 0x0002A0, "Wrong size on USoundSource");
static_assert(offsetof(USoundSource, bIsRunning) == 0x000030, "Member 'USoundSource::bIsRunning' has a wrong offset!");
static_assert(offsetof(USoundSource, bIsActive) == 0x000031, "Member 'USoundSource::bIsActive' has a wrong offset!");
static_assert(offsetof(USoundSource, bIsPaused) == 0x000032, "Member 'USoundSource::bIsPaused' has a wrong offset!");
static_assert(offsetof(USoundSource, TimeSincePrimaryUpdate) == 0x000034, "Member 'USoundSource::TimeSincePrimaryUpdate' has a wrong offset!");
static_assert(offsetof(USoundSource, TimeSincePropagationUpdate) == 0x000038, "Member 'USoundSource::TimeSincePropagationUpdate' has a wrong offset!");
static_assert(offsetof(USoundSource, PrimaryUpdateInterval) == 0x00003C, "Member 'USoundSource::PrimaryUpdateInterval' has a wrong offset!");
static_assert(offsetof(USoundSource, PropagationUpdateInterval) == 0x000040, "Member 'USoundSource::PropagationUpdateInterval' has a wrong offset!");
static_assert(offsetof(USoundSource, OcclusionType) == 0x000044, "Member 'USoundSource::OcclusionType' has a wrong offset!");
static_assert(offsetof(USoundSource, PropagationType) == 0x000045, "Member 'USoundSource::PropagationType' has a wrong offset!");
static_assert(offsetof(USoundSource, SoundSourceType) == 0x000046, "Member 'USoundSource::SoundSourceType' has a wrong offset!");
static_assert(offsetof(USoundSource, HierarchyType) == 0x000047, "Member 'USoundSource::HierarchyType' has a wrong offset!");
static_assert(offsetof(USoundSource, ChildrenSoundSources) == 0x000048, "Member 'USoundSource::ChildrenSoundSources' has a wrong offset!");
static_assert(offsetof(USoundSource, ParentSoundSource) == 0x000058, "Member 'USoundSource::ParentSoundSource' has a wrong offset!");
static_assert(offsetof(USoundSource, InstanceGuid) == 0x000060, "Member 'USoundSource::InstanceGuid' has a wrong offset!");
static_assert(offsetof(USoundSource, Event) == 0x000070, "Member 'USoundSource::Event' has a wrong offset!");
static_assert(offsetof(USoundSource, Transform) == 0x000080, "Member 'USoundSource::Transform' has a wrong offset!");
static_assert(offsetof(USoundSource, AttachToComponent) == 0x0000E0, "Member 'USoundSource::AttachToComponent' has a wrong offset!");
static_assert(offsetof(USoundSource, AttachPointName) == 0x0000E8, "Member 'USoundSource::AttachPointName' has a wrong offset!");
static_assert(offsetof(USoundSource, bDebugMode) == 0x0000F0, "Member 'USoundSource::bDebugMode' has a wrong offset!");
static_assert(offsetof(USoundSource, bIsDoorAttachedSound) == 0x0000F1, "Member 'USoundSource::bIsDoorAttachedSound' has a wrong offset!");
static_assert(offsetof(USoundSource, World) == 0x0000F8, "Member 'USoundSource::World' has a wrong offset!");
static_assert(offsetof(USoundSource, bRegisterLater) == 0x000100, "Member 'USoundSource::bRegisterLater' has a wrong offset!");
static_assert(offsetof(USoundSource, bPlayLater) == 0x000101, "Member 'USoundSource::bPlayLater' has a wrong offset!");
static_assert(offsetof(USoundSource, OnSoundStopped) == 0x000110, "Member 'USoundSource::OnSoundStopped' has a wrong offset!");
static_assert(offsetof(USoundSource, ProgrammerSoundName) == 0x000158, "Member 'USoundSource::ProgrammerSoundName' has a wrong offset!");
static_assert(offsetof(USoundSource, OnEventStopped) == 0x0001B8, "Member 'USoundSource::OnEventStopped' has a wrong offset!");
static_assert(offsetof(USoundSource, OnSoundFinished) == 0x0001C8, "Member 'USoundSource::OnSoundFinished' has a wrong offset!");
static_assert(offsetof(USoundSource, OnTimelineMarker) == 0x0001D8, "Member 'USoundSource::OnTimelineMarker' has a wrong offset!");
static_assert(offsetof(USoundSource, OnTimelineBeat) == 0x0001E8, "Member 'USoundSource::OnTimelineBeat' has a wrong offset!");
static_assert(offsetof(USoundSource, ParameterCache) == 0x0001F8, "Member 'USoundSource::ParameterCache' has a wrong offset!");

// Class ReadyOrNot.SoundSourceAnimNotify
// 0x0020 (0x0058 - 0x0038)
class USoundSourceAnimNotify final : public UAnimNotify
{
public:
	uint8                                         bFollow : 1;                                       // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AttachName;                                        // 0x0040(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             Event;                                             // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundSourceAnimNotify">();
	}
	static class USoundSourceAnimNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundSourceAnimNotify>();
	}
};
static_assert(alignof(USoundSourceAnimNotify) == 0x000008, "Wrong alignment on USoundSourceAnimNotify");
static_assert(sizeof(USoundSourceAnimNotify) == 0x000058, "Wrong size on USoundSourceAnimNotify");
static_assert(offsetof(USoundSourceAnimNotify, AttachName) == 0x000040, "Member 'USoundSourceAnimNotify::AttachName' has a wrong offset!");
static_assert(offsetof(USoundSourceAnimNotify, Event) == 0x000050, "Member 'USoundSourceAnimNotify::Event' has a wrong offset!");

// Class ReadyOrNot.SpawnGenerator
// 0x0058 (0x02F0 - 0x0298)
class ASpawnGenerator final : public AActor
{
public:
	class USceneComponent*                        SceneComponent;                                    // 0x0298(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A0[0x8];                                      // 0x02A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	ETeamType                                     SpawnTeam;                                         // 0x02A8(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A9[0x1];                                      // 0x02A9(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	uint16                                        Rows;                                              // 0x02AA(0x0002)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint16                                        Columns;                                           // 0x02AC(0x0002)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2AE[0x2];                                      // 0x02AE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RowSpacing;                                        // 0x02B0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ColumnSpacing;                                     // 0x02B4(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bShowNodes : 1;                                    // 0x02B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnTemplate, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_2B9[0x17];                                     // 0x02B9(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class APlayerStart*>                   PlayerStarts;                                      // 0x02D0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E0[0x10];                                     // 0x02E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RefreshSpawns();
	void SelectAll();
	void UpdatePlayerStartTags();

	const TArray<class APlayerStart*> GetAllPlayerStarts() const;
	TArray<struct FVector> GetNodes() const;
	ETeamType GetSpawnTeam() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnGenerator">();
	}
	static class ASpawnGenerator* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASpawnGenerator>();
	}
};
static_assert(alignof(ASpawnGenerator) == 0x000008, "Wrong alignment on ASpawnGenerator");
static_assert(sizeof(ASpawnGenerator) == 0x0002F0, "Wrong size on ASpawnGenerator");
static_assert(offsetof(ASpawnGenerator, SceneComponent) == 0x000298, "Member 'ASpawnGenerator::SceneComponent' has a wrong offset!");
static_assert(offsetof(ASpawnGenerator, SpawnTeam) == 0x0002A8, "Member 'ASpawnGenerator::SpawnTeam' has a wrong offset!");
static_assert(offsetof(ASpawnGenerator, Rows) == 0x0002AA, "Member 'ASpawnGenerator::Rows' has a wrong offset!");
static_assert(offsetof(ASpawnGenerator, Columns) == 0x0002AC, "Member 'ASpawnGenerator::Columns' has a wrong offset!");
static_assert(offsetof(ASpawnGenerator, RowSpacing) == 0x0002B0, "Member 'ASpawnGenerator::RowSpacing' has a wrong offset!");
static_assert(offsetof(ASpawnGenerator, ColumnSpacing) == 0x0002B4, "Member 'ASpawnGenerator::ColumnSpacing' has a wrong offset!");
static_assert(offsetof(ASpawnGenerator, PlayerStarts) == 0x0002D0, "Member 'ASpawnGenerator::PlayerStarts' has a wrong offset!");

// Class ReadyOrNot.SpawnStaticMeshAnimNotifyState
// 0x0030 (0x0060 - 0x0030)
class USpawnStaticMeshAnimNotifyState final : public UAnimNotifyState
{
public:
	class UStaticMesh*                            StaticMeshToSpawn;                                 // 0x0030(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneToSpawnOn;                                     // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCastShadow;                                       // 0x0040(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyOwnerSee;                                     // 0x0041(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOwnerNoSee;                                       // 0x0042(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDestroyAtEnd;                                     // 0x0043(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSimulatePhysicsAtEnd;                             // 0x0044(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSimulatePhysicsWhenRagdolled;                     // 0x0045(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_46[0x2];                                       // 0x0046(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ForceVector;                                       // 0x0048(0x0018)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnStaticMeshAnimNotifyState">();
	}
	static class USpawnStaticMeshAnimNotifyState* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpawnStaticMeshAnimNotifyState>();
	}
};
static_assert(alignof(USpawnStaticMeshAnimNotifyState) == 0x000008, "Wrong alignment on USpawnStaticMeshAnimNotifyState");
static_assert(sizeof(USpawnStaticMeshAnimNotifyState) == 0x000060, "Wrong size on USpawnStaticMeshAnimNotifyState");
static_assert(offsetof(USpawnStaticMeshAnimNotifyState, StaticMeshToSpawn) == 0x000030, "Member 'USpawnStaticMeshAnimNotifyState::StaticMeshToSpawn' has a wrong offset!");
static_assert(offsetof(USpawnStaticMeshAnimNotifyState, BoneToSpawnOn) == 0x000038, "Member 'USpawnStaticMeshAnimNotifyState::BoneToSpawnOn' has a wrong offset!");
static_assert(offsetof(USpawnStaticMeshAnimNotifyState, bCastShadow) == 0x000040, "Member 'USpawnStaticMeshAnimNotifyState::bCastShadow' has a wrong offset!");
static_assert(offsetof(USpawnStaticMeshAnimNotifyState, bOnlyOwnerSee) == 0x000041, "Member 'USpawnStaticMeshAnimNotifyState::bOnlyOwnerSee' has a wrong offset!");
static_assert(offsetof(USpawnStaticMeshAnimNotifyState, bOwnerNoSee) == 0x000042, "Member 'USpawnStaticMeshAnimNotifyState::bOwnerNoSee' has a wrong offset!");
static_assert(offsetof(USpawnStaticMeshAnimNotifyState, bDestroyAtEnd) == 0x000043, "Member 'USpawnStaticMeshAnimNotifyState::bDestroyAtEnd' has a wrong offset!");
static_assert(offsetof(USpawnStaticMeshAnimNotifyState, bSimulatePhysicsAtEnd) == 0x000044, "Member 'USpawnStaticMeshAnimNotifyState::bSimulatePhysicsAtEnd' has a wrong offset!");
static_assert(offsetof(USpawnStaticMeshAnimNotifyState, bSimulatePhysicsWhenRagdolled) == 0x000045, "Member 'USpawnStaticMeshAnimNotifyState::bSimulatePhysicsWhenRagdolled' has a wrong offset!");
static_assert(offsetof(USpawnStaticMeshAnimNotifyState, ForceVector) == 0x000048, "Member 'USpawnStaticMeshAnimNotifyState::ForceVector' has a wrong offset!");

// Class ReadyOrNot.SpectateHUD
// 0x0000 (0x0388 - 0x0388)
class ASpectateHUD final : public AHUD
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpectateHUD">();
	}
	static class ASpectateHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASpectateHUD>();
	}
};
static_assert(alignof(ASpectateHUD) == 0x000008, "Wrong alignment on ASpectateHUD");
static_assert(sizeof(ASpectateHUD) == 0x000388, "Wrong size on ASpectateHUD");

// Class ReadyOrNot.SpectatePawn
// 0x0060 (0x03A8 - 0x0348)
class ASpectatePawn : public ASpectatorPawn
{
public:
	class UCameraComponent*                       PawnCamera;                                        // 0x0348(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDeadSpectatePawn;                                 // 0x0350(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_351[0x1];                                      // 0x0351(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bBlendWithViewTarget;                              // 0x0352(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPendingCenterprint;                               // 0x0353(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PendingCenterprintDuration;                        // 0x0354(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PendingCenterprintType;                            // 0x0358(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerCharacter*                       PendingCenterprintOther;                           // 0x0360(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterial*                              HeadcamMaterial;                                   // 0x0368(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               HeadcamMaterialInstance;                           // 0x0370(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USpectatorCharacterHUD*                 SpectatorHUD;                                      // 0x0378(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldShowViewTargetHUD;                          // 0x0380(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_381[0x7];                                      // 0x0381(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 CurrentViewTarget;                                 // 0x0388(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideWidgets;                                      // 0x0390(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_391[0x7];                                      // 0x0391(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerCharacter*                       Killer;                                            // 0x0398(0x0008)(Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerCharacter*                       KilledCharacter;                                   // 0x03A0(0x0008)(Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void CleanUpOldPlayer();
	void EscapeMenu();
	void OnChatPressed();
	void OnSpectatedActorEndPlay(class AActor* Actor, EEndPlayReason EndPlayReason);
	void OnTeamChatPressed();
	void SetViewTarget(class AReadyOrNotCharacter* InCharacter);
	void SpectateNextPlayer();
	void SpectatePreviousPlayer();

	ETeamType GetTeam() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpectatePawn">();
	}
	static class ASpectatePawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASpectatePawn>();
	}
};
static_assert(alignof(ASpectatePawn) == 0x000008, "Wrong alignment on ASpectatePawn");
static_assert(sizeof(ASpectatePawn) == 0x0003A8, "Wrong size on ASpectatePawn");
static_assert(offsetof(ASpectatePawn, PawnCamera) == 0x000348, "Member 'ASpectatePawn::PawnCamera' has a wrong offset!");
static_assert(offsetof(ASpectatePawn, bDeadSpectatePawn) == 0x000350, "Member 'ASpectatePawn::bDeadSpectatePawn' has a wrong offset!");
static_assert(offsetof(ASpectatePawn, bBlendWithViewTarget) == 0x000352, "Member 'ASpectatePawn::bBlendWithViewTarget' has a wrong offset!");
static_assert(offsetof(ASpectatePawn, bPendingCenterprint) == 0x000353, "Member 'ASpectatePawn::bPendingCenterprint' has a wrong offset!");
static_assert(offsetof(ASpectatePawn, PendingCenterprintDuration) == 0x000354, "Member 'ASpectatePawn::PendingCenterprintDuration' has a wrong offset!");
static_assert(offsetof(ASpectatePawn, PendingCenterprintType) == 0x000358, "Member 'ASpectatePawn::PendingCenterprintType' has a wrong offset!");
static_assert(offsetof(ASpectatePawn, PendingCenterprintOther) == 0x000360, "Member 'ASpectatePawn::PendingCenterprintOther' has a wrong offset!");
static_assert(offsetof(ASpectatePawn, HeadcamMaterial) == 0x000368, "Member 'ASpectatePawn::HeadcamMaterial' has a wrong offset!");
static_assert(offsetof(ASpectatePawn, HeadcamMaterialInstance) == 0x000370, "Member 'ASpectatePawn::HeadcamMaterialInstance' has a wrong offset!");
static_assert(offsetof(ASpectatePawn, SpectatorHUD) == 0x000378, "Member 'ASpectatePawn::SpectatorHUD' has a wrong offset!");
static_assert(offsetof(ASpectatePawn, bShouldShowViewTargetHUD) == 0x000380, "Member 'ASpectatePawn::bShouldShowViewTargetHUD' has a wrong offset!");
static_assert(offsetof(ASpectatePawn, CurrentViewTarget) == 0x000388, "Member 'ASpectatePawn::CurrentViewTarget' has a wrong offset!");
static_assert(offsetof(ASpectatePawn, bHideWidgets) == 0x000390, "Member 'ASpectatePawn::bHideWidgets' has a wrong offset!");
static_assert(offsetof(ASpectatePawn, Killer) == 0x000398, "Member 'ASpectatePawn::Killer' has a wrong offset!");
static_assert(offsetof(ASpectatePawn, KilledCharacter) == 0x0003A0, "Member 'ASpectatePawn::KilledCharacter' has a wrong offset!");

// Class ReadyOrNot.SplineTrigger
// 0x0090 (0x0328 - 0x0298)
class ASplineTrigger : public AActor
{
public:
	TMulticastInlineDelegate<void(class APlayerCharacter* PlayerCharacter)> Delegate_OnSplineEnclosureEntered; // 0x0298(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class APlayerCharacter* PlayerCharacter)> Delegate_OnSplineEnclosureExited; // 0x02A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bInvertBounds;                                     // 0x02B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B9[0x7];                                      // 0x02B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LastValidPlayerLocation;                           // 0x02C0(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BoundsEntryDirection;                              // 0x02D8(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bEnabled : 1;                                      // 0x02F0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDrawDebugElements : 1;                            // 0x02F0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_2F1[0x7];                                      // 0x02F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AverageSplinePointLocation;                        // 0x02F8(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bIsOutsideSplineEnclosure : 1;                     // 0x0310(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_311[0x7];                                      // 0x0311(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USplineComponent*                       SplineComponent;                                   // 0x0318(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_320[0x8];                                      // 0x0320(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DisableTrigger();
	void EnableTrigger();
	void OnSplineEnclosureEntered(class APlayerCharacter* PlayerCharacter);
	void OnSplineEnclosureExited(class APlayerCharacter* PlayerCharacter);
	void ToggleDrawDebug();

	bool IsActorInsideSplineEnclosure(class AActor* InActor) const;
	bool IsActorOutsideSplineEnclosure(class AActor* InActor) const;
	bool IsInsideSplineEnclosure() const;
	bool IsLocationOutsideSplineEnclosure(const struct FVector& Location) const;
	bool IsOutsideSplineEnclosure() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SplineTrigger">();
	}
	static class ASplineTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASplineTrigger>();
	}
};
static_assert(alignof(ASplineTrigger) == 0x000008, "Wrong alignment on ASplineTrigger");
static_assert(sizeof(ASplineTrigger) == 0x000328, "Wrong size on ASplineTrigger");
static_assert(offsetof(ASplineTrigger, Delegate_OnSplineEnclosureEntered) == 0x000298, "Member 'ASplineTrigger::Delegate_OnSplineEnclosureEntered' has a wrong offset!");
static_assert(offsetof(ASplineTrigger, Delegate_OnSplineEnclosureExited) == 0x0002A8, "Member 'ASplineTrigger::Delegate_OnSplineEnclosureExited' has a wrong offset!");
static_assert(offsetof(ASplineTrigger, bInvertBounds) == 0x0002B8, "Member 'ASplineTrigger::bInvertBounds' has a wrong offset!");
static_assert(offsetof(ASplineTrigger, LastValidPlayerLocation) == 0x0002C0, "Member 'ASplineTrigger::LastValidPlayerLocation' has a wrong offset!");
static_assert(offsetof(ASplineTrigger, BoundsEntryDirection) == 0x0002D8, "Member 'ASplineTrigger::BoundsEntryDirection' has a wrong offset!");
static_assert(offsetof(ASplineTrigger, AverageSplinePointLocation) == 0x0002F8, "Member 'ASplineTrigger::AverageSplinePointLocation' has a wrong offset!");
static_assert(offsetof(ASplineTrigger, SplineComponent) == 0x000318, "Member 'ASplineTrigger::SplineComponent' has a wrong offset!");

// Class ReadyOrNot.SplineTrigger_Incrimination
// 0x0000 (0x0328 - 0x0328)
class ASplineTrigger_Incrimination final : public ASplineTrigger
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SplineTrigger_Incrimination">();
	}
	static class ASplineTrigger_Incrimination* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASplineTrigger_Incrimination>();
	}
};
static_assert(alignof(ASplineTrigger_Incrimination) == 0x000008, "Wrong alignment on ASplineTrigger_Incrimination");
static_assert(sizeof(ASplineTrigger_Incrimination) == 0x000328, "Wrong size on ASplineTrigger_Incrimination");

// Class ReadyOrNot.SAGNumberOfSquadMembersWithValidTarget
// 0x0020 (0x0048 - 0x0028)
class USAGNumberOfSquadMembersWithValidTarget final : public USquadActionGate
{
public:
	int32                                         RequiredNumber;                                    // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ETargetType>                           TargetTypes;                                       // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, ExposeOnSpawn, NativeAccessSpecifierPublic)
	bool                                          bAllowLastTrackedTarget;                           // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SAGNumberOfSquadMembersWithValidTarget">();
	}
	static class USAGNumberOfSquadMembersWithValidTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USAGNumberOfSquadMembersWithValidTarget>();
	}
};
static_assert(alignof(USAGNumberOfSquadMembersWithValidTarget) == 0x000008, "Wrong alignment on USAGNumberOfSquadMembersWithValidTarget");
static_assert(sizeof(USAGNumberOfSquadMembersWithValidTarget) == 0x000048, "Wrong size on USAGNumberOfSquadMembersWithValidTarget");
static_assert(offsetof(USAGNumberOfSquadMembersWithValidTarget, RequiredNumber) == 0x000028, "Member 'USAGNumberOfSquadMembersWithValidTarget::RequiredNumber' has a wrong offset!");
static_assert(offsetof(USAGNumberOfSquadMembersWithValidTarget, TargetTypes) == 0x000030, "Member 'USAGNumberOfSquadMembersWithValidTarget::TargetTypes' has a wrong offset!");
static_assert(offsetof(USAGNumberOfSquadMembersWithValidTarget, bAllowLastTrackedTarget) == 0x000040, "Member 'USAGNumberOfSquadMembersWithValidTarget::bAllowLastTrackedTarget' has a wrong offset!");

// Class ReadyOrNot.SAGNumberOfSquadMembersKilled
// 0x0008 (0x0030 - 0x0028)
class USAGNumberOfSquadMembersKilled final : public USquadActionGate
{
public:
	int32                                         RequiredKilled;                                    // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncludeIncapacitated;                             // 0x002C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SAGNumberOfSquadMembersKilled">();
	}
	static class USAGNumberOfSquadMembersKilled* GetDefaultObj()
	{
		return GetDefaultObjImpl<USAGNumberOfSquadMembersKilled>();
	}
};
static_assert(alignof(USAGNumberOfSquadMembersKilled) == 0x000008, "Wrong alignment on USAGNumberOfSquadMembersKilled");
static_assert(sizeof(USAGNumberOfSquadMembersKilled) == 0x000030, "Wrong size on USAGNumberOfSquadMembersKilled");
static_assert(offsetof(USAGNumberOfSquadMembersKilled, RequiredKilled) == 0x000028, "Member 'USAGNumberOfSquadMembersKilled::RequiredKilled' has a wrong offset!");
static_assert(offsetof(USAGNumberOfSquadMembersKilled, bIncludeIncapacitated) == 0x00002C, "Member 'USAGNumberOfSquadMembersKilled::bIncludeIncapacitated' has a wrong offset!");

// Class ReadyOrNot.SquadManager
// 0x00E0 (0x0378 - 0x0298)
class ASquadManager final : public AInfo
{
public:
	class FName                                   SquadName;                                         // 0x0298(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ACyberneticCharacter*>           SquadMembers;                                      // 0x02A0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<class AReadyOrNotCharacter*, struct FCyberneticCharacterArrayContainer> ActiveTargetToSquadMembersMap; // 0x02B0(0x0050)(NativeAccessSpecifierPublic)
	class USquadRulesData*                        SquadActionRules;                                  // 0x0300(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UBaseSquadsActivity*>            SquadActivities;                                   // 0x0308(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class UBaseSquadsActivity*                    ActiveSquadActivity;                               // 0x0318(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class UBaseSquadsActivity*, float>       SquadsActivityCooldownMap;                         // 0x0320(0x0050)(NativeAccessSpecifierPublic)
	uint8                                         Pad_370[0x8];                                      // 0x0370(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMemberAwarenessChange(class ACyberneticController* Controller, EAIAwarenessState Previous, EAIAwarenessState Current);
	void OnMemberIncapacitated(class AReadyOrNotCharacter* IncapacitatedCharacter, class AReadyOrNotCharacter* InstigatorCharacter);
	void OnMemberKilled(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter);
	void OnMemberSeenCharacter(class ACyberneticCharacter* Spotter, class AReadyOrNotCharacter* Character);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SquadManager">();
	}
	static class ASquadManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASquadManager>();
	}
};
static_assert(alignof(ASquadManager) == 0x000008, "Wrong alignment on ASquadManager");
static_assert(sizeof(ASquadManager) == 0x000378, "Wrong size on ASquadManager");
static_assert(offsetof(ASquadManager, SquadName) == 0x000298, "Member 'ASquadManager::SquadName' has a wrong offset!");
static_assert(offsetof(ASquadManager, SquadMembers) == 0x0002A0, "Member 'ASquadManager::SquadMembers' has a wrong offset!");
static_assert(offsetof(ASquadManager, ActiveTargetToSquadMembersMap) == 0x0002B0, "Member 'ASquadManager::ActiveTargetToSquadMembersMap' has a wrong offset!");
static_assert(offsetof(ASquadManager, SquadActionRules) == 0x000300, "Member 'ASquadManager::SquadActionRules' has a wrong offset!");
static_assert(offsetof(ASquadManager, SquadActivities) == 0x000308, "Member 'ASquadManager::SquadActivities' has a wrong offset!");
static_assert(offsetof(ASquadManager, ActiveSquadActivity) == 0x000318, "Member 'ASquadManager::ActiveSquadActivity' has a wrong offset!");
static_assert(offsetof(ASquadManager, SquadsActivityCooldownMap) == 0x000320, "Member 'ASquadManager::SquadsActivityCooldownMap' has a wrong offset!");

// Class ReadyOrNot.StackUpActor
// 0x0028 (0x02C0 - 0x0298)
class AStackUpActor final : public AActor
{
public:
	class USceneComponent*                        DefaultScene;                                      // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Depth;                                             // 0x02A0(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A1[0x7];                                      // 0x02A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AController*                            OccupiedBy;                                        // 0x02A8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESquadPosition                                StackUpPosition;                                   // 0x02B0(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B1[0x7];                                      // 0x02B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ADoor*                                  LinkedDoor;                                        // 0x02B8(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StackUpActor">();
	}
	static class AStackUpActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStackUpActor>();
	}
};
static_assert(alignof(AStackUpActor) == 0x000008, "Wrong alignment on AStackUpActor");
static_assert(sizeof(AStackUpActor) == 0x0002C0, "Wrong size on AStackUpActor");
static_assert(offsetof(AStackUpActor, DefaultScene) == 0x000298, "Member 'AStackUpActor::DefaultScene' has a wrong offset!");
static_assert(offsetof(AStackUpActor, Depth) == 0x0002A0, "Member 'AStackUpActor::Depth' has a wrong offset!");
static_assert(offsetof(AStackUpActor, OccupiedBy) == 0x0002A8, "Member 'AStackUpActor::OccupiedBy' has a wrong offset!");
static_assert(offsetof(AStackUpActor, StackUpPosition) == 0x0002B0, "Member 'AStackUpActor::StackUpPosition' has a wrong offset!");
static_assert(offsetof(AStackUpActor, LinkedDoor) == 0x0002B8, "Member 'AStackUpActor::LinkedDoor' has a wrong offset!");

// Class ReadyOrNot.StaticCharacterFaceAnimInstance
// 0x00A0 (0x03F0 - 0x0350)
class UStaticCharacterFaceAnimInstance : public UAnimInstance
{
public:
	class USkeletalMeshComponent*                 BodyDriverMesh;                                    // 0x0348(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 FaceMesh;                                          // 0x0350(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPoseAsset*                             FaceROM;                                           // 0x0358(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODAudioComponent*                    VoiceComponent;                                    // 0x0360(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               FocalTargetLookRotation;                           // 0x0368(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               HeadLookRotation;                                  // 0x0380(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         EyeTargetLookLeft;                                 // 0x0398(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EyeTargetLookRight;                                // 0x039C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EyeTargetLookUp;                                   // 0x03A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EyeTargetLookDown;                                 // 0x03A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          CurrentLipSyncAnimation;                           // 0x03A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B0[0x4];                                      // 0x03B0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurrentLipSyncTime;                                // 0x03B4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B8[0x24];                                     // 0x03B8(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurrentBlinkAmount;                                // 0x03DC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E0[0x10];                                     // 0x03E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PlayLipSyncAnimation(const class FString& SpeakerName, const class FString& VoiceLine);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StaticCharacterFaceAnimInstance">();
	}
	static class UStaticCharacterFaceAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStaticCharacterFaceAnimInstance>();
	}
};
static_assert(alignof(UStaticCharacterFaceAnimInstance) == 0x000010, "Wrong alignment on UStaticCharacterFaceAnimInstance");
static_assert(sizeof(UStaticCharacterFaceAnimInstance) == 0x0003F0, "Wrong size on UStaticCharacterFaceAnimInstance");
static_assert(offsetof(UStaticCharacterFaceAnimInstance, BodyDriverMesh) == 0x000348, "Member 'UStaticCharacterFaceAnimInstance::BodyDriverMesh' has a wrong offset!");
static_assert(offsetof(UStaticCharacterFaceAnimInstance, FaceMesh) == 0x000350, "Member 'UStaticCharacterFaceAnimInstance::FaceMesh' has a wrong offset!");
static_assert(offsetof(UStaticCharacterFaceAnimInstance, FaceROM) == 0x000358, "Member 'UStaticCharacterFaceAnimInstance::FaceROM' has a wrong offset!");
static_assert(offsetof(UStaticCharacterFaceAnimInstance, VoiceComponent) == 0x000360, "Member 'UStaticCharacterFaceAnimInstance::VoiceComponent' has a wrong offset!");
static_assert(offsetof(UStaticCharacterFaceAnimInstance, FocalTargetLookRotation) == 0x000368, "Member 'UStaticCharacterFaceAnimInstance::FocalTargetLookRotation' has a wrong offset!");
static_assert(offsetof(UStaticCharacterFaceAnimInstance, HeadLookRotation) == 0x000380, "Member 'UStaticCharacterFaceAnimInstance::HeadLookRotation' has a wrong offset!");
static_assert(offsetof(UStaticCharacterFaceAnimInstance, EyeTargetLookLeft) == 0x000398, "Member 'UStaticCharacterFaceAnimInstance::EyeTargetLookLeft' has a wrong offset!");
static_assert(offsetof(UStaticCharacterFaceAnimInstance, EyeTargetLookRight) == 0x00039C, "Member 'UStaticCharacterFaceAnimInstance::EyeTargetLookRight' has a wrong offset!");
static_assert(offsetof(UStaticCharacterFaceAnimInstance, EyeTargetLookUp) == 0x0003A0, "Member 'UStaticCharacterFaceAnimInstance::EyeTargetLookUp' has a wrong offset!");
static_assert(offsetof(UStaticCharacterFaceAnimInstance, EyeTargetLookDown) == 0x0003A4, "Member 'UStaticCharacterFaceAnimInstance::EyeTargetLookDown' has a wrong offset!");
static_assert(offsetof(UStaticCharacterFaceAnimInstance, CurrentLipSyncAnimation) == 0x0003A8, "Member 'UStaticCharacterFaceAnimInstance::CurrentLipSyncAnimation' has a wrong offset!");
static_assert(offsetof(UStaticCharacterFaceAnimInstance, CurrentLipSyncTime) == 0x0003B4, "Member 'UStaticCharacterFaceAnimInstance::CurrentLipSyncTime' has a wrong offset!");
static_assert(offsetof(UStaticCharacterFaceAnimInstance, CurrentBlinkAmount) == 0x0003DC, "Member 'UStaticCharacterFaceAnimInstance::CurrentBlinkAmount' has a wrong offset!");

// Class ReadyOrNot.StationSubLevelController
// 0x0020 (0x02B8 - 0x0298)
class AStationSubLevelController final : public AActor
{
public:
	class FName                                   LevelToLoad;                                       // 0x0298(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   EnableAfterCompleting;                             // 0x02A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   DisableAfterCompleting;                            // 0x02A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsMultiplayerOnly;                                // 0x02B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B1[0x7];                                      // 0x02B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TArray<class FString> GetCampaignLevelOptions() const;
	TArray<class FString> GetStreamingLevelOptions() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StationSubLevelController">();
	}
	static class AStationSubLevelController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStationSubLevelController>();
	}
};
static_assert(alignof(AStationSubLevelController) == 0x000008, "Wrong alignment on AStationSubLevelController");
static_assert(sizeof(AStationSubLevelController) == 0x0002B8, "Wrong size on AStationSubLevelController");
static_assert(offsetof(AStationSubLevelController, LevelToLoad) == 0x000298, "Member 'AStationSubLevelController::LevelToLoad' has a wrong offset!");
static_assert(offsetof(AStationSubLevelController, EnableAfterCompleting) == 0x0002A0, "Member 'AStationSubLevelController::EnableAfterCompleting' has a wrong offset!");
static_assert(offsetof(AStationSubLevelController, DisableAfterCompleting) == 0x0002A8, "Member 'AStationSubLevelController::DisableAfterCompleting' has a wrong offset!");
static_assert(offsetof(AStationSubLevelController, bIsMultiplayerOnly) == 0x0002B0, "Member 'AStationSubLevelController::bIsMultiplayerOnly' has a wrong offset!");

// Class ReadyOrNot.StrideWarpingLibrary
// 0x0000 (0x0028 - 0x0028)
class UStrideWarpingLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void UpdateStrideWarping(float DeltaTime, const struct FVector& Velocity, const float& VelocityInterpTime, const float& CurrentAnimationSpeed, const float& PlayrateMaxAdjustment, float& StrideScaling, float& PlayRate, struct FVector& VelocitySmoothed);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StrideWarpingLibrary">();
	}
	static class UStrideWarpingLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStrideWarpingLibrary>();
	}
};
static_assert(alignof(UStrideWarpingLibrary) == 0x000008, "Wrong alignment on UStrideWarpingLibrary");
static_assert(sizeof(UStrideWarpingLibrary) == 0x000028, "Wrong size on UStrideWarpingLibrary");

// Class ReadyOrNot.SubtitlesSettings
// 0x00B0 (0x00E8 - 0x0038)
class USubtitlesSettings final : public UDeveloperSettings
{
public:
	class FString                                 FallbackLocale;                                    // 0x0038(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, class FText>              AvailableLocales;                                  // 0x0048(0x0050)(Edit, Config, NativeAccessSpecifierPublic)
	TMap<class FString, float>                    VoiceLineCooldowns;                                // 0x0098(0x0050)(Edit, Config, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SubtitlesSettings">();
	}
	static class USubtitlesSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<USubtitlesSettings>();
	}
};
static_assert(alignof(USubtitlesSettings) == 0x000008, "Wrong alignment on USubtitlesSettings");
static_assert(sizeof(USubtitlesSettings) == 0x0000E8, "Wrong size on USubtitlesSettings");
static_assert(offsetof(USubtitlesSettings, FallbackLocale) == 0x000038, "Member 'USubtitlesSettings::FallbackLocale' has a wrong offset!");
static_assert(offsetof(USubtitlesSettings, AvailableLocales) == 0x000048, "Member 'USubtitlesSettings::AvailableLocales' has a wrong offset!");
static_assert(offsetof(USubtitlesSettings, VoiceLineCooldowns) == 0x000098, "Member 'USubtitlesSettings::VoiceLineCooldowns' has a wrong offset!");

// Class ReadyOrNot.SubtitlesSubsystem
// 0x0168 (0x0198 - 0x0030)
class USubtitlesSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x168];                                     // 0x0030(0x0168)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SubtitlesSubsystem">();
	}
	static class USubtitlesSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<USubtitlesSubsystem>();
	}
};
static_assert(alignof(USubtitlesSubsystem) == 0x000008, "Wrong alignment on USubtitlesSubsystem");
static_assert(sizeof(USubtitlesSubsystem) == 0x000198, "Wrong size on USubtitlesSubsystem");

// Class ReadyOrNot.SubtitleBlock
// 0x0010 (0x02D0 - 0x02C0)
class USubtitleBlock : public UUserWidget
{
public:
	float                                         CurrentTime;                                       // 0x02C0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalTime;                                         // 0x02C4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVerticalBoxSlot*                       VerticalBoxSlot;                                   // 0x02C8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void SetBackgroundColor(const struct FLinearColor& Color);
	void SetText(const class FText& Text);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SubtitleBlock">();
	}
	static class USubtitleBlock* GetDefaultObj()
	{
		return GetDefaultObjImpl<USubtitleBlock>();
	}
};
static_assert(alignof(USubtitleBlock) == 0x000008, "Wrong alignment on USubtitleBlock");
static_assert(sizeof(USubtitleBlock) == 0x0002D0, "Wrong size on USubtitleBlock");
static_assert(offsetof(USubtitleBlock, CurrentTime) == 0x0002C0, "Member 'USubtitleBlock::CurrentTime' has a wrong offset!");
static_assert(offsetof(USubtitleBlock, TotalTime) == 0x0002C4, "Member 'USubtitleBlock::TotalTime' has a wrong offset!");
static_assert(offsetof(USubtitleBlock, VerticalBoxSlot) == 0x0002C8, "Member 'USubtitleBlock::VerticalBoxSlot' has a wrong offset!");

// Class ReadyOrNot.SubtitlesWidget
// 0x0050 (0x0310 - 0x02C0)
class USubtitlesWidget : public UUserWidget
{
public:
	TSubclassOf<class USubtitleBlock>             SubtitleBlockClass;                                // 0x02C0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxSubtitles;                                      // 0x02C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LingerTime;                                        // 0x02CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeInTime;                                        // 0x02D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeOutTime;                                       // 0x02D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PadInTime;                                         // 0x02D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DC[0x4];                                      // 0x02DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UVerticalBox*                           SubtitlesVerticalBox;                              // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USubtitleBlock*>                 SubtitleBlocks;                                    // 0x02E8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	class USubtitleBlock*                         PreviousSubtitle;                                  // 0x02F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_300[0x10];                                     // 0x0300(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetSubtitlesSize(ESubtitlesSize Size);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SubtitlesWidget">();
	}
	static class USubtitlesWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USubtitlesWidget>();
	}
};
static_assert(alignof(USubtitlesWidget) == 0x000008, "Wrong alignment on USubtitlesWidget");
static_assert(sizeof(USubtitlesWidget) == 0x000310, "Wrong size on USubtitlesWidget");
static_assert(offsetof(USubtitlesWidget, SubtitleBlockClass) == 0x0002C0, "Member 'USubtitlesWidget::SubtitleBlockClass' has a wrong offset!");
static_assert(offsetof(USubtitlesWidget, MaxSubtitles) == 0x0002C8, "Member 'USubtitlesWidget::MaxSubtitles' has a wrong offset!");
static_assert(offsetof(USubtitlesWidget, LingerTime) == 0x0002CC, "Member 'USubtitlesWidget::LingerTime' has a wrong offset!");
static_assert(offsetof(USubtitlesWidget, FadeInTime) == 0x0002D0, "Member 'USubtitlesWidget::FadeInTime' has a wrong offset!");
static_assert(offsetof(USubtitlesWidget, FadeOutTime) == 0x0002D4, "Member 'USubtitlesWidget::FadeOutTime' has a wrong offset!");
static_assert(offsetof(USubtitlesWidget, PadInTime) == 0x0002D8, "Member 'USubtitlesWidget::PadInTime' has a wrong offset!");
static_assert(offsetof(USubtitlesWidget, SubtitlesVerticalBox) == 0x0002E0, "Member 'USubtitlesWidget::SubtitlesVerticalBox' has a wrong offset!");
static_assert(offsetof(USubtitlesWidget, SubtitleBlocks) == 0x0002E8, "Member 'USubtitlesWidget::SubtitleBlocks' has a wrong offset!");
static_assert(offsetof(USubtitlesWidget, PreviousSubtitle) == 0x0002F8, "Member 'USubtitlesWidget::PreviousSubtitle' has a wrong offset!");

// Class ReadyOrNot.SuppressionCombatMove
// 0x0020 (0x0250 - 0x0230)
class USuppressionCombatMove final : public UBaseCombatMoveActivity
{
public:
	uint8                                         Pad_230[0x20];                                     // 0x0230(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SuppressionCombatMove">();
	}
	static class USuppressionCombatMove* GetDefaultObj()
	{
		return GetDefaultObjImpl<USuppressionCombatMove>();
	}
};
static_assert(alignof(USuppressionCombatMove) == 0x000008, "Wrong alignment on USuppressionCombatMove");
static_assert(sizeof(USuppressionCombatMove) == 0x000250, "Wrong size on USuppressionCombatMove");

// Class ReadyOrNot.SuspectCharacter
// 0x0010 (0x2560 - 0x2550)
class ASuspectCharacter : public ACyberneticCharacter
{
public:
	class AController*                            C2PlacedByController;                              // 0x2550(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2558[0x8];                                     // 0x2558(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SuspectCharacter">();
	}
	static class ASuspectCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASuspectCharacter>();
	}
};
static_assert(alignof(ASuspectCharacter) == 0x000010, "Wrong alignment on ASuspectCharacter");
static_assert(sizeof(ASuspectCharacter) == 0x002560, "Wrong size on ASuspectCharacter");
static_assert(offsetof(ASuspectCharacter, C2PlacedByController) == 0x002550, "Member 'ASuspectCharacter::C2PlacedByController' has a wrong offset!");

// Class ReadyOrNot.SuspectController
// 0x0000 (0x0A48 - 0x0A48)
class ASuspectController final : public ACyberneticController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SuspectController">();
	}
	static class ASuspectController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASuspectController>();
	}
};
static_assert(alignof(ASuspectController) == 0x000008, "Wrong alignment on ASuspectController");
static_assert(sizeof(ASuspectController) == 0x000A48, "Wrong size on ASuspectController");

// Class ReadyOrNot.SuspectsAndCivilianManager
// 0x0090 (0x00D0 - 0x0040)
class USuspectsAndCivilianManager final : public UTickableWorldSubsystem
{
public:
	TArray<class ATrapActor*>                     InvestigatedTrap;                                  // 0x0040(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class ACyberneticCharacter*>           Suspects;                                          // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class ACyberneticCharacter*>           Civilians;                                         // 0x0060(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         TimeSinceLastInvestigation;                        // 0x0070(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0xC];                                       // 0x0074(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, float>                    SpeechCooldownMap;                                 // 0x0080(0x0050)(Protected, NativeAccessSpecifierProtected)

public:
	void Server_PlaySharedBarkOrStartConversation(const class FString& SpeechRow, class ACyberneticCharacter* Speaker, float Cooldown);

	TArray<class ACyberneticCharacter*> GetAllSuspectsAndCivilians() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SuspectsAndCivilianManager">();
	}
	static class USuspectsAndCivilianManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<USuspectsAndCivilianManager>();
	}
};
static_assert(alignof(USuspectsAndCivilianManager) == 0x000008, "Wrong alignment on USuspectsAndCivilianManager");
static_assert(sizeof(USuspectsAndCivilianManager) == 0x0000D0, "Wrong size on USuspectsAndCivilianManager");
static_assert(offsetof(USuspectsAndCivilianManager, InvestigatedTrap) == 0x000040, "Member 'USuspectsAndCivilianManager::InvestigatedTrap' has a wrong offset!");
static_assert(offsetof(USuspectsAndCivilianManager, Suspects) == 0x000050, "Member 'USuspectsAndCivilianManager::Suspects' has a wrong offset!");
static_assert(offsetof(USuspectsAndCivilianManager, Civilians) == 0x000060, "Member 'USuspectsAndCivilianManager::Civilians' has a wrong offset!");
static_assert(offsetof(USuspectsAndCivilianManager, TimeSinceLastInvestigation) == 0x000070, "Member 'USuspectsAndCivilianManager::TimeSinceLastInvestigation' has a wrong offset!");
static_assert(offsetof(USuspectsAndCivilianManager, SpeechCooldownMap) == 0x000080, "Member 'USuspectsAndCivilianManager::SpeechCooldownMap' has a wrong offset!");

// Class ReadyOrNot.ArmourMaterial
// 0x0098 (0x00C8 - 0x0030)
class UArmourMaterial final : public UPrimaryDataAsset
{
public:
	float                                         DamageReduction;                                   // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDamageReduction;                                // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDurabilityEnabled;                                // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Durability;                                        // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        ArmourLevel;                                       // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpallingChance;                                    // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementSpeedModifier;                             // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementAccelerationModifier;                      // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        HitParticle;                                       // 0x0050(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0058(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Description;                                       // 0x0078(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              LoadoutIcon;                                       // 0x0090(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EGameVersionRestriction>               LockedToDLC;                                       // 0x00B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArmourMaterial">();
	}
	static class UArmourMaterial* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArmourMaterial>();
	}
};
static_assert(alignof(UArmourMaterial) == 0x000008, "Wrong alignment on UArmourMaterial");
static_assert(sizeof(UArmourMaterial) == 0x0000C8, "Wrong size on UArmourMaterial");
static_assert(offsetof(UArmourMaterial, DamageReduction) == 0x000030, "Member 'UArmourMaterial::DamageReduction' has a wrong offset!");
static_assert(offsetof(UArmourMaterial, MinDamageReduction) == 0x000034, "Member 'UArmourMaterial::MinDamageReduction' has a wrong offset!");
static_assert(offsetof(UArmourMaterial, bDurabilityEnabled) == 0x000038, "Member 'UArmourMaterial::bDurabilityEnabled' has a wrong offset!");
static_assert(offsetof(UArmourMaterial, Durability) == 0x00003C, "Member 'UArmourMaterial::Durability' has a wrong offset!");
static_assert(offsetof(UArmourMaterial, ArmourLevel) == 0x000040, "Member 'UArmourMaterial::ArmourLevel' has a wrong offset!");
static_assert(offsetof(UArmourMaterial, SpallingChance) == 0x000044, "Member 'UArmourMaterial::SpallingChance' has a wrong offset!");
static_assert(offsetof(UArmourMaterial, MovementSpeedModifier) == 0x000048, "Member 'UArmourMaterial::MovementSpeedModifier' has a wrong offset!");
static_assert(offsetof(UArmourMaterial, MovementAccelerationModifier) == 0x00004C, "Member 'UArmourMaterial::MovementAccelerationModifier' has a wrong offset!");
static_assert(offsetof(UArmourMaterial, HitParticle) == 0x000050, "Member 'UArmourMaterial::HitParticle' has a wrong offset!");
static_assert(offsetof(UArmourMaterial, DisplayName) == 0x000058, "Member 'UArmourMaterial::DisplayName' has a wrong offset!");
static_assert(offsetof(UArmourMaterial, Priority) == 0x000070, "Member 'UArmourMaterial::Priority' has a wrong offset!");
static_assert(offsetof(UArmourMaterial, Description) == 0x000078, "Member 'UArmourMaterial::Description' has a wrong offset!");
static_assert(offsetof(UArmourMaterial, LoadoutIcon) == 0x000090, "Member 'UArmourMaterial::LoadoutIcon' has a wrong offset!");
static_assert(offsetof(UArmourMaterial, LockedToDLC) == 0x0000B8, "Member 'UArmourMaterial::LockedToDLC' has a wrong offset!");

// Class ReadyOrNot.SwatAutomationManager
// 0x0030 (0x02C8 - 0x0298)
class ASwatAutomationManager final : public AInfo
{
public:
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ADoor*>                          Doors;                                             // 0x02A0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class ADoor*>                          BreachedDoors;                                     // 0x02B0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class ADoor*                                  CurrentDoor;                                       // 0x02C0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SwatAutomationManager">();
	}
	static class ASwatAutomationManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASwatAutomationManager>();
	}
};
static_assert(alignof(ASwatAutomationManager) == 0x000008, "Wrong alignment on ASwatAutomationManager");
static_assert(sizeof(ASwatAutomationManager) == 0x0002C8, "Wrong size on ASwatAutomationManager");
static_assert(offsetof(ASwatAutomationManager, Doors) == 0x0002A0, "Member 'ASwatAutomationManager::Doors' has a wrong offset!");
static_assert(offsetof(ASwatAutomationManager, BreachedDoors) == 0x0002B0, "Member 'ASwatAutomationManager::BreachedDoors' has a wrong offset!");
static_assert(offsetof(ASwatAutomationManager, CurrentDoor) == 0x0002C0, "Member 'ASwatAutomationManager::CurrentDoor' has a wrong offset!");

// Class ReadyOrNot.SWATCharacter
// 0x0050 (0x25A0 - 0x2550)
class ASWATCharacter : public ACyberneticCharacter
{
public:
	uint8                                         Pad_2550[0x38];                                    // 0x2550(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class URosterCharacter*                       RosterCharacter;                                   // 0x2588(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2590[0x10];                                    // 0x2590(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PlayOnShotDialogue(bool bIsFriendly);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SWATCharacter">();
	}
	static class ASWATCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASWATCharacter>();
	}
};
static_assert(alignof(ASWATCharacter) == 0x000010, "Wrong alignment on ASWATCharacter");
static_assert(sizeof(ASWATCharacter) == 0x0025A0, "Wrong size on ASWATCharacter");
static_assert(offsetof(ASWATCharacter, RosterCharacter) == 0x002588, "Member 'ASWATCharacter::RosterCharacter' has a wrong offset!");

// Class ReadyOrNot.SwatCombatActivity
// 0x0010 (0x04C0 - 0x04B0)
class USwatCombatActivity final : public UBaseCombatActivity
{
public:
	uint8                                         Pad_4B0[0x10];                                     // 0x04B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SwatCombatActivity">();
	}
	static class USwatCombatActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<USwatCombatActivity>();
	}
};
static_assert(alignof(USwatCombatActivity) == 0x000008, "Wrong alignment on USwatCombatActivity");
static_assert(sizeof(USwatCombatActivity) == 0x0004C0, "Wrong size on USwatCombatActivity");

// Class ReadyOrNot.SwatCommandStatusWidget
// 0x0130 (0x03F0 - 0x02C0)
class USwatCommandStatusWidget : public UUserWidget
{
public:
	bool                                          bIsLead;                                           // 0x02C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESquadPosition                                SquadPosition;                                     // 0x02C1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerHealthStatus                           PlayerHealthStatus;                                // 0x02C2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C3[0x1];                                      // 0x02C3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinHeight;                                         // 0x02C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxHeight;                                         // 0x02C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CC[0x4];                                      // 0x02CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UHorizontalBox*                         CurrentCommand_Box;                                // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVerticalBox*                           CommandStatus_Box;                                 // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextWidget*                            CurrentCommand_Text;                               // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextWidget*                            CurrentCommand_Pulse_Text;                         // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextWidget*                            CurrentCommand_Status_Text;                        // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USizeBox*                               SizeBox;                                           // 0x02F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           SwatInfo_Box;                                      // 0x0300(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         SwatStats_Box;                                     // 0x0308(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextWidget*                            SwatName_Text;                                     // 0x0310(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USizeBox*                               TeamIndicator_Box;                                 // 0x0318(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 TeamIndicator_Image;                               // 0x0320(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USizeBox*                               HealthStatus_SizeBox;                              // 0x0328(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextWidget*                            PlayerHealth_Text;                                 // 0x0330(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         IssueCommand_Hotkey_RichText;                      // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 IssueCommand_Hotkey_Icon;                          // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 IssueCommand_Hotkey_Icon_Highlight;                // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       Anim_CommandCompleted;                             // 0x0350(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       Anim_CommandIssued;                                // 0x0358(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       Anim_CommandCompletedWhileAnotherQueued;           // 0x0360(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsProgress;                                       // 0x0368(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_369[0x3];                                      // 0x0369(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           RedTeamColor;                                      // 0x036C(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           BlueTeamColor;                                     // 0x037C(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           ElementTeamColor;                                  // 0x038C(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           NormalColor;                                       // 0x039C(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           InjuredColor;                                      // 0x03AC(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           DeadColor;                                         // 0x03BC(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3CC[0x24];                                     // 0x03CC(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ShoulderButtonPressed(bool Pressed);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SwatCommandStatusWidget">();
	}
	static class USwatCommandStatusWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USwatCommandStatusWidget>();
	}
};
static_assert(alignof(USwatCommandStatusWidget) == 0x000008, "Wrong alignment on USwatCommandStatusWidget");
static_assert(sizeof(USwatCommandStatusWidget) == 0x0003F0, "Wrong size on USwatCommandStatusWidget");
static_assert(offsetof(USwatCommandStatusWidget, bIsLead) == 0x0002C0, "Member 'USwatCommandStatusWidget::bIsLead' has a wrong offset!");
static_assert(offsetof(USwatCommandStatusWidget, SquadPosition) == 0x0002C1, "Member 'USwatCommandStatusWidget::SquadPosition' has a wrong offset!");
static_assert(offsetof(USwatCommandStatusWidget, PlayerHealthStatus) == 0x0002C2, "Member 'USwatCommandStatusWidget::PlayerHealthStatus' has a wrong offset!");
static_assert(offsetof(USwatCommandStatusWidget, MinHeight) == 0x0002C4, "Member 'USwatCommandStatusWidget::MinHeight' has a wrong offset!");
static_assert(offsetof(USwatCommandStatusWidget, MaxHeight) == 0x0002C8, "Member 'USwatCommandStatusWidget::MaxHeight' has a wrong offset!");
static_assert(offsetof(USwatCommandStatusWidget, CurrentCommand_Box) == 0x0002D0, "Member 'USwatCommandStatusWidget::CurrentCommand_Box' has a wrong offset!");
static_assert(offsetof(USwatCommandStatusWidget, CommandStatus_Box) == 0x0002D8, "Member 'USwatCommandStatusWidget::CommandStatus_Box' has a wrong offset!");
static_assert(offsetof(USwatCommandStatusWidget, CurrentCommand_Text) == 0x0002E0, "Member 'USwatCommandStatusWidget::CurrentCommand_Text' has a wrong offset!");
static_assert(offsetof(USwatCommandStatusWidget, CurrentCommand_Pulse_Text) == 0x0002E8, "Member 'USwatCommandStatusWidget::CurrentCommand_Pulse_Text' has a wrong offset!");
static_assert(offsetof(USwatCommandStatusWidget, CurrentCommand_Status_Text) == 0x0002F0, "Member 'USwatCommandStatusWidget::CurrentCommand_Status_Text' has a wrong offset!");
static_assert(offsetof(USwatCommandStatusWidget, SizeBox) == 0x0002F8, "Member 'USwatCommandStatusWidget::SizeBox' has a wrong offset!");
static_assert(offsetof(USwatCommandStatusWidget, SwatInfo_Box) == 0x000300, "Member 'USwatCommandStatusWidget::SwatInfo_Box' has a wrong offset!");
static_assert(offsetof(USwatCommandStatusWidget, SwatStats_Box) == 0x000308, "Member 'USwatCommandStatusWidget::SwatStats_Box' has a wrong offset!");
static_assert(offsetof(USwatCommandStatusWidget, SwatName_Text) == 0x000310, "Member 'USwatCommandStatusWidget::SwatName_Text' has a wrong offset!");
static_assert(offsetof(USwatCommandStatusWidget, TeamIndicator_Box) == 0x000318, "Member 'USwatCommandStatusWidget::TeamIndicator_Box' has a wrong offset!");
static_assert(offsetof(USwatCommandStatusWidget, TeamIndicator_Image) == 0x000320, "Member 'USwatCommandStatusWidget::TeamIndicator_Image' has a wrong offset!");
static_assert(offsetof(USwatCommandStatusWidget, HealthStatus_SizeBox) == 0x000328, "Member 'USwatCommandStatusWidget::HealthStatus_SizeBox' has a wrong offset!");
static_assert(offsetof(USwatCommandStatusWidget, PlayerHealth_Text) == 0x000330, "Member 'USwatCommandStatusWidget::PlayerHealth_Text' has a wrong offset!");
static_assert(offsetof(USwatCommandStatusWidget, IssueCommand_Hotkey_RichText) == 0x000338, "Member 'USwatCommandStatusWidget::IssueCommand_Hotkey_RichText' has a wrong offset!");
static_assert(offsetof(USwatCommandStatusWidget, IssueCommand_Hotkey_Icon) == 0x000340, "Member 'USwatCommandStatusWidget::IssueCommand_Hotkey_Icon' has a wrong offset!");
static_assert(offsetof(USwatCommandStatusWidget, IssueCommand_Hotkey_Icon_Highlight) == 0x000348, "Member 'USwatCommandStatusWidget::IssueCommand_Hotkey_Icon_Highlight' has a wrong offset!");
static_assert(offsetof(USwatCommandStatusWidget, Anim_CommandCompleted) == 0x000350, "Member 'USwatCommandStatusWidget::Anim_CommandCompleted' has a wrong offset!");
static_assert(offsetof(USwatCommandStatusWidget, Anim_CommandIssued) == 0x000358, "Member 'USwatCommandStatusWidget::Anim_CommandIssued' has a wrong offset!");
static_assert(offsetof(USwatCommandStatusWidget, Anim_CommandCompletedWhileAnotherQueued) == 0x000360, "Member 'USwatCommandStatusWidget::Anim_CommandCompletedWhileAnotherQueued' has a wrong offset!");
static_assert(offsetof(USwatCommandStatusWidget, bIsProgress) == 0x000368, "Member 'USwatCommandStatusWidget::bIsProgress' has a wrong offset!");
static_assert(offsetof(USwatCommandStatusWidget, RedTeamColor) == 0x00036C, "Member 'USwatCommandStatusWidget::RedTeamColor' has a wrong offset!");
static_assert(offsetof(USwatCommandStatusWidget, BlueTeamColor) == 0x00037C, "Member 'USwatCommandStatusWidget::BlueTeamColor' has a wrong offset!");
static_assert(offsetof(USwatCommandStatusWidget, ElementTeamColor) == 0x00038C, "Member 'USwatCommandStatusWidget::ElementTeamColor' has a wrong offset!");
static_assert(offsetof(USwatCommandStatusWidget, NormalColor) == 0x00039C, "Member 'USwatCommandStatusWidget::NormalColor' has a wrong offset!");
static_assert(offsetof(USwatCommandStatusWidget, InjuredColor) == 0x0003AC, "Member 'USwatCommandStatusWidget::InjuredColor' has a wrong offset!");
static_assert(offsetof(USwatCommandStatusWidget, DeadColor) == 0x0003BC, "Member 'USwatCommandStatusWidget::DeadColor' has a wrong offset!");

// Class ReadyOrNot.SwatCommandWidget
// 0x0590 (0x0850 - 0x02C0)
class USwatCommandWidget : public UUserWidget
{
public:
	uint8                                         Pad_2C0[0x10];                                     // 0x02C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DirectoryStringOverride;                           // 0x02D0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 DirectoryString;                                   // 0x02E0(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 LastActorBeforeGoingIntoSubPage;                   // 0x02F0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F8[0x4];                                      // 0x02F8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LastSubCommandPageIndex;                           // 0x02FC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FSwatCommand>                   ParentCommands;                                    // 0x0300(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FSwatCommand>                   ActiveCommandPage;                                 // 0x0310(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FSwatCommand>                   PreviousActiveCommandPage;                         // 0x0320(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FKey>                           CommandCombo;                                      // 0x0330(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	ETeamType                                     ActiveTeamType;                                    // 0x0340(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETeamType                                     PreviousActiveTeamType;                            // 0x0341(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETeamType                                     OverrideActiveTeamType;                            // 0x0342(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bOverrideActiveTeamType : 1;                       // 0x0343(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	ETeamType                                     ExecutionTeamType;                                 // 0x0344(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESwatCommand                                  DefaultDoorOpenCommand;                            // 0x0345(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESwatCommand                                  DefaultDoorUnknownCommand;                         // 0x0346(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESwatCommand                                  DefaultCheckDoorCommand;                           // 0x0347(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESwatCommand                                  DefaultDoorLockedCommand;                          // 0x0348(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESwatCommand                                  DefaultDoorUnlockedCommand;                        // 0x0349(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34A[0xEE];                                     // 0x034A(0x00EE)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 LastContextActor;                                  // 0x0438(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FHitResult                             ContextualData;                                    // 0x0440(0x00E8)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_528[0xE8];                                     // 0x0528(0x00E8)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             LastExecutedCommandContextualData;                 // 0x0610(0x00E8)(IsPlainOldData, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UFMODEvent*                             OpenMenuEvent;                                     // 0x06F8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODEvent*                             OpenSubCommandMenuEvent;                           // 0x0700(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODEvent*                             ExecuteCommandEvent;                               // 0x0708(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ABaseGrenade>               Flashbang;                                         // 0x0710(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ABaseGrenade>               Stinger;                                           // 0x0718(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ABaseGrenade>               CSGas;                                             // 0x0720(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bHoldingQueueCommandKey : 1;                       // 0x0728(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_729[0x7];                                      // 0x0729(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USizeBox*                               SizeBox;                                           // 0x0730(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           VB_Commands;                                       // 0x0738(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           VB_Queue;                                          // 0x0740(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           VB_SwatCommand;                                    // 0x0748(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USwatCommandEntryWidget*                SwatCommandEntry_1;                                // 0x0750(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USwatCommandEntryWidget*                SwatCommandEntry_2;                                // 0x0758(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USwatCommandEntryWidget*                SwatCommandEntry_3;                                // 0x0760(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USwatCommandEntryWidget*                SwatCommandEntry_4;                                // 0x0768(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USwatCommandEntryWidget*                SwatCommandEntry_5;                                // 0x0770(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USwatCommandEntryWidget*                SwatCommandEntry_6;                                // 0x0778(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USwatCommandEntryWidget*                SwatCommandEntry_7;                                // 0x0780(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USwatCommandEntryWidget*                SwatCommandEntry_8;                                // 0x0788(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USwatCommandEntryWidget*                SwatCommandEntry_9;                                // 0x0790(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USwatCommandEntryWidget*                SwatCommandEntry_10;                               // 0x0798(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USwatCommandEntryWidget*                SwatCommandIssued;                                 // 0x07A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USwatCommandEntryWidget*                Back;                                              // 0x07A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextWidget*                            txt_QueueBinding;                                  // 0x07B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextWidget*                            txt_QueueStatus;                                   // 0x07B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextWidget*                            CommandDirectoryText;                              // 0x07C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 DivTop;                                            // 0x07C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 DivBottom;                                         // 0x07D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           RedTeamColor;                                      // 0x07D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           BlueTeamColor;                                     // 0x07E8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           GoldTeamColor;                                     // 0x07F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_808[0x48];                                     // 0x0808(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DoCommand(const struct FSwatCommand& Command, bool bFromQueue, ETeamType ActiveTeamOverride, const struct FHitResult& ContextualDataOverride, bool bOverrideContextualData);
	bool GetSubCommands(const struct FSwatCommand& Command, TArray<struct FSwatCommand>* OutSubCommands);
	void InitEntryWidget(class USwatCommandEntryWidget* Entry, const struct FSwatCommand& InSwatCommand, ETeamType Team, bool bLast);
	void OnClose();
	void OnCommandIssued(int32 Index_0, const struct FSwatCommand& Command, bool bFromDefault);
	void OnInputKey();
	void OnInputMethodChanged(const ECommonInputType InputMethod);
	void OnOpen();
	void OnPageViewUpdateBP();

	struct FKey ConvertIntToInputKey(int32 Int) const;
	ETeamType GetActiveTeam() const;
	struct FKey GetCommandInput(class FName InName) const;
	struct FKey GetInputBack() const;
	struct FKey GetInputEight() const;
	struct FKey GetInputFive() const;
	struct FKey GetInputFour() const;
	struct FKey GetInputNine() const;
	struct FKey GetInputOne() const;
	struct FKey GetInputSeven() const;
	struct FKey GetInputSix() const;
	struct FKey GetInputThree() const;
	struct FKey GetInputTwo() const;
	bool HasQueuedCommandForActiveTeam() const;
	bool HasQueuedCommandForTeam(ETeamType TeamType) const;
	class USwatCommandEntryWidget* IndexToEntryWidget(uint8 Index_0) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SwatCommandWidget">();
	}
	static class USwatCommandWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USwatCommandWidget>();
	}
};
static_assert(alignof(USwatCommandWidget) == 0x000008, "Wrong alignment on USwatCommandWidget");
static_assert(sizeof(USwatCommandWidget) == 0x000850, "Wrong size on USwatCommandWidget");
static_assert(offsetof(USwatCommandWidget, DirectoryStringOverride) == 0x0002D0, "Member 'USwatCommandWidget::DirectoryStringOverride' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, DirectoryString) == 0x0002E0, "Member 'USwatCommandWidget::DirectoryString' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, LastActorBeforeGoingIntoSubPage) == 0x0002F0, "Member 'USwatCommandWidget::LastActorBeforeGoingIntoSubPage' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, LastSubCommandPageIndex) == 0x0002FC, "Member 'USwatCommandWidget::LastSubCommandPageIndex' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, ParentCommands) == 0x000300, "Member 'USwatCommandWidget::ParentCommands' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, ActiveCommandPage) == 0x000310, "Member 'USwatCommandWidget::ActiveCommandPage' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, PreviousActiveCommandPage) == 0x000320, "Member 'USwatCommandWidget::PreviousActiveCommandPage' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, CommandCombo) == 0x000330, "Member 'USwatCommandWidget::CommandCombo' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, ActiveTeamType) == 0x000340, "Member 'USwatCommandWidget::ActiveTeamType' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, PreviousActiveTeamType) == 0x000341, "Member 'USwatCommandWidget::PreviousActiveTeamType' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, OverrideActiveTeamType) == 0x000342, "Member 'USwatCommandWidget::OverrideActiveTeamType' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, ExecutionTeamType) == 0x000344, "Member 'USwatCommandWidget::ExecutionTeamType' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, DefaultDoorOpenCommand) == 0x000345, "Member 'USwatCommandWidget::DefaultDoorOpenCommand' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, DefaultDoorUnknownCommand) == 0x000346, "Member 'USwatCommandWidget::DefaultDoorUnknownCommand' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, DefaultCheckDoorCommand) == 0x000347, "Member 'USwatCommandWidget::DefaultCheckDoorCommand' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, DefaultDoorLockedCommand) == 0x000348, "Member 'USwatCommandWidget::DefaultDoorLockedCommand' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, DefaultDoorUnlockedCommand) == 0x000349, "Member 'USwatCommandWidget::DefaultDoorUnlockedCommand' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, LastContextActor) == 0x000438, "Member 'USwatCommandWidget::LastContextActor' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, ContextualData) == 0x000440, "Member 'USwatCommandWidget::ContextualData' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, LastExecutedCommandContextualData) == 0x000610, "Member 'USwatCommandWidget::LastExecutedCommandContextualData' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, OpenMenuEvent) == 0x0006F8, "Member 'USwatCommandWidget::OpenMenuEvent' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, OpenSubCommandMenuEvent) == 0x000700, "Member 'USwatCommandWidget::OpenSubCommandMenuEvent' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, ExecuteCommandEvent) == 0x000708, "Member 'USwatCommandWidget::ExecuteCommandEvent' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, Flashbang) == 0x000710, "Member 'USwatCommandWidget::Flashbang' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, Stinger) == 0x000718, "Member 'USwatCommandWidget::Stinger' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, CSGas) == 0x000720, "Member 'USwatCommandWidget::CSGas' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, SizeBox) == 0x000730, "Member 'USwatCommandWidget::SizeBox' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, VB_Commands) == 0x000738, "Member 'USwatCommandWidget::VB_Commands' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, VB_Queue) == 0x000740, "Member 'USwatCommandWidget::VB_Queue' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, VB_SwatCommand) == 0x000748, "Member 'USwatCommandWidget::VB_SwatCommand' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, SwatCommandEntry_1) == 0x000750, "Member 'USwatCommandWidget::SwatCommandEntry_1' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, SwatCommandEntry_2) == 0x000758, "Member 'USwatCommandWidget::SwatCommandEntry_2' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, SwatCommandEntry_3) == 0x000760, "Member 'USwatCommandWidget::SwatCommandEntry_3' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, SwatCommandEntry_4) == 0x000768, "Member 'USwatCommandWidget::SwatCommandEntry_4' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, SwatCommandEntry_5) == 0x000770, "Member 'USwatCommandWidget::SwatCommandEntry_5' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, SwatCommandEntry_6) == 0x000778, "Member 'USwatCommandWidget::SwatCommandEntry_6' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, SwatCommandEntry_7) == 0x000780, "Member 'USwatCommandWidget::SwatCommandEntry_7' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, SwatCommandEntry_8) == 0x000788, "Member 'USwatCommandWidget::SwatCommandEntry_8' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, SwatCommandEntry_9) == 0x000790, "Member 'USwatCommandWidget::SwatCommandEntry_9' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, SwatCommandEntry_10) == 0x000798, "Member 'USwatCommandWidget::SwatCommandEntry_10' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, SwatCommandIssued) == 0x0007A0, "Member 'USwatCommandWidget::SwatCommandIssued' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, Back) == 0x0007A8, "Member 'USwatCommandWidget::Back' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, txt_QueueBinding) == 0x0007B0, "Member 'USwatCommandWidget::txt_QueueBinding' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, txt_QueueStatus) == 0x0007B8, "Member 'USwatCommandWidget::txt_QueueStatus' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, CommandDirectoryText) == 0x0007C0, "Member 'USwatCommandWidget::CommandDirectoryText' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, DivTop) == 0x0007C8, "Member 'USwatCommandWidget::DivTop' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, DivBottom) == 0x0007D0, "Member 'USwatCommandWidget::DivBottom' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, RedTeamColor) == 0x0007D8, "Member 'USwatCommandWidget::RedTeamColor' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, BlueTeamColor) == 0x0007E8, "Member 'USwatCommandWidget::BlueTeamColor' has a wrong offset!");
static_assert(offsetof(USwatCommandWidget, GoldTeamColor) == 0x0007F8, "Member 'USwatCommandWidget::GoldTeamColor' has a wrong offset!");

// Class ReadyOrNot.SWATController
// 0x00E0 (0x0B28 - 0x0A48)
class ASWATController : public ACyberneticController
{
public:
	class UTeamFallinActivity*                    FallinActivity;                                    // 0x0A48(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UArrestTargetActivity*                  ArrestTargetActivity;                              // 0x0A50(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTeamStackUpActivity*                   StackUpActivity;                                   // 0x0A58(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTeamBreachAndClearActivity*            BreachAndClearActivity;                            // 0x0A60(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDeployChemlightActivity*               DeployChemlightActivity;                           // 0x0A68(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHoldActivity*                          HoldActivity;                                      // 0x0A70(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UReportTargetActivity*                  ReportTargetActivity;                              // 0x0A78(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCollectEvidenceActivity*               CollectEvidenceActivity;                           // 0x0A80(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDisarmStandaloneTrapActivity*          DisarmStandaloneTrapActivity;                      // 0x0A88(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDeployGrenadeAtLocationActivity*       DeployGrenadeAtLocationActivity;                   // 0x0A90(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UKickDoorActivity*                      KickDoorActivity;                                  // 0x0A98(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UC2DoorActivity*                        C2DoorActivity;                                    // 0x0AA0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URamDoorActivity*                       RamDoorActivity;                                   // 0x0AA8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UShotgunDoorActivity*                   ShotgunDoorActivity;                               // 0x0AB0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UThrowGrenadeThroughDoorActivity*       ThrowGrenadeThroughDoorActivity;                   // 0x0AB8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULaunchGrenadeThroughDoorActivity*      LaunchGrenadeThroughDoorActivity;                  // 0x0AC0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USearchAndSecureActivity*               SearchAndSecureActivity;                           // 0x0AC8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMirrorUnderDoorActivity*               MirrorUnderDoorActivity;                           // 0x0AD0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDisarmDoorTrapActivity*                DisarmDoorTrapActivity;                            // 0x0AD8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDeployWedgeActivity*                   DeployWedgeActivity;                               // 0x0AE0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULockPickDoorActivity*                  LockPickDoorActivity;                              // 0x0AE8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UToggleDoorActivity*                    ToggleDoorActivity;                                // 0x0AF0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScanDoorActivity*                      ScanDoorActivity;                                  // 0x0AF8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTeamCoverAreaActivity*                 CoverAreaActivity;                                 // 0x0B00(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USearchLandmarkActivity*                SearchLandmarkActivity;                            // 0x0B08(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPickUpCharacterActivity*               PickUpCharacterActivity;                           // 0x0B10(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTrailerSearchAndSecureActivity*        TrailerSearchAndSecureActivity;                    // 0x0B18(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UEngageTargetLessLethalActivity*        EngageLessLethalActivity;                          // 0x0B20(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class UArrestTargetActivity* GetArrestTargetActivity() const;
	class UTeamBreachAndClearActivity* GetBreachAndClearActivity() const;
	class UC2DoorActivity* GetC2DoorActivity() const;
	class UCollectEvidenceActivity* GetCollectEvidenceActivity() const;
	class UTeamCoverAreaActivity* GetCoverAreaActivity() const;
	class UDeployChemlightActivity* GetDeployChemlightActivity() const;
	class UDeployGrenadeAtLocationActivity* GetDeployGrenadeAtLocationActivity() const;
	class UDeployWedgeActivity* GetDeployWedgeActivity() const;
	class UDisarmDoorTrapActivity* GetDisarmDoorTrapActivity() const;
	class UDisarmStandaloneTrapActivity* GetDisarmStandaloneTrapActivity() const;
	class UEngageTargetLessLethalActivity* GetEngageLessLethalActivity() const;
	class UTeamFallinActivity* GetFallinActivity() const;
	class UHoldActivity* GetHoldActivity() const;
	class UKickDoorActivity* GetKickDoorActivity() const;
	class ULaunchGrenadeThroughDoorActivity* GetLaunchGrenadeThroughDoorActivity() const;
	class ULockPickDoorActivity* GetLockPickDoorDoorActivity() const;
	class UMirrorUnderDoorActivity* GetMirrorUnderDoorActivity() const;
	class UPickUpCharacterActivity* GetPickUpCharacterActivity() const;
	class URamDoorActivity* GetRamDoorActivity() const;
	class UReportTargetActivity* GetReportTargetActivity() const;
	class UScanDoorActivity* GetScanDoorActivity() const;
	class USearchAndSecureActivity* GetSearchAndSecureActivity() const;
	class USearchLandmarkActivity* GetSearchLandmarkActivity() const;
	class UShotgunDoorActivity* GetShotgunDoorActivity() const;
	class UTeamStackUpActivity* GetStackUpActivity() const;
	class UThrowGrenadeThroughDoorActivity* GetThrowGrenadeThroughDoorActivity() const;
	class UToggleDoorActivity* GetToggleDoorActivity() const;
	class UTrailerSearchAndSecureActivity* GetTrailerSearchAndSecureActivity() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SWATController">();
	}
	static class ASWATController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASWATController>();
	}
};
static_assert(alignof(ASWATController) == 0x000008, "Wrong alignment on ASWATController");
static_assert(sizeof(ASWATController) == 0x000B28, "Wrong size on ASWATController");
static_assert(offsetof(ASWATController, FallinActivity) == 0x000A48, "Member 'ASWATController::FallinActivity' has a wrong offset!");
static_assert(offsetof(ASWATController, ArrestTargetActivity) == 0x000A50, "Member 'ASWATController::ArrestTargetActivity' has a wrong offset!");
static_assert(offsetof(ASWATController, StackUpActivity) == 0x000A58, "Member 'ASWATController::StackUpActivity' has a wrong offset!");
static_assert(offsetof(ASWATController, BreachAndClearActivity) == 0x000A60, "Member 'ASWATController::BreachAndClearActivity' has a wrong offset!");
static_assert(offsetof(ASWATController, DeployChemlightActivity) == 0x000A68, "Member 'ASWATController::DeployChemlightActivity' has a wrong offset!");
static_assert(offsetof(ASWATController, HoldActivity) == 0x000A70, "Member 'ASWATController::HoldActivity' has a wrong offset!");
static_assert(offsetof(ASWATController, ReportTargetActivity) == 0x000A78, "Member 'ASWATController::ReportTargetActivity' has a wrong offset!");
static_assert(offsetof(ASWATController, CollectEvidenceActivity) == 0x000A80, "Member 'ASWATController::CollectEvidenceActivity' has a wrong offset!");
static_assert(offsetof(ASWATController, DisarmStandaloneTrapActivity) == 0x000A88, "Member 'ASWATController::DisarmStandaloneTrapActivity' has a wrong offset!");
static_assert(offsetof(ASWATController, DeployGrenadeAtLocationActivity) == 0x000A90, "Member 'ASWATController::DeployGrenadeAtLocationActivity' has a wrong offset!");
static_assert(offsetof(ASWATController, KickDoorActivity) == 0x000A98, "Member 'ASWATController::KickDoorActivity' has a wrong offset!");
static_assert(offsetof(ASWATController, C2DoorActivity) == 0x000AA0, "Member 'ASWATController::C2DoorActivity' has a wrong offset!");
static_assert(offsetof(ASWATController, RamDoorActivity) == 0x000AA8, "Member 'ASWATController::RamDoorActivity' has a wrong offset!");
static_assert(offsetof(ASWATController, ShotgunDoorActivity) == 0x000AB0, "Member 'ASWATController::ShotgunDoorActivity' has a wrong offset!");
static_assert(offsetof(ASWATController, ThrowGrenadeThroughDoorActivity) == 0x000AB8, "Member 'ASWATController::ThrowGrenadeThroughDoorActivity' has a wrong offset!");
static_assert(offsetof(ASWATController, LaunchGrenadeThroughDoorActivity) == 0x000AC0, "Member 'ASWATController::LaunchGrenadeThroughDoorActivity' has a wrong offset!");
static_assert(offsetof(ASWATController, SearchAndSecureActivity) == 0x000AC8, "Member 'ASWATController::SearchAndSecureActivity' has a wrong offset!");
static_assert(offsetof(ASWATController, MirrorUnderDoorActivity) == 0x000AD0, "Member 'ASWATController::MirrorUnderDoorActivity' has a wrong offset!");
static_assert(offsetof(ASWATController, DisarmDoorTrapActivity) == 0x000AD8, "Member 'ASWATController::DisarmDoorTrapActivity' has a wrong offset!");
static_assert(offsetof(ASWATController, DeployWedgeActivity) == 0x000AE0, "Member 'ASWATController::DeployWedgeActivity' has a wrong offset!");
static_assert(offsetof(ASWATController, LockPickDoorActivity) == 0x000AE8, "Member 'ASWATController::LockPickDoorActivity' has a wrong offset!");
static_assert(offsetof(ASWATController, ToggleDoorActivity) == 0x000AF0, "Member 'ASWATController::ToggleDoorActivity' has a wrong offset!");
static_assert(offsetof(ASWATController, ScanDoorActivity) == 0x000AF8, "Member 'ASWATController::ScanDoorActivity' has a wrong offset!");
static_assert(offsetof(ASWATController, CoverAreaActivity) == 0x000B00, "Member 'ASWATController::CoverAreaActivity' has a wrong offset!");
static_assert(offsetof(ASWATController, SearchLandmarkActivity) == 0x000B08, "Member 'ASWATController::SearchLandmarkActivity' has a wrong offset!");
static_assert(offsetof(ASWATController, PickUpCharacterActivity) == 0x000B10, "Member 'ASWATController::PickUpCharacterActivity' has a wrong offset!");
static_assert(offsetof(ASWATController, TrailerSearchAndSecureActivity) == 0x000B18, "Member 'ASWATController::TrailerSearchAndSecureActivity' has a wrong offset!");
static_assert(offsetof(ASWATController, EngageLessLethalActivity) == 0x000B20, "Member 'ASWATController::EngageLessLethalActivity' has a wrong offset!");

// Class ReadyOrNot.SwatTeamStatusWidget
// 0x0080 (0x0340 - 0x02C0)
class USwatTeamStatusWidget : public UUserWidget
{
public:
	class UVerticalBox*                           SWAT_Status_Container;                             // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USwatCommandStatusWidget*               SWAT_Alpha_Status;                                 // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USwatCommandStatusWidget*               SWAT_Beta_Status;                                  // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USwatCommandStatusWidget*               SWAT_Charlie_Status;                               // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USwatCommandStatusWidget*               SWAT_Delta_Status;                                 // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USwatCommandStatusWidget*               SWAT_Lead_Status;                                  // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<ESquadPosition, class ASWATCharacter*>   InitialSquadMap;                                   // 0x02F0(0x0050)(Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	void OnDefaultCommandIssued(class APlayerCharacter* Issuer, ESwatCommand CommandIssued);
	void UpdateStatus();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SwatTeamStatusWidget">();
	}
	static class USwatTeamStatusWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USwatTeamStatusWidget>();
	}
};
static_assert(alignof(USwatTeamStatusWidget) == 0x000008, "Wrong alignment on USwatTeamStatusWidget");
static_assert(sizeof(USwatTeamStatusWidget) == 0x000340, "Wrong size on USwatTeamStatusWidget");
static_assert(offsetof(USwatTeamStatusWidget, SWAT_Status_Container) == 0x0002C0, "Member 'USwatTeamStatusWidget::SWAT_Status_Container' has a wrong offset!");
static_assert(offsetof(USwatTeamStatusWidget, SWAT_Alpha_Status) == 0x0002C8, "Member 'USwatTeamStatusWidget::SWAT_Alpha_Status' has a wrong offset!");
static_assert(offsetof(USwatTeamStatusWidget, SWAT_Beta_Status) == 0x0002D0, "Member 'USwatTeamStatusWidget::SWAT_Beta_Status' has a wrong offset!");
static_assert(offsetof(USwatTeamStatusWidget, SWAT_Charlie_Status) == 0x0002D8, "Member 'USwatTeamStatusWidget::SWAT_Charlie_Status' has a wrong offset!");
static_assert(offsetof(USwatTeamStatusWidget, SWAT_Delta_Status) == 0x0002E0, "Member 'USwatTeamStatusWidget::SWAT_Delta_Status' has a wrong offset!");
static_assert(offsetof(USwatTeamStatusWidget, SWAT_Lead_Status) == 0x0002E8, "Member 'USwatTeamStatusWidget::SWAT_Lead_Status' has a wrong offset!");
static_assert(offsetof(USwatTeamStatusWidget, InitialSquadMap) == 0x0002F0, "Member 'USwatTeamStatusWidget::InitialSquadMap' has a wrong offset!");

// Class ReadyOrNot.Tablet
// 0x0070 (0x0C20 - 0x0BB0)
class ATablet : public ABaseItem
{
public:
	uint8                                         Pad_BB0[0x10];                                     // 0x0BB0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetComponent*                       WidgetComponent;                                   // 0x0BC0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTabletAwake;                                    // 0x0BC8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC9[0x7];                                      // 0x0BC9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               FocusedCameraRotation;                             // 0x0BD0(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               FocusedItemRotation;                               // 0x0BE8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         FocusedMinimumHorizontalFov;                       // 0x0C00(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FocusedTargetVerticalFov;                          // 0x0C04(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TabletFocusInterpSpeed;                            // 0x0C08(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C0C[0x14];                                     // 0x0C0C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HolsterScreen();
	void OnMissionSelected();
	void PlayNotificationEvent();
	void PlaySoundEvent(class UFMODEvent* Event);
	void PlayVibrationEvent();
	void SleepScreen();
	void WakeScreen();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Tablet">();
	}
	static class ATablet* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATablet>();
	}
};
static_assert(alignof(ATablet) == 0x000010, "Wrong alignment on ATablet");
static_assert(sizeof(ATablet) == 0x000C20, "Wrong size on ATablet");
static_assert(offsetof(ATablet, WidgetComponent) == 0x000BC0, "Member 'ATablet::WidgetComponent' has a wrong offset!");
static_assert(offsetof(ATablet, bIsTabletAwake) == 0x000BC8, "Member 'ATablet::bIsTabletAwake' has a wrong offset!");
static_assert(offsetof(ATablet, FocusedCameraRotation) == 0x000BD0, "Member 'ATablet::FocusedCameraRotation' has a wrong offset!");
static_assert(offsetof(ATablet, FocusedItemRotation) == 0x000BE8, "Member 'ATablet::FocusedItemRotation' has a wrong offset!");
static_assert(offsetof(ATablet, FocusedMinimumHorizontalFov) == 0x000C00, "Member 'ATablet::FocusedMinimumHorizontalFov' has a wrong offset!");
static_assert(offsetof(ATablet, FocusedTargetVerticalFov) == 0x000C04, "Member 'ATablet::FocusedTargetVerticalFov' has a wrong offset!");
static_assert(offsetof(ATablet, TabletFocusInterpSpeed) == 0x000C08, "Member 'ATablet::TabletFocusInterpSpeed' has a wrong offset!");

// Class ReadyOrNot.TabletDisplay
// 0x0008 (0x02C8 - 0x02C0)
class UTabletDisplay final : public UUserWidget
{
public:
	class ATablet*                                OwningTablet;                                      // 0x02C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TabletDisplay">();
	}
	static class UTabletDisplay* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTabletDisplay>();
	}
};
static_assert(alignof(UTabletDisplay) == 0x000008, "Wrong alignment on UTabletDisplay");
static_assert(sizeof(UTabletDisplay) == 0x0002C8, "Wrong size on UTabletDisplay");
static_assert(offsetof(UTabletDisplay, OwningTablet) == 0x0002C0, "Member 'UTabletDisplay::OwningTablet' has a wrong offset!");

// Class ReadyOrNot.TableTennisMachine
// 0x00C0 (0x0358 - 0x0298)
class ATableTennisMachine final : public AActor
{
public:
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GameRenderDistance;                                // 0x02A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxScore;                                          // 0x02A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTableTennisGame                       Game;                                              // 0x02A8(0x0048)(Net, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class ATableTennisPlayer*                     LeftPlayer;                                        // 0x02F0(0x0008)(Net, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ATableTennisPlayer*                     RightPlayer;                                       // 0x02F8(0x0008)(Net, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextureRenderTarget2D*                 GameRenderTarget;                                  // 0x0300(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bHasInsertedCoin : 1;                              // 0x0308(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_309[0x7];                                      // 0x0309(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractableComponent*                 LeftPlayerInteractable;                            // 0x0310(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractableComponent*                 RightPlayerInteractable;                           // 0x0318(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractableComponent*                 InsertCoinInteractable;                            // 0x0320(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             NumberTexture;                                     // 0x0328(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             BackgroundTexture;                                 // 0x0330(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             StartTexture;                                      // 0x0338(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             ReadyTexture;                                      // 0x0340(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             InsertCoinTexture;                                 // 0x0348(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             GameOverTexture;                                   // 0x0350(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnCoinInserted();
	void OnLeftPaddleHit();
	void OnRightPaddleHit();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TableTennisMachine">();
	}
	static class ATableTennisMachine* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATableTennisMachine>();
	}
};
static_assert(alignof(ATableTennisMachine) == 0x000008, "Wrong alignment on ATableTennisMachine");
static_assert(sizeof(ATableTennisMachine) == 0x000358, "Wrong size on ATableTennisMachine");
static_assert(offsetof(ATableTennisMachine, GameRenderDistance) == 0x0002A0, "Member 'ATableTennisMachine::GameRenderDistance' has a wrong offset!");
static_assert(offsetof(ATableTennisMachine, MaxScore) == 0x0002A4, "Member 'ATableTennisMachine::MaxScore' has a wrong offset!");
static_assert(offsetof(ATableTennisMachine, Game) == 0x0002A8, "Member 'ATableTennisMachine::Game' has a wrong offset!");
static_assert(offsetof(ATableTennisMachine, LeftPlayer) == 0x0002F0, "Member 'ATableTennisMachine::LeftPlayer' has a wrong offset!");
static_assert(offsetof(ATableTennisMachine, RightPlayer) == 0x0002F8, "Member 'ATableTennisMachine::RightPlayer' has a wrong offset!");
static_assert(offsetof(ATableTennisMachine, GameRenderTarget) == 0x000300, "Member 'ATableTennisMachine::GameRenderTarget' has a wrong offset!");
static_assert(offsetof(ATableTennisMachine, LeftPlayerInteractable) == 0x000310, "Member 'ATableTennisMachine::LeftPlayerInteractable' has a wrong offset!");
static_assert(offsetof(ATableTennisMachine, RightPlayerInteractable) == 0x000318, "Member 'ATableTennisMachine::RightPlayerInteractable' has a wrong offset!");
static_assert(offsetof(ATableTennisMachine, InsertCoinInteractable) == 0x000320, "Member 'ATableTennisMachine::InsertCoinInteractable' has a wrong offset!");
static_assert(offsetof(ATableTennisMachine, NumberTexture) == 0x000328, "Member 'ATableTennisMachine::NumberTexture' has a wrong offset!");
static_assert(offsetof(ATableTennisMachine, BackgroundTexture) == 0x000330, "Member 'ATableTennisMachine::BackgroundTexture' has a wrong offset!");
static_assert(offsetof(ATableTennisMachine, StartTexture) == 0x000338, "Member 'ATableTennisMachine::StartTexture' has a wrong offset!");
static_assert(offsetof(ATableTennisMachine, ReadyTexture) == 0x000340, "Member 'ATableTennisMachine::ReadyTexture' has a wrong offset!");
static_assert(offsetof(ATableTennisMachine, InsertCoinTexture) == 0x000348, "Member 'ATableTennisMachine::InsertCoinTexture' has a wrong offset!");
static_assert(offsetof(ATableTennisMachine, GameOverTexture) == 0x000350, "Member 'ATableTennisMachine::GameOverTexture' has a wrong offset!");

// Class ReadyOrNot.TabletWidget
// 0x0028 (0x0508 - 0x04E0)
class UTabletWidget : public UMissionPlanWidget
{
public:
	class UTeamViewWidget*                        TeamView;                                          // 0x04E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetSwitcher*                        ScreenSwitcher;                                    // 0x04E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCommonUserWidget*                      OverlayWidget;                                     // 0x04F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4F8[0x10];                                     // 0x04F8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetActiveButton(int32 CurrentIndex, int32 navigationDirection, const TArray<bool>& buttonVisibilities);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TabletWidget">();
	}
	static class UTabletWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTabletWidget>();
	}
};
static_assert(alignof(UTabletWidget) == 0x000008, "Wrong alignment on UTabletWidget");
static_assert(sizeof(UTabletWidget) == 0x000508, "Wrong size on UTabletWidget");
static_assert(offsetof(UTabletWidget, TeamView) == 0x0004E0, "Member 'UTabletWidget::TeamView' has a wrong offset!");
static_assert(offsetof(UTabletWidget, ScreenSwitcher) == 0x0004E8, "Member 'UTabletWidget::ScreenSwitcher' has a wrong offset!");
static_assert(offsetof(UTabletWidget, OverlayWidget) == 0x0004F0, "Member 'UTabletWidget::OverlayWidget' has a wrong offset!");

// Class ReadyOrNot.TacticalSlot_V2
// 0x0000 (0x02E8 - 0x02E8)
class UTacticalSlot_V2 final : public UCommonUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TacticalSlot_V2">();
	}
	static class UTacticalSlot_V2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTacticalSlot_V2>();
	}
};
static_assert(alignof(UTacticalSlot_V2) == 0x000008, "Wrong alignment on UTacticalSlot_V2");
static_assert(sizeof(UTacticalSlot_V2) == 0x0002E8, "Wrong size on UTacticalSlot_V2");

// Class ReadyOrNot.TakeCoverActivity
// 0x02A0 (0x0490 - 0x01F0)
class UTakeCoverActivity final : public UBaseActivity
{
public:
	uint8                                         Pad_1F0[0x10];                                     // 0x01F0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxCoverFireCount;                                 // 0x0200(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CoverFireTimeCooldown;                             // 0x0204(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CoverFireCooldown;                                 // 0x0208(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20C[0x4];                                      // 0x020C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCoverInstigatorStimulus               InstigatorStimulus;                                // 0x0210(0x0080)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_290[0x110];                                    // 0x0290(0x0110)(Fixing Size After Last Property [ Dumper-7 ])
	class ADoor*                                  Door;                                              // 0x03A0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           LastExitMontagePlayed;                             // 0x03A8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           EntryMontage;                                      // 0x03B0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B8[0xD8];                                     // 0x03B8(0x00D8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnterCompleteAbruptState();
	void EnterCompleteState();
	void EnterCoverFireState();
	void EnterCoverState();
	void EnterMoveToCoverState();
	void ExitCoverFireState();
	void ExitCoverState();
	void OnEnemyWeaponFire(class AReadyOrNotCharacter* Character, class ABaseMagazineWeapon* Weapon, const struct FVector& fireDirection);
	void OnStunned(class AReadyOrNotCharacter* StunnedCharacter, float Duration, EStunType StunType, class AActor* DamageCauser);
	void OnTakeDamage(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* DamagedCharacter, class AActor* DamageCauser, float Damage, float HealthRemaining);
	void TickCoverFireState(float DeltaTime, float Uptime);
	void TickCoverState(float DeltaTime, float Uptime);
	void TickMoveToCoverState(float DeltaTime, float Uptime);

	bool CanAbruptCompleteCover() const;
	bool CanCompleteCover() const;
	bool CanCover() const;
	bool CanFireFromCover() const;
	bool CanStopCoverFire() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TakeCoverActivity">();
	}
	static class UTakeCoverActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTakeCoverActivity>();
	}
};
static_assert(alignof(UTakeCoverActivity) == 0x000010, "Wrong alignment on UTakeCoverActivity");
static_assert(sizeof(UTakeCoverActivity) == 0x000490, "Wrong size on UTakeCoverActivity");
static_assert(offsetof(UTakeCoverActivity, MaxCoverFireCount) == 0x000200, "Member 'UTakeCoverActivity::MaxCoverFireCount' has a wrong offset!");
static_assert(offsetof(UTakeCoverActivity, CoverFireTimeCooldown) == 0x000204, "Member 'UTakeCoverActivity::CoverFireTimeCooldown' has a wrong offset!");
static_assert(offsetof(UTakeCoverActivity, CoverFireCooldown) == 0x000208, "Member 'UTakeCoverActivity::CoverFireCooldown' has a wrong offset!");
static_assert(offsetof(UTakeCoverActivity, InstigatorStimulus) == 0x000210, "Member 'UTakeCoverActivity::InstigatorStimulus' has a wrong offset!");
static_assert(offsetof(UTakeCoverActivity, Door) == 0x0003A0, "Member 'UTakeCoverActivity::Door' has a wrong offset!");
static_assert(offsetof(UTakeCoverActivity, LastExitMontagePlayed) == 0x0003A8, "Member 'UTakeCoverActivity::LastExitMontagePlayed' has a wrong offset!");
static_assert(offsetof(UTakeCoverActivity, EntryMontage) == 0x0003B0, "Member 'UTakeCoverActivity::EntryMontage' has a wrong offset!");

// Class ReadyOrNot.TakeCoverAtLandmarkActivity
// 0x0068 (0x0258 - 0x01F0)
class UTakeCoverAtLandmarkActivity final : public UBaseActivity
{
public:
	class ACoverLandmark*                         CoverLandmark;                                     // 0x01F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACoverLandmarkProxy*                    ChosenEntryProxy;                                  // 0x01F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACoverLandmarkProxy*                    ChosenExitProxy;                                   // 0x0200(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SearchRadius;                                      // 0x0208(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20C[0x1C];                                     // 0x020C(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           EntryAnim;                                         // 0x0228(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           ExitAnim;                                          // 0x0230(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           LoopEntryAnim;                                     // 0x0238(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           LoopExitAnim;                                      // 0x0240(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AStaticMeshActor*>               IgnoredMeshActors;                                 // 0x0248(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	void Enter_AbruptExit_State();
	void Enter_EnterLandmark_State();
	void Enter_ExitLandmark_State();
	void Enter_Wait_State();
	void EnterMoveToLandmarkState();
	void OnEnemyWeaponFire(class AReadyOrNotCharacter* Character, class ABaseMagazineWeapon* Weapon, const struct FVector& fireDirection);
	void OnHeardYell(class AReadyOrNotCharacter* Shouter, bool bLOS);
	void OnStunned(class AReadyOrNotCharacter* StunnedCharacter, float Duration, EStunType StunType, class AActor* DamageCauser);
	void OnTakeDamage(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* DamagedCharacter, class AActor* DamageCauser, float Damage, float HealthRemaining);
	void Tick_AbruptExit_State(float DeltaTime, float Uptime);
	void Tick_EnterLandmark_State(float DeltaTime, float Uptime);
	void Tick_ExitLandmark_State(float DeltaTime, float Uptime);
	void Tick_Wait_State(float DeltaTime, float Uptime);
	void TickMoveToLandmarkState(float DeltaTime, float Uptime);

	bool CanAbruptlyExit() const;
	bool CanEnterLandmark() const;
	bool CanExitLandmark() const;
	bool ShouldWait() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TakeCoverAtLandmarkActivity">();
	}
	static class UTakeCoverAtLandmarkActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTakeCoverAtLandmarkActivity>();
	}
};
static_assert(alignof(UTakeCoverAtLandmarkActivity) == 0x000008, "Wrong alignment on UTakeCoverAtLandmarkActivity");
static_assert(sizeof(UTakeCoverAtLandmarkActivity) == 0x000258, "Wrong size on UTakeCoverAtLandmarkActivity");
static_assert(offsetof(UTakeCoverAtLandmarkActivity, CoverLandmark) == 0x0001F0, "Member 'UTakeCoverAtLandmarkActivity::CoverLandmark' has a wrong offset!");
static_assert(offsetof(UTakeCoverAtLandmarkActivity, ChosenEntryProxy) == 0x0001F8, "Member 'UTakeCoverAtLandmarkActivity::ChosenEntryProxy' has a wrong offset!");
static_assert(offsetof(UTakeCoverAtLandmarkActivity, ChosenExitProxy) == 0x000200, "Member 'UTakeCoverAtLandmarkActivity::ChosenExitProxy' has a wrong offset!");
static_assert(offsetof(UTakeCoverAtLandmarkActivity, SearchRadius) == 0x000208, "Member 'UTakeCoverAtLandmarkActivity::SearchRadius' has a wrong offset!");
static_assert(offsetof(UTakeCoverAtLandmarkActivity, EntryAnim) == 0x000228, "Member 'UTakeCoverAtLandmarkActivity::EntryAnim' has a wrong offset!");
static_assert(offsetof(UTakeCoverAtLandmarkActivity, ExitAnim) == 0x000230, "Member 'UTakeCoverAtLandmarkActivity::ExitAnim' has a wrong offset!");
static_assert(offsetof(UTakeCoverAtLandmarkActivity, LoopEntryAnim) == 0x000238, "Member 'UTakeCoverAtLandmarkActivity::LoopEntryAnim' has a wrong offset!");
static_assert(offsetof(UTakeCoverAtLandmarkActivity, LoopExitAnim) == 0x000240, "Member 'UTakeCoverAtLandmarkActivity::LoopExitAnim' has a wrong offset!");
static_assert(offsetof(UTakeCoverAtLandmarkActivity, IgnoredMeshActors) == 0x000248, "Member 'UTakeCoverAtLandmarkActivity::IgnoredMeshActors' has a wrong offset!");

// Class ReadyOrNot.TakeHostageActivity
// 0x0120 (0x0310 - 0x01F0)
class UTakeHostageActivity final : public UBaseActivity
{
public:
	class ACyberneticCharacter*                   Hostage;                                           // 0x01F0(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeToSurrenderHostage;                            // 0x01F8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FC[0xC];                                      // 0x01FC(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AReadyOrNotCharacter*>           SWATCharacters;                                    // 0x0208(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TMap<uint32, class AReadyOrNotCharacter*>     ActivePathQueryIdToSWATMap;                        // 0x0218(0x0050)(Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class AReadyOrNotCharacter*                   ClosestSwat;                                       // 0x0268(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_270[0x8];                                      // 0x0270(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AReadyOrNotCharacter*                   LastEnemySensed;                                   // 0x0278(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FName, class UInteractionsData*>   HostageInteractions;                               // 0x0280(0x0050)(Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D0[0x40];                                     // 0x02D0(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndTakingState();
	void EnterBeginHostageTakeState();
	void EnterEndHostageTakeState();
	void EnterMoveToState();
	void EnterTakingState();
	void EnterTurnState();
	void GetNearestSWAT();
	void OnHeardYell(class AReadyOrNotCharacter* Shouter, bool bLOS);
	void OnHostageKilled(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter);
	void OnHostageTakeEndComplete_Driver(class AActor* Actor);
	void OnHostageTakeEndComplete_Slave(class AActor* Actor);
	void OnHostageTakeKillComplete_Driver(class AActor* Actor);
	void OnHostageTakeKillComplete_Slave(class AActor* Actor);
	void OnHostageTakeStartComplete_Driver(class AActor* Actor);
	void OnHostageTakeStartComplete_Slave(class AActor* Actor);
	void OnHostageTakeTurnComplete_Driver(class AActor* Actor);
	void OnHostageTakeTurnComplete_Slave(class AActor* Actor);
	void OnSpottedCharacter(class ACyberneticCharacter* Spotter, class AReadyOrNotCharacter* SpottedCharacter);
	void OnStunned(class AReadyOrNotCharacter* StunnedCharacter, float Duration, EStunType StunType, class AActor* DamageCauser);
	void OnTakeDamage(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* DamagedCharacter, class AActor* DamageCauser, float Damage, float HealthRemaining);
	void TickBeginHostageTakeState(float DeltaTime, float Uptime);
	void TickEndHostageTakeState(float DeltaTime, float Uptime);
	void TickMoveToState(float DeltaTime, float Uptime);
	void TickTakingState(float DeltaTime, float Uptime);
	void TickTurnState(float DeltaTime, float Uptime);

	bool CanEndHostageTake() const;
	bool CanIdle() const;
	bool CanStartHostageTake() const;
	bool ShouldTurn() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TakeHostageActivity">();
	}
	static class UTakeHostageActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTakeHostageActivity>();
	}
};
static_assert(alignof(UTakeHostageActivity) == 0x000008, "Wrong alignment on UTakeHostageActivity");
static_assert(sizeof(UTakeHostageActivity) == 0x000310, "Wrong size on UTakeHostageActivity");
static_assert(offsetof(UTakeHostageActivity, Hostage) == 0x0001F0, "Member 'UTakeHostageActivity::Hostage' has a wrong offset!");
static_assert(offsetof(UTakeHostageActivity, TimeToSurrenderHostage) == 0x0001F8, "Member 'UTakeHostageActivity::TimeToSurrenderHostage' has a wrong offset!");
static_assert(offsetof(UTakeHostageActivity, SWATCharacters) == 0x000208, "Member 'UTakeHostageActivity::SWATCharacters' has a wrong offset!");
static_assert(offsetof(UTakeHostageActivity, ActivePathQueryIdToSWATMap) == 0x000218, "Member 'UTakeHostageActivity::ActivePathQueryIdToSWATMap' has a wrong offset!");
static_assert(offsetof(UTakeHostageActivity, ClosestSwat) == 0x000268, "Member 'UTakeHostageActivity::ClosestSwat' has a wrong offset!");
static_assert(offsetof(UTakeHostageActivity, LastEnemySensed) == 0x000278, "Member 'UTakeHostageActivity::LastEnemySensed' has a wrong offset!");
static_assert(offsetof(UTakeHostageActivity, HostageInteractions) == 0x000280, "Member 'UTakeHostageActivity::HostageInteractions' has a wrong offset!");

// Class ReadyOrNot.TargetNextCivilianActivity
// 0x0018 (0x0208 - 0x01F0)
class UTargetNextCivilianActivity final : public UBaseActivity
{
public:
	class ACyberneticCharacter*                   TargetingCivilian;                                 // 0x01F0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F8[0xC];                                      // 0x01F8(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	ETargetNextCivilianState                      TargetNextCivilianState;                           // 0x0204(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_205[0x3];                                      // 0x0205(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTargetCivilianKilled(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TargetNextCivilianActivity">();
	}
	static class UTargetNextCivilianActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTargetNextCivilianActivity>();
	}
};
static_assert(alignof(UTargetNextCivilianActivity) == 0x000008, "Wrong alignment on UTargetNextCivilianActivity");
static_assert(sizeof(UTargetNextCivilianActivity) == 0x000208, "Wrong size on UTargetNextCivilianActivity");
static_assert(offsetof(UTargetNextCivilianActivity, TargetingCivilian) == 0x0001F0, "Member 'UTargetNextCivilianActivity::TargetingCivilian' has a wrong offset!");
static_assert(offsetof(UTargetNextCivilianActivity, TargetNextCivilianState) == 0x000204, "Member 'UTargetNextCivilianActivity::TargetNextCivilianState' has a wrong offset!");

// Class ReadyOrNot.Taser
// 0x0380 (0x1AC0 - 0x1740)
class ATaser : public ABaseMagazineWeapon
{
public:
	class UMaterialInstanceDynamic*               TaserLightDynamicMaterial;                         // 0x1738(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             ProjectileHitResult;                               // 0x1740(0x00E8)(Net, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         CartridgesPerSlot;                                 // 0x1828(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartingCartridges;                                // 0x182C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SweepForReactionVolumeSize;                        // 0x1830(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CartridgeWeight;                                   // 0x1834(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFiredCartridge;                                   // 0x1838(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDetachedProbes;                                   // 0x1839(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_183A[0x2];                                     // 0x183A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlinkTime;                                         // 0x183C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlinkState;                                       // 0x1840(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1841[0x3];                                     // 0x1841(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxBatteryLevel;                                   // 0x1844(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinCableLength;                                    // 0x1848(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxCableLength;                                    // 0x184C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CableGainRate;                                     // 0x1850(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProbeMaxDistance;                                  // 0x1854(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             DetachSoundEffect;                                 // 0x1858(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             DetachSoundEffectFMOD;                             // 0x1860(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PingStunDuration;                                  // 0x1868(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StunDurationRemaining;                             // 0x186C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStartedStun;                                      // 0x1870(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1871[0x7];                                     // 0x1871(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             CrackleSoundEffect;                                // 0x1878(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             CrackleSoundEffectFMOD;                            // 0x1880(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             TaserHitEffectFMOD;                                // 0x1888(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABulletProjectile*                      LeftProjectile;                                    // 0x1890(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABulletProjectile*                      RightProjectile;                                   // 0x1898(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18A0[0x8];                                     // 0x18A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        TaserImpactParticle_Start;                         // 0x18A8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystemComponent*               TaserImpactParticleComp_Start;                     // 0x18B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        TaserImpactParticle_Loop;                          // 0x18B8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystemComponent*               TaserImpactParticleComp_LoopLeft;                  // 0x18C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystemComponent*               TaserImpactParticleComp_LoopRight;                 // 0x18C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18D0[0xEC];                                    // 0x18D0(0x00EC)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DoorBlowOutForce;                                  // 0x19BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 LeftCableAttachActor;                              // 0x19C0(0x0008)(Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 RightCableAttachActor;                             // 0x19C8(0x0008)(Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           TaserFireLoop1P;                                   // 0x19D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           TaserFireLoop3P;                                   // 0x19D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ULegacyCameraShake>         TaserFireLoopCameraShake;                          // 0x19E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19E8[0x8];                                     // 0x19E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCableComponent*                        TopCable;                                          // 0x19F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCableComponent*                        BottomCable;                                       // 0x19F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 LeftDoor;                                          // 0x1A00(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 RightDoor;                                         // 0x1A08(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        CrackleSoundGenerator;                             // 0x1A10(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODAudioComponent*                    CrackleSoundGeneratorFMOD;                         // 0x1A18(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ULaserAttachment>           LaserAttachmentClass;                              // 0x1A20(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A28[0x98];                                    // 0x1A28(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DetachProbes();
	void HandleMeleeDeffered(const struct FHitResult& Hit);
	void Multicast_DestroyProjectiles();
	void Multicast_HideCables();
	void Multicast_PlayDetachEffect();
	void Multicast_PlayFireEffects(bool bDryFire);
	void Multicast_PlayTaserHitEffect(const struct FHitResult& Hit);
	void Multicast_ResetCableAttachments();
	void Multicast_ResetDoors();
	void Multicast_StartCrackleSoundEffect();
	void Multicast_StopCrackleSoundEffect();
	void OnRep_ProjectileReplicated();
	void Server_DeliverStunToAttachedTarget();
	void Server_DetachProbes();
	void Server_SetHoldingTaser(bool bNewHold);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Taser">();
	}
	static class ATaser* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATaser>();
	}
};
static_assert(alignof(ATaser) == 0x000010, "Wrong alignment on ATaser");
static_assert(sizeof(ATaser) == 0x001AC0, "Wrong size on ATaser");
static_assert(offsetof(ATaser, TaserLightDynamicMaterial) == 0x001738, "Member 'ATaser::TaserLightDynamicMaterial' has a wrong offset!");
static_assert(offsetof(ATaser, ProjectileHitResult) == 0x001740, "Member 'ATaser::ProjectileHitResult' has a wrong offset!");
static_assert(offsetof(ATaser, CartridgesPerSlot) == 0x001828, "Member 'ATaser::CartridgesPerSlot' has a wrong offset!");
static_assert(offsetof(ATaser, StartingCartridges) == 0x00182C, "Member 'ATaser::StartingCartridges' has a wrong offset!");
static_assert(offsetof(ATaser, SweepForReactionVolumeSize) == 0x001830, "Member 'ATaser::SweepForReactionVolumeSize' has a wrong offset!");
static_assert(offsetof(ATaser, CartridgeWeight) == 0x001834, "Member 'ATaser::CartridgeWeight' has a wrong offset!");
static_assert(offsetof(ATaser, bFiredCartridge) == 0x001838, "Member 'ATaser::bFiredCartridge' has a wrong offset!");
static_assert(offsetof(ATaser, bDetachedProbes) == 0x001839, "Member 'ATaser::bDetachedProbes' has a wrong offset!");
static_assert(offsetof(ATaser, BlinkTime) == 0x00183C, "Member 'ATaser::BlinkTime' has a wrong offset!");
static_assert(offsetof(ATaser, bBlinkState) == 0x001840, "Member 'ATaser::bBlinkState' has a wrong offset!");
static_assert(offsetof(ATaser, MaxBatteryLevel) == 0x001844, "Member 'ATaser::MaxBatteryLevel' has a wrong offset!");
static_assert(offsetof(ATaser, MinCableLength) == 0x001848, "Member 'ATaser::MinCableLength' has a wrong offset!");
static_assert(offsetof(ATaser, MaxCableLength) == 0x00184C, "Member 'ATaser::MaxCableLength' has a wrong offset!");
static_assert(offsetof(ATaser, CableGainRate) == 0x001850, "Member 'ATaser::CableGainRate' has a wrong offset!");
static_assert(offsetof(ATaser, ProbeMaxDistance) == 0x001854, "Member 'ATaser::ProbeMaxDistance' has a wrong offset!");
static_assert(offsetof(ATaser, DetachSoundEffect) == 0x001858, "Member 'ATaser::DetachSoundEffect' has a wrong offset!");
static_assert(offsetof(ATaser, DetachSoundEffectFMOD) == 0x001860, "Member 'ATaser::DetachSoundEffectFMOD' has a wrong offset!");
static_assert(offsetof(ATaser, PingStunDuration) == 0x001868, "Member 'ATaser::PingStunDuration' has a wrong offset!");
static_assert(offsetof(ATaser, StunDurationRemaining) == 0x00186C, "Member 'ATaser::StunDurationRemaining' has a wrong offset!");
static_assert(offsetof(ATaser, bStartedStun) == 0x001870, "Member 'ATaser::bStartedStun' has a wrong offset!");
static_assert(offsetof(ATaser, CrackleSoundEffect) == 0x001878, "Member 'ATaser::CrackleSoundEffect' has a wrong offset!");
static_assert(offsetof(ATaser, CrackleSoundEffectFMOD) == 0x001880, "Member 'ATaser::CrackleSoundEffectFMOD' has a wrong offset!");
static_assert(offsetof(ATaser, TaserHitEffectFMOD) == 0x001888, "Member 'ATaser::TaserHitEffectFMOD' has a wrong offset!");
static_assert(offsetof(ATaser, LeftProjectile) == 0x001890, "Member 'ATaser::LeftProjectile' has a wrong offset!");
static_assert(offsetof(ATaser, RightProjectile) == 0x001898, "Member 'ATaser::RightProjectile' has a wrong offset!");
static_assert(offsetof(ATaser, TaserImpactParticle_Start) == 0x0018A8, "Member 'ATaser::TaserImpactParticle_Start' has a wrong offset!");
static_assert(offsetof(ATaser, TaserImpactParticleComp_Start) == 0x0018B0, "Member 'ATaser::TaserImpactParticleComp_Start' has a wrong offset!");
static_assert(offsetof(ATaser, TaserImpactParticle_Loop) == 0x0018B8, "Member 'ATaser::TaserImpactParticle_Loop' has a wrong offset!");
static_assert(offsetof(ATaser, TaserImpactParticleComp_LoopLeft) == 0x0018C0, "Member 'ATaser::TaserImpactParticleComp_LoopLeft' has a wrong offset!");
static_assert(offsetof(ATaser, TaserImpactParticleComp_LoopRight) == 0x0018C8, "Member 'ATaser::TaserImpactParticleComp_LoopRight' has a wrong offset!");
static_assert(offsetof(ATaser, DoorBlowOutForce) == 0x0019BC, "Member 'ATaser::DoorBlowOutForce' has a wrong offset!");
static_assert(offsetof(ATaser, LeftCableAttachActor) == 0x0019C0, "Member 'ATaser::LeftCableAttachActor' has a wrong offset!");
static_assert(offsetof(ATaser, RightCableAttachActor) == 0x0019C8, "Member 'ATaser::RightCableAttachActor' has a wrong offset!");
static_assert(offsetof(ATaser, TaserFireLoop1P) == 0x0019D0, "Member 'ATaser::TaserFireLoop1P' has a wrong offset!");
static_assert(offsetof(ATaser, TaserFireLoop3P) == 0x0019D8, "Member 'ATaser::TaserFireLoop3P' has a wrong offset!");
static_assert(offsetof(ATaser, TaserFireLoopCameraShake) == 0x0019E0, "Member 'ATaser::TaserFireLoopCameraShake' has a wrong offset!");
static_assert(offsetof(ATaser, TopCable) == 0x0019F0, "Member 'ATaser::TopCable' has a wrong offset!");
static_assert(offsetof(ATaser, BottomCable) == 0x0019F8, "Member 'ATaser::BottomCable' has a wrong offset!");
static_assert(offsetof(ATaser, LeftDoor) == 0x001A00, "Member 'ATaser::LeftDoor' has a wrong offset!");
static_assert(offsetof(ATaser, RightDoor) == 0x001A08, "Member 'ATaser::RightDoor' has a wrong offset!");
static_assert(offsetof(ATaser, CrackleSoundGenerator) == 0x001A10, "Member 'ATaser::CrackleSoundGenerator' has a wrong offset!");
static_assert(offsetof(ATaser, CrackleSoundGeneratorFMOD) == 0x001A18, "Member 'ATaser::CrackleSoundGeneratorFMOD' has a wrong offset!");
static_assert(offsetof(ATaser, LaserAttachmentClass) == 0x001A20, "Member 'ATaser::LaserAttachmentClass' has a wrong offset!");

// Class ReadyOrNot.TaserReactionVolume
// 0x0008 (0x02A0 - 0x0298)
class ATaserReactionVolume final : public AActor
{
public:
	class UBoxComponent*                          Bounds;                                            // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnTaserStunDelivered(class AReadyOrNotCharacter* Character, class ATaser* Taser);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TaserReactionVolume">();
	}
	static class ATaserReactionVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATaserReactionVolume>();
	}
};
static_assert(alignof(ATaserReactionVolume) == 0x000008, "Wrong alignment on ATaserReactionVolume");
static_assert(sizeof(ATaserReactionVolume) == 0x0002A0, "Wrong size on ATaserReactionVolume");
static_assert(offsetof(ATaserReactionVolume, Bounds) == 0x000298, "Member 'ATaserReactionVolume::Bounds' has a wrong offset!");

// Class ReadyOrNot.TeamBreachAndClearActivity
// 0x00D8 (0x0320 - 0x0248)
class UTeamBreachAndClearActivity final : public UTeamStackUpActivity
{
public:
	TMulticastInlineDelegate<void(class UTeamBreachAndClearActivity* Activity, bool bAuto)> OnCleared; // 0x0248(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_258[0x40];                                     // 0x0258(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class ACyberneticCharacter*                   AIBlockingClearingPath;                            // 0x0298(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACyberneticCharacter*                   ClearingLeader;                                    // 0x02A0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AThreatAwarenessActor*                  NearestThreat;                                     // 0x02A8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B0[0x70];                                     // 0x02B0(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnterBreachStage();
	void EnterClearedStage();
	void EnterClearStage();
	void EnterScanStage();
	void OnDoorBreachActivityFinished(class UBaseActivity* InActivity, class ACyberneticController* InController);
	void OnDoorBreacherBreaching();
	void OnDoorBreacherReady();
	void OnDoorBreachFinished(class UBaseActivity* InActivity, class ACyberneticController* InController);
	void OnDoorScanFinished(class UBaseActivity* Activity, class ACyberneticController* Controller);
	void OnLeaderGrenadeDetonated(class ABaseGrenade* InGrenade);
	void OnLeaderGrenadeProjectileDetonated(class AGrenadeProjectile* InGrenadeProjectile);
	void OnLeaderItemPrimaryUse(class AReadyOrNotCharacter* ItemOwner, class ABaseItem* Item);
	void PerformBreachStage(float DeltaTime, float Uptime);
	void PerformClearStage(float DeltaTime, float Uptime);
	void PerformScanStage(float DeltaTime, float Uptime);

	bool CanPerformBreach() const;
	bool CanPerformClear() const;
	bool IsFinishedClearing() const;
	bool IsScanFinished() const;
	bool ShouldScan() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeamBreachAndClearActivity">();
	}
	static class UTeamBreachAndClearActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTeamBreachAndClearActivity>();
	}
};
static_assert(alignof(UTeamBreachAndClearActivity) == 0x000008, "Wrong alignment on UTeamBreachAndClearActivity");
static_assert(sizeof(UTeamBreachAndClearActivity) == 0x000320, "Wrong size on UTeamBreachAndClearActivity");
static_assert(offsetof(UTeamBreachAndClearActivity, OnCleared) == 0x000248, "Member 'UTeamBreachAndClearActivity::OnCleared' has a wrong offset!");
static_assert(offsetof(UTeamBreachAndClearActivity, AIBlockingClearingPath) == 0x000298, "Member 'UTeamBreachAndClearActivity::AIBlockingClearingPath' has a wrong offset!");
static_assert(offsetof(UTeamBreachAndClearActivity, ClearingLeader) == 0x0002A0, "Member 'UTeamBreachAndClearActivity::ClearingLeader' has a wrong offset!");
static_assert(offsetof(UTeamBreachAndClearActivity, NearestThreat) == 0x0002A8, "Member 'UTeamBreachAndClearActivity::NearestThreat' has a wrong offset!");

// Class ReadyOrNot.TeamChemlight
// 0x0068 (0x0310 - 0x02A8)
class ATeamChemlight final : public ACustomizationExtra
{
public:
	TMap<ETeamType, TSoftObjectPtr<class UMaterialInterface>> TeamMaterialMap;                       // 0x02A8(0x0050)(Edit, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	int32                                         TeamMaterialIndex;                                 // 0x02F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FC[0x4];                                      // 0x02FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x0300(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ETeamType                                     CurrentTeam;                                       // 0x0308(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_309[0x7];                                      // 0x0309(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleTeamChanged(ETeamType Team);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeamChemlight">();
	}
	static class ATeamChemlight* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATeamChemlight>();
	}
};
static_assert(alignof(ATeamChemlight) == 0x000008, "Wrong alignment on ATeamChemlight");
static_assert(sizeof(ATeamChemlight) == 0x000310, "Wrong size on ATeamChemlight");
static_assert(offsetof(ATeamChemlight, TeamMaterialMap) == 0x0002A8, "Member 'ATeamChemlight::TeamMaterialMap' has a wrong offset!");
static_assert(offsetof(ATeamChemlight, TeamMaterialIndex) == 0x0002F8, "Member 'ATeamChemlight::TeamMaterialIndex' has a wrong offset!");
static_assert(offsetof(ATeamChemlight, StaticMeshComponent) == 0x000300, "Member 'ATeamChemlight::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(ATeamChemlight, CurrentTeam) == 0x000308, "Member 'ATeamChemlight::CurrentTeam' has a wrong offset!");

// Class ReadyOrNot.TeamCoverAreaActivity
// 0x0000 (0x0200 - 0x0200)
class UTeamCoverAreaActivity final : public UTeamBaseActivity
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeamCoverAreaActivity">();
	}
	static class UTeamCoverAreaActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTeamCoverAreaActivity>();
	}
};
static_assert(alignof(UTeamCoverAreaActivity) == 0x000008, "Wrong alignment on UTeamCoverAreaActivity");
static_assert(sizeof(UTeamCoverAreaActivity) == 0x000200, "Wrong size on UTeamCoverAreaActivity");

// Class ReadyOrNot.TeamDeathmatchGS
// 0x0000 (0x08F8 - 0x08F8)
class ATeamDeathmatchGS final : public AReadyOrNotGameState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeamDeathmatchGS">();
	}
	static class ATeamDeathmatchGS* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATeamDeathmatchGS>();
	}
};
static_assert(alignof(ATeamDeathmatchGS) == 0x000008, "Wrong alignment on ATeamDeathmatchGS");
static_assert(sizeof(ATeamDeathmatchGS) == 0x0008F8, "Wrong size on ATeamDeathmatchGS");

// Class ReadyOrNot.TeamFallinActivity
// 0x0010 (0x0210 - 0x0200)
class UTeamFallinActivity final : public UTeamBaseActivity
{
public:
	class ASWATCharacter*                         MyLeader;                                          // 0x0200(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_208[0x8];                                      // 0x0208(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeamFallinActivity">();
	}
	static class UTeamFallinActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTeamFallinActivity>();
	}
};
static_assert(alignof(UTeamFallinActivity) == 0x000008, "Wrong alignment on UTeamFallinActivity");
static_assert(sizeof(UTeamFallinActivity) == 0x000210, "Wrong size on UTeamFallinActivity");
static_assert(offsetof(UTeamFallinActivity, MyLeader) == 0x000200, "Member 'UTeamFallinActivity::MyLeader' has a wrong offset!");

// Class ReadyOrNot.TeamPaperdollWidget
// 0x0008 (0x02C8 - 0x02C0)
class UTeamPaperdollWidget final : public UUserWidget
{
public:
	class UImage*                                 Paperdoll_Image;                                   // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void InitializeWidget(ETeamType InTeam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeamPaperdollWidget">();
	}
	static class UTeamPaperdollWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTeamPaperdollWidget>();
	}
};
static_assert(alignof(UTeamPaperdollWidget) == 0x000008, "Wrong alignment on UTeamPaperdollWidget");
static_assert(sizeof(UTeamPaperdollWidget) == 0x0002C8, "Wrong size on UTeamPaperdollWidget");
static_assert(offsetof(UTeamPaperdollWidget, Paperdoll_Image) == 0x0002C0, "Member 'UTeamPaperdollWidget::Paperdoll_Image' has a wrong offset!");

// Class ReadyOrNot.TeamStatusWidget
// 0x01A8 (0x0490 - 0x02E8)
class UTeamStatusWidget final : public UBaseWidget
{
public:
	class UImage*                                 TeamEmblem_Image_LeftAligned;                      // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         Teammates_Container_LeftAligned;                   // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 TeamEmblem_Image_RightAligned;                     // 0x02F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         Teammates_Container_RightAligned;                  // 0x0300(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHorizontalAlignment                          Alignment;                                         // 0x0308(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_309[0x7];                                      // 0x0309(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            TeamEmblemBrush;                                   // 0x0310(0x00D0)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, ExposeOnSpawn, NativeAccessSpecifierProtected)
	ETeamType                                     Team;                                              // 0x03E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E1[0x7];                                      // 0x03E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UTeamPaperdollWidget>       PaperdollWidgetClass;                              // 0x03E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   EmptyTeamText;                                     // 0x03F0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, ExposeOnSpawn, NativeAccessSpecifierProtected)
	struct FSlateColor                            EmptyTeamTextColor;                                // 0x0408(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, ExposeOnSpawn, NativeAccessSpecifierProtected)
	uint8                                         Pad_41C[0x4];                                      // 0x041C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateFontInfo                         EmptyTeamTextFont;                                 // 0x0420(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UTeamPaperdollWidget*>           TeamPaperdolls;                                    // 0x0478(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UTextBlock*                             EmptyTeam_Text;                                    // 0x0488(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void InitializeTeam();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeamStatusWidget">();
	}
	static class UTeamStatusWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTeamStatusWidget>();
	}
};
static_assert(alignof(UTeamStatusWidget) == 0x000010, "Wrong alignment on UTeamStatusWidget");
static_assert(sizeof(UTeamStatusWidget) == 0x000490, "Wrong size on UTeamStatusWidget");
static_assert(offsetof(UTeamStatusWidget, TeamEmblem_Image_LeftAligned) == 0x0002E8, "Member 'UTeamStatusWidget::TeamEmblem_Image_LeftAligned' has a wrong offset!");
static_assert(offsetof(UTeamStatusWidget, Teammates_Container_LeftAligned) == 0x0002F0, "Member 'UTeamStatusWidget::Teammates_Container_LeftAligned' has a wrong offset!");
static_assert(offsetof(UTeamStatusWidget, TeamEmblem_Image_RightAligned) == 0x0002F8, "Member 'UTeamStatusWidget::TeamEmblem_Image_RightAligned' has a wrong offset!");
static_assert(offsetof(UTeamStatusWidget, Teammates_Container_RightAligned) == 0x000300, "Member 'UTeamStatusWidget::Teammates_Container_RightAligned' has a wrong offset!");
static_assert(offsetof(UTeamStatusWidget, Alignment) == 0x000308, "Member 'UTeamStatusWidget::Alignment' has a wrong offset!");
static_assert(offsetof(UTeamStatusWidget, TeamEmblemBrush) == 0x000310, "Member 'UTeamStatusWidget::TeamEmblemBrush' has a wrong offset!");
static_assert(offsetof(UTeamStatusWidget, Team) == 0x0003E0, "Member 'UTeamStatusWidget::Team' has a wrong offset!");
static_assert(offsetof(UTeamStatusWidget, PaperdollWidgetClass) == 0x0003E8, "Member 'UTeamStatusWidget::PaperdollWidgetClass' has a wrong offset!");
static_assert(offsetof(UTeamStatusWidget, EmptyTeamText) == 0x0003F0, "Member 'UTeamStatusWidget::EmptyTeamText' has a wrong offset!");
static_assert(offsetof(UTeamStatusWidget, EmptyTeamTextColor) == 0x000408, "Member 'UTeamStatusWidget::EmptyTeamTextColor' has a wrong offset!");
static_assert(offsetof(UTeamStatusWidget, EmptyTeamTextFont) == 0x000420, "Member 'UTeamStatusWidget::EmptyTeamTextFont' has a wrong offset!");
static_assert(offsetof(UTeamStatusWidget, TeamPaperdolls) == 0x000478, "Member 'UTeamStatusWidget::TeamPaperdolls' has a wrong offset!");
static_assert(offsetof(UTeamStatusWidget, EmptyTeam_Text) == 0x000488, "Member 'UTeamStatusWidget::EmptyTeam_Text' has a wrong offset!");

// Class ReadyOrNot.TeamViewWidget
// 0x00D8 (0x04E8 - 0x0410)
class UTeamViewWidget : public UCommonActivatableWidget
{
public:
	class UImage*                                 PlayerViewImage;                                   // 0x0410(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             PlayerNameText;                                    // 0x0418(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             PlayerHealthStatusText;                            // 0x0420(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 PlayerTeamIndicatorImage;                          // 0x0428(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         SwitchViewRichText;                                // 0x0430(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         CloseViewRichText;                                 // 0x0438(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             CurrentViewIndexText;                              // 0x0440(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<ETeamType, struct FSlateColor>           TeamColorMap;                                      // 0x0448(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TMap<EPlayerHealthStatus, struct FSlateColor> HealthStatusColorMap;                              // 0x0498(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	class FText FormatKeybindText(const class FString& InputEvent, const class FString& InputAction);
	void OnInputMethodChanged(ECommonInputType InputType);
	void Tick_TeamViewOn();
	void UpdateInputText();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeamViewWidget">();
	}
	static class UTeamViewWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTeamViewWidget>();
	}
};
static_assert(alignof(UTeamViewWidget) == 0x000008, "Wrong alignment on UTeamViewWidget");
static_assert(sizeof(UTeamViewWidget) == 0x0004E8, "Wrong size on UTeamViewWidget");
static_assert(offsetof(UTeamViewWidget, PlayerViewImage) == 0x000410, "Member 'UTeamViewWidget::PlayerViewImage' has a wrong offset!");
static_assert(offsetof(UTeamViewWidget, PlayerNameText) == 0x000418, "Member 'UTeamViewWidget::PlayerNameText' has a wrong offset!");
static_assert(offsetof(UTeamViewWidget, PlayerHealthStatusText) == 0x000420, "Member 'UTeamViewWidget::PlayerHealthStatusText' has a wrong offset!");
static_assert(offsetof(UTeamViewWidget, PlayerTeamIndicatorImage) == 0x000428, "Member 'UTeamViewWidget::PlayerTeamIndicatorImage' has a wrong offset!");
static_assert(offsetof(UTeamViewWidget, SwitchViewRichText) == 0x000430, "Member 'UTeamViewWidget::SwitchViewRichText' has a wrong offset!");
static_assert(offsetof(UTeamViewWidget, CloseViewRichText) == 0x000438, "Member 'UTeamViewWidget::CloseViewRichText' has a wrong offset!");
static_assert(offsetof(UTeamViewWidget, CurrentViewIndexText) == 0x000440, "Member 'UTeamViewWidget::CurrentViewIndexText' has a wrong offset!");
static_assert(offsetof(UTeamViewWidget, TeamColorMap) == 0x000448, "Member 'UTeamViewWidget::TeamColorMap' has a wrong offset!");
static_assert(offsetof(UTeamViewWidget, HealthStatusColorMap) == 0x000498, "Member 'UTeamViewWidget::HealthStatusColorMap' has a wrong offset!");

// Class ReadyOrNot.TelescopicLadder
// 0x0310 (0x0EC0 - 0x0BB0)
class ATelescopicLadder : public ABaseDeployableGear
{
public:
	class USceneComponent*                        LadderVerticalIconPoint;                           // 0x0BB0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        LadderHorizontalIconPoint;                         // 0x0BB8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        LadderBottomMountPoint;                            // 0x0BC0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        LadderTopMountPoint;                               // 0x0BC8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ALadderSnapZone>            LadderSnapZoneBP;                                  // 0x0BD0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFreezeFrame;                                      // 0x0BD8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BD9[0x3];                                      // 0x0BD9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxRollDegreesBeforeUnwalkable;                    // 0x0BDC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BE0[0x110];                                    // 0x0BE0(0x0110)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             FreezeTransform;                                   // 0x0CF0(0x0060)(Net, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D50[0x48];                                     // 0x0D50(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bShowGhostLadder;                                  // 0x0D98(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowCollapsedLadder;                              // 0x0D99(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9A[0x6];                                      // 0x0D9A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          CollapsedLadderAnim;                               // 0x0DA0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DA8[0x8];                                      // 0x0DA8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             LastTransform;                                     // 0x0DB0(0x0060)(Net, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASkeletalMeshActor*                     GhostLadderActor;                                  // 0x0E10(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterial*                              GhostLadderMaterial;                               // 0x0E18(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPhysicsAsset*                          DroppedPhysics;                                    // 0x0E20(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPhysicsAsset*                          PlacedPhysics;                                     // 0x0E28(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             PlacementSoundEvent;                               // 0x0E30(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             PickupSoundEvent;                                  // 0x0E38(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             CollideSoundEvent;                                 // 0x0E40(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDeployed;                                         // 0x0E48(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDeployedHorizontal;                               // 0x0E49(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMounted;                                          // 0x0E4A(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E4B[0x1];                                      // 0x0E4B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RetractedRungCount;                                // 0x0E4C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALadderSnapZone*                        CurrentSnapZone;                                   // 0x0E50(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWallFound;                                        // 0x0E58(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E59[0x67];                                     // 0x0E59(0x0067)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Multicast_DeployLadderAtZone(class ALadderSnapZone* NewSnapZone);
	void Multicast_PlaceLadder();
	void OnRep_CurrentSnapZone();
	void OnRep_Deployed();
	void Server_DeployLadderAtZone(class ALadderSnapZone* NewSnapZone);
	void Server_PlaceLadder();
	void Server_RemoveLadder();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TelescopicLadder">();
	}
	static class ATelescopicLadder* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATelescopicLadder>();
	}
};
static_assert(alignof(ATelescopicLadder) == 0x000010, "Wrong alignment on ATelescopicLadder");
static_assert(sizeof(ATelescopicLadder) == 0x000EC0, "Wrong size on ATelescopicLadder");
static_assert(offsetof(ATelescopicLadder, LadderVerticalIconPoint) == 0x000BB0, "Member 'ATelescopicLadder::LadderVerticalIconPoint' has a wrong offset!");
static_assert(offsetof(ATelescopicLadder, LadderHorizontalIconPoint) == 0x000BB8, "Member 'ATelescopicLadder::LadderHorizontalIconPoint' has a wrong offset!");
static_assert(offsetof(ATelescopicLadder, LadderBottomMountPoint) == 0x000BC0, "Member 'ATelescopicLadder::LadderBottomMountPoint' has a wrong offset!");
static_assert(offsetof(ATelescopicLadder, LadderTopMountPoint) == 0x000BC8, "Member 'ATelescopicLadder::LadderTopMountPoint' has a wrong offset!");
static_assert(offsetof(ATelescopicLadder, LadderSnapZoneBP) == 0x000BD0, "Member 'ATelescopicLadder::LadderSnapZoneBP' has a wrong offset!");
static_assert(offsetof(ATelescopicLadder, bFreezeFrame) == 0x000BD8, "Member 'ATelescopicLadder::bFreezeFrame' has a wrong offset!");
static_assert(offsetof(ATelescopicLadder, MaxRollDegreesBeforeUnwalkable) == 0x000BDC, "Member 'ATelescopicLadder::MaxRollDegreesBeforeUnwalkable' has a wrong offset!");
static_assert(offsetof(ATelescopicLadder, FreezeTransform) == 0x000CF0, "Member 'ATelescopicLadder::FreezeTransform' has a wrong offset!");
static_assert(offsetof(ATelescopicLadder, bShowGhostLadder) == 0x000D98, "Member 'ATelescopicLadder::bShowGhostLadder' has a wrong offset!");
static_assert(offsetof(ATelescopicLadder, bShowCollapsedLadder) == 0x000D99, "Member 'ATelescopicLadder::bShowCollapsedLadder' has a wrong offset!");
static_assert(offsetof(ATelescopicLadder, CollapsedLadderAnim) == 0x000DA0, "Member 'ATelescopicLadder::CollapsedLadderAnim' has a wrong offset!");
static_assert(offsetof(ATelescopicLadder, LastTransform) == 0x000DB0, "Member 'ATelescopicLadder::LastTransform' has a wrong offset!");
static_assert(offsetof(ATelescopicLadder, GhostLadderActor) == 0x000E10, "Member 'ATelescopicLadder::GhostLadderActor' has a wrong offset!");
static_assert(offsetof(ATelescopicLadder, GhostLadderMaterial) == 0x000E18, "Member 'ATelescopicLadder::GhostLadderMaterial' has a wrong offset!");
static_assert(offsetof(ATelescopicLadder, DroppedPhysics) == 0x000E20, "Member 'ATelescopicLadder::DroppedPhysics' has a wrong offset!");
static_assert(offsetof(ATelescopicLadder, PlacedPhysics) == 0x000E28, "Member 'ATelescopicLadder::PlacedPhysics' has a wrong offset!");
static_assert(offsetof(ATelescopicLadder, PlacementSoundEvent) == 0x000E30, "Member 'ATelescopicLadder::PlacementSoundEvent' has a wrong offset!");
static_assert(offsetof(ATelescopicLadder, PickupSoundEvent) == 0x000E38, "Member 'ATelescopicLadder::PickupSoundEvent' has a wrong offset!");
static_assert(offsetof(ATelescopicLadder, CollideSoundEvent) == 0x000E40, "Member 'ATelescopicLadder::CollideSoundEvent' has a wrong offset!");
static_assert(offsetof(ATelescopicLadder, bDeployed) == 0x000E48, "Member 'ATelescopicLadder::bDeployed' has a wrong offset!");
static_assert(offsetof(ATelescopicLadder, bDeployedHorizontal) == 0x000E49, "Member 'ATelescopicLadder::bDeployedHorizontal' has a wrong offset!");
static_assert(offsetof(ATelescopicLadder, bMounted) == 0x000E4A, "Member 'ATelescopicLadder::bMounted' has a wrong offset!");
static_assert(offsetof(ATelescopicLadder, RetractedRungCount) == 0x000E4C, "Member 'ATelescopicLadder::RetractedRungCount' has a wrong offset!");
static_assert(offsetof(ATelescopicLadder, CurrentSnapZone) == 0x000E50, "Member 'ATelescopicLadder::CurrentSnapZone' has a wrong offset!");
static_assert(offsetof(ATelescopicLadder, bWallFound) == 0x000E58, "Member 'ATelescopicLadder::bWallFound' has a wrong offset!");

// Class ReadyOrNot.TherapistWidget
// 0x0010 (0x0420 - 0x0410)
class UTherapistWidget : public UCommonActivatableWidget
{
public:
	TArray<class URosterCharacter*>               CharactersInTherapy;                               // 0x0410(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	void CloseTherapistWidget();
	TArray<class URosterCharacter*> GetCharactersInTherapy();
	class FText GetTherapistText();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TherapistWidget">();
	}
	static class UTherapistWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTherapistWidget>();
	}
};
static_assert(alignof(UTherapistWidget) == 0x000008, "Wrong alignment on UTherapistWidget");
static_assert(sizeof(UTherapistWidget) == 0x000420, "Wrong size on UTherapistWidget");
static_assert(offsetof(UTherapistWidget, CharactersInTherapy) == 0x000410, "Member 'UTherapistWidget::CharactersInTherapy' has a wrong offset!");

// Class ReadyOrNot.ThreatAwarenessActor
// 0x0070 (0x0308 - 0x0298)
class AThreatAwarenessActor final : public AActor
{
public:
	class USceneComponent*                        DefaultScene;                                      // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EThreatLevel                                  ThreatLevel;                                       // 0x02A0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A1[0x7];                                      // 0x02A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FExitData>                      Exits;                                             // 0x02A8(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<class ADoor*>                          UniqueExits;                                       // 0x02B8(0x0010)(Edit, ZeroConstructor, EditConst, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bOverrideOwningRoom;                               // 0x02C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C9[0x3];                                      // 0x02C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   OwningRoom;                                        // 0x02CC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D4[0x4];                                      // 0x02D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ADoor*                                  DoorThreat;                                        // 0x02D8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFrontDoorThreat;                                  // 0x02E0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsOutside;                                        // 0x02E1(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E2[0x6];                                      // 0x02E2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AThreatAwarenessActor*>          PathableThreatAwarenessActors;                     // 0x02E8(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FLookAtPoint>                   SwatLookAtPoints;                                  // 0x02F8(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPublic)

public:
	void GenerateLookAtPoints();
	void RemoveAnyVisibleExits();

	class ADoor* GetAttachedDoor() const;
	bool GetRandomExitDoor(class ADoor** Door) const;
	EThreatLevel GetThreatLevel() const;
	bool GetUniqueExtis(TArray<class ADoor*>* OutDoors) const;
	bool HasExit() const;
	bool HasSpecificExitDoor(class ADoor* Door) const;
	bool IsDoorThreat() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ThreatAwarenessActor">();
	}
	static class AThreatAwarenessActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AThreatAwarenessActor>();
	}
};
static_assert(alignof(AThreatAwarenessActor) == 0x000008, "Wrong alignment on AThreatAwarenessActor");
static_assert(sizeof(AThreatAwarenessActor) == 0x000308, "Wrong size on AThreatAwarenessActor");
static_assert(offsetof(AThreatAwarenessActor, DefaultScene) == 0x000298, "Member 'AThreatAwarenessActor::DefaultScene' has a wrong offset!");
static_assert(offsetof(AThreatAwarenessActor, ThreatLevel) == 0x0002A0, "Member 'AThreatAwarenessActor::ThreatLevel' has a wrong offset!");
static_assert(offsetof(AThreatAwarenessActor, Exits) == 0x0002A8, "Member 'AThreatAwarenessActor::Exits' has a wrong offset!");
static_assert(offsetof(AThreatAwarenessActor, UniqueExits) == 0x0002B8, "Member 'AThreatAwarenessActor::UniqueExits' has a wrong offset!");
static_assert(offsetof(AThreatAwarenessActor, bOverrideOwningRoom) == 0x0002C8, "Member 'AThreatAwarenessActor::bOverrideOwningRoom' has a wrong offset!");
static_assert(offsetof(AThreatAwarenessActor, OwningRoom) == 0x0002CC, "Member 'AThreatAwarenessActor::OwningRoom' has a wrong offset!");
static_assert(offsetof(AThreatAwarenessActor, DoorThreat) == 0x0002D8, "Member 'AThreatAwarenessActor::DoorThreat' has a wrong offset!");
static_assert(offsetof(AThreatAwarenessActor, bFrontDoorThreat) == 0x0002E0, "Member 'AThreatAwarenessActor::bFrontDoorThreat' has a wrong offset!");
static_assert(offsetof(AThreatAwarenessActor, bIsOutside) == 0x0002E1, "Member 'AThreatAwarenessActor::bIsOutside' has a wrong offset!");
static_assert(offsetof(AThreatAwarenessActor, PathableThreatAwarenessActors) == 0x0002E8, "Member 'AThreatAwarenessActor::PathableThreatAwarenessActors' has a wrong offset!");
static_assert(offsetof(AThreatAwarenessActor, SwatLookAtPoints) == 0x0002F8, "Member 'AThreatAwarenessActor::SwatLookAtPoints' has a wrong offset!");

// Class ReadyOrNot.ThreatAwarenessSubsystem
// 0x0058 (0x0088 - 0x0030)
class UThreatAwarenessSubsystem final : public UWorldSubsystem
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AThreatAwarenessActor*>          AllThreatActors;                                   // 0x0038(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         bDrawThreatAwarenessOctree : 1;                    // 0x0048(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawThreatPoints : 1;                             // 0x0048(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawThreatRoomNames : 1;                          // 0x0048(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_49[0x3F];                                      // 0x0049(0x003F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class AThreatAwarenessActor* GetFurthestHighestThreat(const TArray<class AThreatAwarenessActor*>& InThreats, const struct FVector& Location, float minDistance);
	static class AThreatAwarenessActor* GetNearestHighestThreat(const TArray<class AThreatAwarenessActor*>& InThreats, const struct FVector& Location);
	static class AThreatAwarenessActor* GetNearestLowestThreat(const TArray<class AThreatAwarenessActor*>& InThreats, const struct FVector& Location);
	static TArray<class AThreatAwarenessActor*> GetThreatsFromLocationBeyondRadius(const TArray<class AThreatAwarenessActor*>& InThreats, const struct FVector& Location, float minDistance);

	void GetThreatsForLocation(TArray<class AThreatAwarenessActor*>* OutThreats, const struct FVector& Location, float minDistance, bool bRequireLOS, class FName RoomName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ThreatAwarenessSubsystem">();
	}
	static class UThreatAwarenessSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UThreatAwarenessSubsystem>();
	}
};
static_assert(alignof(UThreatAwarenessSubsystem) == 0x000008, "Wrong alignment on UThreatAwarenessSubsystem");
static_assert(sizeof(UThreatAwarenessSubsystem) == 0x000088, "Wrong size on UThreatAwarenessSubsystem");
static_assert(offsetof(UThreatAwarenessSubsystem, AllThreatActors) == 0x000038, "Member 'UThreatAwarenessSubsystem::AllThreatActors' has a wrong offset!");

// Class ReadyOrNot.ThrownChemlight
// 0x0060 (0x0658 - 0x05F8)
class AThrownChemlight : public AThrownItem
{
public:
	class UPointLightComponent*                   LightSource;                                       // 0x05F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ChemlightColor;                                    // 0x0600(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EmissiveBrightness;                                // 0x0610(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightIntensity;                                    // 0x0614(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialGlowSpeed;                                  // 0x0618(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightDimSpeed;                                     // 0x061C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DestroyedDimSpeed;                                 // 0x0620(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartDimTime;                                      // 0x0624(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalLifeTime;                                     // 0x0628(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_62C[0x4];                                      // 0x062C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     DestroyedDecal;                                    // 0x0630(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightZOffset;                                      // 0x0638(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightAdditionalHeight;                             // 0x063C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DestroyedDecalSize;                                // 0x0640(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_644[0xC];                                      // 0x0644(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               ChemlightMaterialInstance;                         // 0x0650(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ThrownChemlight">();
	}
	static class AThrownChemlight* GetDefaultObj()
	{
		return GetDefaultObjImpl<AThrownChemlight>();
	}
};
static_assert(alignof(AThrownChemlight) == 0x000008, "Wrong alignment on AThrownChemlight");
static_assert(sizeof(AThrownChemlight) == 0x000658, "Wrong size on AThrownChemlight");
static_assert(offsetof(AThrownChemlight, LightSource) == 0x0005F8, "Member 'AThrownChemlight::LightSource' has a wrong offset!");
static_assert(offsetof(AThrownChemlight, ChemlightColor) == 0x000600, "Member 'AThrownChemlight::ChemlightColor' has a wrong offset!");
static_assert(offsetof(AThrownChemlight, EmissiveBrightness) == 0x000610, "Member 'AThrownChemlight::EmissiveBrightness' has a wrong offset!");
static_assert(offsetof(AThrownChemlight, LightIntensity) == 0x000614, "Member 'AThrownChemlight::LightIntensity' has a wrong offset!");
static_assert(offsetof(AThrownChemlight, InitialGlowSpeed) == 0x000618, "Member 'AThrownChemlight::InitialGlowSpeed' has a wrong offset!");
static_assert(offsetof(AThrownChemlight, LightDimSpeed) == 0x00061C, "Member 'AThrownChemlight::LightDimSpeed' has a wrong offset!");
static_assert(offsetof(AThrownChemlight, DestroyedDimSpeed) == 0x000620, "Member 'AThrownChemlight::DestroyedDimSpeed' has a wrong offset!");
static_assert(offsetof(AThrownChemlight, StartDimTime) == 0x000624, "Member 'AThrownChemlight::StartDimTime' has a wrong offset!");
static_assert(offsetof(AThrownChemlight, TotalLifeTime) == 0x000628, "Member 'AThrownChemlight::TotalLifeTime' has a wrong offset!");
static_assert(offsetof(AThrownChemlight, DestroyedDecal) == 0x000630, "Member 'AThrownChemlight::DestroyedDecal' has a wrong offset!");
static_assert(offsetof(AThrownChemlight, LightZOffset) == 0x000638, "Member 'AThrownChemlight::LightZOffset' has a wrong offset!");
static_assert(offsetof(AThrownChemlight, LightAdditionalHeight) == 0x00063C, "Member 'AThrownChemlight::LightAdditionalHeight' has a wrong offset!");
static_assert(offsetof(AThrownChemlight, DestroyedDecalSize) == 0x000640, "Member 'AThrownChemlight::DestroyedDecalSize' has a wrong offset!");
static_assert(offsetof(AThrownChemlight, ChemlightMaterialInstance) == 0x000650, "Member 'AThrownChemlight::ChemlightMaterialInstance' has a wrong offset!");

// Class ReadyOrNot.ThrownEvidenceActor
// 0x0058 (0x02F0 - 0x0298)
class AThrownEvidenceActor final : public AActor
{
public:
	uint8                                         Pad_298[0x10];                                     // 0x0298(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          BoxComponent;                                      // 0x02A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABaseItem*                              OwningItem;                                        // 0x02B0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Rep_Location;                                      // 0x02B8(0x0018)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rep_Rotation;                                      // 0x02D0(0x0018)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E8[0x8];                                      // 0x02E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBoxHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ThrownEvidenceActor">();
	}
	static class AThrownEvidenceActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AThrownEvidenceActor>();
	}
};
static_assert(alignof(AThrownEvidenceActor) == 0x000008, "Wrong alignment on AThrownEvidenceActor");
static_assert(sizeof(AThrownEvidenceActor) == 0x0002F0, "Wrong size on AThrownEvidenceActor");
static_assert(offsetof(AThrownEvidenceActor, BoxComponent) == 0x0002A8, "Member 'AThrownEvidenceActor::BoxComponent' has a wrong offset!");
static_assert(offsetof(AThrownEvidenceActor, OwningItem) == 0x0002B0, "Member 'AThrownEvidenceActor::OwningItem' has a wrong offset!");
static_assert(offsetof(AThrownEvidenceActor, Rep_Location) == 0x0002B8, "Member 'AThrownEvidenceActor::Rep_Location' has a wrong offset!");
static_assert(offsetof(AThrownEvidenceActor, Rep_Rotation) == 0x0002D0, "Member 'AThrownEvidenceActor::Rep_Rotation' has a wrong offset!");

// Class ReadyOrNot.ThrownGrenade
// 0x0000 (0x05F8 - 0x05F8)
class AThrownGrenade : public AThrownItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ThrownGrenade">();
	}
	static class AThrownGrenade* GetDefaultObj()
	{
		return GetDefaultObjImpl<AThrownGrenade>();
	}
};
static_assert(alignof(AThrownGrenade) == 0x000008, "Wrong alignment on AThrownGrenade");
static_assert(sizeof(AThrownGrenade) == 0x0005F8, "Wrong size on AThrownGrenade");

// Class ReadyOrNot.TocSpeechData
// 0x00B8 (0x00E8 - 0x0030)
class UTocSpeechData final : public UDataAsset
{
public:
	class USoundCue*                              CivilianIncapacitated;                             // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              CivilianDead;                                      // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              CivilianRestrained;                                // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              SuspectIncapacitated;                              // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              SuspectDead;                                       // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              SuspectRestrained;                                 // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              OfficerDown;                                       // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              DOA;                                               // 0x0068(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             SWATVictory;                                       // 0x0070(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             SuspectVictory;                                    // 0x0078(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             SWATInCustody;                                     // 0x0080(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             SuspectInCustody_MP;                               // 0x0088(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             SWATReinforcements;                                // 0x0090(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             SuspectReinforcements;                             // 0x0098(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             BothTeamsReinforcements;                           // 0x00A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             SWATFriendlyFire;                                  // 0x00A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             SuspectFriendlyFire;                               // 0x00B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             VIPEscorted;                                       // 0x00B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             VIPExecuted;                                       // 0x00C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             SWATKilledVIP;                                     // 0x00C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             SuspectKilledVIP;                                  // 0x00D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             VIPInCustody;                                      // 0x00D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             VIPReleased;                                       // 0x00E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TocSpeechData">();
	}
	static class UTocSpeechData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTocSpeechData>();
	}
};
static_assert(alignof(UTocSpeechData) == 0x000008, "Wrong alignment on UTocSpeechData");
static_assert(sizeof(UTocSpeechData) == 0x0000E8, "Wrong size on UTocSpeechData");
static_assert(offsetof(UTocSpeechData, CivilianIncapacitated) == 0x000030, "Member 'UTocSpeechData::CivilianIncapacitated' has a wrong offset!");
static_assert(offsetof(UTocSpeechData, CivilianDead) == 0x000038, "Member 'UTocSpeechData::CivilianDead' has a wrong offset!");
static_assert(offsetof(UTocSpeechData, CivilianRestrained) == 0x000040, "Member 'UTocSpeechData::CivilianRestrained' has a wrong offset!");
static_assert(offsetof(UTocSpeechData, SuspectIncapacitated) == 0x000048, "Member 'UTocSpeechData::SuspectIncapacitated' has a wrong offset!");
static_assert(offsetof(UTocSpeechData, SuspectDead) == 0x000050, "Member 'UTocSpeechData::SuspectDead' has a wrong offset!");
static_assert(offsetof(UTocSpeechData, SuspectRestrained) == 0x000058, "Member 'UTocSpeechData::SuspectRestrained' has a wrong offset!");
static_assert(offsetof(UTocSpeechData, OfficerDown) == 0x000060, "Member 'UTocSpeechData::OfficerDown' has a wrong offset!");
static_assert(offsetof(UTocSpeechData, DOA) == 0x000068, "Member 'UTocSpeechData::DOA' has a wrong offset!");
static_assert(offsetof(UTocSpeechData, SWATVictory) == 0x000070, "Member 'UTocSpeechData::SWATVictory' has a wrong offset!");
static_assert(offsetof(UTocSpeechData, SuspectVictory) == 0x000078, "Member 'UTocSpeechData::SuspectVictory' has a wrong offset!");
static_assert(offsetof(UTocSpeechData, SWATInCustody) == 0x000080, "Member 'UTocSpeechData::SWATInCustody' has a wrong offset!");
static_assert(offsetof(UTocSpeechData, SuspectInCustody_MP) == 0x000088, "Member 'UTocSpeechData::SuspectInCustody_MP' has a wrong offset!");
static_assert(offsetof(UTocSpeechData, SWATReinforcements) == 0x000090, "Member 'UTocSpeechData::SWATReinforcements' has a wrong offset!");
static_assert(offsetof(UTocSpeechData, SuspectReinforcements) == 0x000098, "Member 'UTocSpeechData::SuspectReinforcements' has a wrong offset!");
static_assert(offsetof(UTocSpeechData, BothTeamsReinforcements) == 0x0000A0, "Member 'UTocSpeechData::BothTeamsReinforcements' has a wrong offset!");
static_assert(offsetof(UTocSpeechData, SWATFriendlyFire) == 0x0000A8, "Member 'UTocSpeechData::SWATFriendlyFire' has a wrong offset!");
static_assert(offsetof(UTocSpeechData, SuspectFriendlyFire) == 0x0000B0, "Member 'UTocSpeechData::SuspectFriendlyFire' has a wrong offset!");
static_assert(offsetof(UTocSpeechData, VIPEscorted) == 0x0000B8, "Member 'UTocSpeechData::VIPEscorted' has a wrong offset!");
static_assert(offsetof(UTocSpeechData, VIPExecuted) == 0x0000C0, "Member 'UTocSpeechData::VIPExecuted' has a wrong offset!");
static_assert(offsetof(UTocSpeechData, SWATKilledVIP) == 0x0000C8, "Member 'UTocSpeechData::SWATKilledVIP' has a wrong offset!");
static_assert(offsetof(UTocSpeechData, SuspectKilledVIP) == 0x0000D0, "Member 'UTocSpeechData::SuspectKilledVIP' has a wrong offset!");
static_assert(offsetof(UTocSpeechData, VIPInCustody) == 0x0000D8, "Member 'UTocSpeechData::VIPInCustody' has a wrong offset!");
static_assert(offsetof(UTocSpeechData, VIPReleased) == 0x0000E0, "Member 'UTocSpeechData::VIPReleased' has a wrong offset!");

// Class ReadyOrNot.ToggleDoorActivity
// 0x0008 (0x0260 - 0x0258)
class UToggleDoorActivity final : public UDoorInteractionActivity
{
public:
	uint8                                         Pad_258[0x8];                                      // 0x0258(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ToggleDoorActivity">();
	}
	static class UToggleDoorActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UToggleDoorActivity>();
	}
};
static_assert(alignof(UToggleDoorActivity) == 0x000008, "Wrong alignment on UToggleDoorActivity");
static_assert(sizeof(UToggleDoorActivity) == 0x000260, "Wrong size on UToggleDoorActivity");

// Class ReadyOrNot.TrackingCameraComponent
// 0x0058 (0x00F8 - 0x00A0)
class UTrackingCameraComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(bool bVisible)> OnSceneCaptureVisibilityChange;                    // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	float                                         ZoomSpeed;                                         // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class URadialTrackingComponent*               TrackingComponent;                                 // 0x00B8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneCaptureComponent2D*               CaptureComponent;                                  // 0x00C0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialParameterCollection*           MaterialParameterCollection;                       // 0x00C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void()>              OnTrackingCameraChange;                            // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_E0[0x18];                                      // 0x00E0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DisableCameraComponent();
	void EnableCameraComponent();
	void Initialise(const struct FTrackingCameraInitStruct& initStruct);
	void Stop();

	bool IsCameraActive() const;
	bool IsCameraAvailable() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TrackingCameraComponent">();
	}
	static class UTrackingCameraComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTrackingCameraComponent>();
	}
};
static_assert(alignof(UTrackingCameraComponent) == 0x000008, "Wrong alignment on UTrackingCameraComponent");
static_assert(sizeof(UTrackingCameraComponent) == 0x0000F8, "Wrong size on UTrackingCameraComponent");
static_assert(offsetof(UTrackingCameraComponent, OnSceneCaptureVisibilityChange) == 0x0000A0, "Member 'UTrackingCameraComponent::OnSceneCaptureVisibilityChange' has a wrong offset!");
static_assert(offsetof(UTrackingCameraComponent, ZoomSpeed) == 0x0000B0, "Member 'UTrackingCameraComponent::ZoomSpeed' has a wrong offset!");
static_assert(offsetof(UTrackingCameraComponent, TrackingComponent) == 0x0000B8, "Member 'UTrackingCameraComponent::TrackingComponent' has a wrong offset!");
static_assert(offsetof(UTrackingCameraComponent, CaptureComponent) == 0x0000C0, "Member 'UTrackingCameraComponent::CaptureComponent' has a wrong offset!");
static_assert(offsetof(UTrackingCameraComponent, MaterialParameterCollection) == 0x0000C8, "Member 'UTrackingCameraComponent::MaterialParameterCollection' has a wrong offset!");
static_assert(offsetof(UTrackingCameraComponent, OnTrackingCameraChange) == 0x0000D0, "Member 'UTrackingCameraComponent::OnTrackingCameraChange' has a wrong offset!");

// Class ReadyOrNot.TrailerSearchAndSecureActivity
// 0x0050 (0x0240 - 0x01F0)
class UTrailerSearchAndSecureActivity final : public UBaseActivity
{
public:
	TArray<class AActor*>                         AllSecurables;                                     // 0x01F0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_200[0x38];                                     // 0x0200(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ClosestSecurable;                                  // 0x0238(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TrailerSearchAndSecureActivity">();
	}
	static class UTrailerSearchAndSecureActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTrailerSearchAndSecureActivity>();
	}
};
static_assert(alignof(UTrailerSearchAndSecureActivity) == 0x000008, "Wrong alignment on UTrailerSearchAndSecureActivity");
static_assert(sizeof(UTrailerSearchAndSecureActivity) == 0x000240, "Wrong size on UTrailerSearchAndSecureActivity");
static_assert(offsetof(UTrailerSearchAndSecureActivity, AllSecurables) == 0x0001F0, "Member 'UTrailerSearchAndSecureActivity::AllSecurables' has a wrong offset!");
static_assert(offsetof(UTrailerSearchAndSecureActivity, ClosestSecurable) == 0x000238, "Member 'UTrailerSearchAndSecureActivity::ClosestSecurable' has a wrong offset!");

// Class ReadyOrNot.TrailerSWATCharacter
// 0x0000 (0x25A0 - 0x25A0)
class ATrailerSWATCharacter final : public ASWATCharacter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TrailerSWATCharacter">();
	}
	static class ATrailerSWATCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATrailerSWATCharacter>();
	}
};
static_assert(alignof(ATrailerSWATCharacter) == 0x000010, "Wrong alignment on ATrailerSWATCharacter");
static_assert(sizeof(ATrailerSWATCharacter) == 0x0025A0, "Wrong size on ATrailerSWATCharacter");

// Class ReadyOrNot.TrainingGM
// 0x0080 (0x09F0 - 0x0970)
class ATrainingGM final : public AReadyOrNotGameMode
{
public:
	TArray<class AReadyOrNotPlayerController*>    InitalizedPlayerControllers;                       // 0x0970(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	class UCommanderProfile*                      CommanderProfile;                                  // 0x0980(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_988[0x8];                                      // 0x0988(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(bool bSuccess)> OnTrainingEnded;                                   // 0x0990(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	class FString                                 SwatSpawnTag;                                      // 0x09A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACyberneticCharacter>       SWATAIClass;                                       // 0x09B0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AAIController>              FriendlyAIController;                              // 0x09B8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ASWATCharacter*>                 SpawnedSWATAI;                                     // 0x09C0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class AActivityTriggerVolume*>         ActiveTriggerVolumes;                              // 0x09D0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class ACheckpointActivityTriggerVolume*       CurrentCheckpoint;                                 // 0x09E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9E8[0x8];                                      // 0x09E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FriendlyAIKilled(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter);
	void RemoveAllSpawnedAI();
	void ReturnToStation();
	void SpawnPolice(const bool bSpawnWithPlayer);
	void TrainingEnd(bool bSuccess);

	bool IsCommanderProfileTraining() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TrainingGM">();
	}
	static class ATrainingGM* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATrainingGM>();
	}
};
static_assert(alignof(ATrainingGM) == 0x000010, "Wrong alignment on ATrainingGM");
static_assert(sizeof(ATrainingGM) == 0x0009F0, "Wrong size on ATrainingGM");
static_assert(offsetof(ATrainingGM, InitalizedPlayerControllers) == 0x000970, "Member 'ATrainingGM::InitalizedPlayerControllers' has a wrong offset!");
static_assert(offsetof(ATrainingGM, CommanderProfile) == 0x000980, "Member 'ATrainingGM::CommanderProfile' has a wrong offset!");
static_assert(offsetof(ATrainingGM, OnTrainingEnded) == 0x000990, "Member 'ATrainingGM::OnTrainingEnded' has a wrong offset!");
static_assert(offsetof(ATrainingGM, SwatSpawnTag) == 0x0009A0, "Member 'ATrainingGM::SwatSpawnTag' has a wrong offset!");
static_assert(offsetof(ATrainingGM, SWATAIClass) == 0x0009B0, "Member 'ATrainingGM::SWATAIClass' has a wrong offset!");
static_assert(offsetof(ATrainingGM, FriendlyAIController) == 0x0009B8, "Member 'ATrainingGM::FriendlyAIController' has a wrong offset!");
static_assert(offsetof(ATrainingGM, SpawnedSWATAI) == 0x0009C0, "Member 'ATrainingGM::SpawnedSWATAI' has a wrong offset!");
static_assert(offsetof(ATrainingGM, ActiveTriggerVolumes) == 0x0009D0, "Member 'ATrainingGM::ActiveTriggerVolumes' has a wrong offset!");
static_assert(offsetof(ATrainingGM, CurrentCheckpoint) == 0x0009E0, "Member 'ATrainingGM::CurrentCheckpoint' has a wrong offset!");

// Class ReadyOrNot.TrainingTarget
// 0x0038 (0x02D0 - 0x0298)
class ATrainingTarget final : public AActor
{
public:
	class UStaticMeshComponent*                   TargetMesh;                                        // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          SuccessBox;                                        // 0x02A0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          FailureBox;                                        // 0x02A8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void(class ATrainingTarget* Target)> OnSuccessfulShot;                  // 0x02B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ATrainingTarget* Target)> OnGrenadeHit;                      // 0x02C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void OnPointDamage(class AActor* DamagedActor, float Damage, class AController* InstigatedBy, const struct FVector& HitLocation, class UPrimitiveComponent* FHitComponent, class FName BoneName, const struct FVector& ShotFromDirection, const class UDamageType* DamageType, class AActor* DamageCauser);
	void OnRadialDamage(class AActor* DamagedActor, float Damage, const class UDamageType* DamageType, const struct FVector& Origin, const struct FHitResult& HitInfo, class AController* InstigatedBy, class AActor* DamageCauser);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TrainingTarget">();
	}
	static class ATrainingTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATrainingTarget>();
	}
};
static_assert(alignof(ATrainingTarget) == 0x000008, "Wrong alignment on ATrainingTarget");
static_assert(sizeof(ATrainingTarget) == 0x0002D0, "Wrong size on ATrainingTarget");
static_assert(offsetof(ATrainingTarget, TargetMesh) == 0x000298, "Member 'ATrainingTarget::TargetMesh' has a wrong offset!");
static_assert(offsetof(ATrainingTarget, SuccessBox) == 0x0002A0, "Member 'ATrainingTarget::SuccessBox' has a wrong offset!");
static_assert(offsetof(ATrainingTarget, FailureBox) == 0x0002A8, "Member 'ATrainingTarget::FailureBox' has a wrong offset!");
static_assert(offsetof(ATrainingTarget, OnSuccessfulShot) == 0x0002B0, "Member 'ATrainingTarget::OnSuccessfulShot' has a wrong offset!");
static_assert(offsetof(ATrainingTarget, OnGrenadeHit) == 0x0002C0, "Member 'ATrainingTarget::OnGrenadeHit' has a wrong offset!");

// Class ReadyOrNot.TrapActor
// 0x00D0 (0x0368 - 0x0298)
class ATrapActor : public AActor
{
public:
	uint8                                         Pad_298[0x28];                                     // 0x0298(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   TrapMeshComponent;                                 // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODAudioComponent*                    TrapActivateAudioComponent;                        // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractableComponent*                 InteractableComponent;                             // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UScoringComponent*                      ScoringComponent;                                  // 0x02D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USplineComponent*                       SplineComponent;                                   // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCableComponent*                        CutCableComponent1;                                // 0x02E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCableComponent*                        CutCableComponent2;                                // 0x02F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          TripWireTriggerComponent;                          // 0x02F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAIPerceptionStimuliSourceComponent*    PerceptionStimuliComp;                             // 0x0300(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        TrapRoot;                                          // 0x0308(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 AttachedActor;                                     // 0x0310(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TrapName;                                          // 0x0318(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETrapType                                     TrapType;                                          // 0x0328(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETrapState                                    TrapStatus;                                        // 0x0329(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanUseMultitoolWhenActivated;                     // 0x032A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInitializeTrapOnBeginPlay;                        // 0x032B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32C[0x4];                                      // 0x032C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            CableMesh;                                         // 0x0330(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     CableMaterial;                                     // 0x0338(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ATrapActor* Trap, class AReadyOrNotCharacter* TriggeredBy)> TrapTriggered; // 0x0340(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UForceFeedbackEffect*                   ForceFeedbackEffect;                               // 0x0350(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UForceFeedbackAttenuation*              ForceFeedbackAttenuation;                          // 0x0358(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_360[0x8];                                      // 0x0360(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Multicast_OnTrapDisarmed();
	void Multicast_OnTrapTriggered(class AReadyOrNotCharacter* TriggeredBy);
	void OnTrapDisarmed(class AReadyOrNotCharacter* DisarmedBy);
	void OnTrapTriggered(class AReadyOrNotCharacter* TriggeredBy);
	void Server_OnTrapDisarmed();
	void Server_OnTrapTriggered(class AReadyOrNotCharacter* TriggeredBy);
	void TrapDeInit();
	void TrapInit();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TrapActor">();
	}
	static class ATrapActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATrapActor>();
	}
};
static_assert(alignof(ATrapActor) == 0x000008, "Wrong alignment on ATrapActor");
static_assert(sizeof(ATrapActor) == 0x000368, "Wrong size on ATrapActor");
static_assert(offsetof(ATrapActor, TrapMeshComponent) == 0x0002C0, "Member 'ATrapActor::TrapMeshComponent' has a wrong offset!");
static_assert(offsetof(ATrapActor, TrapActivateAudioComponent) == 0x0002C8, "Member 'ATrapActor::TrapActivateAudioComponent' has a wrong offset!");
static_assert(offsetof(ATrapActor, InteractableComponent) == 0x0002D0, "Member 'ATrapActor::InteractableComponent' has a wrong offset!");
static_assert(offsetof(ATrapActor, ScoringComponent) == 0x0002D8, "Member 'ATrapActor::ScoringComponent' has a wrong offset!");
static_assert(offsetof(ATrapActor, SplineComponent) == 0x0002E0, "Member 'ATrapActor::SplineComponent' has a wrong offset!");
static_assert(offsetof(ATrapActor, CutCableComponent1) == 0x0002E8, "Member 'ATrapActor::CutCableComponent1' has a wrong offset!");
static_assert(offsetof(ATrapActor, CutCableComponent2) == 0x0002F0, "Member 'ATrapActor::CutCableComponent2' has a wrong offset!");
static_assert(offsetof(ATrapActor, TripWireTriggerComponent) == 0x0002F8, "Member 'ATrapActor::TripWireTriggerComponent' has a wrong offset!");
static_assert(offsetof(ATrapActor, PerceptionStimuliComp) == 0x000300, "Member 'ATrapActor::PerceptionStimuliComp' has a wrong offset!");
static_assert(offsetof(ATrapActor, TrapRoot) == 0x000308, "Member 'ATrapActor::TrapRoot' has a wrong offset!");
static_assert(offsetof(ATrapActor, AttachedActor) == 0x000310, "Member 'ATrapActor::AttachedActor' has a wrong offset!");
static_assert(offsetof(ATrapActor, TrapName) == 0x000318, "Member 'ATrapActor::TrapName' has a wrong offset!");
static_assert(offsetof(ATrapActor, TrapType) == 0x000328, "Member 'ATrapActor::TrapType' has a wrong offset!");
static_assert(offsetof(ATrapActor, TrapStatus) == 0x000329, "Member 'ATrapActor::TrapStatus' has a wrong offset!");
static_assert(offsetof(ATrapActor, bCanUseMultitoolWhenActivated) == 0x00032A, "Member 'ATrapActor::bCanUseMultitoolWhenActivated' has a wrong offset!");
static_assert(offsetof(ATrapActor, bInitializeTrapOnBeginPlay) == 0x00032B, "Member 'ATrapActor::bInitializeTrapOnBeginPlay' has a wrong offset!");
static_assert(offsetof(ATrapActor, CableMesh) == 0x000330, "Member 'ATrapActor::CableMesh' has a wrong offset!");
static_assert(offsetof(ATrapActor, CableMaterial) == 0x000338, "Member 'ATrapActor::CableMaterial' has a wrong offset!");
static_assert(offsetof(ATrapActor, TrapTriggered) == 0x000340, "Member 'ATrapActor::TrapTriggered' has a wrong offset!");
static_assert(offsetof(ATrapActor, ForceFeedbackEffect) == 0x000350, "Member 'ATrapActor::ForceFeedbackEffect' has a wrong offset!");
static_assert(offsetof(ATrapActor, ForceFeedbackAttenuation) == 0x000358, "Member 'ATrapActor::ForceFeedbackAttenuation' has a wrong offset!");

// Class ReadyOrNot.TrapActorAttachedToDoor
// 0x0098 (0x0400 - 0x0368)
class ATrapActorAttachedToDoor : public ATrapActor
{
public:
	class ADoor*                                  AttachedToDoor;                                    // 0x0368(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WireYPosition;                                     // 0x0370(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_374[0xC];                                      // 0x0374(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             CableTransform;                                    // 0x0380(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class USplineMeshComponent*>           CableMeshComponents;                               // 0x03E0(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	float                                         CurveStrength;                                     // 0x03F0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MappedSplineLocation;                              // 0x03F4(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bChunk1Destroyed : 1;                              // 0x03F8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bChunk2Destroyed : 1;                              // 0x03F8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bSubdoorChunk1Destroyed : 1;                       // 0x03F8(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bSubdoorChunk2Destroyed : 1;                       // 0x03F8(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_3F9[0x7];                                      // 0x03F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TrapActorAttachedToDoor">();
	}
	static class ATrapActorAttachedToDoor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATrapActorAttachedToDoor>();
	}
};
static_assert(alignof(ATrapActorAttachedToDoor) == 0x000010, "Wrong alignment on ATrapActorAttachedToDoor");
static_assert(sizeof(ATrapActorAttachedToDoor) == 0x000400, "Wrong size on ATrapActorAttachedToDoor");
static_assert(offsetof(ATrapActorAttachedToDoor, AttachedToDoor) == 0x000368, "Member 'ATrapActorAttachedToDoor::AttachedToDoor' has a wrong offset!");
static_assert(offsetof(ATrapActorAttachedToDoor, WireYPosition) == 0x000370, "Member 'ATrapActorAttachedToDoor::WireYPosition' has a wrong offset!");
static_assert(offsetof(ATrapActorAttachedToDoor, CableTransform) == 0x000380, "Member 'ATrapActorAttachedToDoor::CableTransform' has a wrong offset!");
static_assert(offsetof(ATrapActorAttachedToDoor, CableMeshComponents) == 0x0003E0, "Member 'ATrapActorAttachedToDoor::CableMeshComponents' has a wrong offset!");
static_assert(offsetof(ATrapActorAttachedToDoor, CurveStrength) == 0x0003F0, "Member 'ATrapActorAttachedToDoor::CurveStrength' has a wrong offset!");
static_assert(offsetof(ATrapActorAttachedToDoor, MappedSplineLocation) == 0x0003F4, "Member 'ATrapActorAttachedToDoor::MappedSplineLocation' has a wrong offset!");

// Class ReadyOrNot.TraverseHoleActivity
// 0x0110 (0x0300 - 0x01F0)
class alignas(0x10) UTraverseHoleActivity final : public UBaseActivity
{
public:
	class AWallHoleTraversal*                     WallHoleTraversalActor;                            // 0x01F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, NoDestructor, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIgnoreCooldown : 1;                               // 0x01F8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, DisableEditOnTemplate, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFromNavLink : 1;                                  // 0x01F8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, DisableEditOnTemplate, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1F9[0x7];                                      // 0x01F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           EntryAnim;                                         // 0x0200(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           ExitAnim;                                          // 0x0208(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           LoopAnim;                                          // 0x0210(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_218[0xE8];                                     // 0x0218(0x00E8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Enter_EnterHole_State();
	void Enter_ExitHole_State();
	void Enter_Move_State();
	void Enter_MoveToHole_State();
	void Tick_EnterHole_State(float DeltaTime, float Uptime);
	void Tick_ExitHole_State(float DeltaTime, float Uptime);
	void Tick_Move_State(float DeltaTime, float Uptime);
	void Tick_MoveToHole_State(float DeltaTime, float Uptime);

	bool CanEnterHole() const;
	bool CanExitHole() const;
	bool ShouldMove() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TraverseHoleActivity">();
	}
	static class UTraverseHoleActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTraverseHoleActivity>();
	}
};
static_assert(alignof(UTraverseHoleActivity) == 0x000010, "Wrong alignment on UTraverseHoleActivity");
static_assert(sizeof(UTraverseHoleActivity) == 0x000300, "Wrong size on UTraverseHoleActivity");
static_assert(offsetof(UTraverseHoleActivity, WallHoleTraversalActor) == 0x0001F0, "Member 'UTraverseHoleActivity::WallHoleTraversalActor' has a wrong offset!");
static_assert(offsetof(UTraverseHoleActivity, EntryAnim) == 0x000200, "Member 'UTraverseHoleActivity::EntryAnim' has a wrong offset!");
static_assert(offsetof(UTraverseHoleActivity, ExitAnim) == 0x000208, "Member 'UTraverseHoleActivity::ExitAnim' has a wrong offset!");
static_assert(offsetof(UTraverseHoleActivity, LoopAnim) == 0x000210, "Member 'UTraverseHoleActivity::LoopAnim' has a wrong offset!");

// Class ReadyOrNot.TugOfWarButton
// 0x0048 (0x0338 - 0x02F0)
class ATugOfWarButton final : public AInteractionActor
{
public:
	ETeamType                                     OnlyTeamUse;                                       // 0x02F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F1[0x7];                                      // 0x02F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ATugOfWarMover*                         Mover;                                             // 0x02F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerCharacter*                       CurrentUser;                                       // 0x0300(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_308[0x30];                                     // 0x0308(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnInfluencerArrested(class APlayerCharacter* ArrestedCharacter, class APlayerCharacter* InstigatorCharacter);
	void OnInfluencerKilled(class AActor* Causer, class ACharacter* InstigatorCharacter, class ACharacter* KilledCharacter, const struct FDamageEvent& DamageEvent, class APlayerState* LastPlayerState);
	void OnInfluencerStunned(class APlayerCharacter* StunnedCharacter, float Duration, EStunType StunType, class AActor* DamageCauser);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TugOfWarButton">();
	}
	static class ATugOfWarButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATugOfWarButton>();
	}
};
static_assert(alignof(ATugOfWarButton) == 0x000008, "Wrong alignment on ATugOfWarButton");
static_assert(sizeof(ATugOfWarButton) == 0x000338, "Wrong size on ATugOfWarButton");
static_assert(offsetof(ATugOfWarButton, OnlyTeamUse) == 0x0002F0, "Member 'ATugOfWarButton::OnlyTeamUse' has a wrong offset!");
static_assert(offsetof(ATugOfWarButton, Mover) == 0x0002F8, "Member 'ATugOfWarButton::Mover' has a wrong offset!");
static_assert(offsetof(ATugOfWarButton, CurrentUser) == 0x000300, "Member 'ATugOfWarButton::CurrentUser' has a wrong offset!");

// Class ReadyOrNot.TugOfWarGM
// 0x0040 (0x0A10 - 0x09D0)
class ATugOfWarGM final : public AReadyOrNotGameMode_PVP
{
public:
	TArray<class APlayerCharacter*>               ArrestedBlueCharacters;                            // 0x09D0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class APlayerCharacter*>               ArrestedRedCharacters;                             // 0x09E0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class UFMODEvent*                             TOWVictorySound;                                   // 0x09F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             MatchLoopMusic;                                    // 0x09F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             MatchStartMusic;                                   // 0x0A00(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             MatchEndMusic;                                     // 0x0A08(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TugOfWarGM">();
	}
	static class ATugOfWarGM* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATugOfWarGM>();
	}
};
static_assert(alignof(ATugOfWarGM) == 0x000010, "Wrong alignment on ATugOfWarGM");
static_assert(sizeof(ATugOfWarGM) == 0x000A10, "Wrong size on ATugOfWarGM");
static_assert(offsetof(ATugOfWarGM, ArrestedBlueCharacters) == 0x0009D0, "Member 'ATugOfWarGM::ArrestedBlueCharacters' has a wrong offset!");
static_assert(offsetof(ATugOfWarGM, ArrestedRedCharacters) == 0x0009E0, "Member 'ATugOfWarGM::ArrestedRedCharacters' has a wrong offset!");
static_assert(offsetof(ATugOfWarGM, TOWVictorySound) == 0x0009F0, "Member 'ATugOfWarGM::TOWVictorySound' has a wrong offset!");
static_assert(offsetof(ATugOfWarGM, MatchLoopMusic) == 0x0009F8, "Member 'ATugOfWarGM::MatchLoopMusic' has a wrong offset!");
static_assert(offsetof(ATugOfWarGM, MatchStartMusic) == 0x000A00, "Member 'ATugOfWarGM::MatchStartMusic' has a wrong offset!");
static_assert(offsetof(ATugOfWarGM, MatchEndMusic) == 0x000A08, "Member 'ATugOfWarGM::MatchEndMusic' has a wrong offset!");

// Class ReadyOrNot.TugOfWarMover
// 0x0048 (0x02E0 - 0x0298)
class ATugOfWarMover final : public AActor
{
public:
	class USplineComponent*                       MoverPath;                                         // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 MoverMesh;                                         // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A8[0x10];                                     // 0x02A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MoverSpeed;                                        // 0x02B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvertVictoryPositions;                           // 0x02BC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMoverForward;                                     // 0x02BD(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMoverMoving;                                      // 0x02BE(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BF[0x1];                                      // 0x02BF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MoverStartingPosition;                             // 0x02C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoverCurrentPosition;                              // 0x02C4(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bContested;                                        // 0x02C8(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C9[0x7];                                      // 0x02C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class APlayerCharacter*>               Influencers;                                       // 0x02D0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TugOfWarMover">();
	}
	static class ATugOfWarMover* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATugOfWarMover>();
	}
};
static_assert(alignof(ATugOfWarMover) == 0x000008, "Wrong alignment on ATugOfWarMover");
static_assert(sizeof(ATugOfWarMover) == 0x0002E0, "Wrong size on ATugOfWarMover");
static_assert(offsetof(ATugOfWarMover, MoverPath) == 0x000298, "Member 'ATugOfWarMover::MoverPath' has a wrong offset!");
static_assert(offsetof(ATugOfWarMover, MoverMesh) == 0x0002A0, "Member 'ATugOfWarMover::MoverMesh' has a wrong offset!");
static_assert(offsetof(ATugOfWarMover, MoverSpeed) == 0x0002B8, "Member 'ATugOfWarMover::MoverSpeed' has a wrong offset!");
static_assert(offsetof(ATugOfWarMover, bInvertVictoryPositions) == 0x0002BC, "Member 'ATugOfWarMover::bInvertVictoryPositions' has a wrong offset!");
static_assert(offsetof(ATugOfWarMover, bMoverForward) == 0x0002BD, "Member 'ATugOfWarMover::bMoverForward' has a wrong offset!");
static_assert(offsetof(ATugOfWarMover, bMoverMoving) == 0x0002BE, "Member 'ATugOfWarMover::bMoverMoving' has a wrong offset!");
static_assert(offsetof(ATugOfWarMover, MoverStartingPosition) == 0x0002C0, "Member 'ATugOfWarMover::MoverStartingPosition' has a wrong offset!");
static_assert(offsetof(ATugOfWarMover, MoverCurrentPosition) == 0x0002C4, "Member 'ATugOfWarMover::MoverCurrentPosition' has a wrong offset!");
static_assert(offsetof(ATugOfWarMover, bContested) == 0x0002C8, "Member 'ATugOfWarMover::bContested' has a wrong offset!");
static_assert(offsetof(ATugOfWarMover, Influencers) == 0x0002D0, "Member 'ATugOfWarMover::Influencers' has a wrong offset!");

// Class ReadyOrNot.TugOfWarZone
// 0x0048 (0x02E0 - 0x0298)
class ATugOfWarZone final : public AActor
{
public:
	bool                                          bZoneDisabled;                                     // 0x0298(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_299[0x7];                                      // 0x0299(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ATugOfWarMover*                         Mover;                                             // 0x02A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          Bounds;                                            // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B0[0x30];                                     // 0x02B0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnInfluencerArrested(class APlayerCharacter* ArrestedCharacter, class APlayerCharacter* InstigatorCharacter);
	void OnInfluencerKilled(class AActor* Causer, class ACharacter* InstigatorCharacter, class ACharacter* KilledCharacter, const struct FDamageEvent& DamageEvent, class APlayerState* LastPlayerState);
	void OnOverlapBegin(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnOverlapEnd(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TugOfWarZone">();
	}
	static class ATugOfWarZone* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATugOfWarZone>();
	}
};
static_assert(alignof(ATugOfWarZone) == 0x000008, "Wrong alignment on ATugOfWarZone");
static_assert(sizeof(ATugOfWarZone) == 0x0002E0, "Wrong size on ATugOfWarZone");
static_assert(offsetof(ATugOfWarZone, bZoneDisabled) == 0x000298, "Member 'ATugOfWarZone::bZoneDisabled' has a wrong offset!");
static_assert(offsetof(ATugOfWarZone, Mover) == 0x0002A0, "Member 'ATugOfWarZone::Mover' has a wrong offset!");
static_assert(offsetof(ATugOfWarZone, Bounds) == 0x0002A8, "Member 'ATugOfWarZone::Bounds' has a wrong offset!");

// Class ReadyOrNot.TutorialGS
// 0x0480 (0x0E88 - 0x0A08)
class ATutorialGS : public ACoopGS
{
public:
	struct FTutorialMissionData                   CurrentTutorialData;                               // 0x0A08(0x0300)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UWorld>                  TutorialMenuLevel;                                 // 0x0D08(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULevelStreaming*                        TutorialMenuStreamedLevel;                         // 0x0D30(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULevelStreaming*                        CurrentTutorialStreamedLevel;                      // 0x0D38(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UWorld>                  ShootingRangeLevel;                                // 0x0D40(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UWorld>                  KillHouseLevel;                                    // 0x0D68(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UWorld>                  BasicControlsLevel;                                // 0x0D90(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UWorld>                  MirrorgunLevel;                                    // 0x0DB8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UWorld>                  StackUpLevel;                                      // 0x0DE0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UWorld>                  ArrestLevel;                                       // 0x0E08(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UWorld>                  GrenadesLevel;                                     // 0x0E30(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UWorld>                  MovementLevel;                                     // 0x0E58(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E80[0x2];                                      // 0x0E80(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bFinishedUsingTutorialMenu;                        // 0x0E82(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E83[0x5];                                      // 0x0E83(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TSoftObjectPtr<class UWorld> GetCurrentTutorialStreamedLevel();
	void OnPostUpdateSwatCommands(class USwatCommandWidget* Widget, TArray<struct FSwatCommand>* SwatCommands);
	void SetCurrentTutorialData(const struct FTutorialMissionData& TutorialData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialGS">();
	}
	static class ATutorialGS* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATutorialGS>();
	}
};
static_assert(alignof(ATutorialGS) == 0x000008, "Wrong alignment on ATutorialGS");
static_assert(sizeof(ATutorialGS) == 0x000E88, "Wrong size on ATutorialGS");
static_assert(offsetof(ATutorialGS, CurrentTutorialData) == 0x000A08, "Member 'ATutorialGS::CurrentTutorialData' has a wrong offset!");
static_assert(offsetof(ATutorialGS, TutorialMenuLevel) == 0x000D08, "Member 'ATutorialGS::TutorialMenuLevel' has a wrong offset!");
static_assert(offsetof(ATutorialGS, TutorialMenuStreamedLevel) == 0x000D30, "Member 'ATutorialGS::TutorialMenuStreamedLevel' has a wrong offset!");
static_assert(offsetof(ATutorialGS, CurrentTutorialStreamedLevel) == 0x000D38, "Member 'ATutorialGS::CurrentTutorialStreamedLevel' has a wrong offset!");
static_assert(offsetof(ATutorialGS, ShootingRangeLevel) == 0x000D40, "Member 'ATutorialGS::ShootingRangeLevel' has a wrong offset!");
static_assert(offsetof(ATutorialGS, KillHouseLevel) == 0x000D68, "Member 'ATutorialGS::KillHouseLevel' has a wrong offset!");
static_assert(offsetof(ATutorialGS, BasicControlsLevel) == 0x000D90, "Member 'ATutorialGS::BasicControlsLevel' has a wrong offset!");
static_assert(offsetof(ATutorialGS, MirrorgunLevel) == 0x000DB8, "Member 'ATutorialGS::MirrorgunLevel' has a wrong offset!");
static_assert(offsetof(ATutorialGS, StackUpLevel) == 0x000DE0, "Member 'ATutorialGS::StackUpLevel' has a wrong offset!");
static_assert(offsetof(ATutorialGS, ArrestLevel) == 0x000E08, "Member 'ATutorialGS::ArrestLevel' has a wrong offset!");
static_assert(offsetof(ATutorialGS, GrenadesLevel) == 0x000E30, "Member 'ATutorialGS::GrenadesLevel' has a wrong offset!");
static_assert(offsetof(ATutorialGS, MovementLevel) == 0x000E58, "Member 'ATutorialGS::MovementLevel' has a wrong offset!");
static_assert(offsetof(ATutorialGS, bFinishedUsingTutorialMenu) == 0x000E82, "Member 'ATutorialGS::bFinishedUsingTutorialMenu' has a wrong offset!");

// Class ReadyOrNot.TutorialMessageVolume
// 0x0050 (0x0318 - 0x02C8)
class ATutorialMessageVolume final : public AReadyOrNotTriggerVolume
{
public:
	class FString                                 MessageMapID;                                      // 0x02C8(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsBigPopUp;                                       // 0x02D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasDisplayedMessage;                              // 0x02D9(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DA[0x6];                                      // 0x02DA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   MessageTitle;                                      // 0x02E0(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<class FText>                           MessageContent;                                    // 0x02F8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTutorialActionPromptSlot>      MessageActions;                                    // 0x0308(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void GenerateMessageContent();
	void TutorialBoxBeginOverlap(class AActor* ThisActor, class AActor* OtherActor);
	void TutorialBoxEndOverlap(class AActor* ThisActor, class AActor* OtherActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialMessageVolume">();
	}
	static class ATutorialMessageVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATutorialMessageVolume>();
	}
};
static_assert(alignof(ATutorialMessageVolume) == 0x000008, "Wrong alignment on ATutorialMessageVolume");
static_assert(sizeof(ATutorialMessageVolume) == 0x000318, "Wrong size on ATutorialMessageVolume");
static_assert(offsetof(ATutorialMessageVolume, MessageMapID) == 0x0002C8, "Member 'ATutorialMessageVolume::MessageMapID' has a wrong offset!");
static_assert(offsetof(ATutorialMessageVolume, bIsBigPopUp) == 0x0002D8, "Member 'ATutorialMessageVolume::bIsBigPopUp' has a wrong offset!");
static_assert(offsetof(ATutorialMessageVolume, bHasDisplayedMessage) == 0x0002D9, "Member 'ATutorialMessageVolume::bHasDisplayedMessage' has a wrong offset!");
static_assert(offsetof(ATutorialMessageVolume, MessageTitle) == 0x0002E0, "Member 'ATutorialMessageVolume::MessageTitle' has a wrong offset!");
static_assert(offsetof(ATutorialMessageVolume, MessageContent) == 0x0002F8, "Member 'ATutorialMessageVolume::MessageContent' has a wrong offset!");
static_assert(offsetof(ATutorialMessageVolume, MessageActions) == 0x000308, "Member 'ATutorialMessageVolume::MessageActions' has a wrong offset!");

// Class ReadyOrNot.TutorialTextPrompt_Widget
// 0x0000 (0x02C0 - 0x02C0)
class UTutorialTextPrompt_Widget : public UUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialTextPrompt_Widget">();
	}
	static class UTutorialTextPrompt_Widget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTutorialTextPrompt_Widget>();
	}
};
static_assert(alignof(UTutorialTextPrompt_Widget) == 0x000008, "Wrong alignment on UTutorialTextPrompt_Widget");
static_assert(sizeof(UTutorialTextPrompt_Widget) == 0x0002C0, "Wrong size on UTutorialTextPrompt_Widget");

// Class ReadyOrNot.TutorialWidget
// 0x0090 (0x04A0 - 0x0410)
class UTutorialWidget : public UCommonActivatableWidget
{
public:
	bool                                          bShowFooter;                                       // 0x0410(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUsingGamepad;                                     // 0x0411(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_412[0x6];                                      // 0x0412(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DescriptionIconSize;                               // 0x0418(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_428[0x78];                                     // 0x0428(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HideMainWidget();
	void OnInputMethodChanged(const ECommonInputType InputMethod);
	void RefreshWidget(ECommonInputType InputType);
	void SetData(const struct FTutorialWidgetData& InData);
	void ShowMainWidget();

	class FText GetDescription() const;
	class FText GetTitle() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialWidget">();
	}
	static class UTutorialWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTutorialWidget>();
	}
};
static_assert(alignof(UTutorialWidget) == 0x000008, "Wrong alignment on UTutorialWidget");
static_assert(sizeof(UTutorialWidget) == 0x0004A0, "Wrong size on UTutorialWidget");
static_assert(offsetof(UTutorialWidget, bShowFooter) == 0x000410, "Member 'UTutorialWidget::bShowFooter' has a wrong offset!");
static_assert(offsetof(UTutorialWidget, bUsingGamepad) == 0x000411, "Member 'UTutorialWidget::bUsingGamepad' has a wrong offset!");
static_assert(offsetof(UTutorialWidget, DescriptionIconSize) == 0x000418, "Member 'UTutorialWidget::DescriptionIconSize' has a wrong offset!");

// Class ReadyOrNot.UseabilityInterface
// 0x0000 (0x0000 - 0x0000)
class IUseabilityInterface final
{
public:
	void DoubleTapInteract(class AReadyOrNotCharacter* InteractInstigator, class UInteractableComponent* InInteractableComponent);
	void EndFire(class AReadyOrNotCharacter* InteractInstigator, class UInteractableComponent* InInteractableComponent);
	void EndInteract(class AReadyOrNotCharacter* InteractInstigator, class UInteractableComponent* InInteractableComponent);
	void Fire(class AReadyOrNotCharacter* InteractInstigator, class UInteractableComponent* InInteractableComponent);
	void Interact(class AReadyOrNotCharacter* InteractInstigator, class UInteractableComponent* InInteractableComponent);
	void MeleeInteract(class AReadyOrNotCharacter* InteractInstigator, class UInteractableComponent* InInteractableComponent);
	void OnFocusGain(class AReadyOrNotCharacter* InteractInstigator, class UInteractableComponent* InInteractableComponent);
	void OnFocusLost(class AReadyOrNotCharacter* InteractInstigator, class UInteractableComponent* InInteractableComponent);

	bool CanInteract() const;
	bool CanInteractThroughHitActors(const struct FHitResult& Hit) const;
	class FText DetermineActionText() const;
	class FName DetermineAnimatedIcon() const;
	float DetermineCurrentProgress() const;
	EInputEvent DetermineInputEvent() const;
	float DetermineInteractionDistance() const;
	class UInteractableComponent* GetInteractableComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UseabilityInterface">();
	}
	static class IUseabilityInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IUseabilityInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IUseabilityInterface) == 0x000001, "Wrong alignment on IUseabilityInterface");
static_assert(sizeof(IUseabilityInterface) == 0x000001, "Wrong size on IUseabilityInterface");

// Class ReadyOrNot.VIPEscortGM
// 0x0050 (0x0A20 - 0x09D0)
class AVIPEscortGM final : public AReadyOrNotGameMode_PVP
{
public:
	TMulticastInlineDelegate<void(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter)> OnVIPKilled; // 0x09D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ACharacter* Freed, class ACharacter* Freer)> OnVIPFreed;     // 0x09E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class APlayerController*                      VIPPlayer;                                         // 0x09F0(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerStart_VIP_Spawn*                 ChosenVIPSpawn;                                    // 0x09F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class APlayerCharacter>           VIPCharacterClass;                                 // 0x0A00(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   VIPSpawnTag;                                       // 0x0A08(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeToDeliverVIP;                                  // 0x0A10(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HostageHoldTime;                                   // 0x0A14(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A18[0x8];                                      // 0x0A18(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsVIPAlive();
	bool IsVIPArrested();
	bool IsVIPDead();
	void VIPFreed(class ACharacter* Freed, class ACharacter* Freer);
	void VIPKilled(class AReadyOrNotCharacter* InstigatorCharacter, class AReadyOrNotCharacter* KilledCharacter);

	ETeamType GetCurrentVIPTeam() const;
	class APlayerCharacter* GetVIPCharacter() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VIPEscortGM">();
	}
	static class AVIPEscortGM* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVIPEscortGM>();
	}
};
static_assert(alignof(AVIPEscortGM) == 0x000010, "Wrong alignment on AVIPEscortGM");
static_assert(sizeof(AVIPEscortGM) == 0x000A20, "Wrong size on AVIPEscortGM");
static_assert(offsetof(AVIPEscortGM, OnVIPKilled) == 0x0009D0, "Member 'AVIPEscortGM::OnVIPKilled' has a wrong offset!");
static_assert(offsetof(AVIPEscortGM, OnVIPFreed) == 0x0009E0, "Member 'AVIPEscortGM::OnVIPFreed' has a wrong offset!");
static_assert(offsetof(AVIPEscortGM, VIPPlayer) == 0x0009F0, "Member 'AVIPEscortGM::VIPPlayer' has a wrong offset!");
static_assert(offsetof(AVIPEscortGM, ChosenVIPSpawn) == 0x0009F8, "Member 'AVIPEscortGM::ChosenVIPSpawn' has a wrong offset!");
static_assert(offsetof(AVIPEscortGM, VIPCharacterClass) == 0x000A00, "Member 'AVIPEscortGM::VIPCharacterClass' has a wrong offset!");
static_assert(offsetof(AVIPEscortGM, VIPSpawnTag) == 0x000A08, "Member 'AVIPEscortGM::VIPSpawnTag' has a wrong offset!");
static_assert(offsetof(AVIPEscortGM, TimeToDeliverVIP) == 0x000A10, "Member 'AVIPEscortGM::TimeToDeliverVIP' has a wrong offset!");
static_assert(offsetof(AVIPEscortGM, HostageHoldTime) == 0x000A14, "Member 'AVIPEscortGM::HostageHoldTime' has a wrong offset!");

// Class ReadyOrNot.VIPEscortGS
// 0x0070 (0x0968 - 0x08F8)
class AVIPEscortGS final : public AReadyOrNotGameState
{
public:
	float                                         HoldVIP_TimeRemaining;                             // 0x08F8(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVIPArrested;                                      // 0x08FC(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanKillVIP;                                       // 0x08FD(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8FE[0x2];                                      // 0x08FE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerCharacter*                       VIPCharacter;                                      // 0x0900(0x0008)(BlueprintVisible, Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerController*                      VIPPlayer;                                         // 0x0908(0x0008)(BlueprintVisible, Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AReadyOrNotPlayerState*                 VIPPlayerState;                                    // 0x0910(0x0008)(BlueprintVisible, Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETeamType                                     LastWinningTeam;                                   // 0x0918(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVIPSelected;                                      // 0x0919(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVIPKilled;                                        // 0x091A(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETeamType                                     CurrentVIPTeam;                                    // 0x091B(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91C[0x4];                                      // 0x091C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AReadyOrNotCharacter*                   RecentArrester;                                    // 0x0920(0x0008)(BlueprintVisible, Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AReadyOrNotCharacter*                   RecentFreer;                                       // 0x0928(0x0008)(BlueprintVisible, Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AReadyOrNotCharacter*                   RecentVIPKiller;                                   // 0x0930(0x0008)(BlueprintVisible, Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   VIPRescueText;                                     // 0x0938(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   VIPExecuteText;                                    // 0x0950(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	void OnRep_VIPArrested();
	void OnRep_VIPKilled();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VIPEscortGS">();
	}
	static class AVIPEscortGS* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVIPEscortGS>();
	}
};
static_assert(alignof(AVIPEscortGS) == 0x000008, "Wrong alignment on AVIPEscortGS");
static_assert(sizeof(AVIPEscortGS) == 0x000968, "Wrong size on AVIPEscortGS");
static_assert(offsetof(AVIPEscortGS, HoldVIP_TimeRemaining) == 0x0008F8, "Member 'AVIPEscortGS::HoldVIP_TimeRemaining' has a wrong offset!");
static_assert(offsetof(AVIPEscortGS, bVIPArrested) == 0x0008FC, "Member 'AVIPEscortGS::bVIPArrested' has a wrong offset!");
static_assert(offsetof(AVIPEscortGS, bCanKillVIP) == 0x0008FD, "Member 'AVIPEscortGS::bCanKillVIP' has a wrong offset!");
static_assert(offsetof(AVIPEscortGS, VIPCharacter) == 0x000900, "Member 'AVIPEscortGS::VIPCharacter' has a wrong offset!");
static_assert(offsetof(AVIPEscortGS, VIPPlayer) == 0x000908, "Member 'AVIPEscortGS::VIPPlayer' has a wrong offset!");
static_assert(offsetof(AVIPEscortGS, VIPPlayerState) == 0x000910, "Member 'AVIPEscortGS::VIPPlayerState' has a wrong offset!");
static_assert(offsetof(AVIPEscortGS, LastWinningTeam) == 0x000918, "Member 'AVIPEscortGS::LastWinningTeam' has a wrong offset!");
static_assert(offsetof(AVIPEscortGS, bVIPSelected) == 0x000919, "Member 'AVIPEscortGS::bVIPSelected' has a wrong offset!");
static_assert(offsetof(AVIPEscortGS, bVIPKilled) == 0x00091A, "Member 'AVIPEscortGS::bVIPKilled' has a wrong offset!");
static_assert(offsetof(AVIPEscortGS, CurrentVIPTeam) == 0x00091B, "Member 'AVIPEscortGS::CurrentVIPTeam' has a wrong offset!");
static_assert(offsetof(AVIPEscortGS, RecentArrester) == 0x000920, "Member 'AVIPEscortGS::RecentArrester' has a wrong offset!");
static_assert(offsetof(AVIPEscortGS, RecentFreer) == 0x000928, "Member 'AVIPEscortGS::RecentFreer' has a wrong offset!");
static_assert(offsetof(AVIPEscortGS, RecentVIPKiller) == 0x000930, "Member 'AVIPEscortGS::RecentVIPKiller' has a wrong offset!");
static_assert(offsetof(AVIPEscortGS, VIPRescueText) == 0x000938, "Member 'AVIPEscortGS::VIPRescueText' has a wrong offset!");
static_assert(offsetof(AVIPEscortGS, VIPExecuteText) == 0x000950, "Member 'AVIPEscortGS::VIPExecuteText' has a wrong offset!");

// Class ReadyOrNot.VisibilityBlockingVolume
// 0x0000 (0x02D0 - 0x02D0)
class AVisibilityBlockingVolume final : public AVolume
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VisibilityBlockingVolume">();
	}
	static class AVisibilityBlockingVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVisibilityBlockingVolume>();
	}
};
static_assert(alignof(AVisibilityBlockingVolume) == 0x000008, "Wrong alignment on AVisibilityBlockingVolume");
static_assert(sizeof(AVisibilityBlockingVolume) == 0x0002D0, "Wrong size on AVisibilityBlockingVolume");

// Class ReadyOrNot.VOIPTalkerEntryWidget
// 0x0070 (0x0330 - 0x02C0)
class UVOIPTalkerEntryWidget : public UUserWidget
{
public:
	TMap<ETeamType, struct FSlateColor>           VoiceTypeColorMap;                                 // 0x02C0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class UTextBlock*                             PlayerName;                                        // 0x0310(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             PlayerChannel;                                     // 0x0318(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 VoiceImage;                                        // 0x0320(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AReadyOrNotPlayerState*                 PlayerState;                                       // 0x0328(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	struct FSlateColor GetVoiceTypeColor() const;
	class FText GetVoiceTypeText() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VOIPTalkerEntryWidget">();
	}
	static class UVOIPTalkerEntryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVOIPTalkerEntryWidget>();
	}
};
static_assert(alignof(UVOIPTalkerEntryWidget) == 0x000008, "Wrong alignment on UVOIPTalkerEntryWidget");
static_assert(sizeof(UVOIPTalkerEntryWidget) == 0x000330, "Wrong size on UVOIPTalkerEntryWidget");
static_assert(offsetof(UVOIPTalkerEntryWidget, VoiceTypeColorMap) == 0x0002C0, "Member 'UVOIPTalkerEntryWidget::VoiceTypeColorMap' has a wrong offset!");
static_assert(offsetof(UVOIPTalkerEntryWidget, PlayerName) == 0x000310, "Member 'UVOIPTalkerEntryWidget::PlayerName' has a wrong offset!");
static_assert(offsetof(UVOIPTalkerEntryWidget, PlayerChannel) == 0x000318, "Member 'UVOIPTalkerEntryWidget::PlayerChannel' has a wrong offset!");
static_assert(offsetof(UVOIPTalkerEntryWidget, VoiceImage) == 0x000320, "Member 'UVOIPTalkerEntryWidget::VoiceImage' has a wrong offset!");
static_assert(offsetof(UVOIPTalkerEntryWidget, PlayerState) == 0x000328, "Member 'UVOIPTalkerEntryWidget::PlayerState' has a wrong offset!");

// Class ReadyOrNot.WeaponTrigger
// 0x0008 (0x0058 - 0x0050)
class UWeaponTrigger final : public UInputTrigger
{
public:
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponTrigger">();
	}
	static class UWeaponTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponTrigger>();
	}
};
static_assert(alignof(UWeaponTrigger) == 0x000008, "Wrong alignment on UWeaponTrigger");
static_assert(sizeof(UWeaponTrigger) == 0x000058, "Wrong size on UWeaponTrigger");

// Class ReadyOrNot.WeaponTriggerPressed
// 0x0000 (0x0050 - 0x0050)
class UWeaponTriggerPressed final : public UInputTrigger
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponTriggerPressed">();
	}
	static class UWeaponTriggerPressed* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponTriggerPressed>();
	}
};
static_assert(alignof(UWeaponTriggerPressed) == 0x000008, "Wrong alignment on UWeaponTriggerPressed");
static_assert(sizeof(UWeaponTriggerPressed) == 0x000050, "Wrong size on UWeaponTriggerPressed");

// Class ReadyOrNot.WeaponWheel_ItemStat_Base
// 0x0000 (0x02C0 - 0x02C0)
class UWeaponWheel_ItemStat_Base : public UUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponWheel_ItemStat_Base">();
	}
	static class UWeaponWheel_ItemStat_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponWheel_ItemStat_Base>();
	}
};
static_assert(alignof(UWeaponWheel_ItemStat_Base) == 0x000008, "Wrong alignment on UWeaponWheel_ItemStat_Base");
static_assert(sizeof(UWeaponWheel_ItemStat_Base) == 0x0002C0, "Wrong size on UWeaponWheel_ItemStat_Base");

// Class ReadyOrNot.SpectatorCharacterHUD
// 0x0000 (0x02E8 - 0x02E8)
class USpectatorCharacterHUD : public UBaseWidget
{
public:
	void ChatPressed();
	void OnActivate();
	void OnNewCharacterViewed(class AReadyOrNotCharacter* NewViewTarget);
	void TeamChatPressed();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpectatorCharacterHUD">();
	}
	static class USpectatorCharacterHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpectatorCharacterHUD>();
	}
};
static_assert(alignof(USpectatorCharacterHUD) == 0x000008, "Wrong alignment on USpectatorCharacterHUD");
static_assert(sizeof(USpectatorCharacterHUD) == 0x0002E8, "Wrong size on USpectatorCharacterHUD");

// Class ReadyOrNot.WorldAction
// 0x0098 (0x0330 - 0x0298)
class AWorldAction final : public AActor
{
public:
	bool                                          bIsEnabled;                                        // 0x0298(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_299[0x7];                                      // 0x0299(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UWorldActionActivity>       Activity;                                          // 0x02A0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAIActionGateData>              Gates;                                             // 0x02A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bMoveTo;                                           // 0x02B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoOnce;                                           // 0x02B9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BA[0x2];                                      // 0x02BA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxDistanceToConsider;                             // 0x02BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              MinMaxCooldownTime;                                // 0x02C0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseWhitelist;                                     // 0x02D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D1[0x7];                                      // 0x02D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class AAISpawn>>        WhitelistedSpawns;                                 // 0x02D8(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  EventsToFire;                                      // 0x02E8(0x0020)(Edit, NativeAccessSpecifierPublic)
	bool                                          bAllowSuspicious;                                  // 0x0308(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowUnalert;                                     // 0x0309(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowAlert;                                       // 0x030A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30B[0x5];                                      // 0x030B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class AWorldAction>>    NextWorldActions;                                  // 0x0310(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, UObjectWrapper, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_             OnWorldActionUsed;                                 // 0x0320(0x0001)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_321[0xF];                                      // 0x0321(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldAction">();
	}
	static class AWorldAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWorldAction>();
	}
};
static_assert(alignof(AWorldAction) == 0x000008, "Wrong alignment on AWorldAction");
static_assert(sizeof(AWorldAction) == 0x000330, "Wrong size on AWorldAction");
static_assert(offsetof(AWorldAction, bIsEnabled) == 0x000298, "Member 'AWorldAction::bIsEnabled' has a wrong offset!");
static_assert(offsetof(AWorldAction, Activity) == 0x0002A0, "Member 'AWorldAction::Activity' has a wrong offset!");
static_assert(offsetof(AWorldAction, Gates) == 0x0002A8, "Member 'AWorldAction::Gates' has a wrong offset!");
static_assert(offsetof(AWorldAction, bMoveTo) == 0x0002B8, "Member 'AWorldAction::bMoveTo' has a wrong offset!");
static_assert(offsetof(AWorldAction, bDoOnce) == 0x0002B9, "Member 'AWorldAction::bDoOnce' has a wrong offset!");
static_assert(offsetof(AWorldAction, MaxDistanceToConsider) == 0x0002BC, "Member 'AWorldAction::MaxDistanceToConsider' has a wrong offset!");
static_assert(offsetof(AWorldAction, MinMaxCooldownTime) == 0x0002C0, "Member 'AWorldAction::MinMaxCooldownTime' has a wrong offset!");
static_assert(offsetof(AWorldAction, bUseWhitelist) == 0x0002D0, "Member 'AWorldAction::bUseWhitelist' has a wrong offset!");
static_assert(offsetof(AWorldAction, WhitelistedSpawns) == 0x0002D8, "Member 'AWorldAction::WhitelistedSpawns' has a wrong offset!");
static_assert(offsetof(AWorldAction, EventsToFire) == 0x0002E8, "Member 'AWorldAction::EventsToFire' has a wrong offset!");
static_assert(offsetof(AWorldAction, bAllowSuspicious) == 0x000308, "Member 'AWorldAction::bAllowSuspicious' has a wrong offset!");
static_assert(offsetof(AWorldAction, bAllowUnalert) == 0x000309, "Member 'AWorldAction::bAllowUnalert' has a wrong offset!");
static_assert(offsetof(AWorldAction, bAllowAlert) == 0x00030A, "Member 'AWorldAction::bAllowAlert' has a wrong offset!");
static_assert(offsetof(AWorldAction, NextWorldActions) == 0x000310, "Member 'AWorldAction::NextWorldActions' has a wrong offset!");
static_assert(offsetof(AWorldAction, OnWorldActionUsed) == 0x000320, "Member 'AWorldAction::OnWorldActionUsed' has a wrong offset!");

// Class ReadyOrNot.WorldActionActivity
// 0x0098 (0x0288 - 0x01F0)
class UWorldActionActivity final : public UBaseActivity
{
public:
	bool                                          bUseAnimationDataTableMontage;                     // 0x01F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F1[0x7];                                      // 0x01F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           StartMontage;                                      // 0x01F8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           LoopMontage;                                       // 0x0200(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           EndMontage;                                        // 0x0208(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           InterruptedMontage;                                // 0x0210(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LoopTime;                                          // 0x0218(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21C[0x4];                                      // 0x021C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TableMontageRowName;                               // 0x0220(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHolsterWeapon;                                    // 0x0230(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldStrafeToLocation;                           // 0x0231(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRequiresExactLocation;                            // 0x0232(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRequiresExactRotation;                            // 0x0233(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAbortOnSeenSwat;                                  // 0x0234(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAbortOnAggressiveNoise;                           // 0x0235(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_236[0x2];                                      // 0x0236(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class AWorldAction*                           WorldAction;                                       // 0x0238(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_240[0x48];                                     // 0x0240(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnEnterEndState();
	void OnEnterInterruptState();
	void OnEnterLoopState();
	void OnEnterStartState();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldActionActivity">();
	}
	static class UWorldActionActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWorldActionActivity>();
	}
};
static_assert(alignof(UWorldActionActivity) == 0x000008, "Wrong alignment on UWorldActionActivity");
static_assert(sizeof(UWorldActionActivity) == 0x000288, "Wrong size on UWorldActionActivity");
static_assert(offsetof(UWorldActionActivity, bUseAnimationDataTableMontage) == 0x0001F0, "Member 'UWorldActionActivity::bUseAnimationDataTableMontage' has a wrong offset!");
static_assert(offsetof(UWorldActionActivity, StartMontage) == 0x0001F8, "Member 'UWorldActionActivity::StartMontage' has a wrong offset!");
static_assert(offsetof(UWorldActionActivity, LoopMontage) == 0x000200, "Member 'UWorldActionActivity::LoopMontage' has a wrong offset!");
static_assert(offsetof(UWorldActionActivity, EndMontage) == 0x000208, "Member 'UWorldActionActivity::EndMontage' has a wrong offset!");
static_assert(offsetof(UWorldActionActivity, InterruptedMontage) == 0x000210, "Member 'UWorldActionActivity::InterruptedMontage' has a wrong offset!");
static_assert(offsetof(UWorldActionActivity, LoopTime) == 0x000218, "Member 'UWorldActionActivity::LoopTime' has a wrong offset!");
static_assert(offsetof(UWorldActionActivity, TableMontageRowName) == 0x000220, "Member 'UWorldActionActivity::TableMontageRowName' has a wrong offset!");
static_assert(offsetof(UWorldActionActivity, bHolsterWeapon) == 0x000230, "Member 'UWorldActionActivity::bHolsterWeapon' has a wrong offset!");
static_assert(offsetof(UWorldActionActivity, bShouldStrafeToLocation) == 0x000231, "Member 'UWorldActionActivity::bShouldStrafeToLocation' has a wrong offset!");
static_assert(offsetof(UWorldActionActivity, bRequiresExactLocation) == 0x000232, "Member 'UWorldActionActivity::bRequiresExactLocation' has a wrong offset!");
static_assert(offsetof(UWorldActionActivity, bRequiresExactRotation) == 0x000233, "Member 'UWorldActionActivity::bRequiresExactRotation' has a wrong offset!");
static_assert(offsetof(UWorldActionActivity, bAbortOnSeenSwat) == 0x000234, "Member 'UWorldActionActivity::bAbortOnSeenSwat' has a wrong offset!");
static_assert(offsetof(UWorldActionActivity, bAbortOnAggressiveNoise) == 0x000235, "Member 'UWorldActionActivity::bAbortOnAggressiveNoise' has a wrong offset!");
static_assert(offsetof(UWorldActionActivity, WorldAction) == 0x000238, "Member 'UWorldActionActivity::WorldAction' has a wrong offset!");

// Class ReadyOrNot.WorldDataGenerator
// 0x0070 (0x0308 - 0x0298)
class AWorldDataGenerator final : public AInfo
{
public:
	class USceneComponent*                        SceneComponent;                                    // 0x0298(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ADoor*>                          VisitedDoors;                                      // 0x02A0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B0[0x1];                                      // 0x02B0(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bHasWorldEverBeenGenerated;                        // 0x02B1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B2[0x6];                                      // 0x02B2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AThreatAwarenessActor*>          IgnoredExitThreats;                                // 0x02B8(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C8[0x1];                                      // 0x02C8(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDoorwaysBlocked;                                  // 0x02C9(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CA[0x6];                                      // 0x02CA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRoomGenData                           RoomData;                                          // 0x02D0(0x0020)(Edit, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F0[0x18];                                     // 0x02F0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BlockAllDoorways();
	void CalculateAllExits();
	void ClearNullReferences();
	void DestroyAllStackups();
	void DestroyAllThreats();
	void DestroyCoverPoints();
	void GenerateAllDoorClearPoints();
	void GenerateAllDoorPositions();
	void GenerateAllDoorThreatAwarenessActors();
	void GenerateCoverPoints();
	void GenerateRooms();
	void GenerateStackUpPoints();
	void GenerateWorld();
	void GenerateWorldThreatAwarenessActors();
	void ReportAllUnreachableSpawns();
	void UnblockAllDoorways();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldDataGenerator">();
	}
	static class AWorldDataGenerator* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWorldDataGenerator>();
	}
};
static_assert(alignof(AWorldDataGenerator) == 0x000008, "Wrong alignment on AWorldDataGenerator");
static_assert(sizeof(AWorldDataGenerator) == 0x000308, "Wrong size on AWorldDataGenerator");
static_assert(offsetof(AWorldDataGenerator, SceneComponent) == 0x000298, "Member 'AWorldDataGenerator::SceneComponent' has a wrong offset!");
static_assert(offsetof(AWorldDataGenerator, VisitedDoors) == 0x0002A0, "Member 'AWorldDataGenerator::VisitedDoors' has a wrong offset!");
static_assert(offsetof(AWorldDataGenerator, bHasWorldEverBeenGenerated) == 0x0002B1, "Member 'AWorldDataGenerator::bHasWorldEverBeenGenerated' has a wrong offset!");
static_assert(offsetof(AWorldDataGenerator, IgnoredExitThreats) == 0x0002B8, "Member 'AWorldDataGenerator::IgnoredExitThreats' has a wrong offset!");
static_assert(offsetof(AWorldDataGenerator, bDoorwaysBlocked) == 0x0002C9, "Member 'AWorldDataGenerator::bDoorwaysBlocked' has a wrong offset!");
static_assert(offsetof(AWorldDataGenerator, RoomData) == 0x0002D0, "Member 'AWorldDataGenerator::RoomData' has a wrong offset!");

// Class ReadyOrNot.WorldTutorial
// 0x00B8 (0x0350 - 0x0298)
class AWorldTutorial final : public AActor
{
public:
	class AActor*                                 AttachedObject;                                    // 0x0298(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTutorialWidgetData                    WidgetData;                                        // 0x02A0(0x0078)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bEnableScreenspaceMarker;                          // 0x0318(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseTutorialLocationForScreenspaceMarker;          // 0x0319(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWaitForCompletionClose;                           // 0x031A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bResetAfterCompletion;                             // 0x031B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LoginsUntilInvalid;                                // 0x031C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETooltipActivationType                        TutorialActivationType;                            // 0x0320(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EScreenspaceMarkerType                        ScreenspaceMarkerType;                             // 0x0321(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETutorialWidgetLocation                       TutorialWidgetLocation;                            // 0x0322(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_323[0x1];                                      // 0x0323(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TutorialActivationDistance;                        // 0x0324(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPlayerInRange;                                  // 0x0328(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTutorialVisible;                                // 0x0329(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32A[0x6];                                      // 0x032A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UTutorialWidget*                        TutorialWidget;                                    // 0x0330(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USphereComponent*                       ActivationComponent;                               // 0x0338(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_340[0x10];                                     // 0x0340(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CompletionEvent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldTutorial">();
	}
	static class AWorldTutorial* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWorldTutorial>();
	}
};
static_assert(alignof(AWorldTutorial) == 0x000008, "Wrong alignment on AWorldTutorial");
static_assert(sizeof(AWorldTutorial) == 0x000350, "Wrong size on AWorldTutorial");
static_assert(offsetof(AWorldTutorial, AttachedObject) == 0x000298, "Member 'AWorldTutorial::AttachedObject' has a wrong offset!");
static_assert(offsetof(AWorldTutorial, WidgetData) == 0x0002A0, "Member 'AWorldTutorial::WidgetData' has a wrong offset!");
static_assert(offsetof(AWorldTutorial, bEnableScreenspaceMarker) == 0x000318, "Member 'AWorldTutorial::bEnableScreenspaceMarker' has a wrong offset!");
static_assert(offsetof(AWorldTutorial, bUseTutorialLocationForScreenspaceMarker) == 0x000319, "Member 'AWorldTutorial::bUseTutorialLocationForScreenspaceMarker' has a wrong offset!");
static_assert(offsetof(AWorldTutorial, bWaitForCompletionClose) == 0x00031A, "Member 'AWorldTutorial::bWaitForCompletionClose' has a wrong offset!");
static_assert(offsetof(AWorldTutorial, bResetAfterCompletion) == 0x00031B, "Member 'AWorldTutorial::bResetAfterCompletion' has a wrong offset!");
static_assert(offsetof(AWorldTutorial, LoginsUntilInvalid) == 0x00031C, "Member 'AWorldTutorial::LoginsUntilInvalid' has a wrong offset!");
static_assert(offsetof(AWorldTutorial, TutorialActivationType) == 0x000320, "Member 'AWorldTutorial::TutorialActivationType' has a wrong offset!");
static_assert(offsetof(AWorldTutorial, ScreenspaceMarkerType) == 0x000321, "Member 'AWorldTutorial::ScreenspaceMarkerType' has a wrong offset!");
static_assert(offsetof(AWorldTutorial, TutorialWidgetLocation) == 0x000322, "Member 'AWorldTutorial::TutorialWidgetLocation' has a wrong offset!");
static_assert(offsetof(AWorldTutorial, TutorialActivationDistance) == 0x000324, "Member 'AWorldTutorial::TutorialActivationDistance' has a wrong offset!");
static_assert(offsetof(AWorldTutorial, bIsPlayerInRange) == 0x000328, "Member 'AWorldTutorial::bIsPlayerInRange' has a wrong offset!");
static_assert(offsetof(AWorldTutorial, bIsTutorialVisible) == 0x000329, "Member 'AWorldTutorial::bIsTutorialVisible' has a wrong offset!");
static_assert(offsetof(AWorldTutorial, TutorialWidget) == 0x000330, "Member 'AWorldTutorial::TutorialWidget' has a wrong offset!");
static_assert(offsetof(AWorldTutorial, ActivationComponent) == 0x000338, "Member 'AWorldTutorial::ActivationComponent' has a wrong offset!");

// Class ReadyOrNot.Zipcuffs
// 0x0160 (0x0D10 - 0x0BB0)
class AZipcuffs : public ABaseItem
{
public:
	class APlayerCharacter*                       PendingArrestCharacter;                            // 0x0BB0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AReadyOrNotCharacter*                   TargetedCharacter;                                 // 0x0BB8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bArresting;                                        // 0x0BC0(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC1[0x7];                                      // 0x0BC1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ArrestMaxDistance;                                 // 0x0BC8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BCC[0x4];                                      // 0x0BCC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ECollisionChannel>                     ArrestCollisionChannels;                           // 0x0BD0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class UAnimMontage*                           UseZipcuffs_1P;                                    // 0x0BE0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           UseZipcuffs_3P;                                    // 0x0BE8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArrestTime;                                        // 0x0BF0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BF4[0x14];                                     // 0x0BF4(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractionsData*                      ForcedInteractionData;                             // 0x0C08(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UInteractionsData*>              StandingArrestInteractionSuspects;                 // 0x0C10(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UInteractionsData*>              StandingArrestInteractionCivilians;                // 0x0C20(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UInteractionsData*>              PvPArrestInteraction;                              // 0x0C30(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class UInteractionsData*                      ArrestRagdoll_Up;                                  // 0x0C40(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractionsData*                      ArrestRagdoll_Down;                                // 0x0C48(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractionsData*                      ArrestRagdoll_Left;                                // 0x0C50(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractionsData*                      ArrestRagdoll_Right;                               // 0x0C58(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class APlacedZipcuffs>            SpawnedZipcuffsClass;                              // 0x0C60(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ZipcuffBone;                                       // 0x0C68(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             SpawnCuffsTransform;                               // 0x0C70(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               SpawnCuffsRelativeRotation;                        // 0x0CD0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                SpawnCuffsRelativeTranslation;                     // 0x0CE8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             FMODZipcuffsArrest;                                // 0x0D00(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D08[0x8];                                      // 0x0D08(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Client_ArrestComplete();
	void Multicast_OnRagdollArrestStart(class AReadyOrNotCharacter* ArrestTarget);
	void OnRagdollArrestComplete_Driver(class AActor* Driver);
	void OnRagdollArrestComplete_Slave(class AActor* Slave);
	void OnRagdollArrestInteractionStarted();
	void Server_ArrestCancelled();
	void Server_ArrestComplete();
	void Server_ArrestManualComplete();
	void Server_ArrestStart(class AReadyOrNotCharacter* TargetedChar);
	void Server_ManualArrestCancelled();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Zipcuffs">();
	}
	static class AZipcuffs* GetDefaultObj()
	{
		return GetDefaultObjImpl<AZipcuffs>();
	}
};
static_assert(alignof(AZipcuffs) == 0x000010, "Wrong alignment on AZipcuffs");
static_assert(sizeof(AZipcuffs) == 0x000D10, "Wrong size on AZipcuffs");
static_assert(offsetof(AZipcuffs, PendingArrestCharacter) == 0x000BB0, "Member 'AZipcuffs::PendingArrestCharacter' has a wrong offset!");
static_assert(offsetof(AZipcuffs, TargetedCharacter) == 0x000BB8, "Member 'AZipcuffs::TargetedCharacter' has a wrong offset!");
static_assert(offsetof(AZipcuffs, bArresting) == 0x000BC0, "Member 'AZipcuffs::bArresting' has a wrong offset!");
static_assert(offsetof(AZipcuffs, ArrestMaxDistance) == 0x000BC8, "Member 'AZipcuffs::ArrestMaxDistance' has a wrong offset!");
static_assert(offsetof(AZipcuffs, ArrestCollisionChannels) == 0x000BD0, "Member 'AZipcuffs::ArrestCollisionChannels' has a wrong offset!");
static_assert(offsetof(AZipcuffs, UseZipcuffs_1P) == 0x000BE0, "Member 'AZipcuffs::UseZipcuffs_1P' has a wrong offset!");
static_assert(offsetof(AZipcuffs, UseZipcuffs_3P) == 0x000BE8, "Member 'AZipcuffs::UseZipcuffs_3P' has a wrong offset!");
static_assert(offsetof(AZipcuffs, ArrestTime) == 0x000BF0, "Member 'AZipcuffs::ArrestTime' has a wrong offset!");
static_assert(offsetof(AZipcuffs, ForcedInteractionData) == 0x000C08, "Member 'AZipcuffs::ForcedInteractionData' has a wrong offset!");
static_assert(offsetof(AZipcuffs, StandingArrestInteractionSuspects) == 0x000C10, "Member 'AZipcuffs::StandingArrestInteractionSuspects' has a wrong offset!");
static_assert(offsetof(AZipcuffs, StandingArrestInteractionCivilians) == 0x000C20, "Member 'AZipcuffs::StandingArrestInteractionCivilians' has a wrong offset!");
static_assert(offsetof(AZipcuffs, PvPArrestInteraction) == 0x000C30, "Member 'AZipcuffs::PvPArrestInteraction' has a wrong offset!");
static_assert(offsetof(AZipcuffs, ArrestRagdoll_Up) == 0x000C40, "Member 'AZipcuffs::ArrestRagdoll_Up' has a wrong offset!");
static_assert(offsetof(AZipcuffs, ArrestRagdoll_Down) == 0x000C48, "Member 'AZipcuffs::ArrestRagdoll_Down' has a wrong offset!");
static_assert(offsetof(AZipcuffs, ArrestRagdoll_Left) == 0x000C50, "Member 'AZipcuffs::ArrestRagdoll_Left' has a wrong offset!");
static_assert(offsetof(AZipcuffs, ArrestRagdoll_Right) == 0x000C58, "Member 'AZipcuffs::ArrestRagdoll_Right' has a wrong offset!");
static_assert(offsetof(AZipcuffs, SpawnedZipcuffsClass) == 0x000C60, "Member 'AZipcuffs::SpawnedZipcuffsClass' has a wrong offset!");
static_assert(offsetof(AZipcuffs, ZipcuffBone) == 0x000C68, "Member 'AZipcuffs::ZipcuffBone' has a wrong offset!");
static_assert(offsetof(AZipcuffs, SpawnCuffsTransform) == 0x000C70, "Member 'AZipcuffs::SpawnCuffsTransform' has a wrong offset!");
static_assert(offsetof(AZipcuffs, SpawnCuffsRelativeRotation) == 0x000CD0, "Member 'AZipcuffs::SpawnCuffsRelativeRotation' has a wrong offset!");
static_assert(offsetof(AZipcuffs, SpawnCuffsRelativeTranslation) == 0x000CE8, "Member 'AZipcuffs::SpawnCuffsRelativeTranslation' has a wrong offset!");
static_assert(offsetof(AZipcuffs, FMODZipcuffsArrest) == 0x000D00, "Member 'AZipcuffs::FMODZipcuffsArrest' has a wrong offset!");

}

